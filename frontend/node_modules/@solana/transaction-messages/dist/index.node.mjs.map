{"version":3,"sources":["../src/blockhash.ts","../../codecs-strings/src/assertions.ts","../../codecs-strings/src/baseX.ts","../../codecs-strings/src/base58.ts","../src/codecs/address-table-lookup.ts","../src/codecs/header.ts","../src/codecs/instruction.ts","../src/codecs/transaction-version.ts","../src/codecs/message.ts","../src/compile/accounts.ts","../src/compile/address-table-lookups.ts","../src/compile/header.ts","../src/compile/instructions.ts","../src/compile/lifetime-token.ts","../src/compile/static-accounts.ts","../src/compile/message.ts","../src/compress-transaction-message.ts","../src/create-transaction-message.ts","../src/durable-nonce.ts","../src/fee-payer.ts","../src/instructions.ts","../src/decompile-message.ts"],"names":["alphabet","SolanaError","getU8Encoder","getU8Decoder","getStructEncoder","getStructDecoder","getArrayEncoder","getShortU16Encoder","transformDecoder","getArrayDecoder","getShortU16Decoder","createEncoder","createDecoder","combineCodec","transformEncoder","getAddressEncoder","getAddressDecoder","AccountRole","getAddressComparator","isWritableRole","isSignerRole"],"mappings":"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","file":"index.node.mjs","sourcesContent":["import { SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME, SolanaError } from '@solana/errors';\nimport { assertIsBlockhash, type Blockhash } from '@solana/rpc-types';\n\nimport { TransactionMessageWithDurableNonceLifetime } from './durable-nonce';\nimport { BaseTransactionMessage } from './transaction-message';\n\n/**\n * A constraint which, when applied to a transaction message, makes that transaction message\n * eligible to land on the network. The transaction message will continue to be eligible to land\n * until the network considers the `blockhash` to be expired.\n *\n * This can happen when the network proceeds past the `lastValidBlockHeight` for which the blockhash\n * is considered valid, or when the network switches to a fork where that blockhash is not present.\n */\ntype BlockhashLifetimeConstraint = Readonly<{\n    /**\n     * A recent blockhash observed by the transaction proposer.\n     *\n     * The transaction message will be considered eligible to land until the network determines this\n     * blockhash to be too old, or has switched to a fork where it is not present.\n     */\n    blockhash: Blockhash;\n    /**\n     * This is the block height beyond which the network will consider the blockhash to be too old\n     * to make a transaction message eligible to land.\n     */\n    lastValidBlockHeight: bigint;\n}>;\n\n/**\n * Represents a transaction message whose lifetime is defined by the age of the blockhash it\n * includes.\n *\n * Such a transaction can only be landed on the network if the current block height of the network\n * is less than or equal to the value of\n * `TransactionMessageWithBlockhashLifetime['lifetimeConstraint']['lastValidBlockHeight']`.\n */\nexport interface TransactionMessageWithBlockhashLifetime {\n    readonly lifetimeConstraint: BlockhashLifetimeConstraint;\n}\n\n/**\n * A type guard that returns `true` if the transaction message conforms to the\n * {@link TransactionMessageWithBlockhashLifetime} type, and refines its type for use in your\n * program.\n *\n * @example\n * ```ts\n * import { isTransactionMessageWithBlockhashLifetime } from '@solana/transaction-messages';\n *\n * if (isTransactionMessageWithBlockhashLifetime(message)) {\n *     // At this point, `message` has been refined to a `TransactionMessageWithBlockhashLifetime`.\n *     const { blockhash } = message.lifetimeConstraint;\n *     const { value: blockhashIsValid } = await rpc.isBlockhashValid(blockhash).send();\n *     setBlockhashIsValid(blockhashIsValid);\n * } else {\n *     setError(\n *         `${getSignatureFromTransaction(transaction)} does not have a blockhash-based lifetime`,\n *     );\n * }\n * ```\n */\nexport function isTransactionMessageWithBlockhashLifetime(\n    transactionMessage: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithBlockhashLifetime),\n): transactionMessage is BaseTransactionMessage & TransactionMessageWithBlockhashLifetime {\n    const lifetimeConstraintShapeMatches =\n        'lifetimeConstraint' in transactionMessage &&\n        typeof transactionMessage.lifetimeConstraint.blockhash === 'string' &&\n        typeof transactionMessage.lifetimeConstraint.lastValidBlockHeight === 'bigint';\n    if (!lifetimeConstraintShapeMatches) return false;\n    try {\n        assertIsBlockhash(transactionMessage.lifetimeConstraint.blockhash);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\n/**\n * From time to time you might acquire a transaction message, that you expect to have a\n * blockhash-based lifetime, from an untrusted network API or user input. Use this function to\n * assert that such a transaction message actually has a blockhash-based lifetime.\n *\n * @example\n * ```ts\n * import { assertIsTransactionMessageWithBlockhashLifetime } from '@solana/transaction-messages';\n *\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `message` to `TransactionMessageWithBlockhashLifetime`.\n *     assertIsTransactionMessageWithBlockhashLifetime(message);\n *     // At this point, `message` is a `TransactionMessageWithBlockhashLifetime` that can be used\n *     // with the RPC.\n *     const { blockhash } = message.lifetimeConstraint;\n *     const { value: blockhashIsValid } = await rpc.isBlockhashValid(blockhash).send();\n * } catch (e) {\n *     // `message` turned out not to have a blockhash-based lifetime\n * }\n * ```\n */\nexport function assertIsTransactionMessageWithBlockhashLifetime(\n    transactionMessage: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithBlockhashLifetime),\n): asserts transactionMessage is BaseTransactionMessage & TransactionMessageWithBlockhashLifetime {\n    if (!isTransactionMessageWithBlockhashLifetime(transactionMessage)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME);\n    }\n}\n\n/**\n * Given a blockhash and the last block height at which that blockhash is considered usable to land\n * transactions, this method will return a new transaction message having the same type as the one\n * supplied plus the `TransactionMessageWithBlockhashLifetime` type.\n *\n * @example\n * ```ts\n * import { setTransactionMessageLifetimeUsingBlockhash } from '@solana/transaction-messages';\n *\n * const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();\n * const txMessageWithBlockhashLifetime = setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, txMessage);\n * ```\n */\nexport function setTransactionMessageLifetimeUsingBlockhash<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime,\n>(\n    blockhashLifetimeConstraint: BlockhashLifetimeConstraint,\n    transactionMessage: TTransactionMessage,\n): Omit<TTransactionMessage, 'lifetimeConstraint'> & TransactionMessageWithBlockhashLifetime;\n\nexport function setTransactionMessageLifetimeUsingBlockhash<\n    TTransactionMessage extends\n        | BaseTransactionMessage\n        | (BaseTransactionMessage & TransactionMessageWithBlockhashLifetime),\n>(\n    blockhashLifetimeConstraint: BlockhashLifetimeConstraint,\n    transactionMessage: TTransactionMessage,\n): TransactionMessageWithBlockhashLifetime & TTransactionMessage;\n\nexport function setTransactionMessageLifetimeUsingBlockhash(\n    blockhashLifetimeConstraint: BlockhashLifetimeConstraint,\n    transactionMessage: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithBlockhashLifetime),\n) {\n    if (\n        'lifetimeConstraint' in transactionMessage &&\n        transactionMessage.lifetimeConstraint.blockhash === blockhashLifetimeConstraint.blockhash &&\n        transactionMessage.lifetimeConstraint.lastValidBlockHeight === blockhashLifetimeConstraint.lastValidBlockHeight\n    ) {\n        return transactionMessage;\n    }\n    const out = {\n        ...transactionMessage,\n        lifetimeConstraint: Object.freeze(blockhashLifetimeConstraint),\n    };\n    Object.freeze(out);\n    return out;\n}\n","import { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given string contains only characters from the specified alphabet.\n *\n * This function validates whether a string consists exclusively of characters\n * from the provided `alphabet`. If the validation fails, it throws an error\n * indicating the invalid base string.\n *\n * @param alphabet - The allowed set of characters for the base encoding.\n * @param testValue - The string to validate against the given alphabet.\n * @param givenValue - The original string provided by the user (defaults to `testValue`).\n *\n * @throws {SolanaError} If `testValue` contains characters not present in `alphabet`.\n *\n * @example\n * Validating a base-8 encoded string.\n * ```ts\n * assertValidBaseString('01234567', '123047'); // Passes\n * assertValidBaseString('01234567', '128');    // Throws error\n * ```\n */\nexport function assertValidBaseString(alphabet: string, testValue: string, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet}]*$`))) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet,\n            base: alphabet.length,\n            value: givenValue,\n        });\n    }\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings.\n *\n * This encoder serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process involves converting the input string to a numeric value in base-X, then\n * encoding that value into bytes while preserving leading zeroes.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings.\n *\n * @example\n * Encoding a base-X string using a custom alphabet.\n * ```ts\n * const encoder = getBaseXEncoder('0123456789abcdef');\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXEncoder = (alphabet: string): VariableSizeEncoder<string> => {\n    return createEncoder({\n        getSizeFromValue: (value: string): number => {\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) return value.length;\n\n            const base10Number = getBigIntFromBaseX(tailChars, alphabet);\n            return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n        },\n        write(value: string, bytes, offset) {\n            // Check if the value is valid.\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n\n            // Handle leading zeroes.\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) {\n                bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n                return offset + leadingZeroes.length;\n            }\n\n            // From baseX to base10.\n            let base10Number = getBigIntFromBaseX(tailChars, alphabet);\n\n            // From base10 to bytes.\n            const tailBytes: number[] = [];\n            while (base10Number > 0n) {\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n\n            const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for base-X encoded strings.\n *\n * This decoder deserializes base-X encoded strings from a byte array using a custom alphabet.\n * The decoding process converts the byte array into a numeric value in base-10, then\n * maps that value back to characters in the specified base-X alphabet.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings.\n *\n * @example\n * Decoding a base-X string using a custom alphabet.\n * ```ts\n * const decoder = getBaseXDecoder('0123456789abcdef');\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXDecoder = (alphabet: string): VariableSizeDecoder<string> => {\n    return createDecoder({\n        read(rawBytes, offset): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', 0];\n\n            // Handle leading zeroes.\n            let trailIndex = bytes.findIndex(n => n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n\n            // From bytes to base10.\n            const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n\n            // From base10 to baseX.\n            const tailChars = getBaseXFromBigInt(base10Number, alphabet);\n\n            return [leadingZeroes + tailChars, rawBytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding base-X strings.\n *\n * This codec serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process converts the input string into a numeric value in base-X, which is then encoded as bytes.\n * The decoding process reverses this transformation to reconstruct the original string.\n *\n * This codec supports leading zeroes by treating the first character of the alphabet as the zero character.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings.\n *\n * @example\n * Encoding and decoding a base-X string using a custom alphabet.\n * ```ts\n * const codec = getBaseXCodec('0123456789abcdef');\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXCodec('0123456789abcdef'), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXCodec('0123456789abcdef'), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXEncoder} and {@link getBaseXDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXEncoder('0123456789abcdef').encode('deadface');\n * const value = getBaseXDecoder('0123456789abcdef').decode(bytes);\n * ```\n *\n * @see {@link getBaseXEncoder}\n * @see {@link getBaseXDecoder}\n */\nexport const getBaseXCodec = (alphabet: string): VariableSizeCodec<string> =>\n    combineCodec(getBaseXEncoder(alphabet), getBaseXDecoder(alphabet));\n\nfunction partitionLeadingZeroes(\n    value: string,\n    zeroCharacter: string,\n): [leadingZeros: string, tailChars: string | undefined] {\n    const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n    return [leadingZeros, tailChars];\n}\n\nfunction getBigIntFromBaseX(value: string, alphabet: string): bigint {\n    const base = BigInt(alphabet.length);\n    let sum = 0n;\n    for (const char of value) {\n        sum *= base;\n        sum += BigInt(alphabet.indexOf(char));\n    }\n    return sum;\n}\n\nfunction getBaseXFromBigInt(value: bigint, alphabet: string): string {\n    const base = BigInt(alphabet.length);\n    const tailChars = [];\n    while (value > 0n) {\n        tailChars.unshift(alphabet[Number(value % base)]);\n        value /= base;\n    }\n    return tailChars.join('');\n}\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/**\n * Returns an encoder for base-58 strings.\n *\n * This encoder serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-58 strings.\n *\n * @example\n * Encoding a base-58 string.\n * ```ts\n * const encoder = getBase58Encoder();\n * const bytes = encoder.encode('heLLo'); // 0x1b6a3070\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-58 strings.\n *\n * This decoder deserializes base-58 encoded strings from a byte array.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-58 strings.\n *\n * @example\n * Decoding a base-58 string.\n * ```ts\n * const decoder = getBase58Decoder();\n * const value = decoder.decode(new Uint8Array([0x1b, 0x6a, 0x30, 0x70])); // \"heLLo\"\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-58 strings.\n *\n * This codec serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-58 strings.\n *\n * @example\n * Encoding and decoding a base-58 string.\n * ```ts\n * const codec = getBase58Codec();\n * const bytes = codec.encode('heLLo'); // 0x1b6a3070\n * const value = codec.decode(bytes);   // \"heLLo\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-58 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase58Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-58 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase58Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase58Encoder} and {@link getBase58Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase58Encoder().encode('heLLo');\n * const value = getBase58Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase58Encoder}\n * @see {@link getBase58Decoder}\n */\nexport const getBase58Codec = () => getBaseXCodec(alphabet);\n","import { getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    type Encoder,\n    transformDecoder,\n    type VariableSizeCodec,\n    type VariableSizeDecoder,\n    type VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getArrayDecoder, getArrayEncoder, getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport type { getCompiledAddressTableLookups } from '../compile/address-table-lookups';\n\ntype AddressTableLookup = ReturnType<typeof getCompiledAddressTableLookups>[number];\n\nlet memoizedAddressTableLookupEncoder: VariableSizeEncoder<AddressTableLookup> | undefined;\nexport function getAddressTableLookupEncoder(): VariableSizeEncoder<AddressTableLookup> {\n    if (!memoizedAddressTableLookupEncoder) {\n        const indexEncoder = getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() }) as Encoder<\n            readonly number[]\n        >;\n        memoizedAddressTableLookupEncoder = getStructEncoder([\n            ['lookupTableAddress', getAddressEncoder()],\n            ['writableIndexes', indexEncoder],\n            ['readonlyIndexes', indexEncoder],\n        ]);\n    }\n\n    return memoizedAddressTableLookupEncoder;\n}\n\nlet memoizedAddressTableLookupDecoder: VariableSizeDecoder<AddressTableLookup> | undefined;\nexport function getAddressTableLookupDecoder(): VariableSizeDecoder<AddressTableLookup> {\n    if (!memoizedAddressTableLookupDecoder) {\n        const indexEncoder = getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() });\n        // @ts-expect-error Remove when `readableIndices` and `writableIndices` are removed.\n        memoizedAddressTableLookupDecoder = transformDecoder(\n            getStructDecoder([\n                ['lookupTableAddress', getAddressDecoder()],\n                ['writableIndexes', indexEncoder],\n                ['readonlyIndexes', indexEncoder],\n            ]),\n            lookupTable =>\n                'readableIndices' in lookupTable\n                    ? ({\n                          ...lookupTable,\n                          readonlyIndexes: lookupTable.readableIndices,\n                          // @ts-expect-error Remove when `readableIndices` and `writableIndices` are removed.\n                          writableIndexes: lookupTable.writableIndices,\n                      } as AddressTableLookup)\n                    : lookupTable,\n        );\n    }\n\n    // @ts-expect-error Remove when `readableIndices` and `writableIndices` are removed.\n    return memoizedAddressTableLookupDecoder;\n}\n\nexport function getAddressTableLookupCodec(): VariableSizeCodec<AddressTableLookup> {\n    return combineCodec(getAddressTableLookupEncoder(), getAddressTableLookupDecoder());\n}\n","import { FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\nimport { getStructCodec, getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport { getU8Codec, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport { getCompiledMessageHeader } from '../compile/header';\n\ntype MessageHeader = ReturnType<typeof getCompiledMessageHeader>;\n\nlet memoizedU8Encoder: FixedSizeEncoder<number, 1> | undefined;\nfunction getMemoizedU8Encoder(): FixedSizeEncoder<number, 1> {\n    if (!memoizedU8Encoder) memoizedU8Encoder = getU8Encoder();\n    return memoizedU8Encoder;\n}\n\nlet memoizedU8Decoder: FixedSizeDecoder<number, 1> | undefined;\nfunction getMemoizedU8Decoder(): FixedSizeDecoder<number, 1> {\n    if (!memoizedU8Decoder) memoizedU8Decoder = getU8Decoder();\n    return memoizedU8Decoder;\n}\n\nlet memoizedU8Codec: FixedSizeCodec<number, number, 1> | undefined;\nfunction getMemoizedU8Codec(): FixedSizeCodec<number, number, 1> {\n    if (!memoizedU8Codec) memoizedU8Codec = getU8Codec();\n    return memoizedU8Codec;\n}\n\nexport function getMessageHeaderEncoder(): FixedSizeEncoder<MessageHeader, 3> {\n    return getStructEncoder([\n        ['numSignerAccounts', getMemoizedU8Encoder()],\n        ['numReadonlySignerAccounts', getMemoizedU8Encoder()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Encoder()],\n    ]) as FixedSizeEncoder<MessageHeader, 3>;\n}\n\nexport function getMessageHeaderDecoder(): FixedSizeDecoder<MessageHeader, 3> {\n    return getStructDecoder([\n        ['numSignerAccounts', getMemoizedU8Decoder()],\n        ['numReadonlySignerAccounts', getMemoizedU8Decoder()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Decoder()],\n    ]) as FixedSizeDecoder<MessageHeader, 3>;\n}\n\nexport function getMessageHeaderCodec(): FixedSizeCodec<MessageHeader, MessageHeader, 3> {\n    return getStructCodec([\n        ['numSignerAccounts', getMemoizedU8Codec()],\n        ['numReadonlySignerAccounts', getMemoizedU8Codec()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Codec()],\n    ]) as FixedSizeCodec<MessageHeader, MessageHeader, 3>;\n}\n","import {\n    addDecoderSizePrefix,\n    addEncoderSizePrefix,\n    combineCodec,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getArrayEncoder,\n    getBytesDecoder,\n    getBytesEncoder,\n    getStructDecoder,\n    getStructEncoder,\n} from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport { getCompiledInstructions } from '../compile/instructions';\n\ntype Instruction = ReturnType<typeof getCompiledInstructions>[number];\n\nlet memoizedGetInstructionEncoder: VariableSizeEncoder<Instruction> | undefined;\nexport function getInstructionEncoder(): VariableSizeEncoder<Instruction> {\n    if (!memoizedGetInstructionEncoder) {\n        memoizedGetInstructionEncoder = transformEncoder<Required<Instruction>, Instruction>(\n            getStructEncoder([\n                ['programAddressIndex', getU8Encoder()],\n                ['accountIndices', getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() })],\n                ['data', addEncoderSizePrefix(getBytesEncoder(), getShortU16Encoder())],\n            ]),\n            // Convert an instruction to have all fields defined\n            (instruction: Instruction): Required<Instruction> => {\n                if (instruction.accountIndices !== undefined && instruction.data !== undefined) {\n                    return instruction as Required<Instruction>;\n                }\n                return {\n                    ...instruction,\n                    accountIndices: instruction.accountIndices ?? [],\n                    data: instruction.data ?? new Uint8Array(0),\n                } as Required<Instruction>;\n            },\n        );\n    }\n\n    return memoizedGetInstructionEncoder;\n}\n\nlet memoizedGetInstructionDecoder: VariableSizeDecoder<Instruction> | undefined;\nexport function getInstructionDecoder(): VariableSizeDecoder<Instruction> {\n    if (!memoizedGetInstructionDecoder) {\n        memoizedGetInstructionDecoder = transformDecoder<Required<Instruction>, Instruction>(\n            getStructDecoder([\n                ['programAddressIndex', getU8Decoder()],\n                ['accountIndices', getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() })],\n                [\n                    'data',\n                    addDecoderSizePrefix(getBytesDecoder(), getShortU16Decoder()) as VariableSizeDecoder<Uint8Array>,\n                ],\n            ]),\n            // Convert an instruction to exclude optional fields if they are empty\n            (instruction: Required<Instruction>): Instruction => {\n                if (instruction.accountIndices.length && instruction.data.byteLength) {\n                    return instruction;\n                }\n                const { accountIndices, data, ...rest } = instruction;\n                return {\n                    ...rest,\n                    ...(accountIndices.length ? { accountIndices } : null),\n                    ...(data.byteLength ? { data } : null),\n                };\n            },\n        );\n    }\n    return memoizedGetInstructionDecoder;\n}\n\nexport function getInstructionCodec(): VariableSizeCodec<Instruction> {\n    return combineCodec(getInstructionEncoder(), getInstructionDecoder());\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\nimport { TransactionVersion } from '../transaction-message';\n\nconst VERSION_FLAG_MASK = 0x80;\n\n/**\n * Returns an encoder that you can use to encode a {@link TransactionVersion} to a byte array.\n *\n * Legacy messages will produce an empty array and will not advance the offset. Versioned messages\n * will produce an array with a single byte.\n */\nexport function getTransactionVersionEncoder(): VariableSizeEncoder<TransactionVersion> {\n    return createEncoder({\n        getSizeFromValue: value => (value === 'legacy' ? 0 : 1),\n        maxSize: 1,\n        write: (value, bytes, offset) => {\n            if (value === 'legacy') {\n                return offset;\n            }\n            if (value < 0 || value > 127) {\n                throw new SolanaError(SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE, {\n                    actualVersion: value,\n                });\n            }\n            bytes.set([value | VERSION_FLAG_MASK], offset);\n            return offset + 1;\n        },\n    });\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing a\n * {@link TransactionVersion}.\n *\n * When the byte at the current offset is determined to represent a legacy transaction, this decoder\n * will return `'legacy'` and will not advance the offset.\n */\nexport function getTransactionVersionDecoder(): VariableSizeDecoder<TransactionVersion> {\n    return createDecoder({\n        maxSize: 1,\n        read: (bytes, offset) => {\n            const firstByte = bytes[offset];\n            if ((firstByte & VERSION_FLAG_MASK) === 0) {\n                // No version flag set; it's a legacy (unversioned) transaction.\n                return ['legacy', offset];\n            } else {\n                const version = (firstByte ^ VERSION_FLAG_MASK) as TransactionVersion;\n                return [version, offset + 1];\n            }\n        },\n    });\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link TransactionVersion}\n *\n * @see {@link getTransactionVersionDecoder}\n * @see {@link getTransactionVersionEncoder}\n */\nexport function getTransactionVersionCodec(): VariableSizeCodec<TransactionVersion> {\n    return combineCodec(getTransactionVersionEncoder(), getTransactionVersionDecoder());\n}\n","import { getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    createEncoder,\n    Decoder,\n    fixDecoderSize,\n    fixEncoderSize,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getArrayDecoder, getArrayEncoder, getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder } from '@solana/codecs-numbers';\nimport { getBase58Decoder, getBase58Encoder } from '@solana/codecs-strings';\n\nimport { getCompiledAddressTableLookups } from '../compile/address-table-lookups';\nimport { CompiledTransactionMessage } from '../compile/message';\nimport { getAddressTableLookupDecoder, getAddressTableLookupEncoder } from './address-table-lookup';\nimport { getMessageHeaderDecoder, getMessageHeaderEncoder } from './header';\nimport { getInstructionDecoder, getInstructionEncoder } from './instruction';\nimport { getTransactionVersionDecoder, getTransactionVersionEncoder } from './transaction-version';\n\nfunction getCompiledMessageLegacyEncoder(): VariableSizeEncoder<CompiledTransactionMessage> {\n    return getStructEncoder(getPreludeStructEncoderTuple()) as VariableSizeEncoder<CompiledTransactionMessage>;\n}\n\nfunction getCompiledMessageVersionedEncoder(): VariableSizeEncoder<CompiledTransactionMessage> {\n    return transformEncoder(\n        getStructEncoder([\n            ...getPreludeStructEncoderTuple(),\n            ['addressTableLookups', getAddressTableLookupArrayEncoder()],\n        ]) as VariableSizeEncoder<CompiledTransactionMessage>,\n        (value: CompiledTransactionMessage) => {\n            if (value.version === 'legacy') {\n                return value;\n            }\n            return {\n                ...value,\n                addressTableLookups: value.addressTableLookups ?? [],\n            } as Exclude<CompiledTransactionMessage, { readonly version: 'legacy' }>;\n        },\n    );\n}\n\nfunction getPreludeStructEncoderTuple() {\n    return [\n        ['version', getTransactionVersionEncoder()],\n        ['header', getMessageHeaderEncoder()],\n        ['staticAccounts', getArrayEncoder(getAddressEncoder(), { size: getShortU16Encoder() })],\n        ['lifetimeToken', fixEncoderSize(getBase58Encoder(), 32)],\n        ['instructions', getArrayEncoder(getInstructionEncoder(), { size: getShortU16Encoder() })],\n    ] as const;\n}\n\nfunction getPreludeStructDecoderTuple() {\n    return [\n        ['version', getTransactionVersionDecoder() as Decoder<number>],\n        ['header', getMessageHeaderDecoder()],\n        ['staticAccounts', getArrayDecoder(getAddressDecoder(), { size: getShortU16Decoder() })],\n        ['lifetimeToken', fixDecoderSize(getBase58Decoder(), 32)],\n        ['instructions', getArrayDecoder(getInstructionDecoder(), { size: getShortU16Decoder() })],\n        ['addressTableLookups', getAddressTableLookupArrayDecoder()],\n    ] as const;\n}\n\nfunction getAddressTableLookupArrayEncoder() {\n    return getArrayEncoder(getAddressTableLookupEncoder(), { size: getShortU16Encoder() });\n}\n\nfunction getAddressTableLookupArrayDecoder() {\n    return getArrayDecoder(getAddressTableLookupDecoder(), { size: getShortU16Decoder() });\n}\n\n/**\n * Returns an encoder that you can use to encode a {@link CompiledTransactionMessage} to a byte\n * array.\n *\n * The wire format of a Solana transaction consists of signatures followed by a compiled transaction\n * message. The byte array produced by this encoder is the message part.\n */\nexport function getCompiledTransactionMessageEncoder(): VariableSizeEncoder<CompiledTransactionMessage> {\n    return createEncoder({\n        getSizeFromValue: (compiledMessage: CompiledTransactionMessage) => {\n            if (compiledMessage.version === 'legacy') {\n                return getCompiledMessageLegacyEncoder().getSizeFromValue(compiledMessage);\n            } else {\n                return getCompiledMessageVersionedEncoder().getSizeFromValue(compiledMessage);\n            }\n        },\n        write: (compiledMessage, bytes, offset) => {\n            if (compiledMessage.version === 'legacy') {\n                return getCompiledMessageLegacyEncoder().write(compiledMessage, bytes, offset);\n            } else {\n                return getCompiledMessageVersionedEncoder().write(compiledMessage, bytes, offset);\n            }\n        },\n    });\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing a\n * {@link CompiledTransactionMessage}.\n *\n * The wire format of a Solana transaction consists of signatures followed by a compiled transaction\n * message. You can use this decoder to decode the message part.\n */\nexport function getCompiledTransactionMessageDecoder(): VariableSizeDecoder<CompiledTransactionMessage> {\n    return transformDecoder(\n        getStructDecoder(getPreludeStructDecoderTuple()) as VariableSizeDecoder<\n            CompiledTransactionMessage & { addressTableLookups?: ReturnType<typeof getCompiledAddressTableLookups> }\n        >,\n        ({ addressTableLookups, ...restOfMessage }) => {\n            if (restOfMessage.version === 'legacy' || !addressTableLookups?.length) {\n                return restOfMessage;\n            }\n            return { ...restOfMessage, addressTableLookups } as Exclude<\n                CompiledTransactionMessage,\n                { readonly version: 'legacy' }\n            >;\n        },\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link CompiledTransactionMessage}\n *\n * @see {@link getCompiledTransactionMessageDecoder}\n * @see {@link getCompiledTransactionMessageEncoder}\n */\nexport function getCompiledTransactionMessageCodec(): VariableSizeCodec<CompiledTransactionMessage> {\n    return combineCodec(getCompiledTransactionMessageEncoder(), getCompiledTransactionMessageDecoder());\n}\n","import { Address, getAddressComparator } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n    SolanaError,\n} from '@solana/errors';\nimport {\n    AccountRole,\n    IAccountLookupMeta,\n    IAccountMeta,\n    IInstruction,\n    isSignerRole,\n    isWritableRole,\n    mergeRoles,\n    ReadonlyAccount,\n    ReadonlyAccountLookup,\n    ReadonlySignerAccount,\n    WritableAccount,\n    WritableAccountLookup,\n    WritableSignerAccount,\n} from '@solana/instructions';\nimport { Brand } from '@solana/nominal-types';\n\nexport const enum AddressMapEntryType {\n    FEE_PAYER,\n    LOOKUP_TABLE,\n    STATIC,\n}\n\ntype AddressMap = {\n    [address: string]: FeePayerAccountEntry | LookupTableAccountEntry | StaticAccountEntry;\n};\ntype FeePayerAccountEntry = Omit<WritableSignerAccount, 'address'> & {\n    [TYPE]: AddressMapEntryType.FEE_PAYER;\n};\ntype LookupTableAccountEntry = Omit<ReadonlyAccountLookup | WritableAccountLookup, 'address'> & {\n    [TYPE]: AddressMapEntryType.LOOKUP_TABLE;\n};\nexport type OrderedAccounts = Brand<(IAccountLookupMeta | IAccountMeta)[], 'OrderedAccounts'>;\ntype StaticAccountEntry = Omit<\n    ReadonlyAccount | ReadonlySignerAccount | WritableAccount | WritableSignerAccount,\n    'address'\n> & { [TYPE]: AddressMapEntryType.STATIC };\n\nfunction upsert(\n    addressMap: AddressMap,\n    address: Address,\n    update: (\n        entry: FeePayerAccountEntry | LookupTableAccountEntry | Record<never, never> | StaticAccountEntry,\n    ) => AddressMap[Address],\n) {\n    addressMap[address] = update(addressMap[address] ?? { role: AccountRole.READONLY });\n}\n\nconst TYPE = Symbol('AddressMapTypeProperty');\nexport const ADDRESS_MAP_TYPE_PROPERTY: typeof TYPE = TYPE;\n\nexport function getAddressMapFromInstructions(feePayer: Address, instructions: readonly IInstruction[]): AddressMap {\n    const addressMap: AddressMap = {\n        [feePayer]: { [TYPE]: AddressMapEntryType.FEE_PAYER, role: AccountRole.WRITABLE_SIGNER },\n    };\n    const addressesOfInvokedPrograms = new Set<Address>();\n    for (const instruction of instructions) {\n        upsert(addressMap, instruction.programAddress, entry => {\n            addressesOfInvokedPrograms.add(instruction.programAddress);\n            if (TYPE in entry) {\n                if (isWritableRole(entry.role)) {\n                    switch (entry[TYPE]) {\n                        case AddressMapEntryType.FEE_PAYER:\n                            throw new SolanaError(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES, {\n                                programAddress: instruction.programAddress,\n                            });\n                        default:\n                            throw new SolanaError(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE, {\n                                programAddress: instruction.programAddress,\n                            });\n                    }\n                }\n                if (entry[TYPE] === AddressMapEntryType.STATIC) {\n                    return entry;\n                }\n            }\n            return { [TYPE]: AddressMapEntryType.STATIC, role: AccountRole.READONLY };\n        });\n        let addressComparator: ReturnType<typeof getAddressComparator>;\n        if (!instruction.accounts) {\n            continue;\n        }\n        for (const account of instruction.accounts) {\n            upsert(addressMap, account.address, entry => {\n                const {\n                    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                    address: _,\n                    ...accountMeta\n                } = account;\n                if (TYPE in entry) {\n                    switch (entry[TYPE]) {\n                        case AddressMapEntryType.FEE_PAYER:\n                            // The fee payer already has the highest rank -- it is by definition\n                            // writable-signer. Return it, no matter how `account` is configured\n                            return entry;\n                        case AddressMapEntryType.LOOKUP_TABLE: {\n                            const nextRole = mergeRoles(entry.role, accountMeta.role);\n                            if ('lookupTableAddress' in accountMeta) {\n                                const shouldReplaceEntry =\n                                    // Consider using the new LOOKUP_TABLE if its address is different...\n                                    entry.lookupTableAddress !== accountMeta.lookupTableAddress &&\n                                    // ...and sorts before the existing one.\n                                    (addressComparator ||= getAddressComparator())(\n                                        accountMeta.lookupTableAddress,\n                                        entry.lookupTableAddress,\n                                    ) < 0;\n                                if (shouldReplaceEntry) {\n                                    return {\n                                        [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                                        ...accountMeta,\n                                        role: nextRole,\n                                    } as LookupTableAccountEntry;\n                                }\n                            } else if (isSignerRole(accountMeta.role)) {\n                                // Upgrade this LOOKUP_TABLE entry to a static entry if it must sign.\n                                return {\n                                    [TYPE]: AddressMapEntryType.STATIC,\n                                    role: nextRole,\n                                } as StaticAccountEntry;\n                            }\n                            if (entry.role !== nextRole) {\n                                return {\n                                    ...entry,\n                                    role: nextRole,\n                                } as LookupTableAccountEntry;\n                            } else {\n                                return entry;\n                            }\n                        }\n                        case AddressMapEntryType.STATIC: {\n                            const nextRole = mergeRoles(entry.role, accountMeta.role);\n                            if (\n                                // Check to see if this address represents a program that is invoked\n                                // in this transaction.\n                                addressesOfInvokedPrograms.has(account.address)\n                            ) {\n                                if (isWritableRole(accountMeta.role)) {\n                                    throw new SolanaError(\n                                        SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n                                        {\n                                            programAddress: account.address,\n                                        },\n                                    );\n                                }\n                                if (entry.role !== nextRole) {\n                                    return {\n                                        ...entry,\n                                        role: nextRole,\n                                    } as StaticAccountEntry;\n                                } else {\n                                    return entry;\n                                }\n                            } else if (\n                                'lookupTableAddress' in accountMeta &&\n                                // Static accounts can be 'upgraded' to lookup table accounts as\n                                // long as they are not require to sign the transaction.\n                                !isSignerRole(entry.role)\n                            ) {\n                                return {\n                                    ...accountMeta,\n                                    [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                                    role: nextRole,\n                                } as LookupTableAccountEntry;\n                            } else {\n                                if (entry.role !== nextRole) {\n                                    // The account's role ranks higher than the current entry's.\n                                    return {\n                                        ...entry,\n                                        role: nextRole,\n                                    } as StaticAccountEntry;\n                                } else {\n                                    return entry;\n                                }\n                            }\n                        }\n                    }\n                }\n                if ('lookupTableAddress' in accountMeta) {\n                    return {\n                        ...accountMeta,\n                        [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                    };\n                } else {\n                    return {\n                        ...accountMeta,\n                        [TYPE]: AddressMapEntryType.STATIC,\n                    };\n                }\n            });\n        }\n    }\n    return addressMap;\n}\n\nexport function getOrderedAccountsFromAddressMap(addressMap: AddressMap): OrderedAccounts {\n    let addressComparator: ReturnType<typeof getAddressComparator>;\n    const orderedAccounts: (IAccountLookupMeta | IAccountMeta)[] = Object.entries(addressMap)\n        .sort(([leftAddress, leftEntry], [rightAddress, rightEntry]) => {\n            // STEP 1: Rapid precedence check. Fee payer, then static addresses, then lookups.\n            if (leftEntry[TYPE] !== rightEntry[TYPE]) {\n                if (leftEntry[TYPE] === AddressMapEntryType.FEE_PAYER) {\n                    return -1;\n                } else if (rightEntry[TYPE] === AddressMapEntryType.FEE_PAYER) {\n                    return 1;\n                } else if (leftEntry[TYPE] === AddressMapEntryType.STATIC) {\n                    return -1;\n                } else if (rightEntry[TYPE] === AddressMapEntryType.STATIC) {\n                    return 1;\n                }\n            }\n            // STEP 2: Sort by signer-writability.\n            const leftIsSigner = isSignerRole(leftEntry.role);\n            if (leftIsSigner !== isSignerRole(rightEntry.role)) {\n                return leftIsSigner ? -1 : 1;\n            }\n            const leftIsWritable = isWritableRole(leftEntry.role);\n            if (leftIsWritable !== isWritableRole(rightEntry.role)) {\n                return leftIsWritable ? -1 : 1;\n            }\n            // STEP 3: Sort by address.\n            addressComparator ||= getAddressComparator();\n            if (\n                leftEntry[TYPE] === AddressMapEntryType.LOOKUP_TABLE &&\n                rightEntry[TYPE] === AddressMapEntryType.LOOKUP_TABLE &&\n                leftEntry.lookupTableAddress !== rightEntry.lookupTableAddress\n            ) {\n                return addressComparator(leftEntry.lookupTableAddress, rightEntry.lookupTableAddress);\n            } else {\n                return addressComparator(leftAddress, rightAddress);\n            }\n        })\n        .map(([address, addressMeta]) => ({\n            address: address as Address<typeof address>,\n            ...addressMeta,\n        }));\n    return orderedAccounts as unknown as OrderedAccounts;\n}\n","import { Address, getAddressComparator } from '@solana/addresses';\nimport { AccountRole } from '@solana/instructions';\n\nimport { OrderedAccounts } from '../compile/accounts';\n\ntype AddressTableLookup = Readonly<{\n    /** The address of the address lookup table account. */\n    lookupTableAddress: Address;\n    /** @deprecated Use `readonlyIndexes` */\n    readableIndices: readonly number[];\n    /** Indexes of accounts in a lookup table to load as read-only. */\n    readonlyIndexes: readonly number[];\n    /** Indexes of accounts in a lookup table to load as writable. */\n    writableIndexes: readonly number[];\n    /** @deprecated Use `writableIndexes` */\n    writableIndices: readonly number[];\n}>;\n\nexport function getCompiledAddressTableLookups(orderedAccounts: OrderedAccounts): AddressTableLookup[] {\n    const index: Record<\n        Address,\n        Readonly<{\n            [K in keyof Omit<AddressTableLookup, 'lookupTableAddress'>]: number[];\n        }>\n    > = {};\n    for (const account of orderedAccounts) {\n        if (!('lookupTableAddress' in account)) {\n            continue;\n        }\n        const entry = (index[account.lookupTableAddress] ||= {\n            /** @deprecated Remove in a future major version */\n            readableIndices: [],\n            readonlyIndexes: [],\n            writableIndexes: [],\n            /** @deprecated Remove in a future major version */\n            writableIndices: [],\n        });\n        if (account.role === AccountRole.WRITABLE) {\n            entry.writableIndexes.push(account.addressIndex);\n            /** @deprecated Remove in a future major version */\n            entry.writableIndices.push(account.addressIndex);\n        } else {\n            /** @deprecated Remove in a future major version */\n            entry.readableIndices.push(account.addressIndex);\n            entry.readonlyIndexes.push(account.addressIndex);\n        }\n    }\n    return Object.keys(index)\n        .sort(getAddressComparator())\n        .map(lookupTableAddress => ({\n            lookupTableAddress: lookupTableAddress as Address,\n            ...index[lookupTableAddress as unknown as Address],\n        }));\n}\n","import { isSignerRole, isWritableRole } from '@solana/instructions';\n\nimport { OrderedAccounts } from '../compile/accounts';\n\ntype MessageHeader = Readonly<{\n    /**\n     * The number of accounts in the static accounts list that are neither writable nor\n     * signers.\n     *\n     * Adding this number to `numSignerAccounts` yields the index of the first read-only non-signer\n     * account in the static accounts list.\n     */\n    numReadonlyNonSignerAccounts: number;\n    /**\n     * The number of read-only accounts in the static accounts list that must sign this\n     * transaction.\n     *\n     * Subtracting this number from `numSignerAccounts` yields the index of the first read-only\n     * signer account in the static accounts list.\n     */\n    numReadonlySignerAccounts: number;\n    /**\n     * The number of accounts in the static accounts list that must sign this transaction.\n     *\n     * Subtracting `numReadonlySignerAccounts` from this number yields the number of\n     * writable signer accounts in the static accounts list. Writable signer accounts always\n     * begin at index zero in the static accounts list.\n     *\n     * This number itself is the index of the first non-signer account in the static\n     * accounts list.\n     */\n    numSignerAccounts: number;\n}>;\n\nexport function getCompiledMessageHeader(orderedAccounts: OrderedAccounts): MessageHeader {\n    let numReadonlyNonSignerAccounts = 0;\n    let numReadonlySignerAccounts = 0;\n    let numSignerAccounts = 0;\n    for (const account of orderedAccounts) {\n        if ('lookupTableAddress' in account) {\n            break;\n        }\n        const accountIsWritable = isWritableRole(account.role);\n        if (isSignerRole(account.role)) {\n            numSignerAccounts++;\n            if (!accountIsWritable) {\n                numReadonlySignerAccounts++;\n            }\n        } else if (!accountIsWritable) {\n            numReadonlyNonSignerAccounts++;\n        }\n    }\n    return {\n        numReadonlyNonSignerAccounts,\n        numReadonlySignerAccounts,\n        numSignerAccounts,\n    };\n}\n","import { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport { IInstruction } from '@solana/instructions';\n\nimport { OrderedAccounts } from './accounts';\n\ntype CompiledInstruction = Readonly<{\n    /**\n     * An ordered list of indices that indicate which accounts in the transaction message's\n     * accounts list are loaded by this instruction.\n     */\n    accountIndices?: number[];\n    /** The input to the invoked program */\n    data?: ReadonlyUint8Array;\n    /**\n     * The index of the address in the transaction message's accounts list associated with the\n     * program to invoke.\n     */\n    programAddressIndex: number;\n}>;\n\nfunction getAccountIndex(orderedAccounts: OrderedAccounts) {\n    const out: Record<Address, number> = {};\n    for (const [index, account] of orderedAccounts.entries()) {\n        out[account.address] = index;\n    }\n    return out;\n}\n\nexport function getCompiledInstructions(\n    instructions: readonly IInstruction[],\n    orderedAccounts: OrderedAccounts,\n): CompiledInstruction[] {\n    const accountIndex = getAccountIndex(orderedAccounts);\n    return instructions.map(({ accounts, data, programAddress }) => {\n        return {\n            programAddressIndex: accountIndex[programAddress],\n            ...(accounts ? { accountIndices: accounts.map(({ address }) => accountIndex[address]) } : null),\n            ...(data ? { data } : null),\n        };\n    });\n}\n","import { TransactionMessageWithBlockhashLifetime, TransactionMessageWithDurableNonceLifetime } from '../index';\n\nexport function getCompiledLifetimeToken(\n    lifetimeConstraint: (\n        | TransactionMessageWithBlockhashLifetime\n        | TransactionMessageWithDurableNonceLifetime\n    )['lifetimeConstraint'],\n): string {\n    if ('nonce' in lifetimeConstraint) {\n        return lifetimeConstraint.nonce;\n    }\n    return lifetimeConstraint.blockhash;\n}\n","import { Address } from '@solana/addresses';\n\nimport { OrderedAccounts } from './accounts';\n\nexport function getCompiledStaticAccounts(orderedAccounts: OrderedAccounts): Address[] {\n    const firstLookupTableAccountIndex = orderedAccounts.findIndex(account => 'lookupTableAddress' in account);\n    const orderedStaticAccounts =\n        firstLookupTableAccountIndex === -1 ? orderedAccounts : orderedAccounts.slice(0, firstLookupTableAccountIndex);\n    return orderedStaticAccounts.map(({ address }) => address);\n}\n","import { CompilableTransactionMessage } from '../compilable-transaction-message';\nimport { getAddressMapFromInstructions, getOrderedAccountsFromAddressMap } from './accounts';\nimport { getCompiledAddressTableLookups } from './address-table-lookups';\nimport { getCompiledMessageHeader } from './header';\nimport { getCompiledInstructions } from './instructions';\nimport { getCompiledLifetimeToken } from './lifetime-token';\nimport { getCompiledStaticAccounts } from './static-accounts';\n\ntype BaseCompiledTransactionMessage = Readonly<{\n    /**\n     * Information about the version of the transaction message and the role of the accounts it\n     * loads.\n     */\n    header: ReturnType<typeof getCompiledMessageHeader>;\n    instructions: ReturnType<typeof getCompiledInstructions>;\n    /**\n     * 32 bytes of data observed by the transaction proposed that makes a transaction eligible to\n     * land on the network.\n     *\n     * In the case of a transaction message with a nonce lifetime constraint, this will be the value\n     * of the nonce itself. In all other cases this will be a recent blockhash.\n     */\n    lifetimeToken: ReturnType<typeof getCompiledLifetimeToken>;\n    /** A list of addresses indicating which accounts to load */\n    staticAccounts: ReturnType<typeof getCompiledStaticAccounts>;\n}>;\n\n/**\n * A transaction message in a form suitable for encoding for execution on the network.\n *\n * You can not fully reconstruct a source message from a compiled message without extra information.\n * In particular, supporting details about the lifetime constraint and the concrete addresses of\n * accounts sourced from account lookup tables are lost to compilation.\n */\nexport type CompiledTransactionMessage = LegacyCompiledTransactionMessage | VersionedCompiledTransactionMessage;\n\ntype LegacyCompiledTransactionMessage = BaseCompiledTransactionMessage &\n    Readonly<{\n        version: 'legacy';\n    }>;\n\ntype VersionedCompiledTransactionMessage = BaseCompiledTransactionMessage &\n    Readonly<{\n        /** A list of address tables and the accounts that this transaction loads from them */\n        addressTableLookups?: ReturnType<typeof getCompiledAddressTableLookups>;\n        version: number;\n    }>;\n\n/**\n * Converts the type of transaction message data structure that you create in your application to\n * the type of transaction message data structure that can be encoded for execution on the network.\n *\n * This is a lossy process; you can not fully reconstruct a source message from a compiled message\n * without extra information. In particular, supporting details about the lifetime constraint and\n * the concrete addresses of accounts sourced from account lookup tables will be lost to\n * compilation.\n *\n * @see {@link decompileTransactionMessage}\n */\nexport function compileTransactionMessage(\n    transactionMessage: CompilableTransactionMessage & Readonly<{ version: 'legacy' }>,\n): LegacyCompiledTransactionMessage;\nexport function compileTransactionMessage(\n    transactionMessage: CompilableTransactionMessage,\n): VersionedCompiledTransactionMessage;\nexport function compileTransactionMessage(\n    transactionMessage: CompilableTransactionMessage,\n): CompiledTransactionMessage {\n    const addressMap = getAddressMapFromInstructions(\n        transactionMessage.feePayer.address,\n        transactionMessage.instructions,\n    );\n    const orderedAccounts = getOrderedAccountsFromAddressMap(addressMap);\n    return {\n        ...(transactionMessage.version !== 'legacy'\n            ? { addressTableLookups: getCompiledAddressTableLookups(orderedAccounts) }\n            : null),\n        header: getCompiledMessageHeader(orderedAccounts),\n        instructions: getCompiledInstructions(transactionMessage.instructions, orderedAccounts),\n        lifetimeToken: getCompiledLifetimeToken(transactionMessage.lifetimeConstraint),\n        staticAccounts: getCompiledStaticAccounts(orderedAccounts),\n        version: transactionMessage.version,\n    };\n}\n","import { Address } from '@solana/addresses';\nimport { AccountRole, IAccountLookupMeta, IAccountMeta, IInstruction, isSignerRole } from '@solana/instructions';\n\nimport { AddressesByLookupTableAddress } from './addresses-by-lookup-table-address';\nimport { BaseTransactionMessage, TransactionMessage } from './transaction-message';\n\ntype Mutable<T> = {\n    -readonly [P in keyof T]: T[P];\n};\n\n// Look up the address in lookup tables, return a lookup meta if it is found in any of them\nfunction findAddressInLookupTables(\n    address: Address,\n    role: AccountRole.READONLY | AccountRole.WRITABLE,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): IAccountLookupMeta | undefined {\n    for (const [lookupTableAddress, addresses] of Object.entries(addressesByLookupTableAddress)) {\n        for (let i = 0; i < addresses.length; i++) {\n            if (address === addresses[i]) {\n                return {\n                    address,\n                    addressIndex: i,\n                    lookupTableAddress: lookupTableAddress as Address,\n                    role,\n                };\n            }\n        }\n    }\n}\n\ntype TransactionMessageNotLegacy = Exclude<TransactionMessage, { version: 'legacy' }>;\n\n// Each account can be IAccountLookupMeta | IAccountMeta\ntype WidenInstructionAccounts<TInstruction extends IInstruction> =\n    TInstruction extends IInstruction<infer TProgramAddress, infer TAccounts>\n        ? IInstruction<\n              TProgramAddress,\n              {\n                  [K in keyof TAccounts]: TAccounts[K] extends IAccountMeta<infer TAddress>\n                      ? IAccountLookupMeta<TAddress> | IAccountMeta<TAddress>\n                      : TAccounts[K];\n              }\n          >\n        : TInstruction;\n\ntype ExtractAdditionalProps<T, U> = Omit<T, keyof U>;\n\ntype WidenTransactionMessageInstructions<TTransactionMessage extends TransactionMessage> =\n    TTransactionMessage extends BaseTransactionMessage<infer TVersion, infer TInstruction>\n        ? BaseTransactionMessage<TVersion, WidenInstructionAccounts<TInstruction>> &\n              ExtractAdditionalProps<\n                  TTransactionMessage,\n                  BaseTransactionMessage<TVersion, WidenInstructionAccounts<TInstruction>>\n              >\n        : TTransactionMessage;\n\n/**\n * Given a transaction message and a mapping of lookup tables to the addresses stored in them, this\n * function will return a new transaction message with the same instructions but with all non-signer\n * accounts that are found in the given lookup tables represented by an {@link IAccountLookupMeta}\n * instead of an {@link IAccountMeta}.\n *\n * This means that these accounts will take up less space in the compiled transaction message. This\n * size reduction is most significant when the transaction includes many accounts from the same\n * lookup table.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { compressTransactionMessageUsingAddressLookupTables } from '@solana/transaction-messages';\n *\n * const lookupTableAddress = address('4QwSwNriKPrz8DLW4ju5uxC2TN5cksJx6tPUPj7DGLAW');\n * const accountAddress = address('5n2ADjHPsqB4EVUNEX48xRqtnmuLu5XSHDwkJRR98qpM');\n * const lookupTableAddresses: AddressesByLookupTableAddress = {\n *     [lookupTableAddress]: [accountAddress],\n * };\n *\n * const compressedTransactionMessage = compressTransactionMessageUsingAddressLookupTables(\n *     transactionMessage,\n *     lookupTableAddresses,\n * );\n * ```\n *\n */\nexport function compressTransactionMessageUsingAddressLookupTables<\n    TTransactionMessage extends TransactionMessageNotLegacy = TransactionMessageNotLegacy,\n>(\n    transactionMessage: TTransactionMessage,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): TTransactionMessage | WidenTransactionMessageInstructions<TTransactionMessage> {\n    const lookupTableAddresses = new Set(Object.values(addressesByLookupTableAddress).flatMap(a => a));\n\n    const newInstructions: IInstruction[] = [];\n    let updatedAnyInstructions = false;\n    for (const instruction of transactionMessage.instructions) {\n        if (!instruction.accounts) {\n            newInstructions.push(instruction);\n            continue;\n        }\n\n        const newAccounts: Mutable<NonNullable<IInstruction['accounts']>> = [];\n        let updatedAnyAccounts = false;\n        for (const account of instruction.accounts) {\n            // If the address is already a lookup, is not in any lookup tables, or is a signer role, return as-is\n            if (\n                'lookupTableAddress' in account ||\n                !lookupTableAddresses.has(account.address) ||\n                isSignerRole(account.role)\n            ) {\n                newAccounts.push(account);\n                continue;\n            }\n\n            // We already checked it's in one of the lookup tables\n            const lookupMetaAccount = findAddressInLookupTables(\n                account.address,\n                account.role,\n                addressesByLookupTableAddress,\n            )!;\n            newAccounts.push(Object.freeze(lookupMetaAccount));\n            updatedAnyAccounts = true;\n            updatedAnyInstructions = true;\n        }\n\n        newInstructions.push(\n            Object.freeze(updatedAnyAccounts ? { ...instruction, accounts: newAccounts } : instruction),\n        );\n    }\n\n    return Object.freeze(\n        updatedAnyInstructions ? { ...transactionMessage, instructions: newInstructions } : transactionMessage,\n    );\n}\n","import { TransactionMessage, TransactionVersion } from './transaction-message';\n\ntype TransactionConfig<TVersion extends TransactionVersion> = Readonly<{\n    version: TVersion;\n}>;\n\n/**\n * Given a {@link TransactionVersion} this method will return an empty transaction having the\n * capabilities of that version.\n *\n * @example\n * ```ts\n * import { createTransactionMessage } from '@solana/transaction-messages';\n *\n * const message = createTransactionMessage({ version: 0 });\n * ```\n */\nexport function createTransactionMessage<TVersion extends TransactionVersion>(\n    config: TransactionConfig<TVersion>,\n): Extract<TransactionMessage, { version: TVersion }>;\nexport function createTransactionMessage<TVersion extends TransactionVersion>({\n    version,\n}: TransactionConfig<TVersion>): TransactionMessage {\n    return Object.freeze({\n        instructions: Object.freeze([]),\n        version,\n    }) as TransactionMessage;\n}\n","import { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport { SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME, SolanaError } from '@solana/errors';\nimport {\n    AccountRole,\n    IInstruction,\n    IInstructionWithAccounts,\n    IInstructionWithData,\n    isSignerRole,\n    ReadonlyAccount,\n    ReadonlySignerAccount,\n    WritableAccount,\n    WritableSignerAccount,\n} from '@solana/instructions';\nimport { Brand } from '@solana/nominal-types';\n\nimport { BaseTransactionMessage } from './transaction-message';\n\ntype AdvanceNonceAccountInstruction<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n> = IInstruction<'11111111111111111111111111111111'> &\n    IInstructionWithAccounts<\n        readonly [\n            WritableAccount<TNonceAccountAddress>,\n            ReadonlyAccount<'SysvarRecentB1ockHashes11111111111111111111'>,\n            ReadonlySignerAccount<TNonceAuthorityAddress> | WritableSignerAccount<TNonceAuthorityAddress>,\n        ]\n    > &\n    IInstructionWithData<AdvanceNonceAccountInstructionData>;\ntype AdvanceNonceAccountInstructionData = Brand<Uint8Array, 'AdvanceNonceAccountInstructionData'>;\ntype DurableNonceConfig<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> = Readonly<{\n    readonly nonce: Nonce<TNonceValue>;\n    readonly nonceAccountAddress: Address<TNonceAccountAddress>;\n    readonly nonceAuthorityAddress: Address<TNonceAuthorityAddress>;\n}>;\n/** Represents a string that is particularly known to be the base58-encoded value of a nonce. */\nexport type Nonce<TNonceValue extends string = string> = Brand<TNonceValue, 'Nonce'>;\n/**\n * A constraint which, when applied to a transaction message, makes that transaction message\n * eligible to land on the network.\n *\n * The transaction message will continue to be eligible to land until the network considers the\n * `nonce` to have advanced. This can happen when the nonce account in which this nonce is found is\n * destroyed, or the nonce value within changes.\n */\ntype NonceLifetimeConstraint<TNonceValue extends string = string> = Readonly<{\n    /**\n     * A value contained in the related nonce account at the time the transaction was prepared.\n     *\n     * The transaction will be considered eligible to land until the nonce account ceases to exist\n     * or contain this value.\n     */\n    nonce: Nonce<TNonceValue>;\n}>;\n\nconst RECENT_BLOCKHASHES_SYSVAR_ADDRESS =\n    'SysvarRecentB1ockHashes11111111111111111111' as Address<'SysvarRecentB1ockHashes11111111111111111111'>;\nconst SYSTEM_PROGRAM_ADDRESS = '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n\n/**\n * Represents a transaction message whose lifetime is defined by the value of a nonce it includes.\n *\n * Such a transaction can only be landed on the network if the nonce is known to the network and has\n * not already been used to land a different transaction.\n */\nexport interface TransactionMessageWithDurableNonceLifetime<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> {\n    readonly instructions: readonly [\n        // The first instruction *must* be the system program's `AdvanceNonceAccount` instruction.\n        AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n        ...IInstruction[],\n    ];\n    readonly lifetimeConstraint: NonceLifetimeConstraint<TNonceValue>;\n}\n\n/**\n * From time to time you might acquire a transaction message, that you expect to have a\n * nonce-based lifetime, from an untrusted network API or user input. Use this function to assert\n * that such a transaction message actually has a nonce-based lifetime.\n *\n * @example\n * ```ts\n * import { assertIsDurableNonceTransactionMessage } from '@solana/transaction-messages';\n *\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `message` to `TransactionMessageWithDurableNonceLifetime`.\n *     assertIsDurableNonceTransactionMessage(message);\n *     // At this point, `message` is a `TransactionMessageWithDurableNonceLifetime` that can be used\n *     // with the RPC.\n *     const { nonce, nonceAccountAddress } = message.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n * } catch (e) {\n *     // `message` turned out not to have a nonce-based lifetime\n * }\n * ```\n */\nexport function assertIsDurableNonceTransactionMessage(\n    transactionMessage: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime),\n): asserts transactionMessage is BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime {\n    if (!isDurableNonceTransaction(transactionMessage)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME);\n    }\n}\n\n/**\n * Creates an instruction for the System program to advance a nonce.\n *\n * This instruction is a prerequisite for a transaction with a nonce-based lifetime to be landed on\n * the network. In order to be considered valid, the transaction must meet all of these criteria.\n *\n * 1. Its lifetime constraint must be a {@link NonceLifetimeConstraint}.\n * 2. The value contained in the on-chain account at the address `nonceAccountAddress` must be equal\n *    to {@link NonceLifetimeConstraint.nonce} at the time the transaction is landed.\n * 3. The first instruction in that transaction message must be the one returned by this function.\n *\n * You could also use the `getAdvanceNonceAccountInstruction` method of `@solana-program/system`.\n */\nfunction createAdvanceNonceAccountInstruction<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n>(\n    nonceAccountAddress: Address<TNonceAccountAddress>,\n    nonceAuthorityAddress: Address<TNonceAuthorityAddress>,\n): AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress> {\n    return {\n        accounts: [\n            { address: nonceAccountAddress, role: AccountRole.WRITABLE },\n            {\n                address: RECENT_BLOCKHASHES_SYSVAR_ADDRESS,\n                role: AccountRole.READONLY,\n            },\n            { address: nonceAuthorityAddress, role: AccountRole.READONLY_SIGNER },\n        ],\n        data: new Uint8Array([4, 0, 0, 0]) as AdvanceNonceAccountInstructionData,\n        programAddress: SYSTEM_PROGRAM_ADDRESS,\n    };\n}\n\n/**\n * A type guard that returns `true` if the instruction conforms to the\n * {@link AdvanceNonceAccountInstruction} type, and refines its type for use in your program.\n *\n * @example\n * ```ts\n * import { isAdvanceNonceAccountInstruction } from '@solana/transaction-messages';\n *\n * if (isAdvanceNonceAccountInstruction(message.instructions[0])) {\n *     // At this point, the first instruction in the message has been refined to a\n *     // `AdvanceNonceAccountInstruction`.\n *     setNonceAccountAddress(message.instructions[0].accounts[0].address);\n * } else {\n *     setError('The first instruction is not an `AdvanceNonce` instruction');\n * }\n * ```\n */\nexport function isAdvanceNonceAccountInstruction(\n    instruction: IInstruction,\n): instruction is AdvanceNonceAccountInstruction {\n    return (\n        instruction.programAddress === SYSTEM_PROGRAM_ADDRESS &&\n        // Test for `AdvanceNonceAccount` instruction data\n        instruction.data != null &&\n        isAdvanceNonceAccountInstructionData(instruction.data) &&\n        // Test for exactly 3 accounts\n        instruction.accounts?.length === 3 &&\n        // First account is nonce account address\n        instruction.accounts[0].address != null &&\n        instruction.accounts[0].role === AccountRole.WRITABLE &&\n        // Second account is recent blockhashes sysvar\n        instruction.accounts[1].address === RECENT_BLOCKHASHES_SYSVAR_ADDRESS &&\n        instruction.accounts[1].role === AccountRole.READONLY &&\n        // Third account is nonce authority account\n        instruction.accounts[2].address != null &&\n        isSignerRole(instruction.accounts[2].role)\n    );\n}\n\nfunction isAdvanceNonceAccountInstructionData(data: ReadonlyUint8Array): data is AdvanceNonceAccountInstructionData {\n    // AdvanceNonceAccount is the fifth instruction in the System Program (index 4)\n    return data.byteLength === 4 && data[0] === 4 && data[1] === 0 && data[2] === 0 && data[3] === 0;\n}\n\n/**\n * A type guard that returns `true` if the transaction message conforms to the\n * {@link TransactionMessageWithDurableNonceLifetime} type, and refines its type for use in your\n * program.\n *\n * @example\n * ```ts\n * import { isTransactionMessageWithDurableNonceLifetime } from '@solana/transaction-messages';\n * import { fetchNonce } from \"@solana-program/system\";\n *\n * if (isTransactionMessageWithDurableNonceLifetime(message)) {\n *     // At this point, `message` has been refined to a\n *     // `TransactionMessageWithDurableNonceLifetime`.\n *     const { nonce, nonceAccountAddress } = message.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n *     setNonceIsValid(nonce === actualNonce);\n * } else {\n *     setError(\n *         `${getSignatureFromTransaction(transaction)} does not have a nonce-based lifetime`,\n *     );\n * }\n * ```\n */\nexport function isDurableNonceTransaction(\n    transactionMessage: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime),\n): transactionMessage is BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime {\n    return (\n        'lifetimeConstraint' in transactionMessage &&\n        typeof transactionMessage.lifetimeConstraint.nonce === 'string' &&\n        transactionMessage.instructions[0] != null &&\n        isAdvanceNonceAccountInstruction(transactionMessage.instructions[0])\n    );\n}\n\nfunction isAdvanceNonceAccountInstructionForNonce<\n    TNonceAccountAddress extends Address = Address,\n    TNonceAuthorityAddress extends Address = Address,\n>(\n    instruction: AdvanceNonceAccountInstruction,\n    nonceAccountAddress: TNonceAccountAddress,\n    nonceAuthorityAddress: TNonceAuthorityAddress,\n): instruction is AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress> {\n    return (\n        instruction.accounts[0].address === nonceAccountAddress &&\n        instruction.accounts[2].address === nonceAuthorityAddress\n    );\n}\n\n/**\n * Given a nonce, the account where the value of the nonce is stored, and the address of the account\n * authorized to consume that nonce, this method will return a new transaction having the same type\n * as the one supplied plus the {@link TransactionMessageWithDurableNonceLifetime} type.\n *\n * In particular, this method _prepends_ an instruction to the transaction message designed to\n * consume (or 'advance') the nonce in the same transaction whose lifetime is defined by it.\n *\n * @param config\n *\n * @example\n * ```ts\n * import { setTransactionMessageLifetimeUsingDurableNonce } from '@solana/transactions';\n *\n * const NONCE_VALUE_OFFSET =\n *     4 + // version(u32)\n *     4 + // state(u32)\n *     32; // nonce authority(pubkey)\n * // Then comes the nonce value.\n *\n * const nonceAccountAddress = address('EGtMh4yvXswwHhwVhyPxGrVV2TkLTgUqGodbATEPvojZ');\n * const nonceAuthorityAddress = address('4KD1Rdrd89NG7XbzW3xsX9Aqnx2EExJvExiNme6g9iAT');\n * const { value: nonceAccount } = await rpc\n *     .getAccountInfo(nonceAccountAddress, {\n *         dataSlice: { length: 32, offset: NONCE_VALUE_OFFSET },\n *         encoding: 'base58',\n *     })\n *     .send();\n * const nonce =\n *     // This works because we asked for the exact slice of data representing the nonce\n *     // value, and furthermore asked for it in `base58` encoding.\n *     nonceAccount!.data[0] as unknown as Nonce;\n *\n * const durableNonceTransactionMessage = setTransactionMessageLifetimeUsingDurableNonce(\n *     { nonce, nonceAccountAddress, nonceAuthorityAddress },\n *     tx,\n * );\n * ```\n */\nexport function setTransactionMessageLifetimeUsingDurableNonce<\n    TTransactionMessage extends BaseTransactionMessage,\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n>(\n    {\n        nonce,\n        nonceAccountAddress,\n        nonceAuthorityAddress,\n    }: DurableNonceConfig<TNonceAccountAddress, TNonceAuthorityAddress, TNonceValue>,\n    transactionMessage: TTransactionMessage | (TransactionMessageWithDurableNonceLifetime & TTransactionMessage),\n): TransactionMessageWithDurableNonceLifetime<TNonceAccountAddress, TNonceAuthorityAddress, TNonceValue> &\n    TTransactionMessage {\n    let newInstructions: [\n        AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n        ...IInstruction[],\n    ];\n\n    const firstInstruction = transactionMessage.instructions[0];\n    if (firstInstruction && isAdvanceNonceAccountInstruction(firstInstruction)) {\n        if (isAdvanceNonceAccountInstructionForNonce(firstInstruction, nonceAccountAddress, nonceAuthorityAddress)) {\n            if (\n                isDurableNonceTransaction(transactionMessage) &&\n                transactionMessage.lifetimeConstraint.nonce === nonce\n            ) {\n                return transactionMessage as TransactionMessageWithDurableNonceLifetime<\n                    TNonceAccountAddress,\n                    TNonceAuthorityAddress,\n                    TNonceValue\n                > &\n                    TTransactionMessage;\n            } else {\n                // we already have the right first instruction, leave it as-is\n                newInstructions = [firstInstruction, ...transactionMessage.instructions.slice(1)];\n            }\n        } else {\n            // we have a different advance nonce instruction as the first instruction, replace it\n            newInstructions = [\n                Object.freeze(createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress)),\n                ...transactionMessage.instructions.slice(1),\n            ];\n        }\n    } else {\n        // we don't have an existing advance nonce instruction as the first instruction, prepend one\n        newInstructions = [\n            Object.freeze(createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress)),\n            ...transactionMessage.instructions,\n        ];\n    }\n\n    return Object.freeze({\n        ...transactionMessage,\n        instructions: Object.freeze(newInstructions),\n        lifetimeConstraint: Object.freeze({\n            nonce,\n        }),\n    }) as TransactionMessageWithDurableNonceLifetime<TNonceAccountAddress, TNonceAuthorityAddress, TNonceValue> &\n        TTransactionMessage;\n}\n","import { Address } from '@solana/addresses';\n\nimport { BaseTransactionMessage } from './transaction-message';\n\n/**\n * Represents a transaction message for which a fee payer has been declared. A transaction must\n * conform to this type to be compiled and landed on the network.\n */\nexport interface ITransactionMessageWithFeePayer<TAddress extends string = string> {\n    readonly feePayer: Readonly<{ address: Address<TAddress> }>;\n}\n\n/**\n * Given a base58-encoded address of a system account, this method will return a new transaction\n * message having the same type as the one supplied plus the {@link ITransactionMessageWithFeePayer}\n * type.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { setTransactionMessageFeePayer } from '@solana/transaction-messages';\n *\n * const myAddress = address('mpngsFd4tmbUfzDYJayjKZwZcaR7aWb2793J6grLsGu');\n * const txPaidByMe = setTransactionMessageFeePayer(myAddress, tx);\n * ```\n */\nexport function setTransactionMessageFeePayer<\n    TFeePayerAddress extends string,\n    TTransactionMessage extends BaseTransactionMessage & Partial<ITransactionMessageWithFeePayer>,\n>(\n    feePayer: Address<TFeePayerAddress>,\n    transactionMessage: TTransactionMessage,\n): ITransactionMessageWithFeePayer<TFeePayerAddress> & Omit<TTransactionMessage, 'feePayer'> {\n    if (\n        'feePayer' in transactionMessage &&\n        feePayer === transactionMessage.feePayer?.address &&\n        isAddressOnlyFeePayer(transactionMessage.feePayer)\n    ) {\n        return transactionMessage as unknown as ITransactionMessageWithFeePayer<TFeePayerAddress> &\n            Omit<TTransactionMessage, 'feePayer'>;\n    }\n    const out = {\n        ...transactionMessage,\n        feePayer: Object.freeze({ address: feePayer }),\n    };\n    Object.freeze(out);\n    return out;\n}\n\nfunction isAddressOnlyFeePayer(\n    feePayer: Partial<ITransactionMessageWithFeePayer>['feePayer'],\n): feePayer is { address: Address } {\n    return (\n        !!feePayer &&\n        'address' in feePayer &&\n        typeof feePayer.address === 'string' &&\n        Object.keys(feePayer).length === 1\n    );\n}\n","import { TransactionMessageWithDurableNonceLifetime } from './durable-nonce';\nimport { BaseTransactionMessage } from './transaction-message';\n\n/**\n * Given an instruction, this method will return a new transaction message with that instruction\n * having been added to the end of the list of existing instructions.\n *\n * @see {@link appendTransactionInstructions} if you need to append multiple instructions to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { appendTransactionMessageInstruction } from '@solana/transaction-messages';\n *\n * const memoTransaction = appendTransactionMessageInstruction(\n *     {\n *         data: new TextEncoder().encode('Hello world!'),\n *         programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *     },\n *     tx,\n * );\n * ```\n */\nexport function appendTransactionMessageInstruction<TTransactionMessage extends BaseTransactionMessage>(\n    instruction: TTransactionMessage['instructions'][number],\n    transactionMessage: TTransactionMessage,\n): TTransactionMessage {\n    return appendTransactionMessageInstructions([instruction], transactionMessage);\n}\n\n/**\n * Given an array of instructions, this method will return a new transaction message with those\n * instructions having been added to the end of the list of existing instructions.\n *\n * @see {@link appendTransactionInstruction} if you only need to append one instruction to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { appendTransactionMessageInstructions } from '@solana/transaction-messages';\n *\n * const memoTransaction = appendTransactionMessageInstructions(\n *     [\n *         {\n *             data: new TextEncoder().encode('Hello world!'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *         {\n *             data: new TextEncoder().encode('How are you?'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *     ],\n *     tx,\n * );\n * ```\n */\nexport function appendTransactionMessageInstructions<TTransactionMessage extends BaseTransactionMessage>(\n    instructions: ReadonlyArray<TTransactionMessage['instructions'][number]>,\n    transactionMessage: TTransactionMessage,\n): TTransactionMessage {\n    return Object.freeze({\n        ...transactionMessage,\n        instructions: Object.freeze([...transactionMessage.instructions, ...instructions]),\n    });\n}\n\n// Durable nonce advance instruction must be the first instruction in the transaction message\n// So if instructions are prepended, we strip the durable nonce transaction message type\ntype ExcludeDurableNonce<T> = T extends TransactionMessageWithDurableNonceLifetime\n    ? BaseTransactionMessage & Omit<T, keyof TransactionMessageWithDurableNonceLifetime>\n    : T;\n\n/**\n * Given an instruction, this method will return a new transaction message with that instruction\n * having been added to the beginning of the list of existing instructions.\n *\n * @see {@link prependTransactionInstructions} if you need to prepend multiple instructions to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { prependTransactionMessageInstruction } from '@solana/transaction-messages';\n *\n * const memoTransaction = prependTransactionMessageInstruction(\n *     {\n *         data: new TextEncoder().encode('Hello world!'),\n *         programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *     },\n *     tx,\n * );\n * ```\n */\nexport function prependTransactionMessageInstruction<TTransactionMessage extends BaseTransactionMessage>(\n    instruction: TTransactionMessage['instructions'][number],\n    transactionMessage: TTransactionMessage,\n): ExcludeDurableNonce<TTransactionMessage> {\n    return prependTransactionMessageInstructions([instruction], transactionMessage);\n}\n\n/**\n * Given an array of instructions, this method will return a new transaction message with those\n * instructions having been added to the beginning of the list of existing instructions.\n *\n * @see {@link prependTransactionInstruction} if you only need to prepend one instruction to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { prependTransactionMessageInstructions } from '@solana/transaction-messages';\n *\n * const memoTransaction = prependTransactionMessageInstructions(\n *     [\n *         {\n *             data: new TextEncoder().encode('Hello world!'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *         {\n *             data: new TextEncoder().encode('How are you?'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *     ],\n *     tx,\n * );\n * ```\n */\nexport function prependTransactionMessageInstructions<TTransactionMessage extends BaseTransactionMessage>(\n    instructions: ReadonlyArray<TTransactionMessage['instructions'][number]>,\n    transactionMessage: TTransactionMessage,\n): ExcludeDurableNonce<TTransactionMessage> {\n    return Object.freeze({\n        ...transactionMessage,\n        instructions: Object.freeze([...instructions, ...transactionMessage.instructions]),\n    }) as ExcludeDurableNonce<TTransactionMessage>;\n}\n","import { Address, assertIsAddress } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND,\n    SolanaError,\n} from '@solana/errors';\nimport { pipe } from '@solana/functional';\nimport { AccountRole, IAccountLookupMeta, IAccountMeta, IInstruction } from '@solana/instructions';\nimport type { Blockhash } from '@solana/rpc-types';\n\nimport { AddressesByLookupTableAddress } from './addresses-by-lookup-table-address';\nimport { setTransactionMessageLifetimeUsingBlockhash } from './blockhash';\nimport { CompilableTransactionMessage } from './compilable-transaction-message';\nimport { CompiledTransactionMessage } from './compile';\nimport type { getCompiledAddressTableLookups } from './compile/address-table-lookups';\nimport { createTransactionMessage } from './create-transaction-message';\nimport {\n    isAdvanceNonceAccountInstruction,\n    Nonce,\n    setTransactionMessageLifetimeUsingDurableNonce,\n} from './durable-nonce';\nimport { setTransactionMessageFeePayer } from './fee-payer';\nimport { appendTransactionMessageInstruction } from './instructions';\nimport { TransactionVersion } from './transaction-message';\n\nfunction getAccountMetas(message: CompiledTransactionMessage): IAccountMeta[] {\n    const { header } = message;\n    const numWritableSignerAccounts = header.numSignerAccounts - header.numReadonlySignerAccounts;\n    const numWritableNonSignerAccounts =\n        message.staticAccounts.length - header.numSignerAccounts - header.numReadonlyNonSignerAccounts;\n\n    const accountMetas: IAccountMeta[] = [];\n\n    let accountIndex = 0;\n    for (let i = 0; i < numWritableSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.WRITABLE_SIGNER,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < header.numReadonlySignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.READONLY_SIGNER,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < numWritableNonSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.WRITABLE,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < header.numReadonlyNonSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.READONLY,\n        });\n        accountIndex++;\n    }\n\n    return accountMetas;\n}\n\nfunction getAddressLookupMetas(\n    compiledAddressTableLookups: ReturnType<typeof getCompiledAddressTableLookups>,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): IAccountLookupMeta[] {\n    // check that all message lookups are known\n    const compiledAddressTableLookupAddresses = compiledAddressTableLookups.map(l => l.lookupTableAddress);\n    const missing = compiledAddressTableLookupAddresses.filter(a => addressesByLookupTableAddress[a] === undefined);\n    if (missing.length > 0) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING, {\n            lookupTableAddresses: missing,\n        });\n    }\n\n    const readOnlyMetas: IAccountLookupMeta[] = [];\n    const writableMetas: IAccountLookupMeta[] = [];\n\n    // we know that for each lookup, knownLookups[lookup.lookupTableAddress] is defined\n    for (const lookup of compiledAddressTableLookups) {\n        const addresses = addressesByLookupTableAddress[lookup.lookupTableAddress];\n        const readonlyIndexes =\n            lookup.readonlyIndexes ??\n            /** @deprecated Remove in a future major version */\n            lookup.readableIndices;\n        const writableIndexes =\n            lookup.writableIndexes ??\n            /** @deprecated Remove in a future major version */\n            lookup.writableIndices;\n\n        const highestIndex = Math.max(...readonlyIndexes, ...writableIndexes);\n        if (highestIndex >= addresses.length) {\n            throw new SolanaError(\n                SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n                {\n                    highestKnownIndex: addresses.length - 1,\n                    highestRequestedIndex: highestIndex,\n                    lookupTableAddress: lookup.lookupTableAddress,\n                },\n            );\n        }\n\n        const readOnlyForLookup: IAccountLookupMeta[] = readonlyIndexes.map(r => ({\n            address: addresses[r],\n            addressIndex: r,\n            lookupTableAddress: lookup.lookupTableAddress,\n            role: AccountRole.READONLY,\n        }));\n        readOnlyMetas.push(...readOnlyForLookup);\n\n        const writableForLookup: IAccountLookupMeta[] = writableIndexes.map(w => ({\n            address: addresses[w],\n            addressIndex: w,\n            lookupTableAddress: lookup.lookupTableAddress,\n            role: AccountRole.WRITABLE,\n        }));\n        writableMetas.push(...writableForLookup);\n    }\n\n    return [...writableMetas, ...readOnlyMetas];\n}\n\nfunction convertInstruction(\n    instruction: CompiledTransactionMessage['instructions'][0],\n    accountMetas: IAccountMeta[],\n): IInstruction {\n    const programAddress = accountMetas[instruction.programAddressIndex]?.address;\n    if (!programAddress) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND, {\n            index: instruction.programAddressIndex,\n        });\n    }\n\n    const accounts = instruction.accountIndices?.map(accountIndex => accountMetas[accountIndex]);\n    const { data } = instruction;\n\n    return Object.freeze({\n        programAddress,\n        ...(accounts && accounts.length ? { accounts: Object.freeze(accounts) } : {}),\n        ...(data && data.length ? { data } : {}),\n    });\n}\n\ntype LifetimeConstraint =\n    | {\n          blockhash: Blockhash;\n          lastValidBlockHeight: bigint;\n      }\n    | {\n          nonce: Nonce;\n          nonceAccountAddress: Address;\n          nonceAuthorityAddress: Address;\n      };\n\nfunction getLifetimeConstraint(\n    messageLifetimeToken: string,\n    firstInstruction?: IInstruction,\n    lastValidBlockHeight?: bigint,\n): LifetimeConstraint {\n    if (!firstInstruction || !isAdvanceNonceAccountInstruction(firstInstruction)) {\n        // first instruction is not advance durable nonce, so use blockhash lifetime constraint\n        return {\n            blockhash: messageLifetimeToken as Blockhash,\n            lastValidBlockHeight: lastValidBlockHeight ?? 2n ** 64n - 1n, // U64 MAX\n        };\n    } else {\n        // We know these accounts are defined because we checked `isAdvanceNonceAccountInstruction`\n        const nonceAccountAddress = firstInstruction.accounts[0].address;\n        assertIsAddress(nonceAccountAddress);\n\n        const nonceAuthorityAddress = firstInstruction.accounts[2].address;\n        assertIsAddress(nonceAuthorityAddress);\n\n        return {\n            nonce: messageLifetimeToken as Nonce,\n            nonceAccountAddress,\n            nonceAuthorityAddress,\n        };\n    }\n}\n\nexport type DecompileTransactionMessageConfig = {\n    /**\n     * If the compiled message loads addresses from one or more address lookup tables, you will have\n     * to supply a map of those tables to an array of the addresses they contained at the time that\n     * the transaction message was constructed.\n     *\n     * @see {@link decompileTransactionMessageFetchingLookupTables} if you do not already have this.\n     */\n    addressesByLookupTableAddress?: AddressesByLookupTableAddress;\n    /**\n     * If the compiled message has a blockhash-based lifetime constraint, you will have to supply\n     * the block height after which that blockhash is no longer valid for use as a lifetime\n     * constraint.\n     */\n    lastValidBlockHeight?: bigint;\n};\n\n/**\n * Converts the type of transaction message data structure appropriate for execution on the network\n * to the type of transaction message data structure designed for use in your application.\n *\n * Because compilation is a lossy process, you can not fully reconstruct a source message from a\n * compiled message without extra information. In order to faithfully reconstruct the original\n * source message you will need to supply supporting details about the lifetime constraint and the\n * concrete addresses of any accounts sourced from account lookup tables.\n *\n * @see {@link compileTransactionMessage}\n */\nexport function decompileTransactionMessage(\n    compiledTransactionMessage: CompiledTransactionMessage,\n    config?: DecompileTransactionMessageConfig,\n): CompilableTransactionMessage {\n    const feePayer = compiledTransactionMessage.staticAccounts[0];\n    if (!feePayer) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING);\n    }\n\n    const accountMetas = getAccountMetas(compiledTransactionMessage);\n    const accountLookupMetas =\n        'addressTableLookups' in compiledTransactionMessage &&\n        compiledTransactionMessage.addressTableLookups !== undefined &&\n        compiledTransactionMessage.addressTableLookups.length > 0\n            ? getAddressLookupMetas(\n                  compiledTransactionMessage.addressTableLookups,\n                  config?.addressesByLookupTableAddress ?? {},\n              )\n            : [];\n    const transactionMetas = [...accountMetas, ...accountLookupMetas];\n\n    const instructions: IInstruction[] = compiledTransactionMessage.instructions.map(compiledInstruction =>\n        convertInstruction(compiledInstruction, transactionMetas),\n    );\n\n    const firstInstruction = instructions[0];\n    const lifetimeConstraint = getLifetimeConstraint(\n        compiledTransactionMessage.lifetimeToken,\n        firstInstruction,\n        config?.lastValidBlockHeight,\n    );\n\n    return pipe(\n        createTransactionMessage({ version: compiledTransactionMessage.version as TransactionVersion }),\n        m => setTransactionMessageFeePayer(feePayer, m),\n        m =>\n            instructions.reduce((acc, instruction) => {\n                return appendTransactionMessageInstruction(instruction, acc);\n            }, m),\n        m =>\n            'blockhash' in lifetimeConstraint\n                ? setTransactionMessageLifetimeUsingBlockhash(lifetimeConstraint, m)\n                : setTransactionMessageLifetimeUsingDurableNonce(lifetimeConstraint, m),\n    );\n}\n"]}