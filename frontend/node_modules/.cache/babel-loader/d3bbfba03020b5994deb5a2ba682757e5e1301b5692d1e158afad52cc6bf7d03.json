{"ast":null,"code":"import { bytesRegex, execTyped, integerRegex, isTupleRegex } from '../../regex.js';\nimport { UnknownSolidityTypeError } from '../errors/abiItem.js';\nimport { InvalidFunctionModifierError, InvalidModifierError, InvalidParameterError, SolidityProtectedKeywordError } from '../errors/abiParameter.js';\nimport { InvalidSignatureError, UnknownSignatureError } from '../errors/signature.js';\nimport { InvalidParenthesisError } from '../errors/splitParameters.js';\nimport { getParameterCacheKey, parameterCache } from './cache.js';\nimport { eventModifiers, execConstructorSignature, execErrorSignature, execEventSignature, execFallbackSignature, execFunctionSignature, functionModifiers, isConstructorSignature, isErrorSignature, isEventSignature, isFallbackSignature, isFunctionSignature, isReceiveSignature } from './signatures.js';\nexport function parseSignature(signature, structs = {}) {\n  if (isFunctionSignature(signature)) return parseFunctionSignature(signature, structs);\n  if (isEventSignature(signature)) return parseEventSignature(signature, structs);\n  if (isErrorSignature(signature)) return parseErrorSignature(signature, structs);\n  if (isConstructorSignature(signature)) return parseConstructorSignature(signature, structs);\n  if (isFallbackSignature(signature)) return parseFallbackSignature(signature);\n  if (isReceiveSignature(signature)) return {\n    type: 'receive',\n    stateMutability: 'payable'\n  };\n  throw new UnknownSignatureError({\n    signature\n  });\n}\nexport function parseFunctionSignature(signature, structs = {}) {\n  const match = execFunctionSignature(signature);\n  if (!match) throw new InvalidSignatureError({\n    signature,\n    type: 'function'\n  });\n  const inputParams = splitParameters(match.parameters);\n  const inputs = [];\n  const inputLength = inputParams.length;\n  for (let i = 0; i < inputLength; i++) {\n    inputs.push(parseAbiParameter(inputParams[i], {\n      modifiers: functionModifiers,\n      structs,\n      type: 'function'\n    }));\n  }\n  const outputs = [];\n  if (match.returns) {\n    const outputParams = splitParameters(match.returns);\n    const outputLength = outputParams.length;\n    for (let i = 0; i < outputLength; i++) {\n      outputs.push(parseAbiParameter(outputParams[i], {\n        modifiers: functionModifiers,\n        structs,\n        type: 'function'\n      }));\n    }\n  }\n  return {\n    name: match.name,\n    type: 'function',\n    stateMutability: match.stateMutability ?? 'nonpayable',\n    inputs,\n    outputs\n  };\n}\nexport function parseEventSignature(signature, structs = {}) {\n  const match = execEventSignature(signature);\n  if (!match) throw new InvalidSignatureError({\n    signature,\n    type: 'event'\n  });\n  const params = splitParameters(match.parameters);\n  const abiParameters = [];\n  const length = params.length;\n  for (let i = 0; i < length; i++) abiParameters.push(parseAbiParameter(params[i], {\n    modifiers: eventModifiers,\n    structs,\n    type: 'event'\n  }));\n  return {\n    name: match.name,\n    type: 'event',\n    inputs: abiParameters\n  };\n}\nexport function parseErrorSignature(signature, structs = {}) {\n  const match = execErrorSignature(signature);\n  if (!match) throw new InvalidSignatureError({\n    signature,\n    type: 'error'\n  });\n  const params = splitParameters(match.parameters);\n  const abiParameters = [];\n  const length = params.length;\n  for (let i = 0; i < length; i++) abiParameters.push(parseAbiParameter(params[i], {\n    structs,\n    type: 'error'\n  }));\n  return {\n    name: match.name,\n    type: 'error',\n    inputs: abiParameters\n  };\n}\nexport function parseConstructorSignature(signature, structs = {}) {\n  const match = execConstructorSignature(signature);\n  if (!match) throw new InvalidSignatureError({\n    signature,\n    type: 'constructor'\n  });\n  const params = splitParameters(match.parameters);\n  const abiParameters = [];\n  const length = params.length;\n  for (let i = 0; i < length; i++) abiParameters.push(parseAbiParameter(params[i], {\n    structs,\n    type: 'constructor'\n  }));\n  return {\n    type: 'constructor',\n    stateMutability: match.stateMutability ?? 'nonpayable',\n    inputs: abiParameters\n  };\n}\nexport function parseFallbackSignature(signature) {\n  const match = execFallbackSignature(signature);\n  if (!match) throw new InvalidSignatureError({\n    signature,\n    type: 'fallback'\n  });\n  return {\n    type: 'fallback',\n    stateMutability: match.stateMutability ?? 'nonpayable'\n  };\n}\nconst abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;\nconst abiParameterWithTupleRegex = /^\\((?<type>.+?)\\)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;\nconst dynamicIntegerRegex = /^u?int$/;\nexport function parseAbiParameter(param, options) {\n  // optional namespace cache by `type`\n  const parameterCacheKey = getParameterCacheKey(param, options?.type, options?.structs);\n  if (parameterCache.has(parameterCacheKey)) return parameterCache.get(parameterCacheKey);\n  const isTuple = isTupleRegex.test(param);\n  const match = execTyped(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);\n  if (!match) throw new InvalidParameterError({\n    param\n  });\n  if (match.name && isSolidityKeyword(match.name)) throw new SolidityProtectedKeywordError({\n    param,\n    name: match.name\n  });\n  const name = match.name ? {\n    name: match.name\n  } : {};\n  const indexed = match.modifier === 'indexed' ? {\n    indexed: true\n  } : {};\n  const structs = options?.structs ?? {};\n  let type;\n  let components = {};\n  if (isTuple) {\n    type = 'tuple';\n    const params = splitParameters(match.type);\n    const components_ = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      // remove `modifiers` from `options` to prevent from being added to tuple components\n      components_.push(parseAbiParameter(params[i], {\n        structs\n      }));\n    }\n    components = {\n      components: components_\n    };\n  } else if (match.type in structs) {\n    type = 'tuple';\n    components = {\n      components: structs[match.type]\n    };\n  } else if (dynamicIntegerRegex.test(match.type)) {\n    type = `${match.type}256`;\n  } else {\n    type = match.type;\n    if (!(options?.type === 'struct') && !isSolidityType(type)) throw new UnknownSolidityTypeError({\n      type\n    });\n  }\n  if (match.modifier) {\n    // Check if modifier exists, but is not allowed (e.g. `indexed` in `functionModifiers`)\n    if (!options?.modifiers?.has?.(match.modifier)) throw new InvalidModifierError({\n      param,\n      type: options?.type,\n      modifier: match.modifier\n    });\n    // Check if resolved `type` is valid if there is a function modifier\n    if (functionModifiers.has(match.modifier) && !isValidDataLocation(type, !!match.array)) throw new InvalidFunctionModifierError({\n      param,\n      type: options?.type,\n      modifier: match.modifier\n    });\n  }\n  const abiParameter = {\n    type: `${type}${match.array ?? ''}`,\n    ...name,\n    ...indexed,\n    ...components\n  };\n  parameterCache.set(parameterCacheKey, abiParameter);\n  return abiParameter;\n}\n// s/o latika for this\nexport function splitParameters(params, result = [], current = '', depth = 0) {\n  const length = params.trim().length;\n  // biome-ignore lint/correctness/noUnreachable: recursive\n  for (let i = 0; i < length; i++) {\n    const char = params[i];\n    const tail = params.slice(i + 1);\n    switch (char) {\n      case ',':\n        return depth === 0 ? splitParameters(tail, [...result, current.trim()]) : splitParameters(tail, result, `${current}${char}`, depth);\n      case '(':\n        return splitParameters(tail, result, `${current}${char}`, depth + 1);\n      case ')':\n        return splitParameters(tail, result, `${current}${char}`, depth - 1);\n      default:\n        return splitParameters(tail, result, `${current}${char}`, depth);\n    }\n  }\n  if (current === '') return result;\n  if (depth !== 0) throw new InvalidParenthesisError({\n    current,\n    depth\n  });\n  result.push(current.trim());\n  return result;\n}\nexport function isSolidityType(type) {\n  return type === 'address' || type === 'bool' || type === 'function' || type === 'string' || bytesRegex.test(type) || integerRegex.test(type);\n}\nconst protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;\n/** @internal */\nexport function isSolidityKeyword(name) {\n  return name === 'address' || name === 'bool' || name === 'function' || name === 'string' || name === 'tuple' || bytesRegex.test(name) || integerRegex.test(name) || protectedKeywordsRegex.test(name);\n}\n/** @internal */\nexport function isValidDataLocation(type, isArray) {\n  return isArray || type === 'bytes' || type === 'string' || type === 'tuple';\n}\n//# sourceMappingURL=utils.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}