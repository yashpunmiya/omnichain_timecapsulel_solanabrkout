{"ast":null,"code":"import { proxy, subscribe as sub } from 'valtio/vanilla';\nimport { W3mFrameRpcConstants } from '@reown/appkit-wallet/utils';\nimport { AccountController } from './AccountController.js';\nimport { BlockchainApiController } from './BlockchainApiController.js';\nimport { ChainController } from './ChainController.js';\nimport { EventsController } from './EventsController.js';\nimport { OptionsController } from './OptionsController.js';\nimport { SnackController } from './SnackController.js';\n// -- State --------------------------------------------- //\nconst state = proxy({\n  transactions: [],\n  coinbaseTransactions: {},\n  transactionsByYear: {},\n  lastNetworkInView: undefined,\n  loading: false,\n  empty: false,\n  next: undefined\n});\n// -- Controller ---------------------------------------- //\nexport const TransactionsController = {\n  state,\n  subscribe(callback) {\n    return sub(state, () => callback(state));\n  },\n  setLastNetworkInView(lastNetworkInView) {\n    state.lastNetworkInView = lastNetworkInView;\n  },\n  async fetchTransactions(accountAddress, onramp) {\n    if (!accountAddress) {\n      throw new Error(\"Transactions can't be fetched without an accountAddress\");\n    }\n    state.loading = true;\n    try {\n      const response = await BlockchainApiController.fetchTransactions({\n        account: accountAddress,\n        cursor: state.next,\n        onramp,\n        // Coinbase transaction history state updates require the latest data\n        cache: onramp === 'coinbase' ? 'no-cache' : undefined,\n        chainId: ChainController.state.activeCaipNetwork?.caipNetworkId\n      });\n      const nonSpamTransactions = this.filterSpamTransactions(response.data);\n      const sameChainTransactions = this.filterByConnectedChain(nonSpamTransactions);\n      const filteredTransactions = [...state.transactions, ...sameChainTransactions];\n      state.loading = false;\n      if (onramp === 'coinbase') {\n        state.coinbaseTransactions = this.groupTransactionsByYearAndMonth(state.coinbaseTransactions, response.data);\n      } else {\n        state.transactions = filteredTransactions;\n        state.transactionsByYear = this.groupTransactionsByYearAndMonth(state.transactionsByYear, sameChainTransactions);\n      }\n      state.empty = filteredTransactions.length === 0;\n      state.next = response.next ? response.next : undefined;\n    } catch (error) {\n      EventsController.sendEvent({\n        type: 'track',\n        event: 'ERROR_FETCH_TRANSACTIONS',\n        properties: {\n          address: accountAddress,\n          projectId: OptionsController.state.projectId,\n          cursor: state.next,\n          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT\n        }\n      });\n      SnackController.showError('Failed to fetch transactions');\n      state.loading = false;\n      state.empty = true;\n      state.next = undefined;\n    }\n  },\n  groupTransactionsByYearAndMonth(transactionsMap = {}, transactions = []) {\n    const grouped = transactionsMap;\n    transactions.forEach(transaction => {\n      const year = new Date(transaction.metadata.minedAt).getFullYear();\n      const month = new Date(transaction.metadata.minedAt).getMonth();\n      const yearTransactions = grouped[year] ?? {};\n      const monthTransactions = yearTransactions[month] ?? [];\n      // If there's a transaction with the same id, remove the old one\n      const newMonthTransactions = monthTransactions.filter(tx => tx.id !== transaction.id);\n      grouped[year] = {\n        ...yearTransactions,\n        [month]: [...newMonthTransactions, transaction].sort((a, b) => new Date(b.metadata.minedAt).getTime() - new Date(a.metadata.minedAt).getTime())\n      };\n    });\n    return grouped;\n  },\n  filterSpamTransactions(transactions) {\n    return transactions.filter(transaction => {\n      const isAllSpam = transaction.transfers.every(transfer => transfer.nft_info?.flags.is_spam === true);\n      return !isAllSpam;\n    });\n  },\n  filterByConnectedChain(transactions) {\n    const chainId = ChainController.state.activeCaipNetwork?.caipNetworkId;\n    const filteredTransactions = transactions.filter(transaction => transaction.metadata.chain === chainId);\n    return filteredTransactions;\n  },\n  clearCursor() {\n    state.next = undefined;\n  },\n  resetTransactions() {\n    state.transactions = [];\n    state.transactionsByYear = {};\n    state.lastNetworkInView = undefined;\n    state.loading = false;\n    state.empty = false;\n    state.next = undefined;\n  }\n};\n//# sourceMappingURL=TransactionsController.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}