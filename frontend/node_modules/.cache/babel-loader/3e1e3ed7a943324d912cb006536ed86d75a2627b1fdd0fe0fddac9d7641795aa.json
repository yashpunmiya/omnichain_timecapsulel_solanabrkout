{"ast":null,"code":"import { proxy as e, subscribe as t, getVersion as n } from \"valtio/vanilla\";\nconst o = new WeakMap(),\n  r = new WeakMap(),\n  s = (e, t) => {\n    const n = o.get(e);\n    n && (n[0].forEach(t => {\n      const {\n        d: n\n      } = t;\n      e !== n && s(n);\n    }), ++n[2], t && n[3].add(t));\n  },\n  l = e => {\n    const t = o.get(e);\n    t && (--t[2], t[2] || (t[3].forEach(e => e()), t[3].clear()), t[0].forEach(t => {\n      const {\n        d: n\n      } = t;\n      e !== n && l(n);\n    }));\n  },\n  c = e => {\n    const {\n      s: n,\n      d: c\n    } = e;\n    let a = r.get(c);\n    a || (a = [new Set()], r.set(e.d, a)), a[0].add(e);\n    let d = o.get(n);\n    if (!d) {\n      const e = new Set(),\n        r = t(n, t => {\n          e.forEach(e => {\n            const {\n              d: o,\n              c: r,\n              n: c,\n              i: a\n            } = e;\n            n === o && t.every(e => 1 === e[1].length && a.includes(e[1][0])) || e.p || (s(n, r), c ? l(n) : e.p = Promise.resolve().then(() => {\n              delete e.p, l(n);\n            }));\n          });\n        }, !0);\n      d = [e, r, 0, new Set()], o.set(n, d);\n    }\n    d[0].add(e);\n  },\n  a = e => {\n    const {\n        s: t,\n        d: n\n      } = e,\n      s = r.get(n);\n    null == s || s[0].delete(e), 0 === (null == s ? void 0 : s[0].size) && r.delete(n);\n    const l = o.get(t);\n    if (l) {\n      const [n, r] = l;\n      n.delete(e), n.size || (r(), o.delete(t));\n    }\n  },\n  d = e => {\n    const t = r.get(e);\n    return t ? Array.from(t[0]) : [];\n  },\n  i = {\n    add: c,\n    remove: a,\n    list: d\n  };\nfunction f(t, r) {\n  const s = (null == r ? void 0 : r.proxy) || e({}),\n    l = !(null == r || !r.sync),\n    d = Object.keys(t);\n  return d.forEach(e => {\n    if (Object.getOwnPropertyDescriptor(s, e)) throw new Error(\"object property already defined\");\n    const r = t[e];\n    let i = null;\n    const f = () => {\n      if (i) {\n        if (Array.from(i).map(([e]) => ((e, t) => {\n          const n = o.get(e);\n          return !(null == n || !n[2] || (n[3].add(t), 0));\n        })(e, f)).some(e => e)) return;\n        if (Array.from(i).every(([e, t]) => n(e) === t.v)) return;\n      }\n      const t = new Map(),\n        u = r(e => (t.set(e, {\n          v: n(e)\n        }), e)),\n        p = () => {\n          var n;\n          t.forEach((t, n) => {\n            var o;\n            const r = null == (o = i) || null == (o = o.get(n)) ? void 0 : o.s;\n            if (r) t.s = r;else {\n              const o = {\n                s: n,\n                d: s,\n                k: e,\n                c: f,\n                n: l,\n                i: d\n              };\n              c(o), t.s = o;\n            }\n          }), null == (n = i) || n.forEach((e, n) => {\n            !t.has(n) && e.s && a(e.s);\n          }), i = t;\n        };\n      u instanceof Promise ? u.finally(p) : p(), s[e] = u;\n    };\n    f();\n  }), s;\n}\nfunction u(e, t) {\n  const n = null != t && t.delete ? new Set() : null;\n  d(e).forEach(e => {\n    const {\n      k: o\n    } = e;\n    null != t && t.keys && !t.keys.includes(o) || (a(e), n && n.add(o));\n  }), n && n.forEach(t => {\n    delete e[t];\n  });\n}\nexport { f as derive, u as underive, i as unstable_deriveSubscriptions };\n//# sourceMappingURL=index.modern.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}