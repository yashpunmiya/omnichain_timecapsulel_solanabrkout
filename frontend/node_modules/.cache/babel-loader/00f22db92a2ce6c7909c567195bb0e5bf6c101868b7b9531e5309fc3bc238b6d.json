{"ast":null,"code":"import { ExecutionRevertedError } from '../../errors/node.js';\nimport { TransactionRejectedRpcError, UserRejectedRequestError } from '../../errors/rpc.js';\nimport { wait } from '../../utils/wait.js';\nimport { createTransport } from './createTransport.js';\nexport function fallback(transports_, config = {}) {\n  const {\n    key = 'fallback',\n    name = 'Fallback',\n    rank = false,\n    retryCount,\n    retryDelay\n  } = config;\n  return ({\n    chain,\n    pollingInterval = 4_000,\n    timeout,\n    ...rest\n  }) => {\n    let transports = transports_;\n    let onResponse = () => {};\n    const transport = createTransport({\n      key,\n      name,\n      async request({\n        method,\n        params\n      }) {\n        let includes;\n        const fetch = async (i = 0) => {\n          const transport = transports[i]({\n            ...rest,\n            chain,\n            retryCount: 0,\n            timeout\n          });\n          try {\n            const response = await transport.request({\n              method,\n              params\n            });\n            onResponse({\n              method,\n              params: params,\n              response,\n              transport,\n              status: 'success'\n            });\n            return response;\n          } catch (err) {\n            onResponse({\n              error: err,\n              method,\n              params: params,\n              transport,\n              status: 'error'\n            });\n            if (shouldThrow(err)) throw err;\n            // If we've reached the end of the fallbacks, throw the error.\n            if (i === transports.length - 1) throw err;\n            // Check if at least one other transport includes the method\n            includes ??= transports.slice(i + 1).some(transport => {\n              const {\n                include,\n                exclude\n              } = transport({\n                chain\n              }).config.methods || {};\n              if (include) return include.includes(method);\n              if (exclude) return !exclude.includes(method);\n              return true;\n            });\n            if (!includes) throw err;\n            // Otherwise, try the next fallback.\n            return fetch(i + 1);\n          }\n        };\n        return fetch();\n      },\n      retryCount,\n      retryDelay,\n      type: 'fallback'\n    }, {\n      onResponse: fn => onResponse = fn,\n      transports: transports.map(fn => fn({\n        chain,\n        retryCount: 0\n      }))\n    });\n    if (rank) {\n      const rankOptions = typeof rank === 'object' ? rank : {};\n      rankTransports({\n        chain,\n        interval: rankOptions.interval ?? pollingInterval,\n        onTransports: transports_ => transports = transports_,\n        ping: rankOptions.ping,\n        sampleCount: rankOptions.sampleCount,\n        timeout: rankOptions.timeout,\n        transports,\n        weights: rankOptions.weights\n      });\n    }\n    return transport;\n  };\n}\nfunction shouldThrow(error) {\n  if ('code' in error && typeof error.code === 'number') {\n    if (error.code === TransactionRejectedRpcError.code || error.code === UserRejectedRequestError.code || ExecutionRevertedError.nodeMessage.test(error.message) || error.code === 5000 // CAIP UserRejectedRequestError\n    ) return true;\n  }\n  return false;\n}\n/** @internal */\nexport function rankTransports({\n  chain,\n  interval = 4_000,\n  onTransports,\n  ping,\n  sampleCount = 10,\n  timeout = 1_000,\n  transports,\n  weights = {}\n}) {\n  const {\n    stability: stabilityWeight = 0.7,\n    latency: latencyWeight = 0.3\n  } = weights;\n  const samples = [];\n  const rankTransports_ = async () => {\n    // 1. Take a sample from each Transport.\n    const sample = await Promise.all(transports.map(async transport => {\n      const transport_ = transport({\n        chain,\n        retryCount: 0,\n        timeout\n      });\n      const start = Date.now();\n      let end;\n      let success;\n      try {\n        await (ping ? ping({\n          transport: transport_\n        }) : transport_.request({\n          method: 'net_listening'\n        }));\n        success = 1;\n      } catch {\n        success = 0;\n      } finally {\n        end = Date.now();\n      }\n      const latency = end - start;\n      return {\n        latency,\n        success\n      };\n    }));\n    // 2. Store the sample. If we have more than `sampleCount` samples, remove\n    // the oldest sample.\n    samples.push(sample);\n    if (samples.length > sampleCount) samples.shift();\n    // 3. Calculate the max latency from samples.\n    const maxLatency = Math.max(...samples.map(sample => Math.max(...sample.map(({\n      latency\n    }) => latency))));\n    // 4. Calculate the score for each Transport.\n    const scores = transports.map((_, i) => {\n      const latencies = samples.map(sample => sample[i].latency);\n      const meanLatency = latencies.reduce((acc, latency) => acc + latency, 0) / latencies.length;\n      const latencyScore = 1 - meanLatency / maxLatency;\n      const successes = samples.map(sample => sample[i].success);\n      const stabilityScore = successes.reduce((acc, success) => acc + success, 0) / successes.length;\n      if (stabilityScore === 0) return [0, i];\n      return [latencyWeight * latencyScore + stabilityWeight * stabilityScore, i];\n    }).sort((a, b) => b[0] - a[0]);\n    // 5. Sort the Transports by score.\n    onTransports(scores.map(([, i]) => transports[i]));\n    // 6. Wait, and then rank again.\n    await wait(interval);\n    rankTransports_();\n  };\n  rankTransports_();\n}\n//# sourceMappingURL=fallback.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}