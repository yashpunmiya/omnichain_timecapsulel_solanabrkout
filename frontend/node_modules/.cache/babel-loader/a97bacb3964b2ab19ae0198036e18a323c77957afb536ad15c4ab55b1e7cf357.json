{"ast":null,"code":"import { InvalidBytesBooleanError } from '../../errors/encoding.js';\nimport { trim } from '../data/trim.js';\nimport { assertSize, hexToBigInt, hexToNumber } from './fromHex.js';\nimport { bytesToHex } from './toHex.js';\n/**\n * Decodes a byte array into a UTF-8 string, hex value, number, bigint or boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes\n * - Example: https://viem.sh/docs/utilities/fromBytes#usage\n *\n * @param bytes Byte array to decode.\n * @param toOrOpts Type to convert to or options.\n * @returns Decoded value.\n *\n * @example\n * import { fromBytes } from 'viem'\n * const data = fromBytes(new Uint8Array([1, 164]), 'number')\n * // 420\n *\n * @example\n * import { fromBytes } from 'viem'\n * const data = fromBytes(\n *   new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]),\n *   'string'\n * )\n * // 'Hello world'\n */\nexport function fromBytes(bytes, toOrOpts) {\n  const opts = typeof toOrOpts === 'string' ? {\n    to: toOrOpts\n  } : toOrOpts;\n  const to = opts.to;\n  if (to === 'number') return bytesToNumber(bytes, opts);\n  if (to === 'bigint') return bytesToBigInt(bytes, opts);\n  if (to === 'boolean') return bytesToBool(bytes, opts);\n  if (to === 'string') return bytesToString(bytes, opts);\n  return bytesToHex(bytes, opts);\n}\n/**\n * Decodes a byte array into a bigint.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestobigint\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns BigInt value.\n *\n * @example\n * import { bytesToBigInt } from 'viem'\n * const data = bytesToBigInt(new Uint8Array([1, 164]))\n * // 420n\n */\nexport function bytesToBigInt(bytes, opts = {}) {\n  if (typeof opts.size !== 'undefined') assertSize(bytes, {\n    size: opts.size\n  });\n  const hex = bytesToHex(bytes, opts);\n  return hexToBigInt(hex, opts);\n}\n/**\n * Decodes a byte array into a boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestobool\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns Boolean value.\n *\n * @example\n * import { bytesToBool } from 'viem'\n * const data = bytesToBool(new Uint8Array([1]))\n * // true\n */\nexport function bytesToBool(bytes_, opts = {}) {\n  let bytes = bytes_;\n  if (typeof opts.size !== 'undefined') {\n    assertSize(bytes, {\n      size: opts.size\n    });\n    bytes = trim(bytes);\n  }\n  if (bytes.length > 1 || bytes[0] > 1) throw new InvalidBytesBooleanError(bytes);\n  return Boolean(bytes[0]);\n}\n/**\n * Decodes a byte array into a number.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestonumber\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns Number value.\n *\n * @example\n * import { bytesToNumber } from 'viem'\n * const data = bytesToNumber(new Uint8Array([1, 164]))\n * // 420\n */\nexport function bytesToNumber(bytes, opts = {}) {\n  if (typeof opts.size !== 'undefined') assertSize(bytes, {\n    size: opts.size\n  });\n  const hex = bytesToHex(bytes, opts);\n  return hexToNumber(hex, opts);\n}\n/**\n * Decodes a byte array into a UTF-8 string.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestostring\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns String value.\n *\n * @example\n * import { bytesToString } from 'viem'\n * const data = bytesToString(new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // 'Hello world'\n */\nexport function bytesToString(bytes_, opts = {}) {\n  let bytes = bytes_;\n  if (typeof opts.size !== 'undefined') {\n    assertSize(bytes, {\n      size: opts.size\n    });\n    bytes = trim(bytes, {\n      dir: 'right'\n    });\n  }\n  return new TextDecoder().decode(bytes);\n}","map":{"version":3,"names":["InvalidBytesBooleanError","trim","assertSize","hexToBigInt","hexToNumber","bytesToHex","fromBytes","bytes","toOrOpts","opts","to","bytesToNumber","bytesToBigInt","bytesToBool","bytesToString","size","hex","bytes_","length","Boolean","dir","TextDecoder","decode"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@reown\\appkit-controllers\\node_modules\\@walletconnect\\utils\\node_modules\\viem\\utils\\encoding\\fromBytes.ts"],"sourcesContent":["import { InvalidBytesBooleanError } from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type TrimErrorType, trim } from '../data/trim.js'\n\nimport {\n  type AssertSizeErrorType,\n  type HexToBigIntErrorType,\n  type HexToNumberErrorType,\n  assertSize,\n  hexToBigInt,\n  hexToNumber,\n} from './fromHex.js'\nimport { type BytesToHexErrorType, bytesToHex } from './toHex.js'\n\nexport type FromBytesParameters<\n  to extends 'string' | 'hex' | 'bigint' | 'number' | 'boolean',\n> =\n  | to\n  | {\n      /** Size of the bytes. */\n      size?: number | undefined\n      /** Type to convert to. */\n      to: to\n    }\n\nexport type FromBytesReturnType<to> = to extends 'string'\n  ? string\n  : to extends 'hex'\n    ? Hex\n    : to extends 'bigint'\n      ? bigint\n      : to extends 'number'\n        ? number\n        : to extends 'boolean'\n          ? boolean\n          : never\n\nexport type FromBytesErrorType =\n  | BytesToHexErrorType\n  | BytesToBigIntErrorType\n  | BytesToBoolErrorType\n  | BytesToNumberErrorType\n  | BytesToStringErrorType\n  | ErrorType\n\n/**\n * Decodes a byte array into a UTF-8 string, hex value, number, bigint or boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes\n * - Example: https://viem.sh/docs/utilities/fromBytes#usage\n *\n * @param bytes Byte array to decode.\n * @param toOrOpts Type to convert to or options.\n * @returns Decoded value.\n *\n * @example\n * import { fromBytes } from 'viem'\n * const data = fromBytes(new Uint8Array([1, 164]), 'number')\n * // 420\n *\n * @example\n * import { fromBytes } from 'viem'\n * const data = fromBytes(\n *   new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]),\n *   'string'\n * )\n * // 'Hello world'\n */\nexport function fromBytes<\n  to extends 'string' | 'hex' | 'bigint' | 'number' | 'boolean',\n>(\n  bytes: ByteArray,\n  toOrOpts: FromBytesParameters<to>,\n): FromBytesReturnType<to> {\n  const opts = typeof toOrOpts === 'string' ? { to: toOrOpts } : toOrOpts\n  const to = opts.to\n\n  if (to === 'number')\n    return bytesToNumber(bytes, opts) as FromBytesReturnType<to>\n  if (to === 'bigint')\n    return bytesToBigInt(bytes, opts) as FromBytesReturnType<to>\n  if (to === 'boolean')\n    return bytesToBool(bytes, opts) as FromBytesReturnType<to>\n  if (to === 'string')\n    return bytesToString(bytes, opts) as FromBytesReturnType<to>\n  return bytesToHex(bytes, opts) as FromBytesReturnType<to>\n}\n\nexport type BytesToBigIntOpts = {\n  /** Whether or not the number of a signed representation. */\n  signed?: boolean | undefined\n  /** Size of the bytes. */\n  size?: number | undefined\n}\n\nexport type BytesToBigIntErrorType =\n  | BytesToHexErrorType\n  | HexToBigIntErrorType\n  | ErrorType\n\n/**\n * Decodes a byte array into a bigint.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestobigint\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns BigInt value.\n *\n * @example\n * import { bytesToBigInt } from 'viem'\n * const data = bytesToBigInt(new Uint8Array([1, 164]))\n * // 420n\n */\nexport function bytesToBigInt(\n  bytes: ByteArray,\n  opts: BytesToBigIntOpts = {},\n): bigint {\n  if (typeof opts.size !== 'undefined') assertSize(bytes, { size: opts.size })\n  const hex = bytesToHex(bytes, opts)\n  return hexToBigInt(hex, opts)\n}\n\nexport type BytesToBoolOpts = {\n  /** Size of the bytes. */\n  size?: number | undefined\n}\n\nexport type BytesToBoolErrorType =\n  | AssertSizeErrorType\n  | TrimErrorType\n  | ErrorType\n\n/**\n * Decodes a byte array into a boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestobool\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns Boolean value.\n *\n * @example\n * import { bytesToBool } from 'viem'\n * const data = bytesToBool(new Uint8Array([1]))\n * // true\n */\nexport function bytesToBool(\n  bytes_: ByteArray,\n  opts: BytesToBoolOpts = {},\n): boolean {\n  let bytes = bytes_\n  if (typeof opts.size !== 'undefined') {\n    assertSize(bytes, { size: opts.size })\n    bytes = trim(bytes)\n  }\n  if (bytes.length > 1 || bytes[0] > 1)\n    throw new InvalidBytesBooleanError(bytes)\n  return Boolean(bytes[0])\n}\n\nexport type BytesToNumberOpts = BytesToBigIntOpts\n\nexport type BytesToNumberErrorType =\n  | BytesToHexErrorType\n  | HexToNumberErrorType\n  | ErrorType\n\n/**\n * Decodes a byte array into a number.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestonumber\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns Number value.\n *\n * @example\n * import { bytesToNumber } from 'viem'\n * const data = bytesToNumber(new Uint8Array([1, 164]))\n * // 420\n */\nexport function bytesToNumber(\n  bytes: ByteArray,\n  opts: BytesToNumberOpts = {},\n): number {\n  if (typeof opts.size !== 'undefined') assertSize(bytes, { size: opts.size })\n  const hex = bytesToHex(bytes, opts)\n  return hexToNumber(hex, opts)\n}\n\nexport type BytesToStringOpts = {\n  /** Size of the bytes. */\n  size?: number | undefined\n}\n\nexport type BytesToStringErrorType =\n  | AssertSizeErrorType\n  | TrimErrorType\n  | ErrorType\n\n/**\n * Decodes a byte array into a UTF-8 string.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestostring\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns String value.\n *\n * @example\n * import { bytesToString } from 'viem'\n * const data = bytesToString(new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // 'Hello world'\n */\nexport function bytesToString(\n  bytes_: ByteArray,\n  opts: BytesToStringOpts = {},\n): string {\n  let bytes = bytes_\n  if (typeof opts.size !== 'undefined') {\n    assertSize(bytes, { size: opts.size })\n    bytes = trim(bytes, { dir: 'right' })\n  }\n  return new TextDecoder().decode(bytes)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}