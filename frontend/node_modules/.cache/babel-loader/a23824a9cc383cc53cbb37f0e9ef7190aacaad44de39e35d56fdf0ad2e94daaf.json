{"ast":null,"code":"import { addressResolverAbi, universalResolverResolveAbi } from '../../constants/abis.js';\nimport { decodeFunctionResult } from '../../utils/abi/decodeFunctionResult.js';\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js';\nimport { getChainContractAddress } from '../../utils/chain/getChainContractAddress.js';\nimport { trim } from '../../utils/data/trim.js';\nimport { toHex } from '../../utils/encoding/toHex.js';\nimport { isNullUniversalResolverError } from '../../utils/ens/errors.js';\nimport { namehash } from '../../utils/ens/namehash.js';\nimport { packetToBytes } from '../../utils/ens/packetToBytes.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { readContract } from '../public/readContract.js';\n/**\n * Gets address for ENS name.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsAddress\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens\n *\n * Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsAddressParameters}\n * @returns Address for ENS name or `null` if not found. {@link GetEnsAddressReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsAddress, normalize } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const ensAddress = await getEnsAddress(client, {\n *   name: normalize('wevm.eth'),\n * })\n * // '0xd2135CfB216b74109775236E36d4b433F1DF507B'\n */\nexport async function getEnsAddress(client, {\n  blockNumber,\n  blockTag,\n  coinType,\n  name,\n  gatewayUrls,\n  strict,\n  universalResolverAddress: universalResolverAddress_\n}) {\n  let universalResolverAddress = universalResolverAddress_;\n  if (!universalResolverAddress) {\n    if (!client.chain) throw new Error('client chain not configured. universalResolverAddress is required.');\n    universalResolverAddress = getChainContractAddress({\n      blockNumber,\n      chain: client.chain,\n      contract: 'ensUniversalResolver'\n    });\n  }\n  try {\n    const functionData = encodeFunctionData({\n      abi: addressResolverAbi,\n      functionName: 'addr',\n      ...(coinType != null ? {\n        args: [namehash(name), BigInt(coinType)]\n      } : {\n        args: [namehash(name)]\n      })\n    });\n    const readContractParameters = {\n      address: universalResolverAddress,\n      abi: universalResolverResolveAbi,\n      functionName: 'resolve',\n      args: [toHex(packetToBytes(name)), functionData],\n      blockNumber,\n      blockTag\n    };\n    const readContractAction = getAction(client, readContract, 'readContract');\n    const res = gatewayUrls ? await readContractAction({\n      ...readContractParameters,\n      args: [...readContractParameters.args, gatewayUrls]\n    }) : await readContractAction(readContractParameters);\n    if (res[0] === '0x') return null;\n    const address = decodeFunctionResult({\n      abi: addressResolverAbi,\n      args: coinType != null ? [namehash(name), BigInt(coinType)] : undefined,\n      functionName: 'addr',\n      data: res[0]\n    });\n    if (address === '0x') return null;\n    if (trim(address) === '0x00') return null;\n    return address;\n  } catch (err) {\n    if (strict) throw err;\n    if (isNullUniversalResolverError(err, 'resolve')) return null;\n    throw err;\n  }\n}","map":{"version":3,"names":["addressResolverAbi","universalResolverResolveAbi","decodeFunctionResult","encodeFunctionData","getChainContractAddress","trim","toHex","isNullUniversalResolverError","namehash","packetToBytes","getAction","readContract","getEnsAddress","client","blockNumber","blockTag","coinType","name","gatewayUrls","strict","universalResolverAddress","universalResolverAddress_","chain","Error","contract","functionData","abi","functionName","args","BigInt","readContractParameters","address","readContractAction","res","undefined","data","err"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@reown\\appkit-controllers\\node_modules\\@walletconnect\\utils\\node_modules\\viem\\actions\\ens\\getEnsAddress.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  addressResolverAbi,\n  universalResolverResolveAbi,\n} from '../../constants/abis.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Prettify } from '../../types/utils.js'\nimport {\n  type DecodeFunctionResultErrorType,\n  decodeFunctionResult,\n} from '../../utils/abi/decodeFunctionResult.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport {\n  type GetChainContractAddressErrorType,\n  getChainContractAddress,\n} from '../../utils/chain/getChainContractAddress.js'\nimport { type TrimErrorType, trim } from '../../utils/data/trim.js'\nimport { type ToHexErrorType, toHex } from '../../utils/encoding/toHex.js'\nimport { isNullUniversalResolverError } from '../../utils/ens/errors.js'\nimport { type NamehashErrorType, namehash } from '../../utils/ens/namehash.js'\nimport {\n  type PacketToBytesErrorType,\n  packetToBytes,\n} from '../../utils/ens/packetToBytes.js'\nimport { getAction } from '../../utils/getAction.js'\nimport {\n  type ReadContractParameters,\n  readContract,\n} from '../public/readContract.js'\n\nexport type GetEnsAddressParameters = Prettify<\n  Pick<ReadContractParameters, 'blockNumber' | 'blockTag'> & {\n    /** ENSIP-9 compliant coinType used to resolve addresses for other chains */\n    coinType?: number | undefined\n    /** Universal Resolver gateway URLs to use for resolving CCIP-read requests. */\n    gatewayUrls?: string[] | undefined\n    /** Name to get the address for. */\n    name: string\n    /** Whether or not to throw errors propagated from the ENS Universal Resolver Contract. */\n    strict?: boolean | undefined\n    /** Address of ENS Universal Resolver Contract. */\n    universalResolverAddress?: Address | undefined\n  }\n>\n\nexport type GetEnsAddressReturnType = Address | null\n\nexport type GetEnsAddressErrorType =\n  | GetChainContractAddressErrorType\n  | EncodeFunctionDataErrorType\n  | NamehashErrorType\n  | ToHexErrorType\n  | PacketToBytesErrorType\n  | DecodeFunctionResultErrorType\n  | TrimErrorType\n  | ErrorType\n\n/**\n * Gets address for ENS name.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsAddress\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens\n *\n * Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsAddressParameters}\n * @returns Address for ENS name or `null` if not found. {@link GetEnsAddressReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsAddress, normalize } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const ensAddress = await getEnsAddress(client, {\n *   name: normalize('wevm.eth'),\n * })\n * // '0xd2135CfB216b74109775236E36d4b433F1DF507B'\n */\nexport async function getEnsAddress<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  {\n    blockNumber,\n    blockTag,\n    coinType,\n    name,\n    gatewayUrls,\n    strict,\n    universalResolverAddress: universalResolverAddress_,\n  }: GetEnsAddressParameters,\n): Promise<GetEnsAddressReturnType> {\n  let universalResolverAddress = universalResolverAddress_\n  if (!universalResolverAddress) {\n    if (!client.chain)\n      throw new Error(\n        'client chain not configured. universalResolverAddress is required.',\n      )\n\n    universalResolverAddress = getChainContractAddress({\n      blockNumber,\n      chain: client.chain,\n      contract: 'ensUniversalResolver',\n    })\n  }\n\n  try {\n    const functionData = encodeFunctionData({\n      abi: addressResolverAbi,\n      functionName: 'addr',\n      ...(coinType != null\n        ? { args: [namehash(name), BigInt(coinType)] }\n        : { args: [namehash(name)] }),\n    })\n\n    const readContractParameters = {\n      address: universalResolverAddress,\n      abi: universalResolverResolveAbi,\n      functionName: 'resolve',\n      args: [toHex(packetToBytes(name)), functionData],\n      blockNumber,\n      blockTag,\n    } as const\n\n    const readContractAction = getAction(client, readContract, 'readContract')\n\n    const res = gatewayUrls\n      ? await readContractAction({\n          ...readContractParameters,\n          args: [...readContractParameters.args, gatewayUrls],\n        })\n      : await readContractAction(readContractParameters)\n\n    if (res[0] === '0x') return null\n\n    const address = decodeFunctionResult({\n      abi: addressResolverAbi,\n      args: coinType != null ? [namehash(name), BigInt(coinType)] : undefined,\n      functionName: 'addr',\n      data: res[0],\n    })\n\n    if (address === '0x') return null\n    if (trim(address) === '0x00') return null\n    return address\n  } catch (err) {\n    if (strict) throw err\n    if (isNullUniversalResolverError(err, 'resolve')) return null\n    throw err\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}