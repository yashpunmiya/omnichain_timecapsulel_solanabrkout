{"ast":null,"code":"// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n\n'use strict';\n\n/* replacement start */\nconst process = require('process/');\n\n/* replacement end */\n\nconst {\n  AbortError,\n  codes\n} = require('../../ours/errors');\nconst {\n  ERR_INVALID_ARG_TYPE,\n  ERR_STREAM_PREMATURE_CLOSE\n} = codes;\nconst {\n  kEmptyObject,\n  once\n} = require('../../ours/util');\nconst {\n  validateAbortSignal,\n  validateFunction,\n  validateObject,\n  validateBoolean\n} = require('../validators');\nconst {\n  Promise,\n  PromisePrototypeThen,\n  SymbolDispose\n} = require('../../ours/primordials');\nconst {\n  isClosed,\n  isReadable,\n  isReadableNodeStream,\n  isReadableStream,\n  isReadableFinished,\n  isReadableErrored,\n  isWritable,\n  isWritableNodeStream,\n  isWritableStream,\n  isWritableFinished,\n  isWritableErrored,\n  isNodeStream,\n  willEmitClose: _willEmitClose,\n  kIsClosedPromise\n} = require('./utils');\nlet addAbortListener;\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\nconst nop = () => {};\nfunction eos(stream, options, callback) {\n  var _options$readable, _options$writable;\n  if (arguments.length === 2) {\n    callback = options;\n    options = kEmptyObject;\n  } else if (options == null) {\n    options = kEmptyObject;\n  } else {\n    validateObject(options, 'options');\n  }\n  validateFunction(callback, 'callback');\n  validateAbortSignal(options.signal, 'options.signal');\n  callback = once(callback);\n  if (isReadableStream(stream) || isWritableStream(stream)) {\n    return eosWeb(stream, options, callback);\n  }\n  if (!isNodeStream(stream)) {\n    throw new ERR_INVALID_ARG_TYPE('stream', ['ReadableStream', 'WritableStream', 'Stream'], stream);\n  }\n  const readable = (_options$readable = options.readable) !== null && _options$readable !== undefined ? _options$readable : isReadableNodeStream(stream);\n  const writable = (_options$writable = options.writable) !== null && _options$writable !== undefined ? _options$writable : isWritableNodeStream(stream);\n  const wState = stream._writableState;\n  const rState = stream._readableState;\n  const onlegacyfinish = () => {\n    if (!stream.writable) {\n      onfinish();\n    }\n  };\n\n  // TODO (ronag): Improve soft detection to include core modules and\n  // common ecosystem modules that do properly emit 'close' but fail\n  // this generic check.\n  let willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable;\n  let writableFinished = isWritableFinished(stream, false);\n  const onfinish = () => {\n    writableFinished = true;\n    // Stream should not be destroyed here. If it is that\n    // means that user space is doing something differently and\n    // we cannot trust willEmitClose.\n    if (stream.destroyed) {\n      willEmitClose = false;\n    }\n    if (willEmitClose && (!stream.readable || readable)) {\n      return;\n    }\n    if (!readable || readableFinished) {\n      callback.call(stream);\n    }\n  };\n  let readableFinished = isReadableFinished(stream, false);\n  const onend = () => {\n    readableFinished = true;\n    // Stream should not be destroyed here. If it is that\n    // means that user space is doing something differently and\n    // we cannot trust willEmitClose.\n    if (stream.destroyed) {\n      willEmitClose = false;\n    }\n    if (willEmitClose && (!stream.writable || writable)) {\n      return;\n    }\n    if (!writable || writableFinished) {\n      callback.call(stream);\n    }\n  };\n  const onerror = err => {\n    callback.call(stream, err);\n  };\n  let closed = isClosed(stream);\n  const onclose = () => {\n    closed = true;\n    const errored = isWritableErrored(stream) || isReadableErrored(stream);\n    if (errored && typeof errored !== 'boolean') {\n      return callback.call(stream, errored);\n    }\n    if (readable && !readableFinished && isReadableNodeStream(stream, true)) {\n      if (!isReadableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());\n    }\n    if (writable && !writableFinished) {\n      if (!isWritableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());\n    }\n    callback.call(stream);\n  };\n  const onclosed = () => {\n    closed = true;\n    const errored = isWritableErrored(stream) || isReadableErrored(stream);\n    if (errored && typeof errored !== 'boolean') {\n      return callback.call(stream, errored);\n    }\n    callback.call(stream);\n  };\n  const onrequest = () => {\n    stream.req.on('finish', onfinish);\n  };\n  if (isRequest(stream)) {\n    stream.on('complete', onfinish);\n    if (!willEmitClose) {\n      stream.on('abort', onclose);\n    }\n    if (stream.req) {\n      onrequest();\n    } else {\n      stream.on('request', onrequest);\n    }\n  } else if (writable && !wState) {\n    // legacy streams\n    stream.on('end', onlegacyfinish);\n    stream.on('close', onlegacyfinish);\n  }\n\n  // Not all streams will emit 'close' after 'aborted'.\n  if (!willEmitClose && typeof stream.aborted === 'boolean') {\n    stream.on('aborted', onclose);\n  }\n  stream.on('end', onend);\n  stream.on('finish', onfinish);\n  if (options.error !== false) {\n    stream.on('error', onerror);\n  }\n  stream.on('close', onclose);\n  if (closed) {\n    process.nextTick(onclose);\n  } else if (wState !== null && wState !== undefined && wState.errorEmitted || rState !== null && rState !== undefined && rState.errorEmitted) {\n    if (!willEmitClose) {\n      process.nextTick(onclosed);\n    }\n  } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === false)) {\n    process.nextTick(onclosed);\n  } else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === false)) {\n    process.nextTick(onclosed);\n  } else if (rState && stream.req && stream.aborted) {\n    process.nextTick(onclosed);\n  }\n  const cleanup = () => {\n    callback = nop;\n    stream.removeListener('aborted', onclose);\n    stream.removeListener('complete', onfinish);\n    stream.removeListener('abort', onclose);\n    stream.removeListener('request', onrequest);\n    if (stream.req) stream.req.removeListener('finish', onfinish);\n    stream.removeListener('end', onlegacyfinish);\n    stream.removeListener('close', onlegacyfinish);\n    stream.removeListener('finish', onfinish);\n    stream.removeListener('end', onend);\n    stream.removeListener('error', onerror);\n    stream.removeListener('close', onclose);\n  };\n  if (options.signal && !closed) {\n    const abort = () => {\n      // Keep it because cleanup removes it.\n      const endCallback = callback;\n      cleanup();\n      endCallback.call(stream, new AbortError(undefined, {\n        cause: options.signal.reason\n      }));\n    };\n    if (options.signal.aborted) {\n      process.nextTick(abort);\n    } else {\n      addAbortListener = addAbortListener || require('../../ours/util').addAbortListener;\n      const disposable = addAbortListener(options.signal, abort);\n      const originalCallback = callback;\n      callback = once((...args) => {\n        disposable[SymbolDispose]();\n        originalCallback.apply(stream, args);\n      });\n    }\n  }\n  return cleanup;\n}\nfunction eosWeb(stream, options, callback) {\n  let isAborted = false;\n  let abort = nop;\n  if (options.signal) {\n    abort = () => {\n      isAborted = true;\n      callback.call(stream, new AbortError(undefined, {\n        cause: options.signal.reason\n      }));\n    };\n    if (options.signal.aborted) {\n      process.nextTick(abort);\n    } else {\n      addAbortListener = addAbortListener || require('../../ours/util').addAbortListener;\n      const disposable = addAbortListener(options.signal, abort);\n      const originalCallback = callback;\n      callback = once((...args) => {\n        disposable[SymbolDispose]();\n        originalCallback.apply(stream, args);\n      });\n    }\n  }\n  const resolverFn = (...args) => {\n    if (!isAborted) {\n      process.nextTick(() => callback.apply(stream, args));\n    }\n  };\n  PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn);\n  return nop;\n}\nfunction finished(stream, opts) {\n  var _opts;\n  let autoCleanup = false;\n  if (opts === null) {\n    opts = kEmptyObject;\n  }\n  if ((_opts = opts) !== null && _opts !== undefined && _opts.cleanup) {\n    validateBoolean(opts.cleanup, 'cleanup');\n    autoCleanup = opts.cleanup;\n  }\n  return new Promise((resolve, reject) => {\n    const cleanup = eos(stream, opts, err => {\n      if (autoCleanup) {\n        cleanup();\n      }\n      if (err) {\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n  });\n}\nmodule.exports = eos;\nmodule.exports.finished = finished;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}