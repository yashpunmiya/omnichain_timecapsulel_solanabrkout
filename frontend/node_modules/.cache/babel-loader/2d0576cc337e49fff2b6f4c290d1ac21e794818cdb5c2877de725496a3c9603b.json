{"ast":null,"code":"var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar _StandardWalletAdapter_instances, _StandardWalletAdapter_account, _StandardWalletAdapter_publicKey, _StandardWalletAdapter_connecting, _StandardWalletAdapter_disconnecting, _StandardWalletAdapter_off, _StandardWalletAdapter_supportedTransactionVersions, _StandardWalletAdapter_wallet, _StandardWalletAdapter_readyState, _StandardWalletAdapter_connect, _StandardWalletAdapter_connected, _StandardWalletAdapter_disconnected, _StandardWalletAdapter_reset, _StandardWalletAdapter_changed, _StandardWalletAdapter_signTransaction, _StandardWalletAdapter_signAllTransactions, _StandardWalletAdapter_signMessage, _StandardWalletAdapter_signIn;\nimport { BaseWalletAdapter, isVersionedTransaction, WalletAccountError, WalletConfigError, WalletConnectionError, WalletDisconnectedError, WalletDisconnectionError, WalletError, WalletNotConnectedError, WalletNotReadyError, WalletPublicKeyError, WalletReadyState, WalletSendTransactionError, WalletSignInError, WalletSignMessageError, WalletSignTransactionError } from '@solana/wallet-adapter-base';\nimport { SolanaSignAndSendTransaction, SolanaSignIn, SolanaSignMessage, SolanaSignTransaction } from '@solana/wallet-standard-features';\nimport { getChainForEndpoint, getCommitment } from '@solana/wallet-standard-util';\nimport { PublicKey, Transaction, VersionedTransaction } from '@solana/web3.js';\nimport { StandardConnect, StandardDisconnect, StandardEvents } from '@wallet-standard/features';\nimport { arraysEqual } from '@wallet-standard/wallet';\nimport bs58 from 'bs58';\n/** TODO: docs */\nexport class StandardWalletAdapter extends BaseWalletAdapter {\n  get name() {\n    return __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").name;\n  }\n  get url() {\n    return 'https://github.com/solana-labs/wallet-standard';\n  }\n  get icon() {\n    return __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").icon;\n  }\n  get readyState() {\n    return __classPrivateFieldGet(this, _StandardWalletAdapter_readyState, \"f\");\n  }\n  get publicKey() {\n    return __classPrivateFieldGet(this, _StandardWalletAdapter_publicKey, \"f\");\n  }\n  get connecting() {\n    return __classPrivateFieldGet(this, _StandardWalletAdapter_connecting, \"f\");\n  }\n  get supportedTransactionVersions() {\n    return __classPrivateFieldGet(this, _StandardWalletAdapter_supportedTransactionVersions, \"f\");\n  }\n  get wallet() {\n    return __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\");\n  }\n  get standard() {\n    return true;\n  }\n  constructor({\n    wallet\n  }) {\n    super();\n    _StandardWalletAdapter_instances.add(this);\n    _StandardWalletAdapter_account.set(this, void 0);\n    _StandardWalletAdapter_publicKey.set(this, void 0);\n    _StandardWalletAdapter_connecting.set(this, void 0);\n    _StandardWalletAdapter_disconnecting.set(this, void 0);\n    _StandardWalletAdapter_off.set(this, void 0);\n    _StandardWalletAdapter_supportedTransactionVersions.set(this, void 0);\n    _StandardWalletAdapter_wallet.set(this, void 0);\n    _StandardWalletAdapter_readyState.set(this, typeof window === 'undefined' || typeof document === 'undefined' ? WalletReadyState.Unsupported : WalletReadyState.Installed);\n    _StandardWalletAdapter_changed.set(this, properties => {\n      // If accounts have changed on the wallet, reflect this on the adapter.\n      if ('accounts' in properties) {\n        const account = __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").accounts[0];\n        // If the adapter isn't connected, or is disconnecting, or the first account hasn't changed, do nothing.\n        if (__classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\") && !__classPrivateFieldGet(this, _StandardWalletAdapter_disconnecting, \"f\") && account !== __classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\")) {\n          // If there's a connected account, connect the adapter. Otherwise, disconnect it.\n          if (account) {\n            // Connect the adapter.\n            __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_connected).call(this, account);\n          } else {\n            // Emit an error because the wallet spontaneously disconnected.\n            this.emit('error', new WalletDisconnectedError());\n            // Disconnect the adapter.\n            __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_disconnected).call(this);\n          }\n        }\n      }\n      // After reflecting account changes, if features have changed on the wallet, reflect this on the adapter.\n      if ('features' in properties) {\n        __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_reset).call(this);\n      }\n    });\n    __classPrivateFieldSet(this, _StandardWalletAdapter_wallet, wallet, \"f\");\n    __classPrivateFieldSet(this, _StandardWalletAdapter_account, null, \"f\");\n    __classPrivateFieldSet(this, _StandardWalletAdapter_publicKey, null, \"f\");\n    __classPrivateFieldSet(this, _StandardWalletAdapter_connecting, false, \"f\");\n    __classPrivateFieldSet(this, _StandardWalletAdapter_disconnecting, false, \"f\");\n    __classPrivateFieldSet(this, _StandardWalletAdapter_off, __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[StandardEvents].on('change', __classPrivateFieldGet(this, _StandardWalletAdapter_changed, \"f\")), \"f\");\n    __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_reset).call(this);\n  }\n  destroy() {\n    __classPrivateFieldSet(this, _StandardWalletAdapter_account, null, \"f\");\n    __classPrivateFieldSet(this, _StandardWalletAdapter_publicKey, null, \"f\");\n    __classPrivateFieldSet(this, _StandardWalletAdapter_connecting, false, \"f\");\n    __classPrivateFieldSet(this, _StandardWalletAdapter_disconnecting, false, \"f\");\n    const off = __classPrivateFieldGet(this, _StandardWalletAdapter_off, \"f\");\n    if (off) {\n      __classPrivateFieldSet(this, _StandardWalletAdapter_off, null, \"f\");\n      off();\n    }\n  }\n  async autoConnect() {\n    return __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_connect).call(this, {\n      silent: true\n    });\n  }\n  async connect() {\n    return __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_connect).call(this);\n  }\n  async disconnect() {\n    if (StandardDisconnect in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features) {\n      try {\n        __classPrivateFieldSet(this, _StandardWalletAdapter_disconnecting, true, \"f\");\n        await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[StandardDisconnect].disconnect();\n      } catch (error) {\n        this.emit('error', new WalletDisconnectionError(error?.message, error));\n      } finally {\n        __classPrivateFieldSet(this, _StandardWalletAdapter_disconnecting, false, \"f\");\n      }\n    }\n    __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_disconnected).call(this);\n  }\n  async sendTransaction(transaction, connection, options = {}) {\n    try {\n      const account = __classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\");\n      if (!account) throw new WalletNotConnectedError();\n      let feature;\n      if (SolanaSignAndSendTransaction in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features) {\n        if (account.features.includes(SolanaSignAndSendTransaction)) {\n          feature = SolanaSignAndSendTransaction;\n        } else if (SolanaSignTransaction in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features && account.features.includes(SolanaSignTransaction)) {\n          feature = SolanaSignTransaction;\n        } else {\n          throw new WalletAccountError();\n        }\n      } else if (SolanaSignTransaction in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features) {\n        if (!account.features.includes(SolanaSignTransaction)) throw new WalletAccountError();\n        feature = SolanaSignTransaction;\n      } else {\n        throw new WalletConfigError();\n      }\n      const chain = getChainForEndpoint(connection.rpcEndpoint);\n      if (!account.chains.includes(chain)) throw new WalletSendTransactionError();\n      try {\n        const {\n          signers,\n          ...sendOptions\n        } = options;\n        let serializedTransaction;\n        if (isVersionedTransaction(transaction)) {\n          signers?.length && transaction.sign(signers);\n          serializedTransaction = transaction.serialize();\n        } else {\n          transaction = await this.prepareTransaction(transaction, connection, sendOptions);\n          signers?.length && transaction.partialSign(...signers);\n          serializedTransaction = new Uint8Array(transaction.serialize({\n            requireAllSignatures: false,\n            verifySignatures: false\n          }));\n        }\n        if (feature === SolanaSignAndSendTransaction) {\n          const [output] = await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[SolanaSignAndSendTransaction].signAndSendTransaction({\n            account,\n            chain,\n            transaction: serializedTransaction,\n            options: {\n              preflightCommitment: getCommitment(sendOptions.preflightCommitment || connection.commitment),\n              skipPreflight: sendOptions.skipPreflight,\n              maxRetries: sendOptions.maxRetries,\n              minContextSlot: sendOptions.minContextSlot\n            }\n          });\n          return bs58.encode(output.signature);\n        } else {\n          const [output] = await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[SolanaSignTransaction].signTransaction({\n            account,\n            chain,\n            transaction: serializedTransaction,\n            options: {\n              preflightCommitment: getCommitment(sendOptions.preflightCommitment || connection.commitment),\n              minContextSlot: sendOptions.minContextSlot\n            }\n          });\n          return await connection.sendRawTransaction(output.signedTransaction, {\n            ...sendOptions,\n            preflightCommitment: getCommitment(sendOptions.preflightCommitment || connection.commitment)\n          });\n        }\n      } catch (error) {\n        if (error instanceof WalletError) throw error;\n        throw new WalletSendTransactionError(error?.message, error);\n      }\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n}\n_StandardWalletAdapter_account = new WeakMap(), _StandardWalletAdapter_publicKey = new WeakMap(), _StandardWalletAdapter_connecting = new WeakMap(), _StandardWalletAdapter_disconnecting = new WeakMap(), _StandardWalletAdapter_off = new WeakMap(), _StandardWalletAdapter_supportedTransactionVersions = new WeakMap(), _StandardWalletAdapter_wallet = new WeakMap(), _StandardWalletAdapter_readyState = new WeakMap(), _StandardWalletAdapter_changed = new WeakMap(), _StandardWalletAdapter_instances = new WeakSet(), _StandardWalletAdapter_connect = async function _StandardWalletAdapter_connect(input) {\n  try {\n    if (this.connected || this.connecting) return;\n    if (__classPrivateFieldGet(this, _StandardWalletAdapter_readyState, \"f\") !== WalletReadyState.Installed) throw new WalletNotReadyError();\n    __classPrivateFieldSet(this, _StandardWalletAdapter_connecting, true, \"f\");\n    if (!__classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").accounts.length) {\n      try {\n        await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[StandardConnect].connect(input);\n      } catch (error) {\n        throw new WalletConnectionError(error?.message, error);\n      }\n    }\n    const account = __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").accounts[0];\n    if (!account) throw new WalletAccountError();\n    __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_connected).call(this, account);\n  } catch (error) {\n    this.emit('error', error);\n    throw error;\n  } finally {\n    __classPrivateFieldSet(this, _StandardWalletAdapter_connecting, false, \"f\");\n  }\n}, _StandardWalletAdapter_connected = function _StandardWalletAdapter_connected(account) {\n  let publicKey;\n  try {\n    // Use account.address instead of account.publicKey since address could be a PDA\n    publicKey = new PublicKey(account.address);\n  } catch (error) {\n    throw new WalletPublicKeyError(error?.message, error);\n  }\n  __classPrivateFieldSet(this, _StandardWalletAdapter_account, account, \"f\");\n  __classPrivateFieldSet(this, _StandardWalletAdapter_publicKey, publicKey, \"f\");\n  __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_reset).call(this);\n  this.emit('connect', publicKey);\n}, _StandardWalletAdapter_disconnected = function _StandardWalletAdapter_disconnected() {\n  __classPrivateFieldSet(this, _StandardWalletAdapter_account, null, \"f\");\n  __classPrivateFieldSet(this, _StandardWalletAdapter_publicKey, null, \"f\");\n  __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_reset).call(this);\n  this.emit('disconnect');\n}, _StandardWalletAdapter_reset = function _StandardWalletAdapter_reset() {\n  const supportedTransactionVersions = SolanaSignAndSendTransaction in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features ? __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[SolanaSignAndSendTransaction].supportedTransactionVersions : __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[SolanaSignTransaction].supportedTransactionVersions;\n  __classPrivateFieldSet(this, _StandardWalletAdapter_supportedTransactionVersions, arraysEqual(supportedTransactionVersions, ['legacy']) ? null : new Set(supportedTransactionVersions), \"f\");\n  if (SolanaSignTransaction in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features && __classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\")?.features.includes(SolanaSignTransaction)) {\n    this.signTransaction = __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_signTransaction);\n    this.signAllTransactions = __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_signAllTransactions);\n  } else {\n    delete this.signTransaction;\n    delete this.signAllTransactions;\n  }\n  if (SolanaSignMessage in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features && __classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\")?.features.includes(SolanaSignMessage)) {\n    this.signMessage = __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_signMessage);\n  } else {\n    delete this.signMessage;\n  }\n  if (SolanaSignIn in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features) {\n    this.signIn = __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_signIn);\n  } else {\n    delete this.signIn;\n  }\n}, _StandardWalletAdapter_signTransaction = async function _StandardWalletAdapter_signTransaction(transaction) {\n  try {\n    const account = __classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\");\n    if (!account) throw new WalletNotConnectedError();\n    if (!(SolanaSignTransaction in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features)) throw new WalletConfigError();\n    if (!account.features.includes(SolanaSignTransaction)) throw new WalletAccountError();\n    try {\n      const signedTransactions = await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[SolanaSignTransaction].signTransaction({\n        account,\n        transaction: isVersionedTransaction(transaction) ? transaction.serialize() : new Uint8Array(transaction.serialize({\n          requireAllSignatures: false,\n          verifySignatures: false\n        }))\n      });\n      const serializedTransaction = signedTransactions[0].signedTransaction;\n      return isVersionedTransaction(transaction) ? VersionedTransaction.deserialize(serializedTransaction) : Transaction.from(serializedTransaction);\n    } catch (error) {\n      if (error instanceof WalletError) throw error;\n      throw new WalletSignTransactionError(error?.message, error);\n    }\n  } catch (error) {\n    this.emit('error', error);\n    throw error;\n  }\n}, _StandardWalletAdapter_signAllTransactions = async function _StandardWalletAdapter_signAllTransactions(transactions) {\n  try {\n    const account = __classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\");\n    if (!account) throw new WalletNotConnectedError();\n    if (!(SolanaSignTransaction in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features)) throw new WalletConfigError();\n    if (!account.features.includes(SolanaSignTransaction)) throw new WalletAccountError();\n    try {\n      const signedTransactions = await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[SolanaSignTransaction].signTransaction(...transactions.map(transaction => ({\n        account,\n        transaction: isVersionedTransaction(transaction) ? transaction.serialize() : new Uint8Array(transaction.serialize({\n          requireAllSignatures: false,\n          verifySignatures: false\n        }))\n      })));\n      return transactions.map((transaction, index) => {\n        const signedTransaction = signedTransactions[index].signedTransaction;\n        return isVersionedTransaction(transaction) ? VersionedTransaction.deserialize(signedTransaction) : Transaction.from(signedTransaction);\n      });\n    } catch (error) {\n      throw new WalletSignTransactionError(error?.message, error);\n    }\n  } catch (error) {\n    this.emit('error', error);\n    throw error;\n  }\n}, _StandardWalletAdapter_signMessage = async function _StandardWalletAdapter_signMessage(message) {\n  try {\n    const account = __classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\");\n    if (!account) throw new WalletNotConnectedError();\n    if (!(SolanaSignMessage in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features)) throw new WalletConfigError();\n    if (!account.features.includes(SolanaSignMessage)) throw new WalletAccountError();\n    try {\n      const signedMessages = await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[SolanaSignMessage].signMessage({\n        account,\n        message\n      });\n      return signedMessages[0].signature;\n    } catch (error) {\n      throw new WalletSignMessageError(error?.message, error);\n    }\n  } catch (error) {\n    this.emit('error', error);\n    throw error;\n  }\n}, _StandardWalletAdapter_signIn = async function _StandardWalletAdapter_signIn(input = {}) {\n  try {\n    if (!(SolanaSignIn in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features)) throw new WalletConfigError();\n    let output;\n    try {\n      [output] = await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[SolanaSignIn].signIn(input);\n    } catch (error) {\n      throw new WalletSignInError(error?.message, error);\n    }\n    if (!output) throw new WalletSignInError();\n    __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_connected).call(this, output.account);\n    return output;\n  } catch (error) {\n    this.emit('error', error);\n    throw error;\n  }\n};","map":{"version":3,"names":["BaseWalletAdapter","isVersionedTransaction","WalletAccountError","WalletConfigError","WalletConnectionError","WalletDisconnectedError","WalletDisconnectionError","WalletError","WalletNotConnectedError","WalletNotReadyError","WalletPublicKeyError","WalletReadyState","WalletSendTransactionError","WalletSignInError","WalletSignMessageError","WalletSignTransactionError","SolanaSignAndSendTransaction","SolanaSignIn","SolanaSignMessage","SolanaSignTransaction","getChainForEndpoint","getCommitment","PublicKey","Transaction","VersionedTransaction","StandardConnect","StandardDisconnect","StandardEvents","arraysEqual","bs58","StandardWalletAdapter","name","__classPrivateFieldGet","_StandardWalletAdapter_wallet","url","icon","readyState","_StandardWalletAdapter_readyState","publicKey","_StandardWalletAdapter_publicKey","connecting","_StandardWalletAdapter_connecting","supportedTransactionVersions","_StandardWalletAdapter_supportedTransactionVersions","wallet","standard","constructor","_StandardWalletAdapter_account","set","_StandardWalletAdapter_disconnecting","_StandardWalletAdapter_off","window","document","Unsupported","Installed","_StandardWalletAdapter_changed","properties","account","accounts","_StandardWalletAdapter_instances","_StandardWalletAdapter_connected","call","emit","_StandardWalletAdapter_disconnected","_StandardWalletAdapter_reset","__classPrivateFieldSet","features","on","destroy","off","autoConnect","_StandardWalletAdapter_connect","silent","connect","disconnect","error","message","sendTransaction","transaction","connection","options","feature","includes","chain","rpcEndpoint","chains","signers","sendOptions","serializedTransaction","length","sign","serialize","prepareTransaction","partialSign","Uint8Array","requireAllSignatures","verifySignatures","output","signAndSendTransaction","preflightCommitment","commitment","skipPreflight","maxRetries","minContextSlot","encode","signature","signTransaction","sendRawTransaction","signedTransaction","input","connected","address","Set","_StandardWalletAdapter_signTransaction","signAllTransactions","_StandardWalletAdapter_signAllTransactions","signMessage","_StandardWalletAdapter_signMessage","signIn","_StandardWalletAdapter_signIn","signedTransactions","deserialize","from","transactions","map","index","signedMessages"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@solana\\wallet-standard-wallet-adapter-base\\src\\adapter.ts"],"sourcesContent":["import {\n    BaseWalletAdapter,\n    isVersionedTransaction,\n    type SendTransactionOptions,\n    type StandardWalletAdapter as StandardWalletAdapterType,\n    type SupportedTransactionVersions,\n    WalletAccountError,\n    type WalletAdapterCompatibleStandardWallet,\n    WalletConfigError,\n    WalletConnectionError,\n    WalletDisconnectedError,\n    WalletDisconnectionError,\n    WalletError,\n    type WalletName,\n    WalletNotConnectedError,\n    WalletNotReadyError,\n    WalletPublicKeyError,\n    WalletReadyState,\n    WalletSendTransactionError,\n    WalletSignInError,\n    WalletSignMessageError,\n    WalletSignTransactionError,\n} from '@solana/wallet-adapter-base';\nimport {\n    SolanaSignAndSendTransaction,\n    type SolanaSignAndSendTransactionFeature,\n    SolanaSignIn,\n    type SolanaSignInInput,\n    type SolanaSignInOutput,\n    SolanaSignMessage,\n    SolanaSignTransaction,\n    type SolanaSignTransactionFeature,\n} from '@solana/wallet-standard-features';\nimport { getChainForEndpoint, getCommitment } from '@solana/wallet-standard-util';\nimport type { Connection, TransactionSignature } from '@solana/web3.js';\nimport { PublicKey, Transaction, VersionedTransaction } from '@solana/web3.js';\nimport type { WalletAccount } from '@wallet-standard/base';\nimport {\n    StandardConnect,\n    type StandardConnectInput,\n    StandardDisconnect,\n    StandardEvents,\n    type StandardEventsListeners,\n} from '@wallet-standard/features';\nimport { arraysEqual } from '@wallet-standard/wallet';\nimport bs58 from 'bs58';\n\n/** TODO: docs */\nexport interface StandardWalletAdapterConfig {\n    wallet: WalletAdapterCompatibleStandardWallet;\n}\n\n/** TODO: docs */\nexport class StandardWalletAdapter extends BaseWalletAdapter implements StandardWalletAdapterType {\n    #account: WalletAccount | null;\n    #publicKey: PublicKey | null;\n    #connecting: boolean;\n    #disconnecting: boolean;\n    #off: (() => void) | null;\n    #supportedTransactionVersions: SupportedTransactionVersions;\n    readonly #wallet: WalletAdapterCompatibleStandardWallet;\n    readonly #readyState: WalletReadyState =\n        typeof window === 'undefined' || typeof document === 'undefined'\n            ? WalletReadyState.Unsupported\n            : WalletReadyState.Installed;\n\n    get name() {\n        return this.#wallet.name as WalletName;\n    }\n\n    get url() {\n        return 'https://github.com/solana-labs/wallet-standard';\n    }\n\n    get icon() {\n        return this.#wallet.icon;\n    }\n\n    get readyState() {\n        return this.#readyState;\n    }\n\n    get publicKey() {\n        return this.#publicKey;\n    }\n\n    get connecting() {\n        return this.#connecting;\n    }\n\n    get supportedTransactionVersions() {\n        return this.#supportedTransactionVersions;\n    }\n\n    get wallet(): WalletAdapterCompatibleStandardWallet {\n        return this.#wallet;\n    }\n\n    get standard() {\n        return true as const;\n    }\n\n    constructor({ wallet }: StandardWalletAdapterConfig) {\n        super();\n\n        this.#wallet = wallet;\n        this.#account = null;\n        this.#publicKey = null;\n        this.#connecting = false;\n        this.#disconnecting = false;\n        this.#off = this.#wallet.features[StandardEvents].on('change', this.#changed);\n\n        this.#reset();\n    }\n\n    destroy(): void {\n        this.#account = null;\n        this.#publicKey = null;\n        this.#connecting = false;\n        this.#disconnecting = false;\n\n        const off = this.#off;\n        if (off) {\n            this.#off = null;\n            off();\n        }\n    }\n\n    async autoConnect(): Promise<void> {\n        return this.#connect({ silent: true });\n    }\n\n    async connect(): Promise<void> {\n        return this.#connect();\n    }\n\n    async #connect(input?: StandardConnectInput): Promise<void> {\n        try {\n            if (this.connected || this.connecting) return;\n            if (this.#readyState !== WalletReadyState.Installed) throw new WalletNotReadyError();\n\n            this.#connecting = true;\n\n            if (!this.#wallet.accounts.length) {\n                try {\n                    await this.#wallet.features[StandardConnect].connect(input);\n                } catch (error: any) {\n                    throw new WalletConnectionError(error?.message, error);\n                }\n            }\n\n            const account = this.#wallet.accounts[0];\n            if (!account) throw new WalletAccountError();\n\n            this.#connected(account);\n        } catch (error: any) {\n            this.emit('error', error);\n            throw error;\n        } finally {\n            this.#connecting = false;\n        }\n    }\n\n    async disconnect(): Promise<void> {\n        if (StandardDisconnect in this.#wallet.features) {\n            try {\n                this.#disconnecting = true;\n                await this.#wallet.features[StandardDisconnect].disconnect();\n            } catch (error: any) {\n                this.emit('error', new WalletDisconnectionError(error?.message, error));\n            } finally {\n                this.#disconnecting = false;\n            }\n        }\n\n        this.#disconnected();\n    }\n\n    #connected(account: WalletAccount) {\n        let publicKey: PublicKey;\n        try {\n            // Use account.address instead of account.publicKey since address could be a PDA\n            publicKey = new PublicKey(account.address);\n        } catch (error: any) {\n            throw new WalletPublicKeyError(error?.message, error);\n        }\n\n        this.#account = account;\n        this.#publicKey = publicKey;\n        this.#reset();\n        this.emit('connect', publicKey);\n    }\n\n    #disconnected(): void {\n        this.#account = null;\n        this.#publicKey = null;\n        this.#reset();\n        this.emit('disconnect');\n    }\n\n    #reset() {\n        const supportedTransactionVersions =\n            SolanaSignAndSendTransaction in this.#wallet.features\n                ? this.#wallet.features[SolanaSignAndSendTransaction].supportedTransactionVersions\n                : this.#wallet.features[SolanaSignTransaction].supportedTransactionVersions;\n        this.#supportedTransactionVersions = arraysEqual(supportedTransactionVersions, ['legacy'])\n            ? null\n            : new Set(supportedTransactionVersions);\n\n        if (SolanaSignTransaction in this.#wallet.features && this.#account?.features.includes(SolanaSignTransaction)) {\n            this.signTransaction = this.#signTransaction;\n            this.signAllTransactions = this.#signAllTransactions;\n        } else {\n            delete this.signTransaction;\n            delete this.signAllTransactions;\n        }\n\n        if (SolanaSignMessage in this.#wallet.features && this.#account?.features.includes(SolanaSignMessage)) {\n            this.signMessage = this.#signMessage;\n        } else {\n            delete this.signMessage;\n        }\n\n        if (SolanaSignIn in this.#wallet.features) {\n            this.signIn = this.#signIn;\n        } else {\n            delete this.signIn;\n        }\n    }\n\n    #changed: StandardEventsListeners['change'] = (properties) => {\n        // If accounts have changed on the wallet, reflect this on the adapter.\n        if ('accounts' in properties) {\n            const account = this.#wallet.accounts[0];\n            // If the adapter isn't connected, or is disconnecting, or the first account hasn't changed, do nothing.\n            if (this.#account && !this.#disconnecting && account !== this.#account) {\n                // If there's a connected account, connect the adapter. Otherwise, disconnect it.\n                if (account) {\n                    // Connect the adapter.\n                    this.#connected(account);\n                } else {\n                    // Emit an error because the wallet spontaneously disconnected.\n                    this.emit('error', new WalletDisconnectedError());\n                    // Disconnect the adapter.\n                    this.#disconnected();\n                }\n            }\n        }\n\n        // After reflecting account changes, if features have changed on the wallet, reflect this on the adapter.\n        if ('features' in properties) {\n            this.#reset();\n        }\n    };\n\n    async sendTransaction<T extends Transaction | VersionedTransaction>(\n        transaction: T,\n        connection: Connection,\n        options: SendTransactionOptions = {}\n    ): Promise<TransactionSignature> {\n        try {\n            const account = this.#account;\n            if (!account) throw new WalletNotConnectedError();\n\n            let feature: typeof SolanaSignAndSendTransaction | typeof SolanaSignTransaction;\n            if (SolanaSignAndSendTransaction in this.#wallet.features) {\n                if (account.features.includes(SolanaSignAndSendTransaction)) {\n                    feature = SolanaSignAndSendTransaction;\n                } else if (\n                    SolanaSignTransaction in this.#wallet.features &&\n                    account.features.includes(SolanaSignTransaction)\n                ) {\n                    feature = SolanaSignTransaction;\n                } else {\n                    throw new WalletAccountError();\n                }\n            } else if (SolanaSignTransaction in this.#wallet.features) {\n                if (!account.features.includes(SolanaSignTransaction)) throw new WalletAccountError();\n                feature = SolanaSignTransaction;\n            } else {\n                throw new WalletConfigError();\n            }\n\n            const chain = getChainForEndpoint(connection.rpcEndpoint);\n            if (!account.chains.includes(chain)) throw new WalletSendTransactionError();\n\n            try {\n                const { signers, ...sendOptions } = options;\n\n                let serializedTransaction: Uint8Array;\n                if (isVersionedTransaction(transaction)) {\n                    signers?.length && transaction.sign(signers);\n                    serializedTransaction = transaction.serialize();\n                } else {\n                    transaction = (await this.prepareTransaction(transaction, connection, sendOptions)) as T;\n                    signers?.length && (transaction as Transaction).partialSign(...signers);\n                    serializedTransaction = new Uint8Array(\n                        (transaction as Transaction).serialize({\n                            requireAllSignatures: false,\n                            verifySignatures: false,\n                        })\n                    );\n                }\n\n                if (feature === SolanaSignAndSendTransaction) {\n                    const [output] = await (this.#wallet.features as SolanaSignAndSendTransactionFeature)[\n                        SolanaSignAndSendTransaction\n                    ].signAndSendTransaction({\n                        account,\n                        chain,\n                        transaction: serializedTransaction,\n                        options: {\n                            preflightCommitment: getCommitment(\n                                sendOptions.preflightCommitment || connection.commitment\n                            ),\n                            skipPreflight: sendOptions.skipPreflight,\n                            maxRetries: sendOptions.maxRetries,\n                            minContextSlot: sendOptions.minContextSlot,\n                        },\n                    });\n\n                    return bs58.encode(output!.signature);\n                } else {\n                    const [output] = await (this.#wallet.features as SolanaSignTransactionFeature)[\n                        SolanaSignTransaction\n                    ].signTransaction({\n                        account,\n                        chain,\n                        transaction: serializedTransaction,\n                        options: {\n                            preflightCommitment: getCommitment(\n                                sendOptions.preflightCommitment || connection.commitment\n                            ),\n                            minContextSlot: sendOptions.minContextSlot,\n                        },\n                    });\n\n                    return await connection.sendRawTransaction(output!.signedTransaction, {\n                        ...sendOptions,\n                        preflightCommitment: getCommitment(sendOptions.preflightCommitment || connection.commitment),\n                    });\n                }\n            } catch (error: any) {\n                if (error instanceof WalletError) throw error;\n                throw new WalletSendTransactionError(error?.message, error);\n            }\n        } catch (error: any) {\n            this.emit('error', error);\n            throw error;\n        }\n    }\n\n    signTransaction: (<T extends Transaction | VersionedTransaction>(transaction: T) => Promise<T>) | undefined;\n    async #signTransaction<T extends Transaction | VersionedTransaction>(transaction: T): Promise<T> {\n        try {\n            const account = this.#account;\n            if (!account) throw new WalletNotConnectedError();\n\n            if (!(SolanaSignTransaction in this.#wallet.features)) throw new WalletConfigError();\n            if (!account.features.includes(SolanaSignTransaction)) throw new WalletAccountError();\n\n            try {\n                const signedTransactions = await this.#wallet.features[SolanaSignTransaction].signTransaction({\n                    account,\n                    transaction: isVersionedTransaction(transaction)\n                        ? transaction.serialize()\n                        : new Uint8Array(\n                              transaction.serialize({\n                                  requireAllSignatures: false,\n                                  verifySignatures: false,\n                              })\n                          ),\n                });\n\n                const serializedTransaction = signedTransactions[0]!.signedTransaction;\n\n                return (\n                    isVersionedTransaction(transaction)\n                        ? VersionedTransaction.deserialize(serializedTransaction)\n                        : Transaction.from(serializedTransaction)\n                ) as T;\n            } catch (error: any) {\n                if (error instanceof WalletError) throw error;\n                throw new WalletSignTransactionError(error?.message, error);\n            }\n        } catch (error: any) {\n            this.emit('error', error);\n            throw error;\n        }\n    }\n\n    signAllTransactions: (<T extends Transaction | VersionedTransaction>(transaction: T[]) => Promise<T[]>) | undefined;\n    async #signAllTransactions<T extends Transaction | VersionedTransaction>(transactions: T[]): Promise<T[]> {\n        try {\n            const account = this.#account;\n            if (!account) throw new WalletNotConnectedError();\n\n            if (!(SolanaSignTransaction in this.#wallet.features)) throw new WalletConfigError();\n            if (!account.features.includes(SolanaSignTransaction)) throw new WalletAccountError();\n\n            try {\n                const signedTransactions = await this.#wallet.features[SolanaSignTransaction].signTransaction(\n                    ...transactions.map((transaction) => ({\n                        account,\n                        transaction: isVersionedTransaction(transaction)\n                            ? transaction.serialize()\n                            : new Uint8Array(\n                                  transaction.serialize({\n                                      requireAllSignatures: false,\n                                      verifySignatures: false,\n                                  })\n                              ),\n                    }))\n                );\n\n                return transactions.map((transaction, index) => {\n                    const signedTransaction = signedTransactions[index]!.signedTransaction;\n\n                    return (\n                        isVersionedTransaction(transaction)\n                            ? VersionedTransaction.deserialize(signedTransaction)\n                            : Transaction.from(signedTransaction)\n                    ) as T;\n                });\n            } catch (error: any) {\n                throw new WalletSignTransactionError(error?.message, error);\n            }\n        } catch (error: any) {\n            this.emit('error', error);\n            throw error;\n        }\n    }\n\n    signMessage: ((message: Uint8Array) => Promise<Uint8Array>) | undefined;\n    async #signMessage(message: Uint8Array): Promise<Uint8Array> {\n        try {\n            const account = this.#account;\n            if (!account) throw new WalletNotConnectedError();\n\n            if (!(SolanaSignMessage in this.#wallet.features)) throw new WalletConfigError();\n            if (!account.features.includes(SolanaSignMessage)) throw new WalletAccountError();\n\n            try {\n                const signedMessages = await this.#wallet.features[SolanaSignMessage].signMessage({\n                    account,\n                    message,\n                });\n\n                return signedMessages[0]!.signature;\n            } catch (error: any) {\n                throw new WalletSignMessageError(error?.message, error);\n            }\n        } catch (error: any) {\n            this.emit('error', error);\n            throw error;\n        }\n    }\n\n    signIn: ((input?: SolanaSignInInput) => Promise<SolanaSignInOutput>) | undefined;\n    async #signIn(input: SolanaSignInInput = {}): Promise<SolanaSignInOutput> {\n        try {\n            if (!(SolanaSignIn in this.#wallet.features)) throw new WalletConfigError();\n\n            let output: SolanaSignInOutput | undefined;\n            try {\n                [output] = await this.#wallet.features[SolanaSignIn].signIn(input);\n            } catch (error: any) {\n                throw new WalletSignInError(error?.message, error);\n            }\n\n            if (!output) throw new WalletSignInError();\n            this.#connected(output.account);\n            return output;\n        } catch (error: any) {\n            this.emit('error', error);\n            throw error;\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}