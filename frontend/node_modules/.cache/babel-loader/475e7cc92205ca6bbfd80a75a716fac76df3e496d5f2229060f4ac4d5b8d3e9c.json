{"ast":null,"code":"/**\n * Montgomery curve methods. It's not really whole montgomery curve,\n * just bunch of very specific methods for X25519 / X448 from\n * [RFC 7748](https://www.rfc-editor.org/rfc/rfc7748)\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { mod } from \"./modular.js\";\nimport { aInRange, bytesToNumberLE, ensureBytes, numberToBytesLE, validateObject } from \"./utils.js\";\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nfunction validateOpts(curve) {\n  validateObject(curve, {\n    adjustScalarBytes: 'function',\n    powPminus2: 'function'\n  });\n  return Object.freeze({\n    ...curve\n  });\n}\nexport function montgomery(curveDef) {\n  const CURVE = validateOpts(curveDef);\n  const {\n    P,\n    type,\n    adjustScalarBytes,\n    powPminus2\n  } = CURVE;\n  const is25519 = type === 'x25519';\n  if (!is25519 && type !== 'x448') throw new Error('invalid type');\n  const montgomeryBits = is25519 ? 255 : 448;\n  const fieldLen = is25519 ? 32 : 56;\n  const Gu = is25519 ? BigInt(9) : BigInt(5);\n  // RFC 7748 #5:\n  // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519 and\n  // (156326 - 2) / 4 = 39081 for curve448/X448\n  // const a = is25519 ? 156326n : 486662n;\n  const a24 = is25519 ? BigInt(121665) : BigInt(39081);\n  // RFC: x25519 \"the resulting integer is of the form 2^254 plus\n  // eight times a value between 0 and 2^251 - 1 (inclusive)\"\n  // x448: \"2^447 plus four times a value between 0 and 2^445 - 1 (inclusive)\"\n  const minScalar = is25519 ? _2n ** BigInt(254) : _2n ** BigInt(447);\n  const maxAdded = is25519 ? BigInt(8) * _2n ** BigInt(251) - _1n : BigInt(4) * _2n ** BigInt(445) - _1n;\n  const maxScalar = minScalar + maxAdded + _1n; // (inclusive)\n  const modP = n => mod(n, P);\n  const GuBytes = encodeU(Gu);\n  function encodeU(u) {\n    return numberToBytesLE(modP(u), fieldLen);\n  }\n  function decodeU(u) {\n    const _u = ensureBytes('u coordinate', u, fieldLen);\n    // RFC: When receiving such an array, implementations of X25519\n    // (but not X448) MUST mask the most significant bit in the final byte.\n    if (is25519) _u[31] &= 127; // 0b0111_1111\n    // RFC: Implementations MUST accept non-canonical values and process them as\n    // if they had been reduced modulo the field prime.  The non-canonical\n    // values are 2^255 - 19 through 2^255 - 1 for X25519 and 2^448 - 2^224\n    // - 1 through 2^448 - 1 for X448.\n    return modP(bytesToNumberLE(_u));\n  }\n  function decodeScalar(scalar) {\n    return bytesToNumberLE(adjustScalarBytes(ensureBytes('scalar', scalar, fieldLen)));\n  }\n  function scalarMult(scalar, u) {\n    const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));\n    // Some public keys are useless, of low-order. Curve author doesn't think\n    // it needs to be validated, but we do it nonetheless.\n    // https://cr.yp.to/ecdh.html#validate\n    if (pu === _0n) throw new Error('invalid private or public key received');\n    return encodeU(pu);\n  }\n  // Computes public key from private. By doing scalar multiplication of base point.\n  function scalarMultBase(scalar) {\n    return scalarMult(scalar, GuBytes);\n  }\n  // cswap from RFC7748 \"example code\"\n  function cswap(swap, x_2, x_3) {\n    // dummy = mask(swap) AND (x_2 XOR x_3)\n    // Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n    // and x_3, computed, e.g., as mask(swap) = 0 - swap.\n    const dummy = modP(swap * (x_2 - x_3));\n    x_2 = modP(x_2 - dummy); // x_2 = x_2 XOR dummy\n    x_3 = modP(x_3 + dummy); // x_3 = x_3 XOR dummy\n    return {\n      x_2,\n      x_3\n    };\n  }\n  /**\n   * Montgomery x-only multiplication ladder.\n   * @param pointU u coordinate (x) on Montgomery Curve 25519\n   * @param scalar by which the point would be multiplied\n   * @returns new Point on Montgomery curve\n   */\n  function montgomeryLadder(u, scalar) {\n    aInRange('u', u, _0n, P);\n    aInRange('scalar', scalar, minScalar, maxScalar);\n    const k = scalar;\n    const x_1 = u;\n    let x_2 = _1n;\n    let z_2 = _0n;\n    let x_3 = u;\n    let z_3 = _1n;\n    let swap = _0n;\n    for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {\n      const k_t = k >> t & _1n;\n      swap ^= k_t;\n      ({\n        x_2,\n        x_3\n      } = cswap(swap, x_2, x_3));\n      ({\n        x_2: z_2,\n        x_3: z_3\n      } = cswap(swap, z_2, z_3));\n      swap = k_t;\n      const A = x_2 + z_2;\n      const AA = modP(A * A);\n      const B = x_2 - z_2;\n      const BB = modP(B * B);\n      const E = AA - BB;\n      const C = x_3 + z_3;\n      const D = x_3 - z_3;\n      const DA = modP(D * A);\n      const CB = modP(C * B);\n      const dacb = DA + CB;\n      const da_cb = DA - CB;\n      x_3 = modP(dacb * dacb);\n      z_3 = modP(x_1 * modP(da_cb * da_cb));\n      x_2 = modP(AA * BB);\n      z_2 = modP(E * (AA + modP(a24 * E)));\n    }\n    ({\n      x_2,\n      x_3\n    } = cswap(swap, x_2, x_3));\n    ({\n      x_2: z_2,\n      x_3: z_3\n    } = cswap(swap, z_2, z_3));\n    const z2 = powPminus2(z_2); // `Fp.pow(x, P - _2n)` is much slower equivalent\n    return modP(x_2 * z2); // Return x_2 * (z_2^(p - 2))\n  }\n  return {\n    scalarMult,\n    scalarMultBase,\n    getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),\n    getPublicKey: privateKey => scalarMultBase(privateKey),\n    utils: {\n      randomPrivateKey: () => CURVE.randomBytes(fieldLen)\n    },\n    GuBytes: GuBytes.slice()\n  };\n}","map":{"version":3,"names":["mod","aInRange","bytesToNumberLE","ensureBytes","numberToBytesLE","validateObject","_0n","BigInt","_1n","_2n","validateOpts","curve","adjustScalarBytes","powPminus2","Object","freeze","montgomery","curveDef","CURVE","P","type","is25519","Error","montgomeryBits","fieldLen","Gu","a24","minScalar","maxAdded","maxScalar","modP","n","GuBytes","encodeU","u","decodeU","_u","decodeScalar","scalar","scalarMult","pu","montgomeryLadder","scalarMultBase","cswap","swap","x_2","x_3","dummy","k","x_1","z_2","z_3","t","k_t","A","AA","B","BB","E","C","D","DA","CB","dacb","da_cb","z2","getSharedSecret","privateKey","publicKey","getPublicKey","utils","randomPrivateKey","randomBytes","slice"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@noble\\curves\\src\\abstract\\montgomery.ts"],"sourcesContent":["/**\n * Montgomery curve methods. It's not really whole montgomery curve,\n * just bunch of very specific methods for X25519 / X448 from\n * [RFC 7748](https://www.rfc-editor.org/rfc/rfc7748)\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { mod } from './modular.ts';\nimport {\n  aInRange,\n  bytesToNumberLE,\n  ensureBytes,\n  numberToBytesLE,\n  validateObject,\n} from './utils.ts';\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\ntype Hex = string | Uint8Array;\n\nexport type CurveType = {\n  P: bigint; // finite field prime\n  type: 'x25519' | 'x448';\n  adjustScalarBytes: (bytes: Uint8Array) => Uint8Array;\n  powPminus2: (x: bigint) => bigint;\n  randomBytes: (bytesLength?: number) => Uint8Array;\n};\n\nexport type CurveFn = {\n  scalarMult: (scalar: Hex, u: Hex) => Uint8Array;\n  scalarMultBase: (scalar: Hex) => Uint8Array;\n  getSharedSecret: (privateKeyA: Hex, publicKeyB: Hex) => Uint8Array;\n  getPublicKey: (privateKey: Hex) => Uint8Array;\n  utils: { randomPrivateKey: () => Uint8Array };\n  GuBytes: Uint8Array;\n};\n\nfunction validateOpts(curve: CurveType) {\n  validateObject(curve, {\n    adjustScalarBytes: 'function',\n    powPminus2: 'function',\n  });\n  return Object.freeze({ ...curve } as const);\n}\n\nexport function montgomery(curveDef: CurveType): CurveFn {\n  const CURVE = validateOpts(curveDef);\n  const { P, type, adjustScalarBytes, powPminus2 } = CURVE;\n  const is25519 = type === 'x25519';\n  if (!is25519 && type !== 'x448') throw new Error('invalid type');\n\n  const montgomeryBits = is25519 ? 255 : 448;\n  const fieldLen = is25519 ? 32 : 56;\n  const Gu = is25519 ? BigInt(9) : BigInt(5);\n  // RFC 7748 #5:\n  // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519 and\n  // (156326 - 2) / 4 = 39081 for curve448/X448\n  // const a = is25519 ? 156326n : 486662n;\n  const a24 = is25519 ? BigInt(121665) : BigInt(39081);\n  // RFC: x25519 \"the resulting integer is of the form 2^254 plus\n  // eight times a value between 0 and 2^251 - 1 (inclusive)\"\n  // x448: \"2^447 plus four times a value between 0 and 2^445 - 1 (inclusive)\"\n  const minScalar = is25519 ? _2n ** BigInt(254) : _2n ** BigInt(447);\n  const maxAdded = is25519\n    ? BigInt(8) * _2n ** BigInt(251) - _1n\n    : BigInt(4) * _2n ** BigInt(445) - _1n;\n  const maxScalar = minScalar + maxAdded + _1n; // (inclusive)\n  const modP = (n: bigint) => mod(n, P);\n  const GuBytes = encodeU(Gu);\n  function encodeU(u: bigint): Uint8Array {\n    return numberToBytesLE(modP(u), fieldLen);\n  }\n  function decodeU(u: Hex): bigint {\n    const _u = ensureBytes('u coordinate', u, fieldLen);\n    // RFC: When receiving such an array, implementations of X25519\n    // (but not X448) MUST mask the most significant bit in the final byte.\n    if (is25519) _u[31] &= 127; // 0b0111_1111\n    // RFC: Implementations MUST accept non-canonical values and process them as\n    // if they had been reduced modulo the field prime.  The non-canonical\n    // values are 2^255 - 19 through 2^255 - 1 for X25519 and 2^448 - 2^224\n    // - 1 through 2^448 - 1 for X448.\n    return modP(bytesToNumberLE(_u));\n  }\n  function decodeScalar(scalar: Hex): bigint {\n    return bytesToNumberLE(adjustScalarBytes(ensureBytes('scalar', scalar, fieldLen)));\n  }\n  function scalarMult(scalar: Hex, u: Hex): Uint8Array {\n    const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));\n    // Some public keys are useless, of low-order. Curve author doesn't think\n    // it needs to be validated, but we do it nonetheless.\n    // https://cr.yp.to/ecdh.html#validate\n    if (pu === _0n) throw new Error('invalid private or public key received');\n    return encodeU(pu);\n  }\n  // Computes public key from private. By doing scalar multiplication of base point.\n  function scalarMultBase(scalar: Hex): Uint8Array {\n    return scalarMult(scalar, GuBytes);\n  }\n\n  // cswap from RFC7748 \"example code\"\n  function cswap(swap: bigint, x_2: bigint, x_3: bigint): { x_2: bigint; x_3: bigint } {\n    // dummy = mask(swap) AND (x_2 XOR x_3)\n    // Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n    // and x_3, computed, e.g., as mask(swap) = 0 - swap.\n    const dummy = modP(swap * (x_2 - x_3));\n    x_2 = modP(x_2 - dummy); // x_2 = x_2 XOR dummy\n    x_3 = modP(x_3 + dummy); // x_3 = x_3 XOR dummy\n    return { x_2, x_3 };\n  }\n\n  /**\n   * Montgomery x-only multiplication ladder.\n   * @param pointU u coordinate (x) on Montgomery Curve 25519\n   * @param scalar by which the point would be multiplied\n   * @returns new Point on Montgomery curve\n   */\n  function montgomeryLadder(u: bigint, scalar: bigint): bigint {\n    aInRange('u', u, _0n, P);\n    aInRange('scalar', scalar, minScalar, maxScalar);\n    const k = scalar;\n    const x_1 = u;\n    let x_2 = _1n;\n    let z_2 = _0n;\n    let x_3 = u;\n    let z_3 = _1n;\n    let swap = _0n;\n    for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {\n      const k_t = (k >> t) & _1n;\n      swap ^= k_t;\n      ({ x_2, x_3 } = cswap(swap, x_2, x_3));\n      ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));\n      swap = k_t;\n\n      const A = x_2 + z_2;\n      const AA = modP(A * A);\n      const B = x_2 - z_2;\n      const BB = modP(B * B);\n      const E = AA - BB;\n      const C = x_3 + z_3;\n      const D = x_3 - z_3;\n      const DA = modP(D * A);\n      const CB = modP(C * B);\n      const dacb = DA + CB;\n      const da_cb = DA - CB;\n      x_3 = modP(dacb * dacb);\n      z_3 = modP(x_1 * modP(da_cb * da_cb));\n      x_2 = modP(AA * BB);\n      z_2 = modP(E * (AA + modP(a24 * E)));\n    }\n    ({ x_2, x_3 } = cswap(swap, x_2, x_3));\n    ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));\n    const z2 = powPminus2(z_2); // `Fp.pow(x, P - _2n)` is much slower equivalent\n    return modP(x_2 * z2); // Return x_2 * (z_2^(p - 2))\n  }\n\n  return {\n    scalarMult,\n    scalarMultBase,\n    getSharedSecret: (privateKey: Hex, publicKey: Hex) => scalarMult(privateKey, publicKey),\n    getPublicKey: (privateKey: Hex): Uint8Array => scalarMultBase(privateKey),\n    utils: { randomPrivateKey: () => CURVE.randomBytes!(fieldLen) },\n    GuBytes: GuBytes.slice(),\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}