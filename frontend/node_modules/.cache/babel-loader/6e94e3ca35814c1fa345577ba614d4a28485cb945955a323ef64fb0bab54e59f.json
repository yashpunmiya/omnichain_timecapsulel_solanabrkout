{"ast":null,"code":"import ft from \"@walletconnect/sign-client\";\nimport { isValidObject as mt, isCaipNamespace as fe, parseNamespaceKey as U, mergeArrays as ee, parseChainId as me, getSdkError as ge, isValidArray as Pe } from \"@walletconnect/utils\";\nimport { pino as gt, getDefaultLoggerOptions as Pt } from \"@walletconnect/logger\";\nimport b, { HttpConnection as bt } from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider as m } from \"@walletconnect/jsonrpc-provider\";\nimport { formatJsonRpcRequest as $t, formatJsonRpcResult as yt } from \"@walletconnect/jsonrpc-utils\";\nimport wt from \"events\";\nconst be = \"error\",\n  _t = \"wss://relay.walletconnect.org\",\n  Ct = \"wc\",\n  It = \"universal_provider\",\n  $e = `${Ct}@2:${It}:`,\n  ye = \"https://rpc.walletconnect.org/v1/\",\n  w = \"generic\",\n  Ot = `${ye}bundler`,\n  f = {\n    DEFAULT_CHAIN_CHANGED: \"default_chain_changed\"\n  };\nvar G = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof global < \"u\" ? global : typeof self < \"u\" ? self : {};\nfunction At() {\n  this.__data__ = [], this.size = 0;\n}\nvar jt = At;\nfunction Ht(r, e) {\n  return r === e || r !== r && e !== e;\n}\nvar z = Ht,\n  Et = z;\nfunction St(r, e) {\n  for (var t = r.length; t--;) if (Et(r[t][0], e)) return t;\n  return -1;\n}\nvar k = St,\n  Nt = k,\n  Tt = Array.prototype,\n  Dt = Tt.splice;\nfunction qt(r) {\n  var e = this.__data__,\n    t = Nt(e, r);\n  if (t < 0) return !1;\n  var i = e.length - 1;\n  return t == i ? e.pop() : Dt.call(e, t, 1), --this.size, !0;\n}\nvar Rt = qt,\n  xt = k;\nfunction Lt(r) {\n  var e = this.__data__,\n    t = xt(e, r);\n  return t < 0 ? void 0 : e[t][1];\n}\nvar Ut = Lt,\n  Ft = k;\nfunction Mt(r) {\n  return Ft(this.__data__, r) > -1;\n}\nvar Gt = Mt,\n  zt = k;\nfunction kt(r, e) {\n  var t = this.__data__,\n    i = zt(t, r);\n  return i < 0 ? (++this.size, t.push([r, e])) : t[i][1] = e, this;\n}\nvar Bt = kt,\n  Vt = jt,\n  Jt = Rt,\n  Kt = Ut,\n  Wt = Gt,\n  Xt = Bt;\nfunction _(r) {\n  var e = -1,\n    t = r == null ? 0 : r.length;\n  for (this.clear(); ++e < t;) {\n    var i = r[e];\n    this.set(i[0], i[1]);\n  }\n}\n_.prototype.clear = Vt, _.prototype.delete = Jt, _.prototype.get = Kt, _.prototype.has = Wt, _.prototype.set = Xt;\nvar B = _,\n  Yt = B;\nfunction Zt() {\n  this.__data__ = new Yt(), this.size = 0;\n}\nvar Qt = Zt;\nfunction er(r) {\n  var e = this.__data__,\n    t = e.delete(r);\n  return this.size = e.size, t;\n}\nvar tr = er;\nfunction rr(r) {\n  return this.__data__.get(r);\n}\nvar ir = rr;\nfunction sr(r) {\n  return this.__data__.has(r);\n}\nvar nr = sr,\n  ar = typeof G == \"object\" && G && G.Object === Object && G,\n  we = ar,\n  or = we,\n  cr = typeof self == \"object\" && self && self.Object === Object && self,\n  hr = or || cr || Function(\"return this\")(),\n  C = hr,\n  pr = C,\n  ur = pr.Symbol,\n  _e = ur,\n  Ce = _e,\n  Ie = Object.prototype,\n  lr = Ie.hasOwnProperty,\n  dr = Ie.toString,\n  F = Ce ? Ce.toStringTag : void 0;\nfunction vr(r) {\n  var e = lr.call(r, F),\n    t = r[F];\n  try {\n    r[F] = void 0;\n    var i = !0;\n  } catch {}\n  var s = dr.call(r);\n  return i && (e ? r[F] = t : delete r[F]), s;\n}\nvar fr = vr,\n  mr = Object.prototype,\n  gr = mr.toString;\nfunction Pr(r) {\n  return gr.call(r);\n}\nvar br = Pr,\n  Oe = _e,\n  $r = fr,\n  yr = br,\n  wr = \"[object Null]\",\n  _r = \"[object Undefined]\",\n  Ae = Oe ? Oe.toStringTag : void 0;\nfunction Cr(r) {\n  return r == null ? r === void 0 ? _r : wr : Ae && Ae in Object(r) ? $r(r) : yr(r);\n}\nvar V = Cr;\nfunction Ir(r) {\n  var e = typeof r;\n  return r != null && (e == \"object\" || e == \"function\");\n}\nvar $ = Ir,\n  Or = V,\n  Ar = $,\n  jr = \"[object AsyncFunction]\",\n  Hr = \"[object Function]\",\n  Er = \"[object GeneratorFunction]\",\n  Sr = \"[object Proxy]\";\nfunction Nr(r) {\n  if (!Ar(r)) return !1;\n  var e = Or(r);\n  return e == Hr || e == Er || e == jr || e == Sr;\n}\nvar te = Nr,\n  Tr = C,\n  Dr = Tr[\"__core-js_shared__\"],\n  qr = Dr,\n  re = qr,\n  je = function () {\n    var r = /[^.]+$/.exec(re && re.keys && re.keys.IE_PROTO || \"\");\n    return r ? \"Symbol(src)_1.\" + r : \"\";\n  }();\nfunction Rr(r) {\n  return !!je && je in r;\n}\nvar xr = Rr,\n  Lr = Function.prototype,\n  Ur = Lr.toString;\nfunction Fr(r) {\n  if (r != null) {\n    try {\n      return Ur.call(r);\n    } catch {}\n    try {\n      return r + \"\";\n    } catch {}\n  }\n  return \"\";\n}\nvar Mr = Fr,\n  Gr = te,\n  zr = xr,\n  kr = $,\n  Br = Mr,\n  Vr = /[\\\\^$.*+?()[\\]{}|]/g,\n  Jr = /^\\[object .+?Constructor\\]$/,\n  Kr = Function.prototype,\n  Wr = Object.prototype,\n  Xr = Kr.toString,\n  Yr = Wr.hasOwnProperty,\n  Zr = RegExp(\"^\" + Xr.call(Yr).replace(Vr, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\");\nfunction Qr(r) {\n  if (!kr(r) || zr(r)) return !1;\n  var e = Gr(r) ? Zr : Jr;\n  return e.test(Br(r));\n}\nvar ei = Qr;\nfunction ti(r, e) {\n  return r?.[e];\n}\nvar ri = ti,\n  ii = ei,\n  si = ri;\nfunction ni(r, e) {\n  var t = si(r, e);\n  return ii(t) ? t : void 0;\n}\nvar ie = ni,\n  ai = ie,\n  oi = C,\n  ci = ai(oi, \"Map\"),\n  He = ci,\n  hi = ie,\n  pi = hi(Object, \"create\"),\n  J = pi,\n  Ee = J;\nfunction ui() {\n  this.__data__ = Ee ? Ee(null) : {}, this.size = 0;\n}\nvar li = ui;\nfunction di(r) {\n  var e = this.has(r) && delete this.__data__[r];\n  return this.size -= e ? 1 : 0, e;\n}\nvar vi = di,\n  fi = J,\n  mi = \"__lodash_hash_undefined__\",\n  gi = Object.prototype,\n  Pi = gi.hasOwnProperty;\nfunction bi(r) {\n  var e = this.__data__;\n  if (fi) {\n    var t = e[r];\n    return t === mi ? void 0 : t;\n  }\n  return Pi.call(e, r) ? e[r] : void 0;\n}\nvar $i = bi,\n  yi = J,\n  wi = Object.prototype,\n  _i = wi.hasOwnProperty;\nfunction Ci(r) {\n  var e = this.__data__;\n  return yi ? e[r] !== void 0 : _i.call(e, r);\n}\nvar Ii = Ci,\n  Oi = J,\n  Ai = \"__lodash_hash_undefined__\";\nfunction ji(r, e) {\n  var t = this.__data__;\n  return this.size += this.has(r) ? 0 : 1, t[r] = Oi && e === void 0 ? Ai : e, this;\n}\nvar Hi = ji,\n  Ei = li,\n  Si = vi,\n  Ni = $i,\n  Ti = Ii,\n  Di = Hi;\nfunction I(r) {\n  var e = -1,\n    t = r == null ? 0 : r.length;\n  for (this.clear(); ++e < t;) {\n    var i = r[e];\n    this.set(i[0], i[1]);\n  }\n}\nI.prototype.clear = Ei, I.prototype.delete = Si, I.prototype.get = Ni, I.prototype.has = Ti, I.prototype.set = Di;\nvar qi = I,\n  Se = qi,\n  Ri = B,\n  xi = He;\nfunction Li() {\n  this.size = 0, this.__data__ = {\n    hash: new Se(),\n    map: new (xi || Ri)(),\n    string: new Se()\n  };\n}\nvar Ui = Li;\nfunction Fi(r) {\n  var e = typeof r;\n  return e == \"string\" || e == \"number\" || e == \"symbol\" || e == \"boolean\" ? r !== \"__proto__\" : r === null;\n}\nvar Mi = Fi,\n  Gi = Mi;\nfunction zi(r, e) {\n  var t = r.__data__;\n  return Gi(e) ? t[typeof e == \"string\" ? \"string\" : \"hash\"] : t.map;\n}\nvar K = zi,\n  ki = K;\nfunction Bi(r) {\n  var e = ki(this, r).delete(r);\n  return this.size -= e ? 1 : 0, e;\n}\nvar Vi = Bi,\n  Ji = K;\nfunction Ki(r) {\n  return Ji(this, r).get(r);\n}\nvar Wi = Ki,\n  Xi = K;\nfunction Yi(r) {\n  return Xi(this, r).has(r);\n}\nvar Zi = Yi,\n  Qi = K;\nfunction es(r, e) {\n  var t = Qi(this, r),\n    i = t.size;\n  return t.set(r, e), this.size += t.size == i ? 0 : 1, this;\n}\nvar ts = es,\n  rs = Ui,\n  is = Vi,\n  ss = Wi,\n  ns = Zi,\n  as = ts;\nfunction O(r) {\n  var e = -1,\n    t = r == null ? 0 : r.length;\n  for (this.clear(); ++e < t;) {\n    var i = r[e];\n    this.set(i[0], i[1]);\n  }\n}\nO.prototype.clear = rs, O.prototype.delete = is, O.prototype.get = ss, O.prototype.has = ns, O.prototype.set = as;\nvar os = O,\n  cs = B,\n  hs = He,\n  ps = os,\n  us = 200;\nfunction ls(r, e) {\n  var t = this.__data__;\n  if (t instanceof cs) {\n    var i = t.__data__;\n    if (!hs || i.length < us - 1) return i.push([r, e]), this.size = ++t.size, this;\n    t = this.__data__ = new ps(i);\n  }\n  return t.set(r, e), this.size = t.size, this;\n}\nvar ds = ls,\n  vs = B,\n  fs = Qt,\n  ms = tr,\n  gs = ir,\n  Ps = nr,\n  bs = ds;\nfunction A(r) {\n  var e = this.__data__ = new vs(r);\n  this.size = e.size;\n}\nA.prototype.clear = fs, A.prototype.delete = ms, A.prototype.get = gs, A.prototype.has = Ps, A.prototype.set = bs;\nvar $s = A,\n  ys = ie,\n  ws = function () {\n    try {\n      var r = ys(Object, \"defineProperty\");\n      return r({}, \"\", {}), r;\n    } catch {}\n  }(),\n  Ne = ws,\n  Te = Ne;\nfunction _s(r, e, t) {\n  e == \"__proto__\" && Te ? Te(r, e, {\n    configurable: !0,\n    enumerable: !0,\n    value: t,\n    writable: !0\n  }) : r[e] = t;\n}\nvar se = _s,\n  Cs = se,\n  Is = z;\nfunction Os(r, e, t) {\n  (t !== void 0 && !Is(r[e], t) || t === void 0 && !(e in r)) && Cs(r, e, t);\n}\nvar De = Os;\nfunction As(r) {\n  return function (e, t, i) {\n    for (var s = -1, n = Object(e), a = i(e), o = a.length; o--;) {\n      var c = a[r ? o : ++s];\n      if (t(n[c], c, n) === !1) break;\n    }\n    return e;\n  };\n}\nvar js = As,\n  Hs = js,\n  Es = Hs(),\n  Ss = Es,\n  ne = {\n    exports: {}\n  };\n(function (r, e) {\n  var t = C,\n    i = e && !e.nodeType && e,\n    s = i && !0 && r && !r.nodeType && r,\n    n = s && s.exports === i,\n    a = n ? t.Buffer : void 0,\n    o = a ? a.allocUnsafe : void 0;\n  function c(u, l) {\n    if (l) return u.slice();\n    var P = u.length,\n      d = o ? o(P) : new u.constructor(P);\n    return u.copy(d), d;\n  }\n  r.exports = c;\n})(ne, ne.exports);\nvar Ns = C,\n  Ts = Ns.Uint8Array,\n  Ds = Ts,\n  qe = Ds;\nfunction qs(r) {\n  var e = new r.constructor(r.byteLength);\n  return new qe(e).set(new qe(r)), e;\n}\nvar Rs = qs,\n  xs = Rs;\nfunction Ls(r, e) {\n  var t = e ? xs(r.buffer) : r.buffer;\n  return new r.constructor(t, r.byteOffset, r.length);\n}\nvar Us = Ls;\nfunction Fs(r, e) {\n  var t = -1,\n    i = r.length;\n  for (e || (e = Array(i)); ++t < i;) e[t] = r[t];\n  return e;\n}\nvar Ms = Fs,\n  Gs = $,\n  Re = Object.create,\n  zs = function () {\n    function r() {}\n    return function (e) {\n      if (!Gs(e)) return {};\n      if (Re) return Re(e);\n      r.prototype = e;\n      var t = new r();\n      return r.prototype = void 0, t;\n    };\n  }(),\n  ks = zs;\nfunction Bs(r, e) {\n  return function (t) {\n    return r(e(t));\n  };\n}\nvar Vs = Bs,\n  Js = Vs,\n  Ks = Js(Object.getPrototypeOf, Object),\n  xe = Ks,\n  Ws = Object.prototype;\nfunction Xs(r) {\n  var e = r && r.constructor,\n    t = typeof e == \"function\" && e.prototype || Ws;\n  return r === t;\n}\nvar Le = Xs,\n  Ys = ks,\n  Zs = xe,\n  Qs = Le;\nfunction en(r) {\n  return typeof r.constructor == \"function\" && !Qs(r) ? Ys(Zs(r)) : {};\n}\nvar tn = en;\nfunction rn(r) {\n  return r != null && typeof r == \"object\";\n}\nvar M = rn,\n  sn = V,\n  nn = M,\n  an = \"[object Arguments]\";\nfunction on(r) {\n  return nn(r) && sn(r) == an;\n}\nvar cn = on,\n  Ue = cn,\n  hn = M,\n  Fe = Object.prototype,\n  pn = Fe.hasOwnProperty,\n  un = Fe.propertyIsEnumerable,\n  ln = Ue(function () {\n    return arguments;\n  }()) ? Ue : function (r) {\n    return hn(r) && pn.call(r, \"callee\") && !un.call(r, \"callee\");\n  },\n  Me = ln,\n  dn = Array.isArray,\n  Ge = dn,\n  vn = 9007199254740991;\nfunction fn(r) {\n  return typeof r == \"number\" && r > -1 && r % 1 == 0 && r <= vn;\n}\nvar ze = fn,\n  mn = te,\n  gn = ze;\nfunction Pn(r) {\n  return r != null && gn(r.length) && !mn(r);\n}\nvar ae = Pn,\n  bn = ae,\n  $n = M;\nfunction yn(r) {\n  return $n(r) && bn(r);\n}\nvar wn = yn,\n  W = {\n    exports: {}\n  };\nfunction _n() {\n  return !1;\n}\nvar Cn = _n;\n(function (r, e) {\n  var t = C,\n    i = Cn,\n    s = e && !e.nodeType && e,\n    n = s && !0 && r && !r.nodeType && r,\n    a = n && n.exports === s,\n    o = a ? t.Buffer : void 0,\n    c = o ? o.isBuffer : void 0,\n    u = c || i;\n  r.exports = u;\n})(W, W.exports);\nvar In = V,\n  On = xe,\n  An = M,\n  jn = \"[object Object]\",\n  Hn = Function.prototype,\n  En = Object.prototype,\n  ke = Hn.toString,\n  Sn = En.hasOwnProperty,\n  Nn = ke.call(Object);\nfunction Tn(r) {\n  if (!An(r) || In(r) != jn) return !1;\n  var e = On(r);\n  if (e === null) return !0;\n  var t = Sn.call(e, \"constructor\") && e.constructor;\n  return typeof t == \"function\" && t instanceof t && ke.call(t) == Nn;\n}\nvar Dn = Tn,\n  qn = V,\n  Rn = ze,\n  xn = M,\n  Ln = \"[object Arguments]\",\n  Un = \"[object Array]\",\n  Fn = \"[object Boolean]\",\n  Mn = \"[object Date]\",\n  Gn = \"[object Error]\",\n  zn = \"[object Function]\",\n  kn = \"[object Map]\",\n  Bn = \"[object Number]\",\n  Vn = \"[object Object]\",\n  Jn = \"[object RegExp]\",\n  Kn = \"[object Set]\",\n  Wn = \"[object String]\",\n  Xn = \"[object WeakMap]\",\n  Yn = \"[object ArrayBuffer]\",\n  Zn = \"[object DataView]\",\n  Qn = \"[object Float32Array]\",\n  ea = \"[object Float64Array]\",\n  ta = \"[object Int8Array]\",\n  ra = \"[object Int16Array]\",\n  ia = \"[object Int32Array]\",\n  sa = \"[object Uint8Array]\",\n  na = \"[object Uint8ClampedArray]\",\n  aa = \"[object Uint16Array]\",\n  oa = \"[object Uint32Array]\",\n  p = {};\np[Qn] = p[ea] = p[ta] = p[ra] = p[ia] = p[sa] = p[na] = p[aa] = p[oa] = !0, p[Ln] = p[Un] = p[Yn] = p[Fn] = p[Zn] = p[Mn] = p[Gn] = p[zn] = p[kn] = p[Bn] = p[Vn] = p[Jn] = p[Kn] = p[Wn] = p[Xn] = !1;\nfunction ca(r) {\n  return xn(r) && Rn(r.length) && !!p[qn(r)];\n}\nvar ha = ca;\nfunction pa(r) {\n  return function (e) {\n    return r(e);\n  };\n}\nvar ua = pa,\n  oe = {\n    exports: {}\n  };\n(function (r, e) {\n  var t = we,\n    i = e && !e.nodeType && e,\n    s = i && !0 && r && !r.nodeType && r,\n    n = s && s.exports === i,\n    a = n && t.process,\n    o = function () {\n      try {\n        var c = s && s.require && s.require(\"util\").types;\n        return c || a && a.binding && a.binding(\"util\");\n      } catch {}\n    }();\n  r.exports = o;\n})(oe, oe.exports);\nvar la = ha,\n  da = ua,\n  Be = oe.exports,\n  Ve = Be && Be.isTypedArray,\n  va = Ve ? da(Ve) : la,\n  Je = va;\nfunction fa(r, e) {\n  if (!(e === \"constructor\" && typeof r[e] == \"function\") && e != \"__proto__\") return r[e];\n}\nvar Ke = fa,\n  ma = se,\n  ga = z,\n  Pa = Object.prototype,\n  ba = Pa.hasOwnProperty;\nfunction $a(r, e, t) {\n  var i = r[e];\n  (!(ba.call(r, e) && ga(i, t)) || t === void 0 && !(e in r)) && ma(r, e, t);\n}\nvar ya = $a,\n  wa = ya,\n  _a = se;\nfunction Ca(r, e, t, i) {\n  var s = !t;\n  t || (t = {});\n  for (var n = -1, a = e.length; ++n < a;) {\n    var o = e[n],\n      c = i ? i(t[o], r[o], o, t, r) : void 0;\n    c === void 0 && (c = r[o]), s ? _a(t, o, c) : wa(t, o, c);\n  }\n  return t;\n}\nvar Ia = Ca;\nfunction Oa(r, e) {\n  for (var t = -1, i = Array(r); ++t < r;) i[t] = e(t);\n  return i;\n}\nvar Aa = Oa,\n  ja = 9007199254740991,\n  Ha = /^(?:0|[1-9]\\d*)$/;\nfunction Ea(r, e) {\n  var t = typeof r;\n  return e = e ?? ja, !!e && (t == \"number\" || t != \"symbol\" && Ha.test(r)) && r > -1 && r % 1 == 0 && r < e;\n}\nvar We = Ea,\n  Sa = Aa,\n  Na = Me,\n  Ta = Ge,\n  Da = W.exports,\n  qa = We,\n  Ra = Je,\n  xa = Object.prototype,\n  La = xa.hasOwnProperty;\nfunction Ua(r, e) {\n  var t = Ta(r),\n    i = !t && Na(r),\n    s = !t && !i && Da(r),\n    n = !t && !i && !s && Ra(r),\n    a = t || i || s || n,\n    o = a ? Sa(r.length, String) : [],\n    c = o.length;\n  for (var u in r) (e || La.call(r, u)) && !(a && (u == \"length\" || s && (u == \"offset\" || u == \"parent\") || n && (u == \"buffer\" || u == \"byteLength\" || u == \"byteOffset\") || qa(u, c))) && o.push(u);\n  return o;\n}\nvar Fa = Ua;\nfunction Ma(r) {\n  var e = [];\n  if (r != null) for (var t in Object(r)) e.push(t);\n  return e;\n}\nvar Ga = Ma,\n  za = $,\n  ka = Le,\n  Ba = Ga,\n  Va = Object.prototype,\n  Ja = Va.hasOwnProperty;\nfunction Ka(r) {\n  if (!za(r)) return Ba(r);\n  var e = ka(r),\n    t = [];\n  for (var i in r) i == \"constructor\" && (e || !Ja.call(r, i)) || t.push(i);\n  return t;\n}\nvar Wa = Ka,\n  Xa = Fa,\n  Ya = Wa,\n  Za = ae;\nfunction Qa(r) {\n  return Za(r) ? Xa(r, !0) : Ya(r);\n}\nvar Xe = Qa,\n  eo = Ia,\n  to = Xe;\nfunction ro(r) {\n  return eo(r, to(r));\n}\nvar io = ro,\n  Ye = De,\n  so = ne.exports,\n  no = Us,\n  ao = Ms,\n  oo = tn,\n  Ze = Me,\n  Qe = Ge,\n  co = wn,\n  ho = W.exports,\n  po = te,\n  uo = $,\n  lo = Dn,\n  vo = Je,\n  et = Ke,\n  fo = io;\nfunction mo(r, e, t, i, s, n, a) {\n  var o = et(r, t),\n    c = et(e, t),\n    u = a.get(c);\n  if (u) {\n    Ye(r, t, u);\n    return;\n  }\n  var l = n ? n(o, c, t + \"\", r, e, a) : void 0,\n    P = l === void 0;\n  if (P) {\n    var d = Qe(c),\n      Q = !d && ho(c),\n      ve = !d && !Q && vo(c);\n    l = c, d || Q || ve ? Qe(o) ? l = o : co(o) ? l = ao(o) : Q ? (P = !1, l = so(c, !0)) : ve ? (P = !1, l = no(c, !0)) : l = [] : lo(c) || Ze(c) ? (l = o, Ze(o) ? l = fo(o) : (!uo(o) || po(o)) && (l = oo(c))) : P = !1;\n  }\n  P && (a.set(c, l), s(l, c, i, n, a), a.delete(c)), Ye(r, t, l);\n}\nvar go = mo,\n  Po = $s,\n  bo = De,\n  $o = Ss,\n  yo = go,\n  wo = $,\n  _o = Xe,\n  Co = Ke;\nfunction tt(r, e, t, i, s) {\n  r !== e && $o(e, function (n, a) {\n    if (s || (s = new Po()), wo(n)) yo(r, e, a, t, tt, i, s);else {\n      var o = i ? i(Co(r, a), n, a + \"\", r, e, s) : void 0;\n      o === void 0 && (o = n), bo(r, a, o);\n    }\n  }, _o);\n}\nvar Io = tt;\nfunction Oo(r) {\n  return r;\n}\nvar rt = Oo;\nfunction Ao(r, e, t) {\n  switch (t.length) {\n    case 0:\n      return r.call(e);\n    case 1:\n      return r.call(e, t[0]);\n    case 2:\n      return r.call(e, t[0], t[1]);\n    case 3:\n      return r.call(e, t[0], t[1], t[2]);\n  }\n  return r.apply(e, t);\n}\nvar jo = Ao,\n  Ho = jo,\n  it = Math.max;\nfunction Eo(r, e, t) {\n  return e = it(e === void 0 ? r.length - 1 : e, 0), function () {\n    for (var i = arguments, s = -1, n = it(i.length - e, 0), a = Array(n); ++s < n;) a[s] = i[e + s];\n    s = -1;\n    for (var o = Array(e + 1); ++s < e;) o[s] = i[s];\n    return o[e] = t(a), Ho(r, this, o);\n  };\n}\nvar So = Eo;\nfunction No(r) {\n  return function () {\n    return r;\n  };\n}\nvar To = No,\n  Do = To,\n  st = Ne,\n  qo = rt,\n  Ro = st ? function (r, e) {\n    return st(r, \"toString\", {\n      configurable: !0,\n      enumerable: !1,\n      value: Do(e),\n      writable: !0\n    });\n  } : qo,\n  xo = Ro,\n  Lo = 800,\n  Uo = 16,\n  Fo = Date.now;\nfunction Mo(r) {\n  var e = 0,\n    t = 0;\n  return function () {\n    var i = Fo(),\n      s = Uo - (i - t);\n    if (t = i, s > 0) {\n      if (++e >= Lo) return arguments[0];\n    } else e = 0;\n    return r.apply(void 0, arguments);\n  };\n}\nvar Go = Mo,\n  zo = xo,\n  ko = Go,\n  Bo = ko(zo),\n  Vo = Bo,\n  Jo = rt,\n  Ko = So,\n  Wo = Vo;\nfunction Xo(r, e) {\n  return Wo(Ko(r, e, Jo), r + \"\");\n}\nvar Yo = Xo,\n  Zo = z,\n  Qo = ae,\n  ec = We,\n  tc = $;\nfunction rc(r, e, t) {\n  if (!tc(t)) return !1;\n  var i = typeof e;\n  return (i == \"number\" ? Qo(t) && ec(e, t.length) : i == \"string\" && e in t) ? Zo(t[e], r) : !1;\n}\nvar ic = rc,\n  sc = Yo,\n  nc = ic;\nfunction ac(r) {\n  return sc(function (e, t) {\n    var i = -1,\n      s = t.length,\n      n = s > 1 ? t[s - 1] : void 0,\n      a = s > 2 ? t[2] : void 0;\n    for (n = r.length > 3 && typeof n == \"function\" ? (s--, n) : void 0, a && nc(t[0], t[1], a) && (n = s < 3 ? void 0 : n, s = 1), e = Object(e); ++i < s;) {\n      var o = t[i];\n      o && r(e, o, i, n);\n    }\n    return e;\n  });\n}\nvar oc = ac,\n  cc = Io,\n  hc = oc,\n  pc = hc(function (r, e, t) {\n    cc(r, e, t);\n  }),\n  uc = pc,\n  lc = Object.defineProperty,\n  dc = Object.defineProperties,\n  vc = Object.getOwnPropertyDescriptors,\n  nt = Object.getOwnPropertySymbols,\n  fc = Object.prototype.hasOwnProperty,\n  mc = Object.prototype.propertyIsEnumerable,\n  at = (r, e, t) => e in r ? lc(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  X = (r, e) => {\n    for (var t in e || (e = {})) fc.call(e, t) && at(r, t, e[t]);\n    if (nt) for (var t of nt(e)) mc.call(e, t) && at(r, t, e[t]);\n    return r;\n  },\n  gc = (r, e) => dc(r, vc(e));\nfunction v(r, e, t) {\n  var i;\n  const s = me(r);\n  return ((i = e.rpcMap) == null ? void 0 : i[s.reference]) || `${ye}?chainId=${s.namespace}:${s.reference}&projectId=${t}`;\n}\nfunction y(r) {\n  return r.includes(\":\") ? r.split(\":\")[1] : r;\n}\nfunction ot(r) {\n  return r.map(e => `${e.split(\":\")[0]}:${e.split(\":\")[1]}`);\n}\nfunction Pc(r, e) {\n  const t = Object.keys(e.namespaces).filter(s => s.includes(r));\n  if (!t.length) return [];\n  const i = [];\n  return t.forEach(s => {\n    const n = e.namespaces[s].accounts;\n    i.push(...n);\n  }), i;\n}\nfunction ce(r = {}, e = {}) {\n  const t = ct(r),\n    i = ct(e);\n  return uc(t, i);\n}\nfunction ct(r) {\n  var e, t, i, s;\n  const n = {};\n  if (!mt(r)) return n;\n  for (const [a, o] of Object.entries(r)) {\n    const c = fe(a) ? [a] : o.chains,\n      u = o.methods || [],\n      l = o.events || [],\n      P = o.rpcMap || {},\n      d = U(a);\n    n[d] = gc(X(X({}, n[d]), o), {\n      chains: ee(c, (e = n[d]) == null ? void 0 : e.chains),\n      methods: ee(u, (t = n[d]) == null ? void 0 : t.methods),\n      events: ee(l, (i = n[d]) == null ? void 0 : i.events),\n      rpcMap: X(X({}, P), (s = n[d]) == null ? void 0 : s.rpcMap)\n    });\n  }\n  return n;\n}\nfunction bc(r) {\n  return r.includes(\":\") ? r.split(\":\")[2] : r;\n}\nfunction ht(r) {\n  const e = {};\n  for (const [t, i] of Object.entries(r)) {\n    const s = i.methods || [],\n      n = i.events || [],\n      a = i.accounts || [],\n      o = fe(t) ? [t] : i.chains ? i.chains : ot(i.accounts);\n    e[t] = {\n      chains: o,\n      methods: s,\n      events: n,\n      accounts: a\n    };\n  }\n  return e;\n}\nfunction he(r) {\n  return typeof r == \"number\" ? r : r.includes(\"0x\") ? parseInt(r, 16) : (r = r.includes(\":\") ? r.split(\":\")[1] : r, isNaN(Number(r)) ? r : Number(r));\n}\nconst pt = {},\n  h = r => pt[r],\n  pe = (r, e) => {\n    pt[r] = e;\n  };\nvar $c = Object.defineProperty,\n  yc = (r, e, t) => e in r ? $c(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  j = (r, e, t) => yc(r, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass wc {\n  constructor(e) {\n    j(this, \"name\", \"polkadot\"), j(this, \"client\"), j(this, \"httpProviders\"), j(this, \"events\"), j(this, \"namespace\"), j(this, \"chainId\"), this.namespace = e.namespace, this.events = h(\"events\"), this.client = h(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(e) {\n    this.namespace = Object.assign(this.namespace, e);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const e = this.namespace.chains[0];\n    if (!e) throw new Error(\"ChainId not found\");\n    return e.split(\":\")[1];\n  }\n  request(e) {\n    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);\n  }\n  setDefaultChain(e, t) {\n    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(f.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);\n  }\n  getAccounts() {\n    const e = this.namespace.accounts;\n    return e ? e.filter(t => t.split(\":\")[1] === this.chainId.toString()).map(t => t.split(\":\")[2]) || [] : [];\n  }\n  createHttpProviders() {\n    const e = {};\n    return this.namespace.chains.forEach(t => {\n      var i;\n      const s = y(t);\n      e[s] = this.createHttpProvider(s, (i = this.namespace.rpcMap) == null ? void 0 : i[t]);\n    }), e;\n  }\n  getHttpProvider() {\n    const e = `${this.name}:${this.chainId}`,\n      t = this.httpProviders[e];\n    if (typeof t > \"u\") throw new Error(`JSON-RPC provider for ${e} not found`);\n    return t;\n  }\n  setHttpProvider(e, t) {\n    const i = this.createHttpProvider(e, t);\n    i && (this.httpProviders[e] = i);\n  }\n  createHttpProvider(e, t) {\n    const i = t || v(e, this.namespace, this.client.core.projectId);\n    if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);\n    return new m(new b(i, h(\"disableProviderPing\")));\n  }\n}\nvar _c = Object.defineProperty,\n  Cc = Object.defineProperties,\n  Ic = Object.getOwnPropertyDescriptors,\n  ut = Object.getOwnPropertySymbols,\n  Oc = Object.prototype.hasOwnProperty,\n  Ac = Object.prototype.propertyIsEnumerable,\n  ue = (r, e, t) => e in r ? _c(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  lt = (r, e) => {\n    for (var t in e || (e = {})) Oc.call(e, t) && ue(r, t, e[t]);\n    if (ut) for (var t of ut(e)) Ac.call(e, t) && ue(r, t, e[t]);\n    return r;\n  },\n  dt = (r, e) => Cc(r, Ic(e)),\n  H = (r, e, t) => ue(r, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass jc {\n  constructor(e) {\n    H(this, \"name\", \"eip155\"), H(this, \"client\"), H(this, \"chainId\"), H(this, \"namespace\"), H(this, \"httpProviders\"), H(this, \"events\"), this.namespace = e.namespace, this.events = h(\"events\"), this.client = h(\"client\"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain());\n  }\n  async request(e) {\n    switch (e.request.method) {\n      case \"eth_requestAccounts\":\n        return this.getAccounts();\n      case \"eth_accounts\":\n        return this.getAccounts();\n      case \"wallet_switchEthereumChain\":\n        return await this.handleSwitchChain(e);\n      case \"eth_chainId\":\n        return parseInt(this.getDefaultChain());\n      case \"wallet_getCapabilities\":\n        return await this.getCapabilities(e);\n      case \"wallet_getCallsStatus\":\n        return await this.getCallStatus(e);\n    }\n    return this.namespace.methods.includes(e.request.method) ? await this.client.request(e) : this.getHttpProvider().request(e.request);\n  }\n  updateNamespace(e) {\n    this.namespace = Object.assign(this.namespace, e);\n  }\n  setDefaultChain(e, t) {\n    this.httpProviders[e] || this.setHttpProvider(parseInt(e), t), this.chainId = parseInt(e), this.events.emit(f.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId.toString();\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const e = this.namespace.chains[0];\n    if (!e) throw new Error(\"ChainId not found\");\n    return e.split(\":\")[1];\n  }\n  createHttpProvider(e, t) {\n    const i = t || v(`${this.name}:${e}`, this.namespace, this.client.core.projectId);\n    if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);\n    return new m(new bt(i, h(\"disableProviderPing\")));\n  }\n  setHttpProvider(e, t) {\n    const i = this.createHttpProvider(e, t);\n    i && (this.httpProviders[e] = i);\n  }\n  createHttpProviders() {\n    const e = {};\n    return this.namespace.chains.forEach(t => {\n      var i;\n      const s = parseInt(y(t));\n      e[s] = this.createHttpProvider(s, (i = this.namespace.rpcMap) == null ? void 0 : i[t]);\n    }), e;\n  }\n  getAccounts() {\n    const e = this.namespace.accounts;\n    return e ? [...new Set(e.filter(t => t.split(\":\")[1] === this.chainId.toString()).map(t => t.split(\":\")[2]))] : [];\n  }\n  getHttpProvider() {\n    const e = this.chainId,\n      t = this.httpProviders[e];\n    if (typeof t > \"u\") throw new Error(`JSON-RPC provider for ${e} not found`);\n    return t;\n  }\n  async handleSwitchChain(e) {\n    var t, i;\n    let s = e.request.params ? (t = e.request.params[0]) == null ? void 0 : t.chainId : \"0x0\";\n    s = s.startsWith(\"0x\") ? s : `0x${s}`;\n    const n = parseInt(s, 16);\n    if (this.isChainApproved(n)) this.setDefaultChain(`${n}`);else if (this.namespace.methods.includes(\"wallet_switchEthereumChain\")) await this.client.request({\n      topic: e.topic,\n      request: {\n        method: e.request.method,\n        params: [{\n          chainId: s\n        }]\n      },\n      chainId: (i = this.namespace.chains) == null ? void 0 : i[0]\n    }), this.setDefaultChain(`${n}`);else throw new Error(`Failed to switch to chain 'eip155:${n}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);\n    return null;\n  }\n  isChainApproved(e) {\n    return this.namespace.chains.includes(`${this.name}:${e}`);\n  }\n  async getCapabilities(e) {\n    var t, i, s;\n    const n = (i = (t = e.request) == null ? void 0 : t.params) == null ? void 0 : i[0];\n    if (!n) throw new Error(\"Missing address parameter in `wallet_getCapabilities` request\");\n    const a = this.client.session.get(e.topic),\n      o = ((s = a?.sessionProperties) == null ? void 0 : s.capabilities) || {};\n    if (o != null && o[n]) return o?.[n];\n    const c = await this.client.request(e);\n    try {\n      await this.client.session.update(e.topic, {\n        sessionProperties: dt(lt({}, a.sessionProperties || {}), {\n          capabilities: dt(lt({}, o || {}), {\n            [n]: c\n          })\n        })\n      });\n    } catch (u) {\n      console.warn(\"Failed to update session with capabilities\", u);\n    }\n    return c;\n  }\n  async getCallStatus(e) {\n    var t, i;\n    const s = this.client.session.get(e.topic),\n      n = (t = s.sessionProperties) == null ? void 0 : t.bundler_name;\n    if (n) {\n      const o = this.getBundlerUrl(e.chainId, n);\n      try {\n        return await this.getUserOperationReceipt(o, e);\n      } catch (c) {\n        console.warn(\"Failed to fetch call status from bundler\", c, o);\n      }\n    }\n    const a = (i = s.sessionProperties) == null ? void 0 : i.bundler_url;\n    if (a) try {\n      return await this.getUserOperationReceipt(a, e);\n    } catch (o) {\n      console.warn(\"Failed to fetch call status from custom bundler\", o, a);\n    }\n    if (this.namespace.methods.includes(e.request.method)) return await this.client.request(e);\n    throw new Error(\"Fetching call status not approved by the wallet.\");\n  }\n  async getUserOperationReceipt(e, t) {\n    var i;\n    const s = new URL(e),\n      n = await fetch(s, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify($t(\"eth_getUserOperationReceipt\", [(i = t.request.params) == null ? void 0 : i[0]]))\n      });\n    if (!n.ok) throw new Error(`Failed to fetch user operation receipt - ${n.status}`);\n    return await n.json();\n  }\n  getBundlerUrl(e, t) {\n    return `${Ot}?projectId=${this.client.core.projectId}&chainId=${e}&bundler=${t}`;\n  }\n}\nvar Hc = Object.defineProperty,\n  Ec = (r, e, t) => e in r ? Hc(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  E = (r, e, t) => Ec(r, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass Sc {\n  constructor(e) {\n    E(this, \"name\", \"solana\"), E(this, \"client\"), E(this, \"httpProviders\"), E(this, \"events\"), E(this, \"namespace\"), E(this, \"chainId\"), this.namespace = e.namespace, this.events = h(\"events\"), this.client = h(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(e) {\n    this.namespace = Object.assign(this.namespace, e);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  request(e) {\n    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);\n  }\n  setDefaultChain(e, t) {\n    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(f.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const e = this.namespace.chains[0];\n    if (!e) throw new Error(\"ChainId not found\");\n    return e.split(\":\")[1];\n  }\n  getAccounts() {\n    const e = this.namespace.accounts;\n    return e ? [...new Set(e.filter(t => t.split(\":\")[1] === this.chainId.toString()).map(t => t.split(\":\")[2]))] : [];\n  }\n  createHttpProviders() {\n    const e = {};\n    return this.namespace.chains.forEach(t => {\n      var i;\n      const s = y(t);\n      e[s] = this.createHttpProvider(s, (i = this.namespace.rpcMap) == null ? void 0 : i[t]);\n    }), e;\n  }\n  getHttpProvider() {\n    const e = `${this.name}:${this.chainId}`,\n      t = this.httpProviders[e];\n    if (typeof t > \"u\") throw new Error(`JSON-RPC provider for ${e} not found`);\n    return t;\n  }\n  setHttpProvider(e, t) {\n    const i = this.createHttpProvider(e, t);\n    i && (this.httpProviders[e] = i);\n  }\n  createHttpProvider(e, t) {\n    const i = t || v(e, this.namespace, this.client.core.projectId);\n    if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);\n    return new m(new b(i, h(\"disableProviderPing\")));\n  }\n}\nvar Nc = Object.defineProperty,\n  Tc = (r, e, t) => e in r ? Nc(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  S = (r, e, t) => Tc(r, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass Dc {\n  constructor(e) {\n    S(this, \"name\", \"cosmos\"), S(this, \"client\"), S(this, \"httpProviders\"), S(this, \"events\"), S(this, \"namespace\"), S(this, \"chainId\"), this.namespace = e.namespace, this.events = h(\"events\"), this.client = h(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(e) {\n    this.namespace = Object.assign(this.namespace, e);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const e = this.namespace.chains[0];\n    if (!e) throw new Error(\"ChainId not found\");\n    return e.split(\":\")[1];\n  }\n  request(e) {\n    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);\n  }\n  setDefaultChain(e, t) {\n    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(f.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n  getAccounts() {\n    const e = this.namespace.accounts;\n    return e ? [...new Set(e.filter(t => t.split(\":\")[1] === this.chainId.toString()).map(t => t.split(\":\")[2]))] : [];\n  }\n  createHttpProviders() {\n    const e = {};\n    return this.namespace.chains.forEach(t => {\n      var i;\n      const s = y(t);\n      e[s] = this.createHttpProvider(s, (i = this.namespace.rpcMap) == null ? void 0 : i[t]);\n    }), e;\n  }\n  getHttpProvider() {\n    const e = `${this.name}:${this.chainId}`,\n      t = this.httpProviders[e];\n    if (typeof t > \"u\") throw new Error(`JSON-RPC provider for ${e} not found`);\n    return t;\n  }\n  setHttpProvider(e, t) {\n    const i = this.createHttpProvider(e, t);\n    i && (this.httpProviders[e] = i);\n  }\n  createHttpProvider(e, t) {\n    const i = t || v(e, this.namespace, this.client.core.projectId);\n    if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);\n    return new m(new b(i, h(\"disableProviderPing\")));\n  }\n}\nvar qc = Object.defineProperty,\n  Rc = (r, e, t) => e in r ? qc(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  N = (r, e, t) => Rc(r, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass xc {\n  constructor(e) {\n    N(this, \"name\", \"algorand\"), N(this, \"client\"), N(this, \"httpProviders\"), N(this, \"events\"), N(this, \"namespace\"), N(this, \"chainId\"), this.namespace = e.namespace, this.events = h(\"events\"), this.client = h(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(e) {\n    this.namespace = Object.assign(this.namespace, e);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  request(e) {\n    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);\n  }\n  setDefaultChain(e, t) {\n    if (!this.httpProviders[e]) {\n      const i = t || v(`${this.name}:${e}`, this.namespace, this.client.core.projectId);\n      if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);\n      this.setHttpProvider(e, i);\n    }\n    this.chainId = e, this.events.emit(f.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const e = this.namespace.chains[0];\n    if (!e) throw new Error(\"ChainId not found\");\n    return e.split(\":\")[1];\n  }\n  getAccounts() {\n    const e = this.namespace.accounts;\n    return e ? [...new Set(e.filter(t => t.split(\":\")[1] === this.chainId.toString()).map(t => t.split(\":\")[2]))] : [];\n  }\n  createHttpProviders() {\n    const e = {};\n    return this.namespace.chains.forEach(t => {\n      var i;\n      e[t] = this.createHttpProvider(t, (i = this.namespace.rpcMap) == null ? void 0 : i[t]);\n    }), e;\n  }\n  getHttpProvider() {\n    const e = `${this.name}:${this.chainId}`,\n      t = this.httpProviders[e];\n    if (typeof t > \"u\") throw new Error(`JSON-RPC provider for ${e} not found`);\n    return t;\n  }\n  setHttpProvider(e, t) {\n    const i = this.createHttpProvider(e, t);\n    i && (this.httpProviders[e] = i);\n  }\n  createHttpProvider(e, t) {\n    const i = t || v(e, this.namespace, this.client.core.projectId);\n    return typeof i > \"u\" ? void 0 : new m(new b(i, h(\"disableProviderPing\")));\n  }\n}\nvar Lc = Object.defineProperty,\n  Uc = (r, e, t) => e in r ? Lc(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  T = (r, e, t) => Uc(r, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass Fc {\n  constructor(e) {\n    T(this, \"name\", \"cip34\"), T(this, \"client\"), T(this, \"httpProviders\"), T(this, \"events\"), T(this, \"namespace\"), T(this, \"chainId\"), this.namespace = e.namespace, this.events = h(\"events\"), this.client = h(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(e) {\n    this.namespace = Object.assign(this.namespace, e);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const e = this.namespace.chains[0];\n    if (!e) throw new Error(\"ChainId not found\");\n    return e.split(\":\")[1];\n  }\n  request(e) {\n    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);\n  }\n  setDefaultChain(e, t) {\n    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(f.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n  getAccounts() {\n    const e = this.namespace.accounts;\n    return e ? [...new Set(e.filter(t => t.split(\":\")[1] === this.chainId.toString()).map(t => t.split(\":\")[2]))] : [];\n  }\n  createHttpProviders() {\n    const e = {};\n    return this.namespace.chains.forEach(t => {\n      const i = this.getCardanoRPCUrl(t),\n        s = y(t);\n      e[s] = this.createHttpProvider(s, i);\n    }), e;\n  }\n  getHttpProvider() {\n    const e = `${this.name}:${this.chainId}`,\n      t = this.httpProviders[e];\n    if (typeof t > \"u\") throw new Error(`JSON-RPC provider for ${e} not found`);\n    return t;\n  }\n  getCardanoRPCUrl(e) {\n    const t = this.namespace.rpcMap;\n    if (t) return t[e];\n  }\n  setHttpProvider(e, t) {\n    const i = this.createHttpProvider(e, t);\n    i && (this.httpProviders[e] = i);\n  }\n  createHttpProvider(e, t) {\n    const i = t || this.getCardanoRPCUrl(e);\n    if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);\n    return new m(new b(i, h(\"disableProviderPing\")));\n  }\n}\nvar Mc = Object.defineProperty,\n  Gc = (r, e, t) => e in r ? Mc(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  D = (r, e, t) => Gc(r, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass zc {\n  constructor(e) {\n    D(this, \"name\", \"elrond\"), D(this, \"client\"), D(this, \"httpProviders\"), D(this, \"events\"), D(this, \"namespace\"), D(this, \"chainId\"), this.namespace = e.namespace, this.events = h(\"events\"), this.client = h(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(e) {\n    this.namespace = Object.assign(this.namespace, e);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  request(e) {\n    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);\n  }\n  setDefaultChain(e, t) {\n    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(f.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const e = this.namespace.chains[0];\n    if (!e) throw new Error(\"ChainId not found\");\n    return e.split(\":\")[1];\n  }\n  getAccounts() {\n    const e = this.namespace.accounts;\n    return e ? [...new Set(e.filter(t => t.split(\":\")[1] === this.chainId.toString()).map(t => t.split(\":\")[2]))] : [];\n  }\n  createHttpProviders() {\n    const e = {};\n    return this.namespace.chains.forEach(t => {\n      var i;\n      const s = y(t);\n      e[s] = this.createHttpProvider(s, (i = this.namespace.rpcMap) == null ? void 0 : i[t]);\n    }), e;\n  }\n  getHttpProvider() {\n    const e = `${this.name}:${this.chainId}`,\n      t = this.httpProviders[e];\n    if (typeof t > \"u\") throw new Error(`JSON-RPC provider for ${e} not found`);\n    return t;\n  }\n  setHttpProvider(e, t) {\n    const i = this.createHttpProvider(e, t);\n    i && (this.httpProviders[e] = i);\n  }\n  createHttpProvider(e, t) {\n    const i = t || v(e, this.namespace, this.client.core.projectId);\n    if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);\n    return new m(new b(i, h(\"disableProviderPing\")));\n  }\n}\nvar kc = Object.defineProperty,\n  Bc = (r, e, t) => e in r ? kc(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  q = (r, e, t) => Bc(r, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass Vc {\n  constructor(e) {\n    q(this, \"name\", \"multiversx\"), q(this, \"client\"), q(this, \"httpProviders\"), q(this, \"events\"), q(this, \"namespace\"), q(this, \"chainId\"), this.namespace = e.namespace, this.events = h(\"events\"), this.client = h(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(e) {\n    this.namespace = Object.assign(this.namespace, e);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  request(e) {\n    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);\n  }\n  setDefaultChain(e, t) {\n    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(f.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const e = this.namespace.chains[0];\n    if (!e) throw new Error(\"ChainId not found\");\n    return e.split(\":\")[1];\n  }\n  getAccounts() {\n    const e = this.namespace.accounts;\n    return e ? [...new Set(e.filter(t => t.split(\":\")[1] === this.chainId.toString()).map(t => t.split(\":\")[2]))] : [];\n  }\n  createHttpProviders() {\n    const e = {};\n    return this.namespace.chains.forEach(t => {\n      var i;\n      const s = y(t);\n      e[s] = this.createHttpProvider(s, (i = this.namespace.rpcMap) == null ? void 0 : i[t]);\n    }), e;\n  }\n  getHttpProvider() {\n    const e = `${this.name}:${this.chainId}`,\n      t = this.httpProviders[e];\n    if (typeof t > \"u\") throw new Error(`JSON-RPC provider for ${e} not found`);\n    return t;\n  }\n  setHttpProvider(e, t) {\n    const i = this.createHttpProvider(e, t);\n    i && (this.httpProviders[e] = i);\n  }\n  createHttpProvider(e, t) {\n    const i = t || v(e, this.namespace, this.client.core.projectId);\n    if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);\n    return new m(new b(i, h(\"disableProviderPing\")));\n  }\n}\nvar Jc = Object.defineProperty,\n  Kc = (r, e, t) => e in r ? Jc(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  R = (r, e, t) => Kc(r, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass Wc {\n  constructor(e) {\n    R(this, \"name\", \"near\"), R(this, \"client\"), R(this, \"httpProviders\"), R(this, \"events\"), R(this, \"namespace\"), R(this, \"chainId\"), this.namespace = e.namespace, this.events = h(\"events\"), this.client = h(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(e) {\n    this.namespace = Object.assign(this.namespace, e);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const e = this.namespace.chains[0];\n    if (!e) throw new Error(\"ChainId not found\");\n    return e.split(\":\")[1];\n  }\n  request(e) {\n    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);\n  }\n  setDefaultChain(e, t) {\n    if (this.chainId = e, !this.httpProviders[e]) {\n      const i = t || v(`${this.name}:${e}`, this.namespace);\n      if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);\n      this.setHttpProvider(e, i);\n    }\n    this.events.emit(f.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n  getAccounts() {\n    const e = this.namespace.accounts;\n    return e ? e.filter(t => t.split(\":\")[1] === this.chainId.toString()).map(t => t.split(\":\")[2]) || [] : [];\n  }\n  createHttpProviders() {\n    const e = {};\n    return this.namespace.chains.forEach(t => {\n      var i;\n      e[t] = this.createHttpProvider(t, (i = this.namespace.rpcMap) == null ? void 0 : i[t]);\n    }), e;\n  }\n  getHttpProvider() {\n    const e = `${this.name}:${this.chainId}`,\n      t = this.httpProviders[e];\n    if (typeof t > \"u\") throw new Error(`JSON-RPC provider for ${e} not found`);\n    return t;\n  }\n  setHttpProvider(e, t) {\n    const i = this.createHttpProvider(e, t);\n    i && (this.httpProviders[e] = i);\n  }\n  createHttpProvider(e, t) {\n    const i = t || v(e, this.namespace);\n    return typeof i > \"u\" ? void 0 : new m(new b(i, h(\"disableProviderPing\")));\n  }\n}\nvar Xc = Object.defineProperty,\n  Yc = (r, e, t) => e in r ? Xc(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  x = (r, e, t) => Yc(r, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass Zc {\n  constructor(e) {\n    x(this, \"name\", \"tezos\"), x(this, \"client\"), x(this, \"httpProviders\"), x(this, \"events\"), x(this, \"namespace\"), x(this, \"chainId\"), this.namespace = e.namespace, this.events = h(\"events\"), this.client = h(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(e) {\n    this.namespace = Object.assign(this.namespace, e);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const e = this.namespace.chains[0];\n    if (!e) throw new Error(\"ChainId not found\");\n    return e.split(\":\")[1];\n  }\n  request(e) {\n    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);\n  }\n  setDefaultChain(e, t) {\n    if (this.chainId = e, !this.httpProviders[e]) {\n      const i = t || v(`${this.name}:${e}`, this.namespace);\n      if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);\n      this.setHttpProvider(e, i);\n    }\n    this.events.emit(f.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n  getAccounts() {\n    const e = this.namespace.accounts;\n    return e ? e.filter(t => t.split(\":\")[1] === this.chainId.toString()).map(t => t.split(\":\")[2]) || [] : [];\n  }\n  createHttpProviders() {\n    const e = {};\n    return this.namespace.chains.forEach(t => {\n      e[t] = this.createHttpProvider(t);\n    }), e;\n  }\n  getHttpProvider() {\n    const e = `${this.name}:${this.chainId}`,\n      t = this.httpProviders[e];\n    if (typeof t > \"u\") throw new Error(`JSON-RPC provider for ${e} not found`);\n    return t;\n  }\n  setHttpProvider(e, t) {\n    const i = this.createHttpProvider(e, t);\n    i && (this.httpProviders[e] = i);\n  }\n  createHttpProvider(e, t) {\n    const i = t || v(e, this.namespace);\n    return typeof i > \"u\" ? void 0 : new m(new b(i));\n  }\n}\nvar Qc = Object.defineProperty,\n  eh = (r, e, t) => e in r ? Qc(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  L = (r, e, t) => eh(r, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass th {\n  constructor(e) {\n    L(this, \"name\", w), L(this, \"client\"), L(this, \"httpProviders\"), L(this, \"events\"), L(this, \"namespace\"), L(this, \"chainId\"), this.namespace = e.namespace, this.events = h(\"events\"), this.client = h(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(e) {\n    this.namespace.chains = [...new Set((this.namespace.chains || []).concat(e.chains || []))], this.namespace.accounts = [...new Set((this.namespace.accounts || []).concat(e.accounts || []))], this.namespace.methods = [...new Set((this.namespace.methods || []).concat(e.methods || []))], this.namespace.events = [...new Set((this.namespace.events || []).concat(e.events || []))], this.httpProviders = this.createHttpProviders();\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  request(e) {\n    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider(e.chainId).request(e.request);\n  }\n  setDefaultChain(e, t) {\n    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(f.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const e = this.namespace.chains[0];\n    if (!e) throw new Error(\"ChainId not found\");\n    return e.split(\":\")[1];\n  }\n  getAccounts() {\n    const e = this.namespace.accounts;\n    return e ? [...new Set(e.filter(t => t.split(\":\")[1] === this.chainId.toString()).map(t => t.split(\":\")[2]))] : [];\n  }\n  createHttpProviders() {\n    var e, t;\n    const i = {};\n    return (t = (e = this.namespace) == null ? void 0 : e.accounts) == null || t.forEach(s => {\n      const n = me(s);\n      i[`${n.namespace}:${n.reference}`] = this.createHttpProvider(s);\n    }), i;\n  }\n  getHttpProvider(e) {\n    const t = this.httpProviders[e];\n    if (typeof t > \"u\") throw new Error(`JSON-RPC provider for ${e} not found`);\n    return t;\n  }\n  setHttpProvider(e, t) {\n    const i = this.createHttpProvider(e, t);\n    i && (this.httpProviders[e] = i);\n  }\n  createHttpProvider(e, t) {\n    const i = t || v(e, this.namespace, this.client.core.projectId);\n    if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);\n    return new m(new b(i, h(\"disableProviderPing\")));\n  }\n}\nvar rh = Object.defineProperty,\n  ih = Object.defineProperties,\n  sh = Object.getOwnPropertyDescriptors,\n  vt = Object.getOwnPropertySymbols,\n  nh = Object.prototype.hasOwnProperty,\n  ah = Object.prototype.propertyIsEnumerable,\n  le = (r, e, t) => e in r ? rh(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  Y = (r, e) => {\n    for (var t in e || (e = {})) nh.call(e, t) && le(r, t, e[t]);\n    if (vt) for (var t of vt(e)) ah.call(e, t) && le(r, t, e[t]);\n    return r;\n  },\n  de = (r, e) => ih(r, sh(e)),\n  g = (r, e, t) => le(r, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass Z {\n  constructor(e) {\n    g(this, \"client\"), g(this, \"namespaces\"), g(this, \"optionalNamespaces\"), g(this, \"sessionProperties\"), g(this, \"events\", new wt()), g(this, \"rpcProviders\", {}), g(this, \"session\"), g(this, \"providerOpts\"), g(this, \"logger\"), g(this, \"uri\"), g(this, \"disableProviderPing\", !1), this.providerOpts = e, this.logger = typeof e?.logger < \"u\" && typeof e?.logger != \"string\" ? e.logger : gt(Pt({\n      level: e?.logger || be\n    })), this.disableProviderPing = e?.disableProviderPing || !1;\n  }\n  static async init(e) {\n    const t = new Z(e);\n    return await t.initialize(), t;\n  }\n  async request(e, t, i) {\n    const [s, n] = this.validateChain(t);\n    if (!this.session) throw new Error(\"Please call connect() before request()\");\n    return await this.getProvider(s).request({\n      request: Y({}, e),\n      chainId: `${s}:${n}`,\n      topic: this.session.topic,\n      expiry: i\n    });\n  }\n  sendAsync(e, t, i, s) {\n    const n = new Date().getTime();\n    this.request(e, i, s).then(a => t(null, yt(n, a))).catch(a => t(a, void 0));\n  }\n  async enable() {\n    if (!this.client) throw new Error(\"Sign Client not initialized\");\n    return this.session || (await this.connect({\n      namespaces: this.namespaces,\n      optionalNamespaces: this.optionalNamespaces,\n      sessionProperties: this.sessionProperties\n    })), await this.requestAccounts();\n  }\n  async disconnect() {\n    var e;\n    if (!this.session) throw new Error(\"Please call connect() before enable()\");\n    await this.client.disconnect({\n      topic: (e = this.session) == null ? void 0 : e.topic,\n      reason: ge(\"USER_DISCONNECTED\")\n    }), await this.cleanup();\n  }\n  async connect(e) {\n    if (!this.client) throw new Error(\"Sign Client not initialized\");\n    if (this.setNamespaces(e), await this.cleanupPendingPairings(), !e.skipPairing) return await this.pair(e.pairingTopic);\n  }\n  async authenticate(e, t) {\n    if (!this.client) throw new Error(\"Sign Client not initialized\");\n    this.setNamespaces(e), await this.cleanupPendingPairings();\n    const {\n      uri: i,\n      response: s\n    } = await this.client.authenticate(e, t);\n    i && (this.uri = i, this.events.emit(\"display_uri\", i));\n    const n = await s();\n    if (this.session = n.session, this.session) {\n      const a = ht(this.session.namespaces);\n      this.namespaces = ce(this.namespaces, a), this.persist(\"namespaces\", this.namespaces), this.onConnect();\n    }\n    return n;\n  }\n  on(e, t) {\n    this.events.on(e, t);\n  }\n  once(e, t) {\n    this.events.once(e, t);\n  }\n  removeListener(e, t) {\n    this.events.removeListener(e, t);\n  }\n  off(e, t) {\n    this.events.off(e, t);\n  }\n  get isWalletConnect() {\n    return !0;\n  }\n  async pair(e) {\n    const {\n      uri: t,\n      approval: i\n    } = await this.client.connect({\n      pairingTopic: e,\n      requiredNamespaces: this.namespaces,\n      optionalNamespaces: this.optionalNamespaces,\n      sessionProperties: this.sessionProperties\n    });\n    t && (this.uri = t, this.events.emit(\"display_uri\", t));\n    const s = await i();\n    this.session = s;\n    const n = ht(s.namespaces);\n    return this.namespaces = ce(this.namespaces, n), this.persist(\"namespaces\", this.namespaces), this.onConnect(), this.session;\n  }\n  setDefaultChain(e, t) {\n    try {\n      if (!this.session) return;\n      const [i, s] = this.validateChain(e),\n        n = this.getProvider(i);\n      n.name === w ? n.setDefaultChain(`${i}:${s}`, t) : n.setDefaultChain(s, t);\n    } catch (i) {\n      if (!/Please call connect/.test(i.message)) throw i;\n    }\n  }\n  async cleanupPendingPairings(e = {}) {\n    this.logger.info(\"Cleaning up inactive pairings...\");\n    const t = this.client.pairing.getAll();\n    if (Pe(t)) {\n      for (const i of t) e.deletePairings ? this.client.core.expirer.set(i.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(i.topic);\n      this.logger.info(`Inactive pairings cleared: ${t.length}`);\n    }\n  }\n  abortPairingAttempt() {\n    this.logger.warn(\"abortPairingAttempt is deprecated. This is now a no-op.\");\n  }\n  async checkStorage() {\n    if (this.namespaces = await this.getFromStore(\"namespaces\"), this.optionalNamespaces = (await this.getFromStore(\"optionalNamespaces\")) || {}, this.client.session.length) {\n      const e = this.client.session.keys.length - 1;\n      this.session = this.client.session.get(this.client.session.keys[e]), this.createProviders();\n    }\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();\n  }\n  async createClient() {\n    this.client = this.providerOpts.client || (await ft.init({\n      core: this.providerOpts.core,\n      logger: this.providerOpts.logger || be,\n      relayUrl: this.providerOpts.relayUrl || _t,\n      projectId: this.providerOpts.projectId,\n      metadata: this.providerOpts.metadata,\n      storageOptions: this.providerOpts.storageOptions,\n      storage: this.providerOpts.storage,\n      name: this.providerOpts.name,\n      customStoragePrefix: this.providerOpts.customStoragePrefix,\n      telemetryEnabled: this.providerOpts.telemetryEnabled\n    })), this.logger.trace(\"SignClient Initialized\");\n  }\n  createProviders() {\n    if (!this.client) throw new Error(\"Sign Client not initialized\");\n    if (!this.session) throw new Error(\"Session not initialized. Please call connect() before enable()\");\n    const e = [...new Set(Object.keys(this.session.namespaces).map(t => U(t)))];\n    pe(\"client\", this.client), pe(\"events\", this.events), pe(\"disableProviderPing\", this.disableProviderPing), e.forEach(t => {\n      if (!this.session) return;\n      const i = Pc(t, this.session),\n        s = ot(i),\n        n = ce(this.namespaces, this.optionalNamespaces),\n        a = de(Y({}, n[t]), {\n          accounts: i,\n          chains: s\n        });\n      switch (t) {\n        case \"eip155\":\n          this.rpcProviders[t] = new jc({\n            namespace: a\n          });\n          break;\n        case \"algorand\":\n          this.rpcProviders[t] = new xc({\n            namespace: a\n          });\n          break;\n        case \"solana\":\n          this.rpcProviders[t] = new Sc({\n            namespace: a\n          });\n          break;\n        case \"cosmos\":\n          this.rpcProviders[t] = new Dc({\n            namespace: a\n          });\n          break;\n        case \"polkadot\":\n          this.rpcProviders[t] = new wc({\n            namespace: a\n          });\n          break;\n        case \"cip34\":\n          this.rpcProviders[t] = new Fc({\n            namespace: a\n          });\n          break;\n        case \"elrond\":\n          this.rpcProviders[t] = new zc({\n            namespace: a\n          });\n          break;\n        case \"multiversx\":\n          this.rpcProviders[t] = new Vc({\n            namespace: a\n          });\n          break;\n        case \"near\":\n          this.rpcProviders[t] = new Wc({\n            namespace: a\n          });\n          break;\n        case \"tezos\":\n          this.rpcProviders[t] = new Zc({\n            namespace: a\n          });\n          break;\n        default:\n          this.rpcProviders[w] ? this.rpcProviders[w].updateNamespace(a) : this.rpcProviders[w] = new th({\n            namespace: a\n          });\n      }\n    });\n  }\n  registerEventListeners() {\n    if (typeof this.client > \"u\") throw new Error(\"Sign Client is not initialized\");\n    this.client.on(\"session_ping\", e => {\n      this.events.emit(\"session_ping\", e);\n    }), this.client.on(\"session_event\", e => {\n      const {\n          params: t\n        } = e,\n        {\n          event: i\n        } = t;\n      if (i.name === \"accountsChanged\") {\n        const s = i.data;\n        s && Pe(s) && this.events.emit(\"accountsChanged\", s.map(bc));\n      } else if (i.name === \"chainChanged\") {\n        const s = t.chainId,\n          n = t.event.data,\n          a = U(s),\n          o = he(s) !== he(n) ? `${a}:${he(n)}` : s;\n        this.onChainChanged(o);\n      } else this.events.emit(i.name, i.data);\n      this.events.emit(\"session_event\", e);\n    }), this.client.on(\"session_update\", ({\n      topic: e,\n      params: t\n    }) => {\n      var i;\n      const {\n          namespaces: s\n        } = t,\n        n = (i = this.client) == null ? void 0 : i.session.get(e);\n      this.session = de(Y({}, n), {\n        namespaces: s\n      }), this.onSessionUpdate(), this.events.emit(\"session_update\", {\n        topic: e,\n        params: t\n      });\n    }), this.client.on(\"session_delete\", async e => {\n      await this.cleanup(), this.events.emit(\"session_delete\", e), this.events.emit(\"disconnect\", de(Y({}, ge(\"USER_DISCONNECTED\")), {\n        data: e.topic\n      }));\n    }), this.on(f.DEFAULT_CHAIN_CHANGED, e => {\n      this.onChainChanged(e, !0);\n    });\n  }\n  getProvider(e) {\n    return this.rpcProviders[e] || this.rpcProviders[w];\n  }\n  onSessionUpdate() {\n    Object.keys(this.rpcProviders).forEach(e => {\n      var t;\n      this.getProvider(e).updateNamespace((t = this.session) == null ? void 0 : t.namespaces[e]);\n    });\n  }\n  setNamespaces(e) {\n    const {\n      namespaces: t,\n      optionalNamespaces: i,\n      sessionProperties: s\n    } = e;\n    t && Object.keys(t).length && (this.namespaces = t), i && Object.keys(i).length && (this.optionalNamespaces = i), this.sessionProperties = s, this.persist(\"namespaces\", t), this.persist(\"optionalNamespaces\", i);\n  }\n  validateChain(e) {\n    const [t, i] = e?.split(\":\") || [\"\", \"\"];\n    if (!this.namespaces || !Object.keys(this.namespaces).length) return [t, i];\n    if (t && !Object.keys(this.namespaces || {}).map(a => U(a)).includes(t)) throw new Error(`Namespace '${t}' is not configured. Please call connect() first with namespace config.`);\n    if (t && i) return [t, i];\n    const s = U(Object.keys(this.namespaces)[0]),\n      n = this.rpcProviders[s].getDefaultChain();\n    return [s, n];\n  }\n  async requestAccounts() {\n    const [e] = this.validateChain();\n    return await this.getProvider(e).requestAccounts();\n  }\n  onChainChanged(e, t = !1) {\n    if (!this.namespaces) return;\n    const [i, s] = this.validateChain(e);\n    s && (t || this.getProvider(i).setDefaultChain(s), this.namespaces[i] ? this.namespaces[i].defaultChain = s : this.namespaces[`${i}:${s}`] ? this.namespaces[`${i}:${s}`].defaultChain = s : this.namespaces[`${i}:${s}`] = {\n      defaultChain: s\n    }, this.persist(\"namespaces\", this.namespaces), this.events.emit(\"chainChanged\", s));\n  }\n  onConnect() {\n    this.createProviders(), this.events.emit(\"connect\", {\n      session: this.session\n    });\n  }\n  async cleanup() {\n    this.session = void 0, this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, this.persist(\"namespaces\", void 0), this.persist(\"optionalNamespaces\", void 0), this.persist(\"sessionProperties\", void 0), await this.cleanupPendingPairings({\n      deletePairings: !0\n    });\n  }\n  persist(e, t) {\n    this.client.core.storage.setItem(`${$e}/${e}`, t);\n  }\n  async getFromStore(e) {\n    return await this.client.core.storage.getItem(`${$e}/${e}`);\n  }\n}\nconst oh = Z;\nexport { oh as UniversalProvider, Z as default };","map":{"version":3,"names":[],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\universal-provider\\src\\constants\\values.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\universal-provider\\src\\constants\\events.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_listCacheClear.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\eq.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_assocIndexOf.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_listCacheDelete.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_listCacheGet.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_listCacheHas.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_listCacheSet.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_ListCache.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_stackClear.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_stackDelete.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_stackGet.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_stackHas.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_freeGlobal.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_root.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_Symbol.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_getRawTag.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_objectToString.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_baseGetTag.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\isObject.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\isFunction.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_coreJsData.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_isMasked.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_toSource.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_baseIsNative.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_getValue.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_getNative.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_Map.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_nativeCreate.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_hashClear.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_hashDelete.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_hashGet.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_hashHas.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_hashSet.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_Hash.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_mapCacheClear.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_isKeyable.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_getMapData.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_mapCacheDelete.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_mapCacheGet.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_mapCacheHas.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_mapCacheSet.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_MapCache.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_stackSet.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_Stack.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_defineProperty.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_baseAssignValue.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_assignMergeValue.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_createBaseFor.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_baseFor.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_cloneBuffer.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_Uint8Array.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_cloneArrayBuffer.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_cloneTypedArray.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_copyArray.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_baseCreate.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_overArg.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_getPrototype.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_isPrototype.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_initCloneObject.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\isObjectLike.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_baseIsArguments.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\isArguments.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\isArray.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\isLength.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\isArrayLike.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\isArrayLikeObject.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\stubFalse.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\isBuffer.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\isPlainObject.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_baseIsTypedArray.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_baseUnary.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_nodeUtil.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\isTypedArray.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_safeGet.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_assignValue.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_copyObject.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_baseTimes.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_isIndex.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_arrayLikeKeys.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_nativeKeysIn.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_baseKeysIn.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\keysIn.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\toPlainObject.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_baseMergeDeep.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_baseMerge.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\identity.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_apply.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_overRest.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\constant.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_baseSetToString.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_shortOut.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_setToString.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_baseRest.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_isIterateeCall.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\_createAssigner.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\lodash\\merge.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\universal-provider\\src\\utils\\misc.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\universal-provider\\src\\utils\\globals.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\universal-provider\\src\\providers\\polkadot.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\universal-provider\\src\\providers\\eip155.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\universal-provider\\src\\providers\\solana.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\universal-provider\\src\\providers\\cosmos.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\universal-provider\\src\\providers\\algorand.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\universal-provider\\src\\providers\\cardano.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\universal-provider\\src\\providers\\elrond.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\universal-provider\\src\\providers\\multiversx.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\universal-provider\\src\\providers\\near.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\universal-provider\\src\\providers\\tezos.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\universal-provider\\src\\providers\\generic.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\universal-provider\\src\\UniversalProvider.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\universal-provider\\src\\index.ts"],"sourcesContent":["export const LOGGER = \"error\";\n\nexport const RELAY_URL = \"wss://relay.walletconnect.org\";\n\nexport const PROTOCOL = \"wc\";\nexport const WC_VERSION = 2;\nexport const CONTEXT = \"universal_provider\";\n\nexport const STORAGE = `${PROTOCOL}@${WC_VERSION}:${CONTEXT}:`;\n\nexport const RPC_URL = \"https://rpc.walletconnect.org/v1/\";\n\nexport const GENERIC_SUBPROVIDER_NAME = \"generic\";\n\nexport const BUNDLER_URL = `${RPC_URL}bundler`;\n","export const PROVIDER_EVENTS = {\n  DEFAULT_CHAIN_CHANGED: \"default_chain_changed\",\n};\n","/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nmodule.exports = listCacheClear;\n","/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nmodule.exports = eq;\n","var eq = require('./eq');\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = assocIndexOf;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nmodule.exports = listCacheDelete;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nmodule.exports = listCacheGet;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nmodule.exports = listCacheHas;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nmodule.exports = listCacheSet;\n","var listCacheClear = require('./_listCacheClear'),\n    listCacheDelete = require('./_listCacheDelete'),\n    listCacheGet = require('./_listCacheGet'),\n    listCacheHas = require('./_listCacheHas'),\n    listCacheSet = require('./_listCacheSet');\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nmodule.exports = ListCache;\n","var ListCache = require('./_ListCache');\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\nmodule.exports = stackClear;\n","/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\nmodule.exports = stackDelete;\n","/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\nmodule.exports = stackGet;\n","/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\nmodule.exports = stackHas;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n","var baseGetTag = require('./_baseGetTag'),\n    isObject = require('./isObject');\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n","var root = require('./_root');\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n","var coreJsData = require('./_coreJsData');\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n","/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n","var isFunction = require('./isFunction'),\n    isMasked = require('./_isMasked'),\n    isObject = require('./isObject'),\n    toSource = require('./_toSource');\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n","/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n","var baseIsNative = require('./_baseIsNative'),\n    getValue = require('./_getValue');\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nmodule.exports = Map;\n","var getNative = require('./_getNative');\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nmodule.exports = nativeCreate;\n","var nativeCreate = require('./_nativeCreate');\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nmodule.exports = hashClear;\n","/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = hashDelete;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nmodule.exports = hashGet;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nmodule.exports = hashHas;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nmodule.exports = hashSet;\n","var hashClear = require('./_hashClear'),\n    hashDelete = require('./_hashDelete'),\n    hashGet = require('./_hashGet'),\n    hashHas = require('./_hashHas'),\n    hashSet = require('./_hashSet');\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nmodule.exports = Hash;\n","var Hash = require('./_Hash'),\n    ListCache = require('./_ListCache'),\n    Map = require('./_Map');\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nmodule.exports = mapCacheClear;\n","/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nmodule.exports = isKeyable;\n","var isKeyable = require('./_isKeyable');\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nmodule.exports = getMapData;\n","var getMapData = require('./_getMapData');\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = mapCacheDelete;\n","var getMapData = require('./_getMapData');\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nmodule.exports = mapCacheGet;\n","var getMapData = require('./_getMapData');\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nmodule.exports = mapCacheHas;\n","var getMapData = require('./_getMapData');\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nmodule.exports = mapCacheSet;\n","var mapCacheClear = require('./_mapCacheClear'),\n    mapCacheDelete = require('./_mapCacheDelete'),\n    mapCacheGet = require('./_mapCacheGet'),\n    mapCacheHas = require('./_mapCacheHas'),\n    mapCacheSet = require('./_mapCacheSet');\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nmodule.exports = MapCache;\n","var ListCache = require('./_ListCache'),\n    Map = require('./_Map'),\n    MapCache = require('./_MapCache');\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\nmodule.exports = stackSet;\n","var ListCache = require('./_ListCache'),\n    stackClear = require('./_stackClear'),\n    stackDelete = require('./_stackDelete'),\n    stackGet = require('./_stackGet'),\n    stackHas = require('./_stackHas'),\n    stackSet = require('./_stackSet');\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\nmodule.exports = Stack;\n","var getNative = require('./_getNative');\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\nmodule.exports = defineProperty;\n","var defineProperty = require('./_defineProperty');\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && defineProperty) {\n    defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\nmodule.exports = baseAssignValue;\n","var baseAssignValue = require('./_baseAssignValue'),\n    eq = require('./eq');\n\n/**\n * This function is like `assignValue` except that it doesn't assign\n * `undefined` values.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignMergeValue(object, key, value) {\n  if ((value !== undefined && !eq(object[key], value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nmodule.exports = assignMergeValue;\n","/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\nmodule.exports = createBaseFor;\n","var createBaseFor = require('./_createBaseFor');\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\nmodule.exports = baseFor;\n","var root = require('./_root');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var length = buffer.length,\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n  buffer.copy(result);\n  return result;\n}\n\nmodule.exports = cloneBuffer;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Uint8Array = root.Uint8Array;\n\nmodule.exports = Uint8Array;\n","var Uint8Array = require('./_Uint8Array');\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\nmodule.exports = cloneArrayBuffer;\n","var cloneArrayBuffer = require('./_cloneArrayBuffer');\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\nmodule.exports = cloneTypedArray;\n","/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\nmodule.exports = copyArray;\n","var isObject = require('./isObject');\n\n/** Built-in value references. */\nvar objectCreate = Object.create;\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function() {\n  function object() {}\n  return function(proto) {\n    if (!isObject(proto)) {\n      return {};\n    }\n    if (objectCreate) {\n      return objectCreate(proto);\n    }\n    object.prototype = proto;\n    var result = new object;\n    object.prototype = undefined;\n    return result;\n  };\n}());\n\nmodule.exports = baseCreate;\n","/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n","var overArg = require('./_overArg');\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nmodule.exports = getPrototype;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\nmodule.exports = isPrototype;\n","var baseCreate = require('./_baseCreate'),\n    getPrototype = require('./_getPrototype'),\n    isPrototype = require('./_isPrototype');\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\nmodule.exports = initCloneObject;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nmodule.exports = baseIsArguments;\n","var baseIsArguments = require('./_baseIsArguments'),\n    isObjectLike = require('./isObjectLike');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nmodule.exports = isArguments;\n","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n","var isFunction = require('./isFunction'),\n    isLength = require('./isLength');\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n","var isArrayLike = require('./isArrayLike'),\n    isObjectLike = require('./isObjectLike');\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\nmodule.exports = isArrayLikeObject;\n","/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = stubFalse;\n","var root = require('./_root'),\n    stubFalse = require('./stubFalse');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\nmodule.exports = isBuffer;\n","var baseGetTag = require('./_baseGetTag'),\n    getPrototype = require('./_getPrototype'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\nmodule.exports = isPlainObject;\n","var baseGetTag = require('./_baseGetTag'),\n    isLength = require('./isLength'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nmodule.exports = baseIsTypedArray;\n","/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nmodule.exports = baseUnary;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nmodule.exports = nodeUtil;\n","var baseIsTypedArray = require('./_baseIsTypedArray'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\nmodule.exports = isTypedArray;\n","/**\n * Gets the value at `key`, unless `key` is \"__proto__\" or \"constructor\".\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction safeGet(object, key) {\n  if (key === 'constructor' && typeof object[key] === 'function') {\n    return;\n  }\n\n  if (key == '__proto__') {\n    return;\n  }\n\n  return object[key];\n}\n\nmodule.exports = safeGet;\n","var baseAssignValue = require('./_baseAssignValue'),\n    eq = require('./eq');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nmodule.exports = assignValue;\n","var assignValue = require('./_assignValue'),\n    baseAssignValue = require('./_baseAssignValue');\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    if (newValue === undefined) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      baseAssignValue(object, key, newValue);\n    } else {\n      assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}\n\nmodule.exports = copyObject;\n","/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nmodule.exports = baseTimes;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n","var baseTimes = require('./_baseTimes'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isIndex = require('./_isIndex'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayLikeKeys;\n","/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = nativeKeysIn;\n","var isObject = require('./isObject'),\n    isPrototype = require('./_isPrototype'),\n    nativeKeysIn = require('./_nativeKeysIn');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeysIn;\n","var arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeysIn = require('./_baseKeysIn'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\nmodule.exports = keysIn;\n","var copyObject = require('./_copyObject'),\n    keysIn = require('./keysIn');\n\n/**\n * Converts `value` to a plain object flattening inherited enumerable string\n * keyed properties of `value` to own properties of the plain object.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {Object} Returns the converted plain object.\n * @example\n *\n * function Foo() {\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.assign({ 'a': 1 }, new Foo);\n * // => { 'a': 1, 'b': 2 }\n *\n * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n * // => { 'a': 1, 'b': 2, 'c': 3 }\n */\nfunction toPlainObject(value) {\n  return copyObject(value, keysIn(value));\n}\n\nmodule.exports = toPlainObject;\n","var assignMergeValue = require('./_assignMergeValue'),\n    cloneBuffer = require('./_cloneBuffer'),\n    cloneTypedArray = require('./_cloneTypedArray'),\n    copyArray = require('./_copyArray'),\n    initCloneObject = require('./_initCloneObject'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isArrayLikeObject = require('./isArrayLikeObject'),\n    isBuffer = require('./isBuffer'),\n    isFunction = require('./isFunction'),\n    isObject = require('./isObject'),\n    isPlainObject = require('./isPlainObject'),\n    isTypedArray = require('./isTypedArray'),\n    safeGet = require('./_safeGet'),\n    toPlainObject = require('./toPlainObject');\n\n/**\n * A specialized version of `baseMerge` for arrays and objects which performs\n * deep merges and tracks traversed objects enabling objects with circular\n * references to be merged.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {string} key The key of the value to merge.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} mergeFunc The function to merge values.\n * @param {Function} [customizer] The function to customize assigned values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */\nfunction baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n  var objValue = safeGet(object, key),\n      srcValue = safeGet(source, key),\n      stacked = stack.get(srcValue);\n\n  if (stacked) {\n    assignMergeValue(object, key, stacked);\n    return;\n  }\n  var newValue = customizer\n    ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n    : undefined;\n\n  var isCommon = newValue === undefined;\n\n  if (isCommon) {\n    var isArr = isArray(srcValue),\n        isBuff = !isArr && isBuffer(srcValue),\n        isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n\n    newValue = srcValue;\n    if (isArr || isBuff || isTyped) {\n      if (isArray(objValue)) {\n        newValue = objValue;\n      }\n      else if (isArrayLikeObject(objValue)) {\n        newValue = copyArray(objValue);\n      }\n      else if (isBuff) {\n        isCommon = false;\n        newValue = cloneBuffer(srcValue, true);\n      }\n      else if (isTyped) {\n        isCommon = false;\n        newValue = cloneTypedArray(srcValue, true);\n      }\n      else {\n        newValue = [];\n      }\n    }\n    else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n      newValue = objValue;\n      if (isArguments(objValue)) {\n        newValue = toPlainObject(objValue);\n      }\n      else if (!isObject(objValue) || isFunction(objValue)) {\n        newValue = initCloneObject(srcValue);\n      }\n    }\n    else {\n      isCommon = false;\n    }\n  }\n  if (isCommon) {\n    // Recursively merge objects and arrays (susceptible to call stack limits).\n    stack.set(srcValue, newValue);\n    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n    stack['delete'](srcValue);\n  }\n  assignMergeValue(object, key, newValue);\n}\n\nmodule.exports = baseMergeDeep;\n","var Stack = require('./_Stack'),\n    assignMergeValue = require('./_assignMergeValue'),\n    baseFor = require('./_baseFor'),\n    baseMergeDeep = require('./_baseMergeDeep'),\n    isObject = require('./isObject'),\n    keysIn = require('./keysIn'),\n    safeGet = require('./_safeGet');\n\n/**\n * The base implementation of `_.merge` without support for multiple sources.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} [customizer] The function to customize merged values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */\nfunction baseMerge(object, source, srcIndex, customizer, stack) {\n  if (object === source) {\n    return;\n  }\n  baseFor(source, function(srcValue, key) {\n    stack || (stack = new Stack);\n    if (isObject(srcValue)) {\n      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n    }\n    else {\n      var newValue = customizer\n        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)\n        : undefined;\n\n      if (newValue === undefined) {\n        newValue = srcValue;\n      }\n      assignMergeValue(object, key, newValue);\n    }\n  }, keysIn);\n}\n\nmodule.exports = baseMerge;\n","/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n","/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\nmodule.exports = apply;\n","var apply = require('./_apply');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */\nfunction overRest(func, start, transform) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = transform(array);\n    return apply(func, this, otherArgs);\n  };\n}\n\nmodule.exports = overRest;\n","/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\nmodule.exports = constant;\n","var constant = require('./constant'),\n    defineProperty = require('./_defineProperty'),\n    identity = require('./identity');\n\n/**\n * The base implementation of `setToString` without support for hot loop shorting.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar baseSetToString = !defineProperty ? identity : function(func, string) {\n  return defineProperty(func, 'toString', {\n    'configurable': true,\n    'enumerable': false,\n    'value': constant(string),\n    'writable': true\n  });\n};\n\nmodule.exports = baseSetToString;\n","/** Used to detect hot functions by number of calls within a span of milliseconds. */\nvar HOT_COUNT = 800,\n    HOT_SPAN = 16;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeNow = Date.now;\n\n/**\n * Creates a function that'll short out and invoke `identity` instead\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n * milliseconds.\n *\n * @private\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new shortable function.\n */\nfunction shortOut(func) {\n  var count = 0,\n      lastCalled = 0;\n\n  return function() {\n    var stamp = nativeNow(),\n        remaining = HOT_SPAN - (stamp - lastCalled);\n\n    lastCalled = stamp;\n    if (remaining > 0) {\n      if (++count >= HOT_COUNT) {\n        return arguments[0];\n      }\n    } else {\n      count = 0;\n    }\n    return func.apply(undefined, arguments);\n  };\n}\n\nmodule.exports = shortOut;\n","var baseSetToString = require('./_baseSetToString'),\n    shortOut = require('./_shortOut');\n\n/**\n * Sets the `toString` method of `func` to return `string`.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar setToString = shortOut(baseSetToString);\n\nmodule.exports = setToString;\n","var identity = require('./identity'),\n    overRest = require('./_overRest'),\n    setToString = require('./_setToString');\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  return setToString(overRest(func, start, identity), func + '');\n}\n\nmodule.exports = baseRest;\n","var eq = require('./eq'),\n    isArrayLike = require('./isArrayLike'),\n    isIndex = require('./_isIndex'),\n    isObject = require('./isObject');\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\nmodule.exports = isIterateeCall;\n","var baseRest = require('./_baseRest'),\n    isIterateeCall = require('./_isIterateeCall');\n\n/**\n * Creates a function like `_.assign`.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */\nfunction createAssigner(assigner) {\n  return baseRest(function(object, sources) {\n    var index = -1,\n        length = sources.length,\n        customizer = length > 1 ? sources[length - 1] : undefined,\n        guard = length > 2 ? sources[2] : undefined;\n\n    customizer = (assigner.length > 3 && typeof customizer == 'function')\n      ? (length--, customizer)\n      : undefined;\n\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      customizer = length < 3 ? undefined : customizer;\n      length = 1;\n    }\n    object = Object(object);\n    while (++index < length) {\n      var source = sources[index];\n      if (source) {\n        assigner(object, source, index, customizer);\n      }\n    }\n    return object;\n  });\n}\n\nmodule.exports = createAssigner;\n","var baseMerge = require('./_baseMerge'),\n    createAssigner = require('./_createAssigner');\n\n/**\n * This method is like `_.assign` except that it recursively merges own and\n * inherited enumerable string keyed properties of source objects into the\n * destination object. Source properties that resolve to `undefined` are\n * skipped if a destination value exists. Array and plain object properties\n * are merged recursively. Other objects and value types are overridden by\n * assignment. Source objects are applied from left to right. Subsequent\n * sources overwrite property assignments of previous sources.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 0.5.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @example\n *\n * var object = {\n *   'a': [{ 'b': 2 }, { 'd': 4 }]\n * };\n *\n * var other = {\n *   'a': [{ 'c': 3 }, { 'e': 5 }]\n * };\n *\n * _.merge(object, other);\n * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n */\nvar merge = createAssigner(function(object, source, srcIndex) {\n  baseMerge(object, source, srcIndex);\n});\n\nmodule.exports = merge;\n","import { SessionTypes } from \"@walletconnect/types\";\nimport {\n  isCaipNamespace,\n  isValidObject,\n  mergeArrays,\n  parseChainId,\n  parseNamespaceKey,\n} from \"@walletconnect/utils\";\nimport { RPC_URL } from \"../constants\";\nimport { Namespace, NamespaceConfig } from \"../types\";\nimport merge from \"lodash/merge\";\n\nexport function getRpcUrl(chainId: string, rpc: Namespace, projectId?: string): string | undefined {\n  const chain = parseChainId(chainId);\n  return (\n    rpc.rpcMap?.[chain.reference] ||\n    `${RPC_URL}?chainId=${chain.namespace}:${chain.reference}&projectId=${projectId}`\n  );\n}\n\nexport function getChainId(chain: string): string {\n  return chain.includes(\":\") ? chain.split(\":\")[1] : chain;\n}\n\nexport function validateChainApproval(chain: string, chains: string[]): void {\n  if (!chains.includes(chain)) {\n    throw new Error(\n      `Chain '${chain}' not approved. Please use one of the following: ${chains.toString()}`,\n    );\n  }\n}\n\nexport function getChainsFromApprovedSession(accounts: string[]): string[] {\n  return accounts.map((address) => `${address.split(\":\")[0]}:${address.split(\":\")[1]}`);\n}\n\nexport function getAccountsFromSession(namespace: string, session: SessionTypes.Struct): string[] {\n  // match namespaces e.g. eip155 with eip155:1\n  const matchedNamespaceKeys = Object.keys(session.namespaces).filter((key) =>\n    key.includes(namespace),\n  );\n  if (!matchedNamespaceKeys.length) return [];\n  const accounts: string[] = [];\n  matchedNamespaceKeys.forEach((key) => {\n    const accountsForNamespace = session.namespaces[key].accounts;\n    accounts.push(...accountsForNamespace);\n  });\n  return accounts;\n}\n\nexport function mergeRequiredOptionalNamespaces(\n  required: NamespaceConfig = {},\n  optional: NamespaceConfig = {},\n) {\n  const requiredNamespaces = normalizeNamespaces(required);\n  const optionalNamespaces = normalizeNamespaces(optional);\n  return merge(requiredNamespaces, optionalNamespaces);\n}\n\n/**\n * Converts\n * {\n *  \"eip155:1\": {...},\n *  \"eip155:2\": {...},\n * }\n * into\n * {\n *  \"eip155\": {\n *      chains: [\"eip155:1\", \"eip155:2\"],\n *      ...\n *    }\n * }\n *\n */\nexport function normalizeNamespaces(namespaces: NamespaceConfig): NamespaceConfig {\n  const normalizedNamespaces: NamespaceConfig = {};\n  if (!isValidObject(namespaces)) return normalizedNamespaces;\n\n  for (const [key, values] of Object.entries(namespaces)) {\n    const chains = isCaipNamespace(key) ? [key] : values.chains;\n    const methods = values.methods || [];\n    const events = values.events || [];\n    const rpcMap = values.rpcMap || {};\n    const normalizedKey = parseNamespaceKey(key);\n    normalizedNamespaces[normalizedKey] = {\n      ...normalizedNamespaces[normalizedKey],\n      ...values,\n      chains: mergeArrays(chains, normalizedNamespaces[normalizedKey]?.chains),\n      methods: mergeArrays(methods, normalizedNamespaces[normalizedKey]?.methods),\n      events: mergeArrays(events, normalizedNamespaces[normalizedKey]?.events),\n      rpcMap: { ...rpcMap, ...normalizedNamespaces[normalizedKey]?.rpcMap },\n    };\n  }\n  return normalizedNamespaces;\n}\n\nexport function parseCaip10Account(caip10Account: string): string {\n  return caip10Account.includes(\":\") ? caip10Account.split(\":\")[2] : caip10Account;\n}\n\n/**\n * Populates the chains array for each namespace with the chains extracted from the accounts if are otherwise missing\n */\nexport function populateNamespacesChains(\n  namespaces: SessionTypes.Namespaces,\n): Record<string, SessionTypes.Namespace> {\n  const parsedNamespaces: Record<string, SessionTypes.Namespace> = {};\n  for (const [key, values] of Object.entries(namespaces)) {\n    const methods = values.methods || [];\n    const events = values.events || [];\n    const accounts = values.accounts || [];\n    // If the key includes a CAIP separator `:` we know it's a namespace + chainId (e.g. `eip155:1`)\n    const chains = isCaipNamespace(key)\n      ? [key]\n      : values.chains\n      ? values.chains\n      : getChainsFromApprovedSession(values.accounts);\n    parsedNamespaces[key] = {\n      chains,\n      methods,\n      events,\n      accounts,\n    };\n  }\n  return parsedNamespaces;\n}\n\nexport function convertChainIdToNumber(chainId: string | number): number | string {\n  if (typeof chainId === \"number\") return chainId;\n  if (chainId.includes(\"0x\")) {\n    return parseInt(chainId, 16);\n  }\n\n  chainId = chainId.includes(\":\") ? chainId.split(\":\")[1] : chainId;\n  return isNaN(Number(chainId)) ? chainId : Number(chainId);\n}\n","const globals = {};\nexport const getGlobal = (key: string) => {\n  return globals[key];\n};\n\nexport const setGlobal = (key: string, value: unknown) => {\n  globals[key] = value;\n};\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\n\nimport { getChainId, getGlobal, getRpcUrl } from \"../utils\";\n\nclass PolkadotProvider implements IProvider {\n  public name = \"polkadot\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      this.setHttpProvider(chainId, rpcUrl);\n    }\n    this.chainId = chainId;\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${chainId}`);\n  }\n\n  // ---------------- PRIVATE ---------------- //\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return (\n      accounts\n        // get the accounts from the active chain\n        .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n        // remove namespace & chainId from the string\n        .map((account) => account.split(\":\")[2]) || []\n    );\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      const parsedChainId = getChainId(chain);\n      http[parsedChainId] = this.createHttpProvider(parsedChainId, this.namespace.rpcMap?.[chain]);\n    });\n    return http;\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace, this.client.core.projectId);\n    if (!rpc) {\n      throw new Error(`No RPC url provided for chainId: ${chainId}`);\n    }\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n}\n\nexport default PolkadotProvider;\n","import Client from \"@walletconnect/sign-client\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport { HttpConnection } from \"@walletconnect/jsonrpc-http-connection\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\n\nimport {\n  IProvider,\n  RpcProvidersMap,\n  SubProviderOpts,\n  RequestParams,\n  SessionNamespace,\n} from \"../types\";\n\nimport { getChainId, getGlobal, getRpcUrl } from \"../utils\";\nimport EventEmitter from \"events\";\nimport { BUNDLER_URL, PROVIDER_EVENTS } from \"../constants\";\nimport { formatJsonRpcRequest } from \"@walletconnect/jsonrpc-utils\";\n\nclass Eip155Provider implements IProvider {\n  public name = \"eip155\";\n  public client: Client;\n  // the active chainId on the dapp\n  public chainId: number;\n  public namespace: SessionNamespace;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.httpProviders = this.createHttpProviders();\n    this.chainId = parseInt(this.getDefaultChain());\n  }\n\n  public async request<T = unknown>(args: RequestParams): Promise<T> {\n    switch (args.request.method) {\n      case \"eth_requestAccounts\":\n        return this.getAccounts() as unknown as T;\n      case \"eth_accounts\":\n        return this.getAccounts() as unknown as T;\n      case \"wallet_switchEthereumChain\": {\n        return (await this.handleSwitchChain(args)) as unknown as T;\n      }\n      case \"eth_chainId\":\n        return parseInt(this.getDefaultChain()) as unknown as T;\n      case \"wallet_getCapabilities\":\n        return (await this.getCapabilities(args)) as unknown as T;\n      case \"wallet_getCallsStatus\":\n        return (await this.getCallStatus(args)) as unknown as T;\n      default:\n        break;\n    }\n    if (this.namespace.methods.includes(args.request.method)) {\n      return await this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      this.setHttpProvider(parseInt(chainId), rpcUrl);\n    }\n    this.chainId = parseInt(chainId);\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${chainId}`);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId.toString();\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  // ---------- Private ----------------------------------------------- //\n\n  private createHttpProvider(\n    chainId: number,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc =\n      rpcUrl || getRpcUrl(`${this.name}:${chainId}`, this.namespace, this.client.core.projectId);\n    if (!rpc) {\n      throw new Error(`No RPC url provided for chainId: ${chainId}`);\n    }\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n\n  private setHttpProvider(chainId: number, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      const parsedChain = parseInt(getChainId(chain));\n      http[parsedChain] = this.createHttpProvider(parsedChain, this.namespace.rpcMap?.[chain]);\n    });\n    return http;\n  }\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n    return [\n      ...new Set(\n        accounts\n          // get the accounts from the active chain\n          .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n          // remove namespace & chainId from the string\n          .map((account) => account.split(\":\")[2]),\n      ),\n    ];\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = this.chainId;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private async handleSwitchChain(args: RequestParams): Promise<any> {\n    let hexChainId = args.request.params ? args.request.params[0]?.chainId : \"0x0\";\n    hexChainId = hexChainId.startsWith(\"0x\") ? hexChainId : `0x${hexChainId}`;\n    const parsedChainId = parseInt(hexChainId, 16);\n    // if chainId is already approved, switch locally\n    if (this.isChainApproved(parsedChainId)) {\n      this.setDefaultChain(`${parsedChainId}`);\n    } else if (this.namespace.methods.includes(\"wallet_switchEthereumChain\")) {\n      // try to switch chain within the wallet\n      await this.client.request({\n        topic: args.topic,\n        request: {\n          method: args.request.method,\n          params: [\n            {\n              chainId: hexChainId,\n            },\n          ],\n        },\n        chainId: this.namespace.chains?.[0], // Sending a previously unapproved chainId will cause namespace validation failure so we must set request chainId to the first chainId in the namespace to avoid it\n      } as EngineTypes.RequestParams);\n      this.setDefaultChain(`${parsedChainId}`);\n    } else {\n      throw new Error(\n        `Failed to switch to chain 'eip155:${parsedChainId}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`,\n      );\n    }\n    return null;\n  }\n\n  private isChainApproved(chainId: number): boolean {\n    return this.namespace.chains.includes(`${this.name}:${chainId}`);\n  }\n\n  private async getCapabilities(args: RequestParams) {\n    // if capabilities are stored in the session, return them, else send the request to the wallet\n    const address = args.request?.params?.[0];\n    if (!address) throw new Error(\"Missing address parameter in `wallet_getCapabilities` request\");\n    const session = this.client.session.get(args.topic);\n    const sessionCapabilities = session?.sessionProperties?.capabilities || {};\n    if (sessionCapabilities?.[address]) {\n      return sessionCapabilities?.[address];\n    }\n    // intentionally omit catching errors/rejection during `request` to allow the error to bubble up\n    const capabilities = await this.client.request(args as EngineTypes.RequestParams);\n    try {\n      // update the session with the capabilities so they can be retrieved later\n      await this.client.session.update(args.topic, {\n        sessionProperties: {\n          ...(session.sessionProperties || {}),\n          capabilities: {\n            ...(sessionCapabilities || {}),\n            [address]: capabilities,\n          } as any, // by spec sessionProperties should be <string, string> but here are used as objects?\n        },\n      });\n    } catch (error) {\n      console.warn(\"Failed to update session with capabilities\", error);\n    }\n    return capabilities;\n  }\n\n  private async getCallStatus(args: RequestParams) {\n    const session = this.client.session.get(args.topic);\n    const bundlerName = session.sessionProperties?.bundler_name;\n    if (bundlerName) {\n      const bundlerUrl = this.getBundlerUrl(args.chainId, bundlerName);\n      try {\n        return await this.getUserOperationReceipt(bundlerUrl, args);\n      } catch (error) {\n        console.warn(\"Failed to fetch call status from bundler\", error, bundlerUrl);\n      }\n    }\n    const customUrl = session.sessionProperties?.bundler_url;\n    if (customUrl) {\n      try {\n        return await this.getUserOperationReceipt(customUrl, args);\n      } catch (error) {\n        console.warn(\"Failed to fetch call status from custom bundler\", error, customUrl);\n      }\n    }\n\n    if (this.namespace.methods.includes(args.request.method)) {\n      return await this.client.request(args as EngineTypes.RequestParams);\n    }\n\n    throw new Error(\"Fetching call status not approved by the wallet.\");\n  }\n\n  private async getUserOperationReceipt(bundlerUrl: string, args: RequestParams) {\n    const url = new URL(bundlerUrl);\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(\n        formatJsonRpcRequest(\"eth_getUserOperationReceipt\", [args.request.params?.[0]]),\n      ),\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to fetch user operation receipt - ${response.status}`);\n    }\n    return await response.json();\n  }\n\n  private getBundlerUrl(cap2ChainId: string, bundlerName: string) {\n    return `${BUNDLER_URL}?projectId=${this.client.core.projectId}&chainId=${cap2ChainId}&bundler=${bundlerName}`;\n  }\n}\n\nexport default Eip155Provider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\nimport { getChainId, getGlobal, getRpcUrl } from \"../utils\";\n\nclass SolanaProvider implements IProvider {\n  public name = \"solana\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      this.setHttpProvider(chainId, rpcUrl);\n    }\n    this.chainId = chainId;\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${chainId}`);\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  // --------- PRIVATE --------- //\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return [\n      ...new Set(\n        accounts\n          // get the accounts from the active chain\n          .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n          // remove namespace & chainId from the string\n          .map((account) => account.split(\":\")[2]),\n      ),\n    ];\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      const parsedChainId = getChainId(chain);\n      http[parsedChainId] = this.createHttpProvider(parsedChainId, this.namespace.rpcMap?.[chain]);\n    });\n    return http;\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace, this.client.core.projectId);\n    if (!rpc) {\n      throw new Error(`No RPC url provided for chainId: ${chainId}`);\n    }\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n}\n\nexport default SolanaProvider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\nimport { getChainId, getGlobal, getRpcUrl } from \"../utils\";\n\nclass CosmosProvider implements IProvider {\n  public name = \"cosmos\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      this.setHttpProvider(chainId, rpcUrl);\n    }\n    this.chainId = chainId;\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n\n  // ---------------- PRIVATE ---------------- //\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return [\n      ...new Set(\n        accounts\n          // get the accounts from the active chain\n          .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n          // remove namespace & chainId from the string\n          .map((account) => account.split(\":\")[2]),\n      ),\n    ];\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      const parsedChainId = getChainId(chain);\n      http[parsedChainId] = this.createHttpProvider(parsedChainId, this.namespace.rpcMap?.[chain]);\n    });\n    return http;\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace, this.client.core.projectId);\n    if (!rpc) {\n      throw new Error(`No RPC url provided for chainId: ${chainId}`);\n    }\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n}\n\nexport default CosmosProvider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\nimport { getGlobal, getRpcUrl } from \"../utils\";\n\nclass AlgorandProvider implements IProvider {\n  public name = \"algorand\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      const rpc =\n        rpcUrl || getRpcUrl(`${this.name}:${chainId}`, this.namespace, this.client.core.projectId);\n      if (!rpc) {\n        throw new Error(`No RPC url provided for chainId: ${chainId}`);\n      }\n      this.setHttpProvider(chainId, rpc);\n    }\n    this.chainId = chainId;\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  // --------- PRIVATE --------- //\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return [\n      ...new Set(\n        accounts\n          // get the accounts from the active chain\n          .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n          // remove namespace & chainId from the string\n          .map((account) => account.split(\":\")[2]),\n      ),\n    ];\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      http[chain] = this.createHttpProvider(chain, this.namespace.rpcMap?.[chain]);\n    });\n    return http;\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace, this.client.core.projectId);\n    if (typeof rpc === \"undefined\") return undefined;\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n}\n\nexport default AlgorandProvider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\nimport { getChainId, getGlobal } from \"../utils\";\n\nclass CardanoProvider implements IProvider {\n  public name = \"cip34\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      this.setHttpProvider(chainId, rpcUrl);\n    }\n    this.chainId = chainId;\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n\n  // ------------- PRIVATE -------------- /\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return [\n      ...new Set(\n        accounts\n          // get the accounts from the active chain\n          .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n          // remove namespace & chainId from the string\n          .map((account) => account.split(\":\")[2]),\n      ),\n    ];\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      const rpcURL = this.getCardanoRPCUrl(chain);\n      const parsedChain = getChainId(chain);\n      http[parsedChain] = this.createHttpProvider(parsedChain, rpcURL);\n    });\n    return http;\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private getCardanoRPCUrl(chainId: string): string | undefined {\n    const rpcMap = this.namespace.rpcMap;\n    if (!rpcMap) return undefined;\n    return rpcMap[chainId];\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || this.getCardanoRPCUrl(chainId);\n    if (!rpc) {\n      throw new Error(`No RPC url provided for chainId: ${chainId}`);\n    }\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n}\n\nexport default CardanoProvider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\nimport { getChainId, getGlobal, getRpcUrl } from \"../utils\";\n\n// Old wallet connect provider for Elrond\nclass ElrondProvider implements IProvider {\n  public name = \"elrond\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      this.setHttpProvider(chainId, rpcUrl);\n    }\n    this.chainId = chainId;\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${chainId}`);\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  // --------- PRIVATE --------- //\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return [\n      ...new Set(\n        accounts\n          // get the accounts from the active chain\n          .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n          // remove namespace & chainId from the string\n          .map((account) => account.split(\":\")[2]),\n      ),\n    ];\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      const parsedChainId = getChainId(chain);\n      http[parsedChainId] = this.createHttpProvider(parsedChainId, this.namespace.rpcMap?.[chain]);\n    });\n    return http;\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace, this.client.core.projectId);\n    if (!rpc) {\n      throw new Error(`No RPC url provided for chainId: ${chainId}`);\n    }\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n}\n\nexport default ElrondProvider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\nimport { getChainId, getGlobal, getRpcUrl } from \"../utils\";\n\nclass MultiversXProvider implements IProvider {\n  public name = \"multiversx\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      this.setHttpProvider(chainId, rpcUrl);\n    }\n    this.chainId = chainId;\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${chainId}`);\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  // --------- PRIVATE --------- //\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return [\n      ...new Set(\n        accounts\n          // get the accounts from the active chain\n          .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n          // remove namespace & chainId from the string\n          .map((account) => account.split(\":\")[2]),\n      ),\n    ];\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      const parsedChainId = getChainId(chain);\n      http[parsedChainId] = this.createHttpProvider(parsedChainId, this.namespace.rpcMap?.[chain]);\n    });\n    return http;\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace, this.client.core.projectId);\n    if (!rpc) {\n      throw new Error(`No RPC url provided for chainId: ${chainId}`);\n    }\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n}\n\nexport default MultiversXProvider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\nimport { getGlobal, getRpcUrl } from \"../utils\";\n\nclass NearProvider implements IProvider {\n  public name = \"near\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    this.chainId = chainId;\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      const rpc = rpcUrl || getRpcUrl(`${this.name}:${chainId}`, this.namespace);\n      if (!rpc) {\n        throw new Error(`No RPC url provided for chainId: ${chainId}`);\n      }\n      this.setHttpProvider(chainId, rpc);\n    }\n\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n\n  // ---------------- PRIVATE ---------------- //\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return (\n      accounts\n        // get the accounts from the active chain\n        .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n        // remove namespace & chainId from the string\n        .map((account) => account.split(\":\")[2]) || []\n    );\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      http[chain] = this.createHttpProvider(chain, this.namespace.rpcMap?.[chain]);\n    });\n    return http;\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace);\n    if (typeof rpc === \"undefined\") return undefined;\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n}\n\nexport default NearProvider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\n\nimport { getRpcUrl, getGlobal } from \"../utils\";\n\nclass TezosProvider implements IProvider {\n  public name = \"tezos\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    this.chainId = chainId;\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      const rpc = rpcUrl || getRpcUrl(`${this.name}:${chainId}`, this.namespace);\n      if (!rpc) {\n        throw new Error(`No RPC url provided for chainId: ${chainId}`);\n      }\n      this.setHttpProvider(chainId, rpc);\n    }\n\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n\n  // ---------------- PRIVATE ---------------- //\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return (\n      accounts\n        // get the accounts from the active chain\n        .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n        // remove namespace & chainId from the string\n        .map((account) => account.split(\":\")[2]) || []\n    );\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http: any = {};\n    this.namespace.chains.forEach((chain) => {\n      http[chain] = this.createHttpProvider(chain);\n    });\n    return http;\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace);\n    if (typeof rpc === \"undefined\") return undefined;\n    const http = new JsonRpcProvider(new HttpConnection(rpc));\n    return http;\n  }\n}\n\nexport default TezosProvider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { GENERIC_SUBPROVIDER_NAME, PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\nimport { getGlobal, getRpcUrl } from \"../utils\";\nimport { parseChainId } from \"@walletconnect/utils\";\n\nclass GenericProvider implements IProvider {\n  public name = GENERIC_SUBPROVIDER_NAME;\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace.chains = [\n      ...new Set((this.namespace.chains || []).concat(namespace.chains || [])),\n    ];\n    this.namespace.accounts = [\n      ...new Set((this.namespace.accounts || []).concat(namespace.accounts || [])),\n    ];\n    this.namespace.methods = [\n      ...new Set((this.namespace.methods || []).concat(namespace.methods || [])),\n    ];\n    this.namespace.events = [\n      ...new Set((this.namespace.events || []).concat(namespace.events || [])),\n    ];\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider(args.chainId).request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      this.setHttpProvider(chainId, rpcUrl);\n    }\n    this.chainId = chainId;\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${chainId}`);\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  // --------- PRIVATE --------- //\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return [\n      ...new Set(\n        accounts\n          // get the accounts from the active chain\n          .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n          // remove namespace & chainId from the string\n          .map((account) => account.split(\":\")[2]),\n      ),\n    ];\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace?.accounts?.forEach((account) => {\n      const chain = parseChainId(account);\n      http[`${chain.namespace}:${chain.reference}`] = this.createHttpProvider(account);\n    });\n    return http;\n  }\n\n  private getHttpProvider(chain: string): JsonRpcProvider {\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(chainId: string, rpcUrl?: string): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace, this.client.core.projectId);\n    if (!rpc) {\n      throw new Error(`No RPC url provided for chainId: ${chainId}`);\n    }\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n}\n\nexport default GenericProvider;\n","import SignClient from \"@walletconnect/sign-client\";\nimport { SessionTypes } from \"@walletconnect/types\";\nimport { JsonRpcResult } from \"@walletconnect/jsonrpc-types\";\nimport { getSdkError, isValidArray, parseNamespaceKey } from \"@walletconnect/utils\";\nimport { getDefaultLoggerOptions, Logger, pino } from \"@walletconnect/logger\";\nimport {\n  convertChainIdToNumber,\n  getAccountsFromSession,\n  getChainsFromApprovedSession,\n  mergeRequiredOptionalNamespaces,\n  parseCaip10Account,\n  populateNamespacesChains,\n  setGlobal,\n} from \"./utils\";\nimport PolkadotProvider from \"./providers/polkadot\";\nimport Eip155Provider from \"./providers/eip155\";\nimport SolanaProvider from \"./providers/solana\";\nimport CosmosProvider from \"./providers/cosmos\";\nimport AlgorandProvider from \"./providers/algorand\";\nimport CardanoProvider from \"./providers/cardano\";\nimport ElrondProvider from \"./providers/elrond\";\nimport MultiversXProvider from \"./providers/multiversx\";\nimport NearProvider from \"./providers/near\";\nimport TezosProvider from \"./providers/tezos\";\nimport GenericProvider from \"./providers/generic\";\n\nimport {\n  IUniversalProvider,\n  IProvider,\n  RpcProviderMap,\n  ConnectParams,\n  RequestArguments,\n  UniversalProviderOpts,\n  NamespaceConfig,\n  PairingsCleanupOpts,\n  ProviderAccounts,\n  AuthenticateParams,\n} from \"./types\";\n\nimport { RELAY_URL, LOGGER, STORAGE, PROVIDER_EVENTS, GENERIC_SUBPROVIDER_NAME } from \"./constants\";\nimport EventEmitter from \"events\";\nimport { formatJsonRpcResult } from \"@walletconnect/jsonrpc-utils\";\n\nexport class UniversalProvider implements IUniversalProvider {\n  public client!: SignClient;\n  public namespaces?: NamespaceConfig;\n  public optionalNamespaces?: NamespaceConfig;\n  public sessionProperties?: Record<string, string>;\n  public events: EventEmitter = new EventEmitter();\n  public rpcProviders: RpcProviderMap = {};\n  public session?: SessionTypes.Struct;\n  public providerOpts: UniversalProviderOpts;\n  public logger: Logger;\n  public uri: string | undefined;\n\n  private disableProviderPing = false;\n\n  static async init(opts: UniversalProviderOpts) {\n    const provider = new UniversalProvider(opts);\n    await provider.initialize();\n    return provider;\n  }\n\n  constructor(opts: UniversalProviderOpts) {\n    this.providerOpts = opts;\n    this.logger =\n      typeof opts?.logger !== \"undefined\" && typeof opts?.logger !== \"string\"\n        ? opts.logger\n        : pino(getDefaultLoggerOptions({ level: opts?.logger || LOGGER }));\n    this.disableProviderPing = opts?.disableProviderPing || false;\n  }\n\n  public async request<T = unknown>(\n    args: RequestArguments,\n    chain?: string | undefined,\n    expiry?: number | undefined,\n  ): Promise<T> {\n    const [namespace, chainId] = this.validateChain(chain);\n\n    if (!this.session) {\n      throw new Error(\"Please call connect() before request()\");\n    }\n\n    return await this.getProvider(namespace).request({\n      request: {\n        ...args,\n      },\n      chainId: `${namespace}:${chainId}`,\n      topic: this.session.topic,\n      expiry,\n    });\n  }\n\n  public sendAsync(\n    args: RequestArguments,\n    callback: (error: Error | null, response: JsonRpcResult) => void,\n    chain?: string | undefined,\n    expiry?: number | undefined,\n  ): void {\n    const id = new Date().getTime();\n    this.request(args, chain, expiry)\n      .then((response) => callback(null, formatJsonRpcResult(id, response)))\n      .catch((error) => callback(error, undefined as any));\n  }\n\n  public async enable(): Promise<ProviderAccounts> {\n    if (!this.client) {\n      throw new Error(\"Sign Client not initialized\");\n    }\n    if (!this.session) {\n      await this.connect({\n        namespaces: this.namespaces,\n        optionalNamespaces: this.optionalNamespaces,\n        sessionProperties: this.sessionProperties,\n      });\n    }\n    const accounts = await this.requestAccounts();\n    return accounts as ProviderAccounts;\n  }\n\n  public async disconnect(): Promise<void> {\n    if (!this.session) {\n      throw new Error(\"Please call connect() before enable()\");\n    }\n    await this.client.disconnect({\n      topic: this.session?.topic,\n      reason: getSdkError(\"USER_DISCONNECTED\"),\n    });\n    await this.cleanup();\n  }\n\n  public async connect(opts: ConnectParams): Promise<SessionTypes.Struct | undefined> {\n    if (!this.client) {\n      throw new Error(\"Sign Client not initialized\");\n    }\n    this.setNamespaces(opts);\n    await this.cleanupPendingPairings();\n    if (opts.skipPairing) return;\n\n    return await this.pair(opts.pairingTopic);\n  }\n\n  public async authenticate(opts: AuthenticateParams, walletUniversalLink?: string) {\n    if (!this.client) {\n      throw new Error(\"Sign Client not initialized\");\n    }\n    this.setNamespaces(opts);\n    await this.cleanupPendingPairings();\n\n    const { uri, response } = await this.client.authenticate(opts, walletUniversalLink);\n    if (uri) {\n      this.uri = uri;\n      this.events.emit(\"display_uri\", uri);\n    }\n    const result = await response();\n    this.session = result.session;\n    if (this.session) {\n      // assign namespaces from session if not already defined\n      const approved = populateNamespacesChains(this.session.namespaces) as NamespaceConfig;\n      this.namespaces = mergeRequiredOptionalNamespaces(this.namespaces, approved);\n      this.persist(\"namespaces\", this.namespaces);\n      this.onConnect();\n    }\n    return result;\n  }\n\n  public on(event: any, listener: any): void {\n    this.events.on(event, listener);\n  }\n\n  public once(event: string, listener: any): void {\n    this.events.once(event, listener);\n  }\n\n  public removeListener(event: string, listener: any): void {\n    this.events.removeListener(event, listener);\n  }\n\n  public off(event: string, listener: any): void {\n    this.events.off(event, listener);\n  }\n\n  get isWalletConnect() {\n    return true;\n  }\n\n  public async pair(pairingTopic: string | undefined): Promise<SessionTypes.Struct> {\n    const { uri, approval } = await this.client.connect({\n      pairingTopic,\n      requiredNamespaces: this.namespaces,\n      optionalNamespaces: this.optionalNamespaces,\n      sessionProperties: this.sessionProperties,\n    });\n\n    if (uri) {\n      this.uri = uri;\n      this.events.emit(\"display_uri\", uri);\n    }\n\n    const session = await approval();\n    this.session = session;\n    // assign namespaces from session if not already defined\n    const approved = populateNamespacesChains(session.namespaces) as NamespaceConfig;\n    this.namespaces = mergeRequiredOptionalNamespaces(this.namespaces, approved);\n    this.persist(\"namespaces\", this.namespaces);\n\n    this.onConnect();\n    return this.session;\n  }\n\n  public setDefaultChain(chain: string, rpcUrl?: string | undefined) {\n    try {\n      // ignore without active session\n      if (!this.session) return;\n      const [namespace, chainId] = this.validateChain(chain);\n      const provider = this.getProvider(namespace);\n      // @ts-expect-error\n      if (provider.name === GENERIC_SUBPROVIDER_NAME) {\n        provider.setDefaultChain(`${namespace}:${chainId}`, rpcUrl);\n      } else {\n        provider.setDefaultChain(chainId, rpcUrl);\n      }\n    } catch (error) {\n      // ignore the error if the fx is used prematurely before namespaces are set\n      if (!/Please call connect/.test((error as Error).message)) throw error;\n    }\n  }\n\n  public async cleanupPendingPairings(opts: PairingsCleanupOpts = {}): Promise<void> {\n    this.logger.info(\"Cleaning up inactive pairings...\");\n    const inactivePairings = this.client.pairing.getAll();\n\n    if (!isValidArray(inactivePairings)) return;\n\n    for (const pairing of inactivePairings) {\n      if (opts.deletePairings) {\n        this.client.core.expirer.set(pairing.topic, 0);\n      } else {\n        await this.client.core.relayer.subscriber.unsubscribe(pairing.topic);\n      }\n    }\n\n    this.logger.info(`Inactive pairings cleared: ${inactivePairings.length}`);\n  }\n\n  public abortPairingAttempt() {\n    this.logger.warn(\"abortPairingAttempt is deprecated. This is now a no-op.\");\n  }\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async checkStorage() {\n    this.namespaces = await this.getFromStore(\"namespaces\");\n    this.optionalNamespaces = (await this.getFromStore(\"optionalNamespaces\")) || {};\n    if (this.client.session.length) {\n      const lastKeyIndex = this.client.session.keys.length - 1;\n      this.session = this.client.session.get(this.client.session.keys[lastKeyIndex]);\n      this.createProviders();\n    }\n  }\n\n  private async initialize() {\n    this.logger.trace(`Initialized`);\n    await this.createClient();\n    await this.checkStorage();\n    this.registerEventListeners();\n  }\n\n  private async createClient() {\n    this.client =\n      this.providerOpts.client ||\n      (await SignClient.init({\n        core: this.providerOpts.core,\n        logger: this.providerOpts.logger || LOGGER,\n        relayUrl: this.providerOpts.relayUrl || RELAY_URL,\n        projectId: this.providerOpts.projectId,\n        metadata: this.providerOpts.metadata,\n        storageOptions: this.providerOpts.storageOptions,\n        storage: this.providerOpts.storage,\n        name: this.providerOpts.name,\n        customStoragePrefix: this.providerOpts.customStoragePrefix,\n        telemetryEnabled: this.providerOpts.telemetryEnabled,\n      }));\n\n    this.logger.trace(`SignClient Initialized`);\n  }\n\n  private createProviders(): void {\n    if (!this.client) {\n      throw new Error(\"Sign Client not initialized\");\n    }\n\n    if (!this.session) {\n      throw new Error(\"Session not initialized. Please call connect() before enable()\");\n    }\n\n    const providersToCreate = [\n      ...new Set(\n        Object.keys(this.session.namespaces).map((namespace) => parseNamespaceKey(namespace)),\n      ),\n    ];\n\n    setGlobal(\"client\", this.client);\n    setGlobal(\"events\", this.events);\n    setGlobal(\"disableProviderPing\", this.disableProviderPing);\n\n    providersToCreate.forEach((namespace) => {\n      if (!this.session) return;\n      const accounts = getAccountsFromSession(namespace, this.session);\n      const approvedChains = getChainsFromApprovedSession(accounts);\n      const mergedNamespaces = mergeRequiredOptionalNamespaces(\n        this.namespaces,\n        this.optionalNamespaces,\n      );\n      const combinedNamespace = {\n        ...mergedNamespaces[namespace],\n        accounts,\n        chains: approvedChains,\n      };\n      switch (namespace) {\n        case \"eip155\":\n          this.rpcProviders[namespace] = new Eip155Provider({\n            namespace: combinedNamespace,\n          });\n          break;\n        case \"algorand\":\n          this.rpcProviders[namespace] = new AlgorandProvider({\n            namespace: combinedNamespace,\n          });\n          break;\n        case \"solana\":\n          this.rpcProviders[namespace] = new SolanaProvider({\n            namespace: combinedNamespace,\n          });\n          break;\n        case \"cosmos\":\n          this.rpcProviders[namespace] = new CosmosProvider({\n            namespace: combinedNamespace,\n          });\n          break;\n        case \"polkadot\":\n          this.rpcProviders[namespace] = new PolkadotProvider({\n            namespace: combinedNamespace,\n          });\n          break;\n        case \"cip34\":\n          this.rpcProviders[namespace] = new CardanoProvider({\n            namespace: combinedNamespace,\n          });\n          break;\n        case \"elrond\":\n          this.rpcProviders[namespace] = new ElrondProvider({\n            namespace: combinedNamespace,\n          });\n          break;\n        case \"multiversx\":\n          this.rpcProviders[namespace] = new MultiversXProvider({\n            namespace: combinedNamespace,\n          });\n          break;\n        case \"near\":\n          this.rpcProviders[namespace] = new NearProvider({\n            namespace: combinedNamespace,\n          });\n          break;\n        case \"tezos\":\n          this.rpcProviders[namespace] = new TezosProvider({\n            namespace: combinedNamespace,\n          });\n          break;\n        default:\n          if (!this.rpcProviders[GENERIC_SUBPROVIDER_NAME]) {\n            this.rpcProviders[GENERIC_SUBPROVIDER_NAME] = new GenericProvider({\n              namespace: combinedNamespace,\n            });\n          } else {\n            this.rpcProviders[GENERIC_SUBPROVIDER_NAME].updateNamespace(combinedNamespace);\n          }\n      }\n    });\n  }\n\n  private registerEventListeners(): void {\n    if (typeof this.client === \"undefined\") {\n      throw new Error(\"Sign Client is not initialized\");\n    }\n\n    this.client.on(\"session_ping\", (args) => {\n      this.events.emit(\"session_ping\", args);\n    });\n\n    this.client.on(\"session_event\", (args) => {\n      const { params } = args;\n      const { event } = params;\n      if (event.name === \"accountsChanged\") {\n        const accounts = event.data;\n        if (accounts && isValidArray(accounts))\n          this.events.emit(\"accountsChanged\", accounts.map(parseCaip10Account));\n      } else if (event.name === \"chainChanged\") {\n        const requestChainId = params.chainId;\n        const payloadChainId = params.event.data as number;\n        const namespace = parseNamespaceKey(requestChainId);\n        // chainIds might differ between the request & payload - request is always in CAIP2 format, while payload might be string, number, CAIP2 or hex\n        // take priority of the payload chainId\n        const chainIdToProcess =\n          convertChainIdToNumber(requestChainId) !== convertChainIdToNumber(payloadChainId)\n            ? `${namespace}:${convertChainIdToNumber(payloadChainId)}`\n            : requestChainId;\n\n        this.onChainChanged(chainIdToProcess);\n      } else {\n        this.events.emit(event.name, event.data);\n      }\n\n      this.events.emit(\"session_event\", args);\n    });\n\n    this.client.on(\"session_update\", ({ topic, params }) => {\n      const { namespaces } = params;\n      const _session = this.client?.session.get(topic);\n      this.session = { ..._session, namespaces } as SessionTypes.Struct;\n      this.onSessionUpdate();\n      this.events.emit(\"session_update\", { topic, params });\n    });\n\n    this.client.on(\"session_delete\", async (payload) => {\n      await this.cleanup();\n      this.events.emit(\"session_delete\", payload);\n      this.events.emit(\"disconnect\", {\n        ...getSdkError(\"USER_DISCONNECTED\"),\n        data: payload.topic,\n      });\n    });\n\n    this.on(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, (caip2ChainId: string) => {\n      this.onChainChanged(caip2ChainId, true);\n    });\n  }\n\n  private getProvider(namespace: string): IProvider {\n    return this.rpcProviders[namespace] || this.rpcProviders[GENERIC_SUBPROVIDER_NAME];\n  }\n\n  private onSessionUpdate(): void {\n    Object.keys(this.rpcProviders).forEach((namespace: string) => {\n      this.getProvider(namespace).updateNamespace(\n        this.session?.namespaces[namespace] as SessionTypes.BaseNamespace,\n      );\n    });\n  }\n\n  private setNamespaces(params: ConnectParams): void {\n    const { namespaces, optionalNamespaces, sessionProperties } = params;\n\n    if (namespaces && Object.keys(namespaces).length) {\n      this.namespaces = namespaces;\n    }\n    if (optionalNamespaces && Object.keys(optionalNamespaces).length) {\n      this.optionalNamespaces = optionalNamespaces;\n    }\n    this.sessionProperties = sessionProperties;\n    this.persist(\"namespaces\", namespaces);\n    this.persist(\"optionalNamespaces\", optionalNamespaces);\n  }\n\n  private validateChain(chain?: string): [string, string] {\n    const [namespace, chainId] = chain?.split(\":\") || [\"\", \"\"];\n    if (!this.namespaces || !Object.keys(this.namespaces).length) return [namespace, chainId];\n    // validate namespace\n    if (namespace) {\n      if (\n        // some namespaces might be defined with inline chainId e.g. eip155:1\n        // and we need to parse them\n        !Object.keys(this.namespaces || {})\n          .map((key) => parseNamespaceKey(key))\n          .includes(namespace)\n      ) {\n        throw new Error(\n          `Namespace '${namespace}' is not configured. Please call connect() first with namespace config.`,\n        );\n      }\n    }\n    if (namespace && chainId) {\n      return [namespace, chainId];\n    }\n    const defaultNamespace = parseNamespaceKey(Object.keys(this.namespaces)[0]);\n    const defaultChain = this.rpcProviders[defaultNamespace].getDefaultChain();\n    return [defaultNamespace, defaultChain];\n  }\n\n  private async requestAccounts(): Promise<string[]> {\n    const [namespace] = this.validateChain();\n    return await this.getProvider(namespace).requestAccounts();\n  }\n\n  private onChainChanged(caip2Chain: string, internal = false): void {\n    if (!this.namespaces) return;\n\n    const [namespace, chainId] = this.validateChain(caip2Chain);\n\n    if (!chainId) return;\n\n    if (!internal) {\n      this.getProvider(namespace).setDefaultChain(chainId);\n    }\n\n    if (this.namespaces[namespace]) {\n      this.namespaces[namespace].defaultChain = chainId;\n    } else if (this.namespaces[`${namespace}:${chainId}`]) {\n      this.namespaces[`${namespace}:${chainId}`].defaultChain = chainId;\n    } else {\n      // @ts-ignore\n      this.namespaces[`${namespace}:${chainId}`] = { defaultChain: chainId };\n    }\n\n    this.persist(\"namespaces\", this.namespaces);\n    this.events.emit(\"chainChanged\", chainId);\n  }\n\n  private onConnect() {\n    this.createProviders();\n    this.events.emit(\"connect\", { session: this.session });\n  }\n\n  private async cleanup() {\n    this.session = undefined;\n    this.namespaces = undefined;\n    this.optionalNamespaces = undefined;\n    this.sessionProperties = undefined;\n    this.persist(\"namespaces\", undefined);\n    this.persist(\"optionalNamespaces\", undefined);\n    this.persist(\"sessionProperties\", undefined);\n    await this.cleanupPendingPairings({ deletePairings: true });\n  }\n\n  private persist(key: string, data: unknown) {\n    this.client.core.storage.setItem(`${STORAGE}/${key}`, data);\n  }\n\n  private async getFromStore(key: string) {\n    return await this.client.core.storage.getItem(`${STORAGE}/${key}`);\n  }\n}\nexport default UniversalProvider;\n","import { UniversalProvider as Provider } from \"./UniversalProvider\";\nexport * from \"./types\";\nexport const UniversalProvider = Provider;\nexport default Provider;\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}