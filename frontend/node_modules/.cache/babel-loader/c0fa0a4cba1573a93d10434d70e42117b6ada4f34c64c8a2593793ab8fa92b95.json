{"ast":null,"code":"import { SocketClosedError, TimeoutError } from '../../errors/request.js';\nimport { createBatchScheduler } from '../promise/createBatchScheduler.js';\nimport { withTimeout } from '../promise/withTimeout.js';\nimport { idCache } from './id.js';\nexport const socketClientCache = /*#__PURE__*/new Map();\nexport async function getSocketRpcClient(parameters) {\n  const {\n    getSocket,\n    keepAlive = true,\n    key = 'socket',\n    reconnect = true,\n    url\n  } = parameters;\n  const {\n    interval: keepAliveInterval = 30_000\n  } = typeof keepAlive === 'object' ? keepAlive : {};\n  const {\n    attempts = 5,\n    delay = 2_000\n  } = typeof reconnect === 'object' ? reconnect : {};\n  let socketClient = socketClientCache.get(`${key}:${url}`);\n  // If the socket already exists, return it.\n  if (socketClient) return socketClient;\n  let reconnectCount = 0;\n  const {\n    schedule\n  } = createBatchScheduler({\n    id: `${key}:${url}`,\n    fn: async () => {\n      // Set up a cache for incoming \"synchronous\" requests.\n      const requests = new Map();\n      // Set up a cache for subscriptions (eth_subscribe).\n      const subscriptions = new Map();\n      let error;\n      let socket;\n      let keepAliveTimer;\n      // Set up socket implementation.\n      async function setup() {\n        const result = await getSocket({\n          onClose() {\n            // Notify all requests and subscriptions of the closure error.\n            for (const request of requests.values()) request.onError?.(new SocketClosedError({\n              url\n            }));\n            for (const subscription of subscriptions.values()) subscription.onError?.(new SocketClosedError({\n              url\n            }));\n            // Clear all requests and subscriptions.\n            requests.clear();\n            subscriptions.clear();\n            // Attempt to reconnect.\n            if (reconnect && reconnectCount < attempts) setTimeout(async () => {\n              reconnectCount++;\n              await setup().catch(console.error);\n            }, delay);\n          },\n          onError(error_) {\n            error = error_;\n            // Notify all requests and subscriptions of the error.\n            for (const request of requests.values()) request.onError?.(error);\n            for (const subscription of subscriptions.values()) subscription.onError?.(error);\n            // Clear all requests and subscriptions.\n            requests.clear();\n            subscriptions.clear();\n            // Make sure socket is definitely closed.\n            socketClient?.close();\n            // Attempt to reconnect.\n            if (reconnect && reconnectCount < attempts) setTimeout(async () => {\n              reconnectCount++;\n              await setup().catch(console.error);\n            }, delay);\n          },\n          onOpen() {\n            error = undefined;\n            reconnectCount = 0;\n          },\n          onResponse(data) {\n            const isSubscription = data.method === 'eth_subscription';\n            const id = isSubscription ? data.params.subscription : data.id;\n            const cache = isSubscription ? subscriptions : requests;\n            const callback = cache.get(id);\n            if (callback) callback.onResponse(data);\n            if (!isSubscription) cache.delete(id);\n          }\n        });\n        socket = result;\n        if (keepAlive) {\n          if (keepAliveTimer) clearInterval(keepAliveTimer);\n          keepAliveTimer = setInterval(() => socket.ping?.(), keepAliveInterval);\n        }\n        return result;\n      }\n      await setup();\n      error = undefined;\n      // Create a new socket instance.\n      socketClient = {\n        close() {\n          keepAliveTimer && clearInterval(keepAliveTimer);\n          socket.close();\n          socketClientCache.delete(`${key}:${url}`);\n        },\n        get socket() {\n          return socket;\n        },\n        request({\n          body,\n          onError,\n          onResponse\n        }) {\n          if (error && onError) onError(error);\n          const id = body.id ?? idCache.take();\n          const callback = response => {\n            if (typeof response.id === 'number' && id !== response.id) return;\n            // If we are subscribing to a topic, we want to set up a listener for incoming\n            // messages.\n            if (body.method === 'eth_subscribe' && typeof response.result === 'string') subscriptions.set(response.result, {\n              onResponse: callback,\n              onError\n            });\n            // If we are unsubscribing from a topic, we want to remove the listener.\n            if (body.method === 'eth_unsubscribe') subscriptions.delete(body.params?.[0]);\n            onResponse(response);\n          };\n          requests.set(id, {\n            onResponse: callback,\n            onError\n          });\n          try {\n            socket.request({\n              body: {\n                jsonrpc: '2.0',\n                id,\n                ...body\n              }\n            });\n          } catch (error) {\n            onError?.(error);\n          }\n        },\n        requestAsync({\n          body,\n          timeout = 10_000\n        }) {\n          return withTimeout(() => new Promise((onResponse, onError) => this.request({\n            body,\n            onError,\n            onResponse\n          })), {\n            errorInstance: new TimeoutError({\n              body,\n              url\n            }),\n            timeout\n          });\n        },\n        requests,\n        subscriptions,\n        url\n      };\n      socketClientCache.set(`${key}:${url}`, socketClient);\n      return [socketClient];\n    }\n  });\n  const [_, [socketClient_]] = await schedule();\n  return socketClient_;\n}\n//# sourceMappingURL=socket.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}