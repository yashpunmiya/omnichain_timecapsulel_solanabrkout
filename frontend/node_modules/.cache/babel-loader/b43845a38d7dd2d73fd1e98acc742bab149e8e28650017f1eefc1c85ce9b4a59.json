{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Intrinsic = Intrinsic;\nconst type_1 = require(\"../create/type\");\nconst index_1 = require(\"../template-literal/index\");\nconst intrinsic_from_mapped_key_1 = require(\"./intrinsic-from-mapped-key\");\nconst index_2 = require(\"../literal/index\");\nconst index_3 = require(\"../union/index\");\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nconst kind_1 = require(\"../guard/kind\");\n// ------------------------------------------------------------------\n// Apply\n// ------------------------------------------------------------------\nfunction ApplyUncapitalize(value) {\n  const [first, rest] = [value.slice(0, 1), value.slice(1)];\n  return [first.toLowerCase(), rest].join('');\n}\nfunction ApplyCapitalize(value) {\n  const [first, rest] = [value.slice(0, 1), value.slice(1)];\n  return [first.toUpperCase(), rest].join('');\n}\nfunction ApplyUppercase(value) {\n  return value.toUpperCase();\n}\nfunction ApplyLowercase(value) {\n  return value.toLowerCase();\n}\nfunction FromTemplateLiteral(schema, mode, options) {\n  // note: template literals require special runtime handling as they are encoded in string patterns.\n  // This diverges from the mapped type which would otherwise map on the template literal kind.\n  const expression = (0, index_1.TemplateLiteralParseExact)(schema.pattern);\n  const finite = (0, index_1.IsTemplateLiteralExpressionFinite)(expression);\n  if (!finite) return {\n    ...schema,\n    pattern: FromLiteralValue(schema.pattern, mode)\n  };\n  const strings = [...(0, index_1.TemplateLiteralExpressionGenerate)(expression)];\n  const literals = strings.map(value => (0, index_2.Literal)(value));\n  const mapped = FromRest(literals, mode);\n  const union = (0, index_3.Union)(mapped);\n  return (0, index_1.TemplateLiteral)([union], options);\n}\n// prettier-ignore\nfunction FromLiteralValue(value, mode) {\n  return typeof value === 'string' ? mode === 'Uncapitalize' ? ApplyUncapitalize(value) : mode === 'Capitalize' ? ApplyCapitalize(value) : mode === 'Uppercase' ? ApplyUppercase(value) : mode === 'Lowercase' ? ApplyLowercase(value) : value : value.toString();\n}\n// prettier-ignore\nfunction FromRest(T, M) {\n  return T.map(L => Intrinsic(L, M));\n}\n/** Applies an intrinsic string manipulation to the given type. */\nfunction Intrinsic(schema, mode, options = {}) {\n  // prettier-ignore\n  return (\n    // Intrinsic-Mapped-Inference\n    (0, kind_1.IsMappedKey)(schema) ? (0, intrinsic_from_mapped_key_1.IntrinsicFromMappedKey)(schema, mode, options) :\n    // Standard-Inference\n    (0, kind_1.IsTemplateLiteral)(schema) ? FromTemplateLiteral(schema, mode, options) : (0, kind_1.IsUnion)(schema) ? (0, index_3.Union)(FromRest(schema.anyOf, mode), options) : (0, kind_1.IsLiteral)(schema) ? (0, index_2.Literal)(FromLiteralValue(schema.const, mode), options) :\n    // Default Type\n    (0, type_1.CreateType)(schema, options)\n  );\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}