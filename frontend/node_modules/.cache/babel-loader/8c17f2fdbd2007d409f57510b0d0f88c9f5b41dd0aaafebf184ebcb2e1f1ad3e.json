{"ast":null,"code":"const e = Symbol(),\n  t = Symbol(),\n  r = \"a\",\n  n = \"w\";\nlet o = (e, t) => new Proxy(e, t);\nconst s = Object.getPrototypeOf,\n  c = new WeakMap(),\n  l = e => e && (c.has(e) ? c.get(e) : s(e) === Object.prototype || s(e) === Array.prototype),\n  f = e => \"object\" == typeof e && null !== e,\n  i = e => {\n    if (Array.isArray(e)) return Array.from(e);\n    const t = Object.getOwnPropertyDescriptors(e);\n    return Object.values(t).forEach(e => {\n      e.configurable = !0;\n    }), Object.create(s(e), t);\n  },\n  u = e => e[t] || e,\n  a = (s, c, f, p) => {\n    if (!l(s)) return s;\n    let g = p && p.get(s);\n    if (!g) {\n      const e = u(s);\n      g = (e => Object.values(Object.getOwnPropertyDescriptors(e)).some(e => !e.configurable && !e.writable))(e) ? [e, i(e)] : [e], null == p || p.set(s, g);\n    }\n    const [y, h] = g;\n    let w = f && f.get(y);\n    return w && w[1].f === !!h || (w = ((o, s) => {\n      const c = {\n        f: s\n      };\n      let l = !1;\n      const f = (e, t) => {\n          if (!l) {\n            let s = c[r].get(o);\n            if (s || (s = {}, c[r].set(o, s)), e === n) s[n] = !0;else {\n              let r = s[e];\n              r || (r = new Set(), s[e] = r), r.add(t);\n            }\n          }\n        },\n        i = {\n          get: (e, n) => n === t ? o : (f(\"k\", n), a(Reflect.get(e, n), c[r], c.c, c.t)),\n          has: (t, n) => n === e ? (l = !0, c[r].delete(o), !0) : (f(\"h\", n), Reflect.has(t, n)),\n          getOwnPropertyDescriptor: (e, t) => (f(\"o\", t), Reflect.getOwnPropertyDescriptor(e, t)),\n          ownKeys: e => (f(n), Reflect.ownKeys(e))\n        };\n      return s && (i.set = i.deleteProperty = () => !1), [i, c];\n    })(y, !!h), w[1].p = o(h || y, w[0]), f && f.set(y, w)), w[1][r] = c, w[1].c = f, w[1].t = p, w[1].p;\n  },\n  p = (e, t, r, o, s = Object.is) => {\n    if (s(e, t)) return !1;\n    if (!f(e) || !f(t)) return !0;\n    const c = r.get(u(e));\n    if (!c) return !0;\n    if (o) {\n      const r = o.get(e);\n      if (r && r.n === t) return r.g;\n      o.set(e, {\n        n: t,\n        g: !1\n      });\n    }\n    let l = null;\n    try {\n      for (const r of c.h || []) if (l = Reflect.has(e, r) !== Reflect.has(t, r), l) return l;\n      if (!0 === c[n]) {\n        if (l = ((e, t) => {\n          const r = Reflect.ownKeys(e),\n            n = Reflect.ownKeys(t);\n          return r.length !== n.length || r.some((e, t) => e !== n[t]);\n        })(e, t), l) return l;\n      } else for (const r of c.o || []) if (l = !!Reflect.getOwnPropertyDescriptor(e, r) != !!Reflect.getOwnPropertyDescriptor(t, r), l) return l;\n      for (const n of c.k || []) if (l = p(e[n], t[n], r, o, s), l) return l;\n      return null === l && (l = !0), l;\n    } finally {\n      o && o.set(e, {\n        n: t,\n        g: l\n      });\n    }\n  },\n  g = t => !!l(t) && e in t,\n  y = e => l(e) && e[t] || null,\n  h = (e, t = !0) => {\n    c.set(e, t);\n  },\n  w = (e, t, r) => {\n    const o = [],\n      s = new WeakSet(),\n      c = (e, l) => {\n        if (s.has(e)) return;\n        f(e) && s.add(e);\n        const i = f(e) && t.get(u(e));\n        if (i) {\n          var a, p;\n          if (null == (a = i.h) || a.forEach(e => {\n            const t = `:has(${String(e)})`;\n            o.push(l ? [...l, t] : [t]);\n          }), !0 === i[n]) {\n            const e = \":ownKeys\";\n            o.push(l ? [...l, e] : [e]);\n          } else {\n            var g;\n            null == (g = i.o) || g.forEach(e => {\n              const t = `:hasOwn(${String(e)})`;\n              o.push(l ? [...l, t] : [t]);\n            });\n          }\n          null == (p = i.k) || p.forEach(t => {\n            r && !(\"value\" in (Object.getOwnPropertyDescriptor(e, t) || {})) || c(e[t], l ? [...l, t] : [t]);\n          });\n        } else l && o.push(l);\n      };\n    return c(e), o;\n  },\n  O = e => {\n    o = e;\n  };\nexport { w as affectedToPathList, a as createProxy, y as getUntracked, p as isChanged, h as markToTrack, O as replaceNewProxy, g as trackMemo };\n//# sourceMappingURL=index.modern.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}