{"ast":null,"code":"import { EventEmitter as l } from \"events\";\nimport { safeJsonStringify as u, safeJsonParse as p } from \"@walletconnect/safe-json\";\nimport { isWsUrl as c, isReactNative as g, isLocalhostUrl as y, formatJsonRpcError as k, parseConnectionError as m } from \"@walletconnect/jsonrpc-utils\";\nconst v = () => typeof WebSocket < \"u\" ? WebSocket : typeof global < \"u\" && typeof global.WebSocket < \"u\" ? global.WebSocket : typeof window < \"u\" && typeof window.WebSocket < \"u\" ? window.WebSocket : typeof self < \"u\" && typeof self.WebSocket < \"u\" ? self.WebSocket : require(\"ws\"),\n  w = () => typeof WebSocket < \"u\" || typeof global < \"u\" && typeof global.WebSocket < \"u\" || typeof window < \"u\" && typeof window.WebSocket < \"u\" || typeof self < \"u\" && typeof self.WebSocket < \"u\",\n  d = r => r.split(\"?\")[0],\n  h = 10,\n  b = v();\nclass f {\n  constructor(e) {\n    if (this.url = e, this.events = new l(), this.registering = !1, !c(e)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);\n    this.url = e;\n  }\n  get connected() {\n    return typeof this.socket < \"u\";\n  }\n  get connecting() {\n    return this.registering;\n  }\n  on(e, t) {\n    this.events.on(e, t);\n  }\n  once(e, t) {\n    this.events.once(e, t);\n  }\n  off(e, t) {\n    this.events.off(e, t);\n  }\n  removeListener(e, t) {\n    this.events.removeListener(e, t);\n  }\n  async open(e = this.url) {\n    await this.register(e);\n  }\n  async close() {\n    return new Promise((e, t) => {\n      if (typeof this.socket > \"u\") {\n        t(new Error(\"Connection already closed\"));\n        return;\n      }\n      this.socket.onclose = n => {\n        this.onClose(n), e();\n      }, this.socket.close();\n    });\n  }\n  async send(e) {\n    typeof this.socket > \"u\" && (this.socket = await this.register());\n    try {\n      this.socket.send(u(e));\n    } catch (t) {\n      this.onError(e.id, t);\n    }\n  }\n  register(e = this.url) {\n    if (!c(e)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);\n    if (this.registering) {\n      const t = this.events.getMaxListeners();\n      return (this.events.listenerCount(\"register_error\") >= t || this.events.listenerCount(\"open\") >= t) && this.events.setMaxListeners(t + 1), new Promise((n, s) => {\n        this.events.once(\"register_error\", o => {\n          this.resetMaxListeners(), s(o);\n        }), this.events.once(\"open\", () => {\n          if (this.resetMaxListeners(), typeof this.socket > \"u\") return s(new Error(\"WebSocket connection is missing or invalid\"));\n          n(this.socket);\n        });\n      });\n    }\n    return this.url = e, this.registering = !0, new Promise((t, n) => {\n      const s = g() ? void 0 : {\n          rejectUnauthorized: !y(e)\n        },\n        o = new b(e, [], s);\n      w() ? o.onerror = i => {\n        const a = i;\n        n(this.emitError(a.error));\n      } : o.on(\"error\", i => {\n        n(this.emitError(i));\n      }), o.onopen = () => {\n        this.onOpen(o), t(o);\n      };\n    });\n  }\n  onOpen(e) {\n    e.onmessage = t => this.onPayload(t), e.onclose = t => this.onClose(t), this.socket = e, this.registering = !1, this.events.emit(\"open\");\n  }\n  onClose(e) {\n    this.socket = void 0, this.registering = !1, this.events.emit(\"close\", e);\n  }\n  onPayload(e) {\n    if (typeof e.data > \"u\") return;\n    const t = typeof e.data == \"string\" ? p(e.data) : e.data;\n    this.events.emit(\"payload\", t);\n  }\n  onError(e, t) {\n    const n = this.parseError(t),\n      s = n.message || n.toString(),\n      o = k(e, s);\n    this.events.emit(\"payload\", o);\n  }\n  parseError(e, t = this.url) {\n    return m(e, d(t), \"WS\");\n  }\n  resetMaxListeners() {\n    this.events.getMaxListeners() > h && this.events.setMaxListeners(h);\n  }\n  emitError(e) {\n    const t = this.parseError(new Error(e?.message || `WebSocket connection failed for host: ${d(this.url)}`));\n    return this.events.emit(\"register_error\", t), t;\n  }\n}\nexport { f as WsConnection, f as default };","map":{"version":3,"names":[],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\jsonrpc-ws-connection\\src\\utils.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\jsonrpc-ws-connection\\src\\ws.ts"],"sourcesContent":["export const resolveWebSocketImplementation = () => {\n  if (typeof WebSocket !== \"undefined\") {\n    return WebSocket;\n  } else if (typeof global !== \"undefined\" && typeof global.WebSocket !== \"undefined\") {\n    return global.WebSocket;\n  } else if (typeof window !== \"undefined\" && typeof window.WebSocket !== \"undefined\") {\n    return window.WebSocket;\n  } else if (typeof self !== \"undefined\" && typeof self.WebSocket !== \"undefined\") {\n    return self.WebSocket;\n  }\n\n  return require(\"ws\");\n};\n\nexport const hasBuiltInWebSocket = () =>\n  typeof WebSocket !== \"undefined\" ||\n  (typeof global !== \"undefined\" && typeof global.WebSocket !== \"undefined\") ||\n  (typeof window !== \"undefined\" && typeof window.WebSocket !== \"undefined\") ||\n  (typeof self !== \"undefined\" && typeof self.WebSocket !== \"undefined\");\n\nexport const isBrowser = () => typeof window !== \"undefined\";\n\nexport const truncateQuery = (wssUrl: string) => wssUrl.split(\"?\")[0];\n","import { EventEmitter } from \"events\";\nimport { safeJsonParse, safeJsonStringify } from \"@walletconnect/safe-json\";\nimport {\n  formatJsonRpcError,\n  IJsonRpcConnection,\n  JsonRpcPayload,\n  isReactNative,\n  isWsUrl,\n  isLocalhostUrl,\n  parseConnectionError,\n} from \"@walletconnect/jsonrpc-utils\";\nimport { truncateQuery, resolveWebSocketImplementation, hasBuiltInWebSocket } from \"./utils\";\n\n// Source: https://nodejs.org/api/events.html#emittersetmaxlistenersn\nconst EVENT_EMITTER_MAX_LISTENERS_DEFAULT = 10;\n\nconst WS = resolveWebSocketImplementation();\n\nexport class WsConnection implements IJsonRpcConnection {\n  public events = new EventEmitter();\n\n  private socket: WebSocket | undefined;\n\n  private registering = false;\n\n  constructor(public url: string) {\n    if (!isWsUrl(url)) {\n      throw new Error(`Provided URL is not compatible with WebSocket connection: ${url}`);\n    }\n    this.url = url;\n  }\n\n  get connected(): boolean {\n    return typeof this.socket !== \"undefined\";\n  }\n\n  get connecting(): boolean {\n    return this.registering;\n  }\n\n  public on(event: string, listener: any): void {\n    this.events.on(event, listener);\n  }\n\n  public once(event: string, listener: any): void {\n    this.events.once(event, listener);\n  }\n\n  public off(event: string, listener: any): void {\n    this.events.off(event, listener);\n  }\n\n  public removeListener(event: string, listener: any): void {\n    this.events.removeListener(event, listener);\n  }\n\n  public async open(url: string = this.url): Promise<void> {\n    await this.register(url);\n  }\n\n  public async close(): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      if (typeof this.socket === \"undefined\") {\n        reject(new Error(\"Connection already closed\"));\n        return;\n      }\n\n      this.socket.onclose = (event) => {\n        this.onClose(event);\n        resolve();\n      };\n\n      this.socket.close();\n    });\n  }\n\n  public async send(payload: JsonRpcPayload): Promise<void> {\n    if (typeof this.socket === \"undefined\") {\n      this.socket = await this.register();\n    }\n    try {\n      this.socket.send(safeJsonStringify(payload));\n    } catch (e) {\n      this.onError(payload.id, e as Error);\n    }\n  }\n\n  // ---------- Private ----------------------------------------------- //\n\n  private register(url = this.url): Promise<WebSocket> {\n    if (!isWsUrl(url)) {\n      throw new Error(`Provided URL is not compatible with WebSocket connection: ${url}`);\n    }\n    if (this.registering) {\n      const currentMaxListeners = this.events.getMaxListeners();\n      if (\n        this.events.listenerCount(\"register_error\") >= currentMaxListeners ||\n        this.events.listenerCount(\"open\") >= currentMaxListeners\n      ) {\n        this.events.setMaxListeners(currentMaxListeners + 1);\n      }\n      return new Promise((resolve, reject) => {\n        this.events.once(\"register_error\", (error) => {\n          this.resetMaxListeners();\n          reject(error);\n        });\n        this.events.once(\"open\", () => {\n          this.resetMaxListeners();\n          if (typeof this.socket === \"undefined\") {\n            return reject(new Error(\"WebSocket connection is missing or invalid\"));\n          }\n          resolve(this.socket);\n        });\n      });\n    }\n    this.url = url;\n    this.registering = true;\n\n    return new Promise((resolve, reject) => {\n      const opts = !isReactNative() ? { rejectUnauthorized: !isLocalhostUrl(url) } : undefined;\n      const socket: WebSocket = new WS(url, [], opts);\n      if (hasBuiltInWebSocket()) {\n        socket.onerror = (event: Event) => {\n          const errorEvent = event as ErrorEvent;\n          reject(this.emitError(errorEvent.error));\n        };\n      } else {\n        (socket as any).on(\"error\", (errorEvent: any) => {\n          reject(this.emitError(errorEvent));\n        });\n      }\n      socket.onopen = () => {\n        this.onOpen(socket);\n        resolve(socket);\n      };\n    });\n  }\n\n  private onOpen(socket: WebSocket) {\n    socket.onmessage = (event: MessageEvent) => this.onPayload(event);\n    socket.onclose = (event) => this.onClose(event);\n    this.socket = socket;\n    this.registering = false;\n    this.events.emit(\"open\");\n  }\n\n  private onClose(event: CloseEvent) {\n    this.socket = undefined;\n    this.registering = false;\n    this.events.emit(\"close\", event);\n  }\n\n  private onPayload(e: { data: any }) {\n    if (typeof e.data === \"undefined\") return;\n    const payload: JsonRpcPayload = typeof e.data === \"string\" ? safeJsonParse(e.data) : e.data;\n    this.events.emit(\"payload\", payload);\n  }\n\n  private onError(id: number, e: Error) {\n    const error = this.parseError(e);\n    const message = error.message || error.toString();\n    const payload = formatJsonRpcError(id, message);\n    this.events.emit(\"payload\", payload);\n  }\n\n  private parseError(e: Error, url = this.url) {\n    return parseConnectionError(e, truncateQuery(url), \"WS\");\n  }\n\n  private resetMaxListeners() {\n    if (this.events.getMaxListeners() > EVENT_EMITTER_MAX_LISTENERS_DEFAULT) {\n      this.events.setMaxListeners(EVENT_EMITTER_MAX_LISTENERS_DEFAULT);\n    }\n  }\n\n  private emitError(errorEvent: Error) {\n    const error = this.parseError(\n      new Error(\n        errorEvent?.message || `WebSocket connection failed for host: ${truncateQuery(this.url)}`,\n      ),\n    );\n    this.events.emit(\"register_error\", error);\n    return error;\n  }\n}\n\nexport default WsConnection;\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}