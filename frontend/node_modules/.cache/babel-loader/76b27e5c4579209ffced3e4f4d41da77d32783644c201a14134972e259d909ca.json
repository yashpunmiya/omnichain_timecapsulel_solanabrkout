{"ast":null,"code":"import ft from \"@walletconnect/sign-client\";\nimport { isValidObject as mt, isCaipNamespace as fe, parseNamespaceKey as U, mergeArrays as ee, parseChainId as me, getSdkError as ge, isValidArray as Pe } from \"@walletconnect/utils\";\nimport { pino as gt, getDefaultLoggerOptions as Pt } from \"@walletconnect/logger\";\nimport b, { HttpConnection as bt } from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider as m } from \"@walletconnect/jsonrpc-provider\";\nimport { formatJsonRpcRequest as $t, formatJsonRpcResult as yt } from \"@walletconnect/jsonrpc-utils\";\nimport wt from \"events\";\nconst be = \"error\",\n  _t = \"wss://relay.walletconnect.org\",\n  Ct = \"wc\",\n  It = \"universal_provider\",\n  $e = `${Ct}@2:${It}:`,\n  ye = \"https://rpc.walletconnect.org/v1/\",\n  w = \"generic\",\n  Ot = `${ye}bundler`,\n  f = {\n    DEFAULT_CHAIN_CHANGED: \"default_chain_changed\"\n  };\nvar G = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof global < \"u\" ? global : typeof self < \"u\" ? self : {};\nfunction At() {\n  this.__data__ = [], this.size = 0;\n}\nvar jt = At;\nfunction Ht(r, e) {\n  return r === e || r !== r && e !== e;\n}\nvar z = Ht,\n  Et = z;\nfunction St(r, e) {\n  for (var t = r.length; t--;) if (Et(r[t][0], e)) return t;\n  return -1;\n}\nvar k = St,\n  Nt = k,\n  Tt = Array.prototype,\n  Dt = Tt.splice;\nfunction qt(r) {\n  var e = this.__data__,\n    t = Nt(e, r);\n  if (t < 0) return !1;\n  var i = e.length - 1;\n  return t == i ? e.pop() : Dt.call(e, t, 1), --this.size, !0;\n}\nvar Rt = qt,\n  xt = k;\nfunction Lt(r) {\n  var e = this.__data__,\n    t = xt(e, r);\n  return t < 0 ? void 0 : e[t][1];\n}\nvar Ut = Lt,\n  Ft = k;\nfunction Mt(r) {\n  return Ft(this.__data__, r) > -1;\n}\nvar Gt = Mt,\n  zt = k;\nfunction kt(r, e) {\n  var t = this.__data__,\n    i = zt(t, r);\n  return i < 0 ? (++this.size, t.push([r, e])) : t[i][1] = e, this;\n}\nvar Bt = kt,\n  Vt = jt,\n  Jt = Rt,\n  Kt = Ut,\n  Wt = Gt,\n  Xt = Bt;\nfunction _(r) {\n  var e = -1,\n    t = r == null ? 0 : r.length;\n  for (this.clear(); ++e < t;) {\n    var i = r[e];\n    this.set(i[0], i[1]);\n  }\n}\n_.prototype.clear = Vt, _.prototype.delete = Jt, _.prototype.get = Kt, _.prototype.has = Wt, _.prototype.set = Xt;\nvar B = _,\n  Yt = B;\nfunction Zt() {\n  this.__data__ = new Yt(), this.size = 0;\n}\nvar Qt = Zt;\nfunction er(r) {\n  var e = this.__data__,\n    t = e.delete(r);\n  return this.size = e.size, t;\n}\nvar tr = er;\nfunction rr(r) {\n  return this.__data__.get(r);\n}\nvar ir = rr;\nfunction sr(r) {\n  return this.__data__.has(r);\n}\nvar nr = sr,\n  ar = typeof G == \"object\" && G && G.Object === Object && G,\n  we = ar,\n  or = we,\n  cr = typeof self == \"object\" && self && self.Object === Object && self,\n  hr = or || cr || Function(\"return this\")(),\n  C = hr,\n  pr = C,\n  ur = pr.Symbol,\n  _e = ur,\n  Ce = _e,\n  Ie = Object.prototype,\n  lr = Ie.hasOwnProperty,\n  dr = Ie.toString,\n  F = Ce ? Ce.toStringTag : void 0;\nfunction vr(r) {\n  var e = lr.call(r, F),\n    t = r[F];\n  try {\n    r[F] = void 0;\n    var i = !0;\n  } catch {}\n  var s = dr.call(r);\n  return i && (e ? r[F] = t : delete r[F]), s;\n}\nvar fr = vr,\n  mr = Object.prototype,\n  gr = mr.toString;\nfunction Pr(r) {\n  return gr.call(r);\n}\nvar br = Pr,\n  Oe = _e,\n  $r = fr,\n  yr = br,\n  wr = \"[object Null]\",\n  _r = \"[object Undefined]\",\n  Ae = Oe ? Oe.toStringTag : void 0;\nfunction Cr(r) {\n  return r == null ? r === void 0 ? _r : wr : Ae && Ae in Object(r) ? $r(r) : yr(r);\n}\nvar V = Cr;\nfunction Ir(r) {\n  var e = typeof r;\n  return r != null && (e == \"object\" || e == \"function\");\n}\nvar $ = Ir,\n  Or = V,\n  Ar = $,\n  jr = \"[object AsyncFunction]\",\n  Hr = \"[object Function]\",\n  Er = \"[object GeneratorFunction]\",\n  Sr = \"[object Proxy]\";\nfunction Nr(r) {\n  if (!Ar(r)) return !1;\n  var e = Or(r);\n  return e == Hr || e == Er || e == jr || e == Sr;\n}\nvar te = Nr,\n  Tr = C,\n  Dr = Tr[\"__core-js_shared__\"],\n  qr = Dr,\n  re = qr,\n  je = function () {\n    var r = /[^.]+$/.exec(re && re.keys && re.keys.IE_PROTO || \"\");\n    return r ? \"Symbol(src)_1.\" + r : \"\";\n  }();\nfunction Rr(r) {\n  return !!je && je in r;\n}\nvar xr = Rr,\n  Lr = Function.prototype,\n  Ur = Lr.toString;\nfunction Fr(r) {\n  if (r != null) {\n    try {\n      return Ur.call(r);\n    } catch {}\n    try {\n      return r + \"\";\n    } catch {}\n  }\n  return \"\";\n}\nvar Mr = Fr,\n  Gr = te,\n  zr = xr,\n  kr = $,\n  Br = Mr,\n  Vr = /[\\\\^$.*+?()[\\]{}|]/g,\n  Jr = /^\\[object .+?Constructor\\]$/,\n  Kr = Function.prototype,\n  Wr = Object.prototype,\n  Xr = Kr.toString,\n  Yr = Wr.hasOwnProperty,\n  Zr = RegExp(\"^\" + Xr.call(Yr).replace(Vr, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\");\nfunction Qr(r) {\n  if (!kr(r) || zr(r)) return !1;\n  var e = Gr(r) ? Zr : Jr;\n  return e.test(Br(r));\n}\nvar ei = Qr;\nfunction ti(r, e) {\n  return r?.[e];\n}\nvar ri = ti,\n  ii = ei,\n  si = ri;\nfunction ni(r, e) {\n  var t = si(r, e);\n  return ii(t) ? t : void 0;\n}\nvar ie = ni,\n  ai = ie,\n  oi = C,\n  ci = ai(oi, \"Map\"),\n  He = ci,\n  hi = ie,\n  pi = hi(Object, \"create\"),\n  J = pi,\n  Ee = J;\nfunction ui() {\n  this.__data__ = Ee ? Ee(null) : {}, this.size = 0;\n}\nvar li = ui;\nfunction di(r) {\n  var e = this.has(r) && delete this.__data__[r];\n  return this.size -= e ? 1 : 0, e;\n}\nvar vi = di,\n  fi = J,\n  mi = \"__lodash_hash_undefined__\",\n  gi = Object.prototype,\n  Pi = gi.hasOwnProperty;\nfunction bi(r) {\n  var e = this.__data__;\n  if (fi) {\n    var t = e[r];\n    return t === mi ? void 0 : t;\n  }\n  return Pi.call(e, r) ? e[r] : void 0;\n}\nvar $i = bi,\n  yi = J,\n  wi = Object.prototype,\n  _i = wi.hasOwnProperty;\nfunction Ci(r) {\n  var e = this.__data__;\n  return yi ? e[r] !== void 0 : _i.call(e, r);\n}\nvar Ii = Ci,\n  Oi = J,\n  Ai = \"__lodash_hash_undefined__\";\nfunction ji(r, e) {\n  var t = this.__data__;\n  return this.size += this.has(r) ? 0 : 1, t[r] = Oi && e === void 0 ? Ai : e, this;\n}\nvar Hi = ji,\n  Ei = li,\n  Si = vi,\n  Ni = $i,\n  Ti = Ii,\n  Di = Hi;\nfunction I(r) {\n  var e = -1,\n    t = r == null ? 0 : r.length;\n  for (this.clear(); ++e < t;) {\n    var i = r[e];\n    this.set(i[0], i[1]);\n  }\n}\nI.prototype.clear = Ei, I.prototype.delete = Si, I.prototype.get = Ni, I.prototype.has = Ti, I.prototype.set = Di;\nvar qi = I,\n  Se = qi,\n  Ri = B,\n  xi = He;\nfunction Li() {\n  this.size = 0, this.__data__ = {\n    hash: new Se(),\n    map: new (xi || Ri)(),\n    string: new Se()\n  };\n}\nvar Ui = Li;\nfunction Fi(r) {\n  var e = typeof r;\n  return e == \"string\" || e == \"number\" || e == \"symbol\" || e == \"boolean\" ? r !== \"__proto__\" : r === null;\n}\nvar Mi = Fi,\n  Gi = Mi;\nfunction zi(r, e) {\n  var t = r.__data__;\n  return Gi(e) ? t[typeof e == \"string\" ? \"string\" : \"hash\"] : t.map;\n}\nvar K = zi,\n  ki = K;\nfunction Bi(r) {\n  var e = ki(this, r).delete(r);\n  return this.size -= e ? 1 : 0, e;\n}\nvar Vi = Bi,\n  Ji = K;\nfunction Ki(r) {\n  return Ji(this, r).get(r);\n}\nvar Wi = Ki,\n  Xi = K;\nfunction Yi(r) {\n  return Xi(this, r).has(r);\n}\nvar Zi = Yi,\n  Qi = K;\nfunction es(r, e) {\n  var t = Qi(this, r),\n    i = t.size;\n  return t.set(r, e), this.size += t.size == i ? 0 : 1, this;\n}\nvar ts = es,\n  rs = Ui,\n  is = Vi,\n  ss = Wi,\n  ns = Zi,\n  as = ts;\nfunction O(r) {\n  var e = -1,\n    t = r == null ? 0 : r.length;\n  for (this.clear(); ++e < t;) {\n    var i = r[e];\n    this.set(i[0], i[1]);\n  }\n}\nO.prototype.clear = rs, O.prototype.delete = is, O.prototype.get = ss, O.prototype.has = ns, O.prototype.set = as;\nvar os = O,\n  cs = B,\n  hs = He,\n  ps = os,\n  us = 200;\nfunction ls(r, e) {\n  var t = this.__data__;\n  if (t instanceof cs) {\n    var i = t.__data__;\n    if (!hs || i.length < us - 1) return i.push([r, e]), this.size = ++t.size, this;\n    t = this.__data__ = new ps(i);\n  }\n  return t.set(r, e), this.size = t.size, this;\n}\nvar ds = ls,\n  vs = B,\n  fs = Qt,\n  ms = tr,\n  gs = ir,\n  Ps = nr,\n  bs = ds;\nfunction A(r) {\n  var e = this.__data__ = new vs(r);\n  this.size = e.size;\n}\nA.prototype.clear = fs, A.prototype.delete = ms, A.prototype.get = gs, A.prototype.has = Ps, A.prototype.set = bs;\nvar $s = A,\n  ys = ie,\n  ws = function () {\n    try {\n      var r = ys(Object, \"defineProperty\");\n      return r({}, \"\", {}), r;\n    } catch {}\n  }(),\n  Ne = ws,\n  Te = Ne;\nfunction _s(r, e, t) {\n  e == \"__proto__\" && Te ? Te(r, e, {\n    configurable: !0,\n    enumerable: !0,\n    value: t,\n    writable: !0\n  }) : r[e] = t;\n}\nvar se = _s,\n  Cs = se,\n  Is = z;\nfunction Os(r, e, t) {\n  (t !== void 0 && !Is(r[e], t) || t === void 0 && !(e in r)) && Cs(r, e, t);\n}\nvar De = Os;\nfunction As(r) {\n  return function (e, t, i) {\n    for (var s = -1, n = Object(e), a = i(e), o = a.length; o--;) {\n      var c = a[r ? o : ++s];\n      if (t(n[c], c, n) === !1) break;\n    }\n    return e;\n  };\n}\nvar js = As,\n  Hs = js,\n  Es = Hs(),\n  Ss = Es,\n  ne = {\n    exports: {}\n  };\n(function (r, e) {\n  var t = C,\n    i = e && !e.nodeType && e,\n    s = i && !0 && r && !r.nodeType && r,\n    n = s && s.exports === i,\n    a = n ? t.Buffer : void 0,\n    o = a ? a.allocUnsafe : void 0;\n  function c(u, l) {\n    if (l) return u.slice();\n    var P = u.length,\n      d = o ? o(P) : new u.constructor(P);\n    return u.copy(d), d;\n  }\n  r.exports = c;\n})(ne, ne.exports);\nvar Ns = C,\n  Ts = Ns.Uint8Array,\n  Ds = Ts,\n  qe = Ds;\nfunction qs(r) {\n  var e = new r.constructor(r.byteLength);\n  return new qe(e).set(new qe(r)), e;\n}\nvar Rs = qs,\n  xs = Rs;\nfunction Ls(r, e) {\n  var t = e ? xs(r.buffer) : r.buffer;\n  return new r.constructor(t, r.byteOffset, r.length);\n}\nvar Us = Ls;\nfunction Fs(r, e) {\n  var t = -1,\n    i = r.length;\n  for (e || (e = Array(i)); ++t < i;) e[t] = r[t];\n  return e;\n}\nvar Ms = Fs,\n  Gs = $,\n  Re = Object.create,\n  zs = function () {\n    function r() {}\n    return function (e) {\n      if (!Gs(e)) return {};\n      if (Re) return Re(e);\n      r.prototype = e;\n      var t = new r();\n      return r.prototype = void 0, t;\n    };\n  }(),\n  ks = zs;\nfunction Bs(r, e) {\n  return function (t) {\n    return r(e(t));\n  };\n}\nvar Vs = Bs,\n  Js = Vs,\n  Ks = Js(Object.getPrototypeOf, Object),\n  xe = Ks,\n  Ws = Object.prototype;\nfunction Xs(r) {\n  var e = r && r.constructor,\n    t = typeof e == \"function\" && e.prototype || Ws;\n  return r === t;\n}\nvar Le = Xs,\n  Ys = ks,\n  Zs = xe,\n  Qs = Le;\nfunction en(r) {\n  return typeof r.constructor == \"function\" && !Qs(r) ? Ys(Zs(r)) : {};\n}\nvar tn = en;\nfunction rn(r) {\n  return r != null && typeof r == \"object\";\n}\nvar M = rn,\n  sn = V,\n  nn = M,\n  an = \"[object Arguments]\";\nfunction on(r) {\n  return nn(r) && sn(r) == an;\n}\nvar cn = on,\n  Ue = cn,\n  hn = M,\n  Fe = Object.prototype,\n  pn = Fe.hasOwnProperty,\n  un = Fe.propertyIsEnumerable,\n  ln = Ue(function () {\n    return arguments;\n  }()) ? Ue : function (r) {\n    return hn(r) && pn.call(r, \"callee\") && !un.call(r, \"callee\");\n  },\n  Me = ln,\n  dn = Array.isArray,\n  Ge = dn,\n  vn = 9007199254740991;\nfunction fn(r) {\n  return typeof r == \"number\" && r > -1 && r % 1 == 0 && r <= vn;\n}\nvar ze = fn,\n  mn = te,\n  gn = ze;\nfunction Pn(r) {\n  return r != null && gn(r.length) && !mn(r);\n}\nvar ae = Pn,\n  bn = ae,\n  $n = M;\nfunction yn(r) {\n  return $n(r) && bn(r);\n}\nvar wn = yn,\n  W = {\n    exports: {}\n  };\nfunction _n() {\n  return !1;\n}\nvar Cn = _n;\n(function (r, e) {\n  var t = C,\n    i = Cn,\n    s = e && !e.nodeType && e,\n    n = s && !0 && r && !r.nodeType && r,\n    a = n && n.exports === s,\n    o = a ? t.Buffer : void 0,\n    c = o ? o.isBuffer : void 0,\n    u = c || i;\n  r.exports = u;\n})(W, W.exports);\nvar In = V,\n  On = xe,\n  An = M,\n  jn = \"[object Object]\",\n  Hn = Function.prototype,\n  En = Object.prototype,\n  ke = Hn.toString,\n  Sn = En.hasOwnProperty,\n  Nn = ke.call(Object);\nfunction Tn(r) {\n  if (!An(r) || In(r) != jn) return !1;\n  var e = On(r);\n  if (e === null) return !0;\n  var t = Sn.call(e, \"constructor\") && e.constructor;\n  return typeof t == \"function\" && t instanceof t && ke.call(t) == Nn;\n}\nvar Dn = Tn,\n  qn = V,\n  Rn = ze,\n  xn = M,\n  Ln = \"[object Arguments]\",\n  Un = \"[object Array]\",\n  Fn = \"[object Boolean]\",\n  Mn = \"[object Date]\",\n  Gn = \"[object Error]\",\n  zn = \"[object Function]\",\n  kn = \"[object Map]\",\n  Bn = \"[object Number]\",\n  Vn = \"[object Object]\",\n  Jn = \"[object RegExp]\",\n  Kn = \"[object Set]\",\n  Wn = \"[object String]\",\n  Xn = \"[object WeakMap]\",\n  Yn = \"[object ArrayBuffer]\",\n  Zn = \"[object DataView]\",\n  Qn = \"[object Float32Array]\",\n  ea = \"[object Float64Array]\",\n  ta = \"[object Int8Array]\",\n  ra = \"[object Int16Array]\",\n  ia = \"[object Int32Array]\",\n  sa = \"[object Uint8Array]\",\n  na = \"[object Uint8ClampedArray]\",\n  aa = \"[object Uint16Array]\",\n  oa = \"[object Uint32Array]\",\n  p = {};\np[Qn] = p[ea] = p[ta] = p[ra] = p[ia] = p[sa] = p[na] = p[aa] = p[oa] = !0, p[Ln] = p[Un] = p[Yn] = p[Fn] = p[Zn] = p[Mn] = p[Gn] = p[zn] = p[kn] = p[Bn] = p[Vn] = p[Jn] = p[Kn] = p[Wn] = p[Xn] = !1;\nfunction ca(r) {\n  return xn(r) && Rn(r.length) && !!p[qn(r)];\n}\nvar ha = ca;\nfunction pa(r) {\n  return function (e) {\n    return r(e);\n  };\n}\nvar ua = pa,\n  oe = {\n    exports: {}\n  };\n(function (r, e) {\n  var t = we,\n    i = e && !e.nodeType && e,\n    s = i && !0 && r && !r.nodeType && r,\n    n = s && s.exports === i,\n    a = n && t.process,\n    o = function () {\n      try {\n        var c = s && s.require && s.require(\"util\").types;\n        return c || a && a.binding && a.binding(\"util\");\n      } catch {}\n    }();\n  r.exports = o;\n})(oe, oe.exports);\nvar la = ha,\n  da = ua,\n  Be = oe.exports,\n  Ve = Be && Be.isTypedArray,\n  va = Ve ? da(Ve) : la,\n  Je = va;\nfunction fa(r, e) {\n  if (!(e === \"constructor\" && typeof r[e] == \"function\") && e != \"__proto__\") return r[e];\n}\nvar Ke = fa,\n  ma = se,\n  ga = z,\n  Pa = Object.prototype,\n  ba = Pa.hasOwnProperty;\nfunction $a(r, e, t) {\n  var i = r[e];\n  (!(ba.call(r, e) && ga(i, t)) || t === void 0 && !(e in r)) && ma(r, e, t);\n}\nvar ya = $a,\n  wa = ya,\n  _a = se;\nfunction Ca(r, e, t, i) {\n  var s = !t;\n  t || (t = {});\n  for (var n = -1, a = e.length; ++n < a;) {\n    var o = e[n],\n      c = i ? i(t[o], r[o], o, t, r) : void 0;\n    c === void 0 && (c = r[o]), s ? _a(t, o, c) : wa(t, o, c);\n  }\n  return t;\n}\nvar Ia = Ca;\nfunction Oa(r, e) {\n  for (var t = -1, i = Array(r); ++t < r;) i[t] = e(t);\n  return i;\n}\nvar Aa = Oa,\n  ja = 9007199254740991,\n  Ha = /^(?:0|[1-9]\\d*)$/;\nfunction Ea(r, e) {\n  var t = typeof r;\n  return e = e ?? ja, !!e && (t == \"number\" || t != \"symbol\" && Ha.test(r)) && r > -1 && r % 1 == 0 && r < e;\n}\nvar We = Ea,\n  Sa = Aa,\n  Na = Me,\n  Ta = Ge,\n  Da = W.exports,\n  qa = We,\n  Ra = Je,\n  xa = Object.prototype,\n  La = xa.hasOwnProperty;\nfunction Ua(r, e) {\n  var t = Ta(r),\n    i = !t && Na(r),\n    s = !t && !i && Da(r),\n    n = !t && !i && !s && Ra(r),\n    a = t || i || s || n,\n    o = a ? Sa(r.length, String) : [],\n    c = o.length;\n  for (var u in r) (e || La.call(r, u)) && !(a && (u == \"length\" || s && (u == \"offset\" || u == \"parent\") || n && (u == \"buffer\" || u == \"byteLength\" || u == \"byteOffset\") || qa(u, c))) && o.push(u);\n  return o;\n}\nvar Fa = Ua;\nfunction Ma(r) {\n  var e = [];\n  if (r != null) for (var t in Object(r)) e.push(t);\n  return e;\n}\nvar Ga = Ma,\n  za = $,\n  ka = Le,\n  Ba = Ga,\n  Va = Object.prototype,\n  Ja = Va.hasOwnProperty;\nfunction Ka(r) {\n  if (!za(r)) return Ba(r);\n  var e = ka(r),\n    t = [];\n  for (var i in r) i == \"constructor\" && (e || !Ja.call(r, i)) || t.push(i);\n  return t;\n}\nvar Wa = Ka,\n  Xa = Fa,\n  Ya = Wa,\n  Za = ae;\nfunction Qa(r) {\n  return Za(r) ? Xa(r, !0) : Ya(r);\n}\nvar Xe = Qa,\n  eo = Ia,\n  to = Xe;\nfunction ro(r) {\n  return eo(r, to(r));\n}\nvar io = ro,\n  Ye = De,\n  so = ne.exports,\n  no = Us,\n  ao = Ms,\n  oo = tn,\n  Ze = Me,\n  Qe = Ge,\n  co = wn,\n  ho = W.exports,\n  po = te,\n  uo = $,\n  lo = Dn,\n  vo = Je,\n  et = Ke,\n  fo = io;\nfunction mo(r, e, t, i, s, n, a) {\n  var o = et(r, t),\n    c = et(e, t),\n    u = a.get(c);\n  if (u) {\n    Ye(r, t, u);\n    return;\n  }\n  var l = n ? n(o, c, t + \"\", r, e, a) : void 0,\n    P = l === void 0;\n  if (P) {\n    var d = Qe(c),\n      Q = !d && ho(c),\n      ve = !d && !Q && vo(c);\n    l = c, d || Q || ve ? Qe(o) ? l = o : co(o) ? l = ao(o) : Q ? (P = !1, l = so(c, !0)) : ve ? (P = !1, l = no(c, !0)) : l = [] : lo(c) || Ze(c) ? (l = o, Ze(o) ? l = fo(o) : (!uo(o) || po(o)) && (l = oo(c))) : P = !1;\n  }\n  P && (a.set(c, l), s(l, c, i, n, a), a.delete(c)), Ye(r, t, l);\n}\nvar go = mo,\n  Po = $s,\n  bo = De,\n  $o = Ss,\n  yo = go,\n  wo = $,\n  _o = Xe,\n  Co = Ke;\nfunction tt(r, e, t, i, s) {\n  r !== e && $o(e, function (n, a) {\n    if (s || (s = new Po()), wo(n)) yo(r, e, a, t, tt, i, s);else {\n      var o = i ? i(Co(r, a), n, a + \"\", r, e, s) : void 0;\n      o === void 0 && (o = n), bo(r, a, o);\n    }\n  }, _o);\n}\nvar Io = tt;\nfunction Oo(r) {\n  return r;\n}\nvar rt = Oo;\nfunction Ao(r, e, t) {\n  switch (t.length) {\n    case 0:\n      return r.call(e);\n    case 1:\n      return r.call(e, t[0]);\n    case 2:\n      return r.call(e, t[0], t[1]);\n    case 3:\n      return r.call(e, t[0], t[1], t[2]);\n  }\n  return r.apply(e, t);\n}\nvar jo = Ao,\n  Ho = jo,\n  it = Math.max;\nfunction Eo(r, e, t) {\n  return e = it(e === void 0 ? r.length - 1 : e, 0), function () {\n    for (var i = arguments, s = -1, n = it(i.length - e, 0), a = Array(n); ++s < n;) a[s] = i[e + s];\n    s = -1;\n    for (var o = Array(e + 1); ++s < e;) o[s] = i[s];\n    return o[e] = t(a), Ho(r, this, o);\n  };\n}\nvar So = Eo;\nfunction No(r) {\n  return function () {\n    return r;\n  };\n}\nvar To = No,\n  Do = To,\n  st = Ne,\n  qo = rt,\n  Ro = st ? function (r, e) {\n    return st(r, \"toString\", {\n      configurable: !0,\n      enumerable: !1,\n      value: Do(e),\n      writable: !0\n    });\n  } : qo,\n  xo = Ro,\n  Lo = 800,\n  Uo = 16,\n  Fo = Date.now;\nfunction Mo(r) {\n  var e = 0,\n    t = 0;\n  return function () {\n    var i = Fo(),\n      s = Uo - (i - t);\n    if (t = i, s > 0) {\n      if (++e >= Lo) return arguments[0];\n    } else e = 0;\n    return r.apply(void 0, arguments);\n  };\n}\nvar Go = Mo,\n  zo = xo,\n  ko = Go,\n  Bo = ko(zo),\n  Vo = Bo,\n  Jo = rt,\n  Ko = So,\n  Wo = Vo;\nfunction Xo(r, e) {\n  return Wo(Ko(r, e, Jo), r + \"\");\n}\nvar Yo = Xo,\n  Zo = z,\n  Qo = ae,\n  ec = We,\n  tc = $;\nfunction rc(r, e, t) {\n  if (!tc(t)) return !1;\n  var i = typeof e;\n  return (i == \"number\" ? Qo(t) && ec(e, t.length) : i == \"string\" && e in t) ? Zo(t[e], r) : !1;\n}\nvar ic = rc,\n  sc = Yo,\n  nc = ic;\nfunction ac(r) {\n  return sc(function (e, t) {\n    var i = -1,\n      s = t.length,\n      n = s > 1 ? t[s - 1] : void 0,\n      a = s > 2 ? t[2] : void 0;\n    for (n = r.length > 3 && typeof n == \"function\" ? (s--, n) : void 0, a && nc(t[0], t[1], a) && (n = s < 3 ? void 0 : n, s = 1), e = Object(e); ++i < s;) {\n      var o = t[i];\n      o && r(e, o, i, n);\n    }\n    return e;\n  });\n}\nvar oc = ac,\n  cc = Io,\n  hc = oc,\n  pc = hc(function (r, e, t) {\n    cc(r, e, t);\n  }),\n  uc = pc,\n  lc = Object.defineProperty,\n  dc = Object.defineProperties,\n  vc = Object.getOwnPropertyDescriptors,\n  nt = Object.getOwnPropertySymbols,\n  fc = Object.prototype.hasOwnProperty,\n  mc = Object.prototype.propertyIsEnumerable,\n  at = (r, e, t) => e in r ? lc(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  X = (r, e) => {\n    for (var t in e || (e = {})) fc.call(e, t) && at(r, t, e[t]);\n    if (nt) for (var t of nt(e)) mc.call(e, t) && at(r, t, e[t]);\n    return r;\n  },\n  gc = (r, e) => dc(r, vc(e));\nfunction v(r, e, t) {\n  var i;\n  const s = me(r);\n  return ((i = e.rpcMap) == null ? void 0 : i[s.reference]) || `${ye}?chainId=${s.namespace}:${s.reference}&projectId=${t}`;\n}\nfunction y(r) {\n  return r.includes(\":\") ? r.split(\":\")[1] : r;\n}\nfunction ot(r) {\n  return r.map(e => `${e.split(\":\")[0]}:${e.split(\":\")[1]}`);\n}\nfunction Pc(r, e) {\n  const t = Object.keys(e.namespaces).filter(s => s.includes(r));\n  if (!t.length) return [];\n  const i = [];\n  return t.forEach(s => {\n    const n = e.namespaces[s].accounts;\n    i.push(...n);\n  }), i;\n}\nfunction ce(r = {}, e = {}) {\n  const t = ct(r),\n    i = ct(e);\n  return uc(t, i);\n}\nfunction ct(r) {\n  var e, t, i, s;\n  const n = {};\n  if (!mt(r)) return n;\n  for (const [a, o] of Object.entries(r)) {\n    const c = fe(a) ? [a] : o.chains,\n      u = o.methods || [],\n      l = o.events || [],\n      P = o.rpcMap || {},\n      d = U(a);\n    n[d] = gc(X(X({}, n[d]), o), {\n      chains: ee(c, (e = n[d]) == null ? void 0 : e.chains),\n      methods: ee(u, (t = n[d]) == null ? void 0 : t.methods),\n      events: ee(l, (i = n[d]) == null ? void 0 : i.events),\n      rpcMap: X(X({}, P), (s = n[d]) == null ? void 0 : s.rpcMap)\n    });\n  }\n  return n;\n}\nfunction bc(r) {\n  return r.includes(\":\") ? r.split(\":\")[2] : r;\n}\nfunction ht(r) {\n  const e = {};\n  for (const [t, i] of Object.entries(r)) {\n    const s = i.methods || [],\n      n = i.events || [],\n      a = i.accounts || [],\n      o = fe(t) ? [t] : i.chains ? i.chains : ot(i.accounts);\n    e[t] = {\n      chains: o,\n      methods: s,\n      events: n,\n      accounts: a\n    };\n  }\n  return e;\n}\nfunction he(r) {\n  return typeof r == \"number\" ? r : r.includes(\"0x\") ? parseInt(r, 16) : (r = r.includes(\":\") ? r.split(\":\")[1] : r, isNaN(Number(r)) ? r : Number(r));\n}\nconst pt = {},\n  h = r => pt[r],\n  pe = (r, e) => {\n    pt[r] = e;\n  };\nvar $c = Object.defineProperty,\n  yc = (r, e, t) => e in r ? $c(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  j = (r, e, t) => yc(r, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass wc {\n  constructor(e) {\n    j(this, \"name\", \"polkadot\"), j(this, \"client\"), j(this, \"httpProviders\"), j(this, \"events\"), j(this, \"namespace\"), j(this, \"chainId\"), this.namespace = e.namespace, this.events = h(\"events\"), this.client = h(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(e) {\n    this.namespace = Object.assign(this.namespace, e);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const e = this.namespace.chains[0];\n    if (!e) throw new Error(\"ChainId not found\");\n    return e.split(\":\")[1];\n  }\n  request(e) {\n    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);\n  }\n  setDefaultChain(e, t) {\n    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(f.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);\n  }\n  getAccounts() {\n    const e = this.namespace.accounts;\n    return e ? e.filter(t => t.split(\":\")[1] === this.chainId.toString()).map(t => t.split(\":\")[2]) || [] : [];\n  }\n  createHttpProviders() {\n    const e = {};\n    return this.namespace.chains.forEach(t => {\n      var i;\n      const s = y(t);\n      e[s] = this.createHttpProvider(s, (i = this.namespace.rpcMap) == null ? void 0 : i[t]);\n    }), e;\n  }\n  getHttpProvider() {\n    const e = `${this.name}:${this.chainId}`,\n      t = this.httpProviders[e];\n    if (typeof t > \"u\") throw new Error(`JSON-RPC provider for ${e} not found`);\n    return t;\n  }\n  setHttpProvider(e, t) {\n    const i = this.createHttpProvider(e, t);\n    i && (this.httpProviders[e] = i);\n  }\n  createHttpProvider(e, t) {\n    const i = t || v(e, this.namespace, this.client.core.projectId);\n    if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);\n    return new m(new b(i, h(\"disableProviderPing\")));\n  }\n}\nvar _c = Object.defineProperty,\n  Cc = Object.defineProperties,\n  Ic = Object.getOwnPropertyDescriptors,\n  ut = Object.getOwnPropertySymbols,\n  Oc = Object.prototype.hasOwnProperty,\n  Ac = Object.prototype.propertyIsEnumerable,\n  ue = (r, e, t) => e in r ? _c(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  lt = (r, e) => {\n    for (var t in e || (e = {})) Oc.call(e, t) && ue(r, t, e[t]);\n    if (ut) for (var t of ut(e)) Ac.call(e, t) && ue(r, t, e[t]);\n    return r;\n  },\n  dt = (r, e) => Cc(r, Ic(e)),\n  H = (r, e, t) => ue(r, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass jc {\n  constructor(e) {\n    H(this, \"name\", \"eip155\"), H(this, \"client\"), H(this, \"chainId\"), H(this, \"namespace\"), H(this, \"httpProviders\"), H(this, \"events\"), this.namespace = e.namespace, this.events = h(\"events\"), this.client = h(\"client\"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain());\n  }\n  async request(e) {\n    switch (e.request.method) {\n      case \"eth_requestAccounts\":\n        return this.getAccounts();\n      case \"eth_accounts\":\n        return this.getAccounts();\n      case \"wallet_switchEthereumChain\":\n        return await this.handleSwitchChain(e);\n      case \"eth_chainId\":\n        return parseInt(this.getDefaultChain());\n      case \"wallet_getCapabilities\":\n        return await this.getCapabilities(e);\n      case \"wallet_getCallsStatus\":\n        return await this.getCallStatus(e);\n    }\n    return this.namespace.methods.includes(e.request.method) ? await this.client.request(e) : this.getHttpProvider().request(e.request);\n  }\n  updateNamespace(e) {\n    this.namespace = Object.assign(this.namespace, e);\n  }\n  setDefaultChain(e, t) {\n    this.httpProviders[e] || this.setHttpProvider(parseInt(e), t), this.chainId = parseInt(e), this.events.emit(f.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId.toString();\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const e = this.namespace.chains[0];\n    if (!e) throw new Error(\"ChainId not found\");\n    return e.split(\":\")[1];\n  }\n  createHttpProvider(e, t) {\n    const i = t || v(`${this.name}:${e}`, this.namespace, this.client.core.projectId);\n    if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);\n    return new m(new bt(i, h(\"disableProviderPing\")));\n  }\n  setHttpProvider(e, t) {\n    const i = this.createHttpProvider(e, t);\n    i && (this.httpProviders[e] = i);\n  }\n  createHttpProviders() {\n    const e = {};\n    return this.namespace.chains.forEach(t => {\n      var i;\n      const s = parseInt(y(t));\n      e[s] = this.createHttpProvider(s, (i = this.namespace.rpcMap) == null ? void 0 : i[t]);\n    }), e;\n  }\n  getAccounts() {\n    const e = this.namespace.accounts;\n    return e ? [...new Set(e.filter(t => t.split(\":\")[1] === this.chainId.toString()).map(t => t.split(\":\")[2]))] : [];\n  }\n  getHttpProvider() {\n    const e = this.chainId,\n      t = this.httpProviders[e];\n    if (typeof t > \"u\") throw new Error(`JSON-RPC provider for ${e} not found`);\n    return t;\n  }\n  async handleSwitchChain(e) {\n    var t, i;\n    let s = e.request.params ? (t = e.request.params[0]) == null ? void 0 : t.chainId : \"0x0\";\n    s = s.startsWith(\"0x\") ? s : `0x${s}`;\n    const n = parseInt(s, 16);\n    if (this.isChainApproved(n)) this.setDefaultChain(`${n}`);else if (this.namespace.methods.includes(\"wallet_switchEthereumChain\")) await this.client.request({\n      topic: e.topic,\n      request: {\n        method: e.request.method,\n        params: [{\n          chainId: s\n        }]\n      },\n      chainId: (i = this.namespace.chains) == null ? void 0 : i[0]\n    }), this.setDefaultChain(`${n}`);else throw new Error(`Failed to switch to chain 'eip155:${n}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);\n    return null;\n  }\n  isChainApproved(e) {\n    return this.namespace.chains.includes(`${this.name}:${e}`);\n  }\n  async getCapabilities(e) {\n    var t, i, s;\n    const n = (i = (t = e.request) == null ? void 0 : t.params) == null ? void 0 : i[0];\n    if (!n) throw new Error(\"Missing address parameter in `wallet_getCapabilities` request\");\n    const a = this.client.session.get(e.topic),\n      o = ((s = a?.sessionProperties) == null ? void 0 : s.capabilities) || {};\n    if (o != null && o[n]) return o?.[n];\n    const c = await this.client.request(e);\n    try {\n      await this.client.session.update(e.topic, {\n        sessionProperties: dt(lt({}, a.sessionProperties || {}), {\n          capabilities: dt(lt({}, o || {}), {\n            [n]: c\n          })\n        })\n      });\n    } catch (u) {\n      console.warn(\"Failed to update session with capabilities\", u);\n    }\n    return c;\n  }\n  async getCallStatus(e) {\n    var t, i;\n    const s = this.client.session.get(e.topic),\n      n = (t = s.sessionProperties) == null ? void 0 : t.bundler_name;\n    if (n) {\n      const o = this.getBundlerUrl(e.chainId, n);\n      try {\n        return await this.getUserOperationReceipt(o, e);\n      } catch (c) {\n        console.warn(\"Failed to fetch call status from bundler\", c, o);\n      }\n    }\n    const a = (i = s.sessionProperties) == null ? void 0 : i.bundler_url;\n    if (a) try {\n      return await this.getUserOperationReceipt(a, e);\n    } catch (o) {\n      console.warn(\"Failed to fetch call status from custom bundler\", o, a);\n    }\n    if (this.namespace.methods.includes(e.request.method)) return await this.client.request(e);\n    throw new Error(\"Fetching call status not approved by the wallet.\");\n  }\n  async getUserOperationReceipt(e, t) {\n    var i;\n    const s = new URL(e),\n      n = await fetch(s, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify($t(\"eth_getUserOperationReceipt\", [(i = t.request.params) == null ? void 0 : i[0]]))\n      });\n    if (!n.ok) throw new Error(`Failed to fetch user operation receipt - ${n.status}`);\n    return await n.json();\n  }\n  getBundlerUrl(e, t) {\n    return `${Ot}?projectId=${this.client.core.projectId}&chainId=${e}&bundler=${t}`;\n  }\n}\nvar Hc = Object.defineProperty,\n  Ec = (r, e, t) => e in r ? Hc(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  E = (r, e, t) => Ec(r, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass Sc {\n  constructor(e) {\n    E(this, \"name\", \"solana\"), E(this, \"client\"), E(this, \"httpProviders\"), E(this, \"events\"), E(this, \"namespace\"), E(this, \"chainId\"), this.namespace = e.namespace, this.events = h(\"events\"), this.client = h(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(e) {\n    this.namespace = Object.assign(this.namespace, e);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  request(e) {\n    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);\n  }\n  setDefaultChain(e, t) {\n    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(f.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const e = this.namespace.chains[0];\n    if (!e) throw new Error(\"ChainId not found\");\n    return e.split(\":\")[1];\n  }\n  getAccounts() {\n    const e = this.namespace.accounts;\n    return e ? [...new Set(e.filter(t => t.split(\":\")[1] === this.chainId.toString()).map(t => t.split(\":\")[2]))] : [];\n  }\n  createHttpProviders() {\n    const e = {};\n    return this.namespace.chains.forEach(t => {\n      var i;\n      const s = y(t);\n      e[s] = this.createHttpProvider(s, (i = this.namespace.rpcMap) == null ? void 0 : i[t]);\n    }), e;\n  }\n  getHttpProvider() {\n    const e = `${this.name}:${this.chainId}`,\n      t = this.httpProviders[e];\n    if (typeof t > \"u\") throw new Error(`JSON-RPC provider for ${e} not found`);\n    return t;\n  }\n  setHttpProvider(e, t) {\n    const i = this.createHttpProvider(e, t);\n    i && (this.httpProviders[e] = i);\n  }\n  createHttpProvider(e, t) {\n    const i = t || v(e, this.namespace, this.client.core.projectId);\n    if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);\n    return new m(new b(i, h(\"disableProviderPing\")));\n  }\n}\nvar Nc = Object.defineProperty,\n  Tc = (r, e, t) => e in r ? Nc(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  S = (r, e, t) => Tc(r, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass Dc {\n  constructor(e) {\n    S(this, \"name\", \"cosmos\"), S(this, \"client\"), S(this, \"httpProviders\"), S(this, \"events\"), S(this, \"namespace\"), S(this, \"chainId\"), this.namespace = e.namespace, this.events = h(\"events\"), this.client = h(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(e) {\n    this.namespace = Object.assign(this.namespace, e);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const e = this.namespace.chains[0];\n    if (!e) throw new Error(\"ChainId not found\");\n    return e.split(\":\")[1];\n  }\n  request(e) {\n    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);\n  }\n  setDefaultChain(e, t) {\n    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(f.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n  getAccounts() {\n    const e = this.namespace.accounts;\n    return e ? [...new Set(e.filter(t => t.split(\":\")[1] === this.chainId.toString()).map(t => t.split(\":\")[2]))] : [];\n  }\n  createHttpProviders() {\n    const e = {};\n    return this.namespace.chains.forEach(t => {\n      var i;\n      const s = y(t);\n      e[s] = this.createHttpProvider(s, (i = this.namespace.rpcMap) == null ? void 0 : i[t]);\n    }), e;\n  }\n  getHttpProvider() {\n    const e = `${this.name}:${this.chainId}`,\n      t = this.httpProviders[e];\n    if (typeof t > \"u\") throw new Error(`JSON-RPC provider for ${e} not found`);\n    return t;\n  }\n  setHttpProvider(e, t) {\n    const i = this.createHttpProvider(e, t);\n    i && (this.httpProviders[e] = i);\n  }\n  createHttpProvider(e, t) {\n    const i = t || v(e, this.namespace, this.client.core.projectId);\n    if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);\n    return new m(new b(i, h(\"disableProviderPing\")));\n  }\n}\nvar qc = Object.defineProperty,\n  Rc = (r, e, t) => e in r ? qc(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  N = (r, e, t) => Rc(r, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass xc {\n  constructor(e) {\n    N(this, \"name\", \"algorand\"), N(this, \"client\"), N(this, \"httpProviders\"), N(this, \"events\"), N(this, \"namespace\"), N(this, \"chainId\"), this.namespace = e.namespace, this.events = h(\"events\"), this.client = h(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(e) {\n    this.namespace = Object.assign(this.namespace, e);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  request(e) {\n    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);\n  }\n  setDefaultChain(e, t) {\n    if (!this.httpProviders[e]) {\n      const i = t || v(`${this.name}:${e}`, this.namespace, this.client.core.projectId);\n      if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);\n      this.setHttpProvider(e, i);\n    }\n    this.chainId = e, this.events.emit(f.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const e = this.namespace.chains[0];\n    if (!e) throw new Error(\"ChainId not found\");\n    return e.split(\":\")[1];\n  }\n  getAccounts() {\n    const e = this.namespace.accounts;\n    return e ? [...new Set(e.filter(t => t.split(\":\")[1] === this.chainId.toString()).map(t => t.split(\":\")[2]))] : [];\n  }\n  createHttpProviders() {\n    const e = {};\n    return this.namespace.chains.forEach(t => {\n      var i;\n      e[t] = this.createHttpProvider(t, (i = this.namespace.rpcMap) == null ? void 0 : i[t]);\n    }), e;\n  }\n  getHttpProvider() {\n    const e = `${this.name}:${this.chainId}`,\n      t = this.httpProviders[e];\n    if (typeof t > \"u\") throw new Error(`JSON-RPC provider for ${e} not found`);\n    return t;\n  }\n  setHttpProvider(e, t) {\n    const i = this.createHttpProvider(e, t);\n    i && (this.httpProviders[e] = i);\n  }\n  createHttpProvider(e, t) {\n    const i = t || v(e, this.namespace, this.client.core.projectId);\n    return typeof i > \"u\" ? void 0 : new m(new b(i, h(\"disableProviderPing\")));\n  }\n}\nvar Lc = Object.defineProperty,\n  Uc = (r, e, t) => e in r ? Lc(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  T = (r, e, t) => Uc(r, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass Fc {\n  constructor(e) {\n    T(this, \"name\", \"cip34\"), T(this, \"client\"), T(this, \"httpProviders\"), T(this, \"events\"), T(this, \"namespace\"), T(this, \"chainId\"), this.namespace = e.namespace, this.events = h(\"events\"), this.client = h(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(e) {\n    this.namespace = Object.assign(this.namespace, e);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const e = this.namespace.chains[0];\n    if (!e) throw new Error(\"ChainId not found\");\n    return e.split(\":\")[1];\n  }\n  request(e) {\n    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);\n  }\n  setDefaultChain(e, t) {\n    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(f.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n  getAccounts() {\n    const e = this.namespace.accounts;\n    return e ? [...new Set(e.filter(t => t.split(\":\")[1] === this.chainId.toString()).map(t => t.split(\":\")[2]))] : [];\n  }\n  createHttpProviders() {\n    const e = {};\n    return this.namespace.chains.forEach(t => {\n      const i = this.getCardanoRPCUrl(t),\n        s = y(t);\n      e[s] = this.createHttpProvider(s, i);\n    }), e;\n  }\n  getHttpProvider() {\n    const e = `${this.name}:${this.chainId}`,\n      t = this.httpProviders[e];\n    if (typeof t > \"u\") throw new Error(`JSON-RPC provider for ${e} not found`);\n    return t;\n  }\n  getCardanoRPCUrl(e) {\n    const t = this.namespace.rpcMap;\n    if (t) return t[e];\n  }\n  setHttpProvider(e, t) {\n    const i = this.createHttpProvider(e, t);\n    i && (this.httpProviders[e] = i);\n  }\n  createHttpProvider(e, t) {\n    const i = t || this.getCardanoRPCUrl(e);\n    if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);\n    return new m(new b(i, h(\"disableProviderPing\")));\n  }\n}\nvar Mc = Object.defineProperty,\n  Gc = (r, e, t) => e in r ? Mc(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  D = (r, e, t) => Gc(r, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass zc {\n  constructor(e) {\n    D(this, \"name\", \"elrond\"), D(this, \"client\"), D(this, \"httpProviders\"), D(this, \"events\"), D(this, \"namespace\"), D(this, \"chainId\"), this.namespace = e.namespace, this.events = h(\"events\"), this.client = h(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(e) {\n    this.namespace = Object.assign(this.namespace, e);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  request(e) {\n    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);\n  }\n  setDefaultChain(e, t) {\n    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(f.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const e = this.namespace.chains[0];\n    if (!e) throw new Error(\"ChainId not found\");\n    return e.split(\":\")[1];\n  }\n  getAccounts() {\n    const e = this.namespace.accounts;\n    return e ? [...new Set(e.filter(t => t.split(\":\")[1] === this.chainId.toString()).map(t => t.split(\":\")[2]))] : [];\n  }\n  createHttpProviders() {\n    const e = {};\n    return this.namespace.chains.forEach(t => {\n      var i;\n      const s = y(t);\n      e[s] = this.createHttpProvider(s, (i = this.namespace.rpcMap) == null ? void 0 : i[t]);\n    }), e;\n  }\n  getHttpProvider() {\n    const e = `${this.name}:${this.chainId}`,\n      t = this.httpProviders[e];\n    if (typeof t > \"u\") throw new Error(`JSON-RPC provider for ${e} not found`);\n    return t;\n  }\n  setHttpProvider(e, t) {\n    const i = this.createHttpProvider(e, t);\n    i && (this.httpProviders[e] = i);\n  }\n  createHttpProvider(e, t) {\n    const i = t || v(e, this.namespace, this.client.core.projectId);\n    if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);\n    return new m(new b(i, h(\"disableProviderPing\")));\n  }\n}\nvar kc = Object.defineProperty,\n  Bc = (r, e, t) => e in r ? kc(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  q = (r, e, t) => Bc(r, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass Vc {\n  constructor(e) {\n    q(this, \"name\", \"multiversx\"), q(this, \"client\"), q(this, \"httpProviders\"), q(this, \"events\"), q(this, \"namespace\"), q(this, \"chainId\"), this.namespace = e.namespace, this.events = h(\"events\"), this.client = h(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(e) {\n    this.namespace = Object.assign(this.namespace, e);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  request(e) {\n    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);\n  }\n  setDefaultChain(e, t) {\n    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(f.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const e = this.namespace.chains[0];\n    if (!e) throw new Error(\"ChainId not found\");\n    return e.split(\":\")[1];\n  }\n  getAccounts() {\n    const e = this.namespace.accounts;\n    return e ? [...new Set(e.filter(t => t.split(\":\")[1] === this.chainId.toString()).map(t => t.split(\":\")[2]))] : [];\n  }\n  createHttpProviders() {\n    const e = {};\n    return this.namespace.chains.forEach(t => {\n      var i;\n      const s = y(t);\n      e[s] = this.createHttpProvider(s, (i = this.namespace.rpcMap) == null ? void 0 : i[t]);\n    }), e;\n  }\n  getHttpProvider() {\n    const e = `${this.name}:${this.chainId}`,\n      t = this.httpProviders[e];\n    if (typeof t > \"u\") throw new Error(`JSON-RPC provider for ${e} not found`);\n    return t;\n  }\n  setHttpProvider(e, t) {\n    const i = this.createHttpProvider(e, t);\n    i && (this.httpProviders[e] = i);\n  }\n  createHttpProvider(e, t) {\n    const i = t || v(e, this.namespace, this.client.core.projectId);\n    if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);\n    return new m(new b(i, h(\"disableProviderPing\")));\n  }\n}\nvar Jc = Object.defineProperty,\n  Kc = (r, e, t) => e in r ? Jc(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  R = (r, e, t) => Kc(r, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass Wc {\n  constructor(e) {\n    R(this, \"name\", \"near\"), R(this, \"client\"), R(this, \"httpProviders\"), R(this, \"events\"), R(this, \"namespace\"), R(this, \"chainId\"), this.namespace = e.namespace, this.events = h(\"events\"), this.client = h(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(e) {\n    this.namespace = Object.assign(this.namespace, e);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const e = this.namespace.chains[0];\n    if (!e) throw new Error(\"ChainId not found\");\n    return e.split(\":\")[1];\n  }\n  request(e) {\n    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);\n  }\n  setDefaultChain(e, t) {\n    if (this.chainId = e, !this.httpProviders[e]) {\n      const i = t || v(`${this.name}:${e}`, this.namespace);\n      if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);\n      this.setHttpProvider(e, i);\n    }\n    this.events.emit(f.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n  getAccounts() {\n    const e = this.namespace.accounts;\n    return e ? e.filter(t => t.split(\":\")[1] === this.chainId.toString()).map(t => t.split(\":\")[2]) || [] : [];\n  }\n  createHttpProviders() {\n    const e = {};\n    return this.namespace.chains.forEach(t => {\n      var i;\n      e[t] = this.createHttpProvider(t, (i = this.namespace.rpcMap) == null ? void 0 : i[t]);\n    }), e;\n  }\n  getHttpProvider() {\n    const e = `${this.name}:${this.chainId}`,\n      t = this.httpProviders[e];\n    if (typeof t > \"u\") throw new Error(`JSON-RPC provider for ${e} not found`);\n    return t;\n  }\n  setHttpProvider(e, t) {\n    const i = this.createHttpProvider(e, t);\n    i && (this.httpProviders[e] = i);\n  }\n  createHttpProvider(e, t) {\n    const i = t || v(e, this.namespace);\n    return typeof i > \"u\" ? void 0 : new m(new b(i, h(\"disableProviderPing\")));\n  }\n}\nvar Xc = Object.defineProperty,\n  Yc = (r, e, t) => e in r ? Xc(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  x = (r, e, t) => Yc(r, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass Zc {\n  constructor(e) {\n    x(this, \"name\", \"tezos\"), x(this, \"client\"), x(this, \"httpProviders\"), x(this, \"events\"), x(this, \"namespace\"), x(this, \"chainId\"), this.namespace = e.namespace, this.events = h(\"events\"), this.client = h(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(e) {\n    this.namespace = Object.assign(this.namespace, e);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const e = this.namespace.chains[0];\n    if (!e) throw new Error(\"ChainId not found\");\n    return e.split(\":\")[1];\n  }\n  request(e) {\n    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);\n  }\n  setDefaultChain(e, t) {\n    if (this.chainId = e, !this.httpProviders[e]) {\n      const i = t || v(`${this.name}:${e}`, this.namespace);\n      if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);\n      this.setHttpProvider(e, i);\n    }\n    this.events.emit(f.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n  getAccounts() {\n    const e = this.namespace.accounts;\n    return e ? e.filter(t => t.split(\":\")[1] === this.chainId.toString()).map(t => t.split(\":\")[2]) || [] : [];\n  }\n  createHttpProviders() {\n    const e = {};\n    return this.namespace.chains.forEach(t => {\n      e[t] = this.createHttpProvider(t);\n    }), e;\n  }\n  getHttpProvider() {\n    const e = `${this.name}:${this.chainId}`,\n      t = this.httpProviders[e];\n    if (typeof t > \"u\") throw new Error(`JSON-RPC provider for ${e} not found`);\n    return t;\n  }\n  setHttpProvider(e, t) {\n    const i = this.createHttpProvider(e, t);\n    i && (this.httpProviders[e] = i);\n  }\n  createHttpProvider(e, t) {\n    const i = t || v(e, this.namespace);\n    return typeof i > \"u\" ? void 0 : new m(new b(i));\n  }\n}\nvar Qc = Object.defineProperty,\n  eh = (r, e, t) => e in r ? Qc(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  L = (r, e, t) => eh(r, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass th {\n  constructor(e) {\n    L(this, \"name\", w), L(this, \"client\"), L(this, \"httpProviders\"), L(this, \"events\"), L(this, \"namespace\"), L(this, \"chainId\"), this.namespace = e.namespace, this.events = h(\"events\"), this.client = h(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(e) {\n    this.namespace.chains = [...new Set((this.namespace.chains || []).concat(e.chains || []))], this.namespace.accounts = [...new Set((this.namespace.accounts || []).concat(e.accounts || []))], this.namespace.methods = [...new Set((this.namespace.methods || []).concat(e.methods || []))], this.namespace.events = [...new Set((this.namespace.events || []).concat(e.events || []))], this.httpProviders = this.createHttpProviders();\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  request(e) {\n    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider(e.chainId).request(e.request);\n  }\n  setDefaultChain(e, t) {\n    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(f.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const e = this.namespace.chains[0];\n    if (!e) throw new Error(\"ChainId not found\");\n    return e.split(\":\")[1];\n  }\n  getAccounts() {\n    const e = this.namespace.accounts;\n    return e ? [...new Set(e.filter(t => t.split(\":\")[1] === this.chainId.toString()).map(t => t.split(\":\")[2]))] : [];\n  }\n  createHttpProviders() {\n    var e, t;\n    const i = {};\n    return (t = (e = this.namespace) == null ? void 0 : e.accounts) == null || t.forEach(s => {\n      const n = me(s);\n      i[`${n.namespace}:${n.reference}`] = this.createHttpProvider(s);\n    }), i;\n  }\n  getHttpProvider(e) {\n    const t = this.httpProviders[e];\n    if (typeof t > \"u\") throw new Error(`JSON-RPC provider for ${e} not found`);\n    return t;\n  }\n  setHttpProvider(e, t) {\n    const i = this.createHttpProvider(e, t);\n    i && (this.httpProviders[e] = i);\n  }\n  createHttpProvider(e, t) {\n    const i = t || v(e, this.namespace, this.client.core.projectId);\n    if (!i) throw new Error(`No RPC url provided for chainId: ${e}`);\n    return new m(new b(i, h(\"disableProviderPing\")));\n  }\n}\nvar rh = Object.defineProperty,\n  ih = Object.defineProperties,\n  sh = Object.getOwnPropertyDescriptors,\n  vt = Object.getOwnPropertySymbols,\n  nh = Object.prototype.hasOwnProperty,\n  ah = Object.prototype.propertyIsEnumerable,\n  le = (r, e, t) => e in r ? rh(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  Y = (r, e) => {\n    for (var t in e || (e = {})) nh.call(e, t) && le(r, t, e[t]);\n    if (vt) for (var t of vt(e)) ah.call(e, t) && le(r, t, e[t]);\n    return r;\n  },\n  de = (r, e) => ih(r, sh(e)),\n  g = (r, e, t) => le(r, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass Z {\n  constructor(e) {\n    g(this, \"client\"), g(this, \"namespaces\"), g(this, \"optionalNamespaces\"), g(this, \"sessionProperties\"), g(this, \"events\", new wt()), g(this, \"rpcProviders\", {}), g(this, \"session\"), g(this, \"providerOpts\"), g(this, \"logger\"), g(this, \"uri\"), g(this, \"disableProviderPing\", !1), this.providerOpts = e, this.logger = typeof e?.logger < \"u\" && typeof e?.logger != \"string\" ? e.logger : gt(Pt({\n      level: e?.logger || be\n    })), this.disableProviderPing = e?.disableProviderPing || !1;\n  }\n  static async init(e) {\n    const t = new Z(e);\n    return await t.initialize(), t;\n  }\n  async request(e, t, i) {\n    const [s, n] = this.validateChain(t);\n    if (!this.session) throw new Error(\"Please call connect() before request()\");\n    return await this.getProvider(s).request({\n      request: Y({}, e),\n      chainId: `${s}:${n}`,\n      topic: this.session.topic,\n      expiry: i\n    });\n  }\n  sendAsync(e, t, i, s) {\n    const n = new Date().getTime();\n    this.request(e, i, s).then(a => t(null, yt(n, a))).catch(a => t(a, void 0));\n  }\n  async enable() {\n    if (!this.client) throw new Error(\"Sign Client not initialized\");\n    return this.session || (await this.connect({\n      namespaces: this.namespaces,\n      optionalNamespaces: this.optionalNamespaces,\n      sessionProperties: this.sessionProperties\n    })), await this.requestAccounts();\n  }\n  async disconnect() {\n    var e;\n    if (!this.session) throw new Error(\"Please call connect() before enable()\");\n    await this.client.disconnect({\n      topic: (e = this.session) == null ? void 0 : e.topic,\n      reason: ge(\"USER_DISCONNECTED\")\n    }), await this.cleanup();\n  }\n  async connect(e) {\n    if (!this.client) throw new Error(\"Sign Client not initialized\");\n    if (this.setNamespaces(e), await this.cleanupPendingPairings(), !e.skipPairing) return await this.pair(e.pairingTopic);\n  }\n  async authenticate(e, t) {\n    if (!this.client) throw new Error(\"Sign Client not initialized\");\n    this.setNamespaces(e), await this.cleanupPendingPairings();\n    const {\n      uri: i,\n      response: s\n    } = await this.client.authenticate(e, t);\n    i && (this.uri = i, this.events.emit(\"display_uri\", i));\n    const n = await s();\n    if (this.session = n.session, this.session) {\n      const a = ht(this.session.namespaces);\n      this.namespaces = ce(this.namespaces, a), this.persist(\"namespaces\", this.namespaces), this.onConnect();\n    }\n    return n;\n  }\n  on(e, t) {\n    this.events.on(e, t);\n  }\n  once(e, t) {\n    this.events.once(e, t);\n  }\n  removeListener(e, t) {\n    this.events.removeListener(e, t);\n  }\n  off(e, t) {\n    this.events.off(e, t);\n  }\n  get isWalletConnect() {\n    return !0;\n  }\n  async pair(e) {\n    const {\n      uri: t,\n      approval: i\n    } = await this.client.connect({\n      pairingTopic: e,\n      requiredNamespaces: this.namespaces,\n      optionalNamespaces: this.optionalNamespaces,\n      sessionProperties: this.sessionProperties\n    });\n    t && (this.uri = t, this.events.emit(\"display_uri\", t));\n    const s = await i();\n    this.session = s;\n    const n = ht(s.namespaces);\n    return this.namespaces = ce(this.namespaces, n), this.persist(\"namespaces\", this.namespaces), this.onConnect(), this.session;\n  }\n  setDefaultChain(e, t) {\n    try {\n      if (!this.session) return;\n      const [i, s] = this.validateChain(e),\n        n = this.getProvider(i);\n      n.name === w ? n.setDefaultChain(`${i}:${s}`, t) : n.setDefaultChain(s, t);\n    } catch (i) {\n      if (!/Please call connect/.test(i.message)) throw i;\n    }\n  }\n  async cleanupPendingPairings(e = {}) {\n    this.logger.info(\"Cleaning up inactive pairings...\");\n    const t = this.client.pairing.getAll();\n    if (Pe(t)) {\n      for (const i of t) e.deletePairings ? this.client.core.expirer.set(i.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(i.topic);\n      this.logger.info(`Inactive pairings cleared: ${t.length}`);\n    }\n  }\n  abortPairingAttempt() {\n    this.logger.warn(\"abortPairingAttempt is deprecated. This is now a no-op.\");\n  }\n  async checkStorage() {\n    if (this.namespaces = await this.getFromStore(\"namespaces\"), this.optionalNamespaces = (await this.getFromStore(\"optionalNamespaces\")) || {}, this.client.session.length) {\n      const e = this.client.session.keys.length - 1;\n      this.session = this.client.session.get(this.client.session.keys[e]), this.createProviders();\n    }\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();\n  }\n  async createClient() {\n    this.client = this.providerOpts.client || (await ft.init({\n      core: this.providerOpts.core,\n      logger: this.providerOpts.logger || be,\n      relayUrl: this.providerOpts.relayUrl || _t,\n      projectId: this.providerOpts.projectId,\n      metadata: this.providerOpts.metadata,\n      storageOptions: this.providerOpts.storageOptions,\n      storage: this.providerOpts.storage,\n      name: this.providerOpts.name,\n      customStoragePrefix: this.providerOpts.customStoragePrefix,\n      telemetryEnabled: this.providerOpts.telemetryEnabled\n    })), this.logger.trace(\"SignClient Initialized\");\n  }\n  createProviders() {\n    if (!this.client) throw new Error(\"Sign Client not initialized\");\n    if (!this.session) throw new Error(\"Session not initialized. Please call connect() before enable()\");\n    const e = [...new Set(Object.keys(this.session.namespaces).map(t => U(t)))];\n    pe(\"client\", this.client), pe(\"events\", this.events), pe(\"disableProviderPing\", this.disableProviderPing), e.forEach(t => {\n      if (!this.session) return;\n      const i = Pc(t, this.session),\n        s = ot(i),\n        n = ce(this.namespaces, this.optionalNamespaces),\n        a = de(Y({}, n[t]), {\n          accounts: i,\n          chains: s\n        });\n      switch (t) {\n        case \"eip155\":\n          this.rpcProviders[t] = new jc({\n            namespace: a\n          });\n          break;\n        case \"algorand\":\n          this.rpcProviders[t] = new xc({\n            namespace: a\n          });\n          break;\n        case \"solana\":\n          this.rpcProviders[t] = new Sc({\n            namespace: a\n          });\n          break;\n        case \"cosmos\":\n          this.rpcProviders[t] = new Dc({\n            namespace: a\n          });\n          break;\n        case \"polkadot\":\n          this.rpcProviders[t] = new wc({\n            namespace: a\n          });\n          break;\n        case \"cip34\":\n          this.rpcProviders[t] = new Fc({\n            namespace: a\n          });\n          break;\n        case \"elrond\":\n          this.rpcProviders[t] = new zc({\n            namespace: a\n          });\n          break;\n        case \"multiversx\":\n          this.rpcProviders[t] = new Vc({\n            namespace: a\n          });\n          break;\n        case \"near\":\n          this.rpcProviders[t] = new Wc({\n            namespace: a\n          });\n          break;\n        case \"tezos\":\n          this.rpcProviders[t] = new Zc({\n            namespace: a\n          });\n          break;\n        default:\n          this.rpcProviders[w] ? this.rpcProviders[w].updateNamespace(a) : this.rpcProviders[w] = new th({\n            namespace: a\n          });\n      }\n    });\n  }\n  registerEventListeners() {\n    if (typeof this.client > \"u\") throw new Error(\"Sign Client is not initialized\");\n    this.client.on(\"session_ping\", e => {\n      this.events.emit(\"session_ping\", e);\n    }), this.client.on(\"session_event\", e => {\n      const {\n          params: t\n        } = e,\n        {\n          event: i\n        } = t;\n      if (i.name === \"accountsChanged\") {\n        const s = i.data;\n        s && Pe(s) && this.events.emit(\"accountsChanged\", s.map(bc));\n      } else if (i.name === \"chainChanged\") {\n        const s = t.chainId,\n          n = t.event.data,\n          a = U(s),\n          o = he(s) !== he(n) ? `${a}:${he(n)}` : s;\n        this.onChainChanged(o);\n      } else this.events.emit(i.name, i.data);\n      this.events.emit(\"session_event\", e);\n    }), this.client.on(\"session_update\", ({\n      topic: e,\n      params: t\n    }) => {\n      var i;\n      const {\n          namespaces: s\n        } = t,\n        n = (i = this.client) == null ? void 0 : i.session.get(e);\n      this.session = de(Y({}, n), {\n        namespaces: s\n      }), this.onSessionUpdate(), this.events.emit(\"session_update\", {\n        topic: e,\n        params: t\n      });\n    }), this.client.on(\"session_delete\", async e => {\n      await this.cleanup(), this.events.emit(\"session_delete\", e), this.events.emit(\"disconnect\", de(Y({}, ge(\"USER_DISCONNECTED\")), {\n        data: e.topic\n      }));\n    }), this.on(f.DEFAULT_CHAIN_CHANGED, e => {\n      this.onChainChanged(e, !0);\n    });\n  }\n  getProvider(e) {\n    return this.rpcProviders[e] || this.rpcProviders[w];\n  }\n  onSessionUpdate() {\n    Object.keys(this.rpcProviders).forEach(e => {\n      var t;\n      this.getProvider(e).updateNamespace((t = this.session) == null ? void 0 : t.namespaces[e]);\n    });\n  }\n  setNamespaces(e) {\n    const {\n      namespaces: t,\n      optionalNamespaces: i,\n      sessionProperties: s\n    } = e;\n    t && Object.keys(t).length && (this.namespaces = t), i && Object.keys(i).length && (this.optionalNamespaces = i), this.sessionProperties = s, this.persist(\"namespaces\", t), this.persist(\"optionalNamespaces\", i);\n  }\n  validateChain(e) {\n    const [t, i] = e?.split(\":\") || [\"\", \"\"];\n    if (!this.namespaces || !Object.keys(this.namespaces).length) return [t, i];\n    if (t && !Object.keys(this.namespaces || {}).map(a => U(a)).includes(t)) throw new Error(`Namespace '${t}' is not configured. Please call connect() first with namespace config.`);\n    if (t && i) return [t, i];\n    const s = U(Object.keys(this.namespaces)[0]),\n      n = this.rpcProviders[s].getDefaultChain();\n    return [s, n];\n  }\n  async requestAccounts() {\n    const [e] = this.validateChain();\n    return await this.getProvider(e).requestAccounts();\n  }\n  onChainChanged(e, t = !1) {\n    if (!this.namespaces) return;\n    const [i, s] = this.validateChain(e);\n    s && (t || this.getProvider(i).setDefaultChain(s), this.namespaces[i] ? this.namespaces[i].defaultChain = s : this.namespaces[`${i}:${s}`] ? this.namespaces[`${i}:${s}`].defaultChain = s : this.namespaces[`${i}:${s}`] = {\n      defaultChain: s\n    }, this.persist(\"namespaces\", this.namespaces), this.events.emit(\"chainChanged\", s));\n  }\n  onConnect() {\n    this.createProviders(), this.events.emit(\"connect\", {\n      session: this.session\n    });\n  }\n  async cleanup() {\n    this.session = void 0, this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, this.persist(\"namespaces\", void 0), this.persist(\"optionalNamespaces\", void 0), this.persist(\"sessionProperties\", void 0), await this.cleanupPendingPairings({\n      deletePairings: !0\n    });\n  }\n  persist(e, t) {\n    this.client.core.storage.setItem(`${$e}/${e}`, t);\n  }\n  async getFromStore(e) {\n    return await this.client.core.storage.getItem(`${$e}/${e}`);\n  }\n}\nconst oh = Z;\nexport { oh as UniversalProvider, Z as default };\n//# sourceMappingURL=index.es.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}