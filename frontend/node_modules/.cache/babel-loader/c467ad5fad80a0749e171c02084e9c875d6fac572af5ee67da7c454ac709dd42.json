{"ast":null,"code":"'use strict';\n\nconst {\n  format,\n  inspect\n} = require('./util/inspect');\nconst {\n  AggregateError: CustomAggregateError\n} = require('./primordials');\n\n/*\n  This file is a reduced and adapted version of the main lib/internal/errors.js file defined at\n\n  https://github.com/nodejs/node/blob/main/lib/internal/errors.js\n\n  Don't try to replace with the original file and keep it up to date (starting from E(...) definitions)\n  with the upstream file.\n*/\n\nconst AggregateError = globalThis.AggregateError || CustomAggregateError;\nconst kIsNodeError = Symbol('kIsNodeError');\nconst kTypes = ['string', 'function', 'number', 'object',\n// Accept 'Function' and 'Object' as alternative to the lower cased version.\n'Function', 'Object', 'boolean', 'bigint', 'symbol'];\nconst classRegExp = /^([A-Z][a-z0-9]*)+$/;\nconst nodeInternalPrefix = '__node_internal_';\nconst codes = {};\nfunction assert(value, message) {\n  if (!value) {\n    throw new codes.ERR_INTERNAL_ASSERTION(message);\n  }\n}\n\n// Only use this for integers! Decimal numbers do not work with this function.\nfunction addNumericalSeparator(val) {\n  let res = '';\n  let i = val.length;\n  const start = val[0] === '-' ? 1 : 0;\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`;\n  }\n  return `${val.slice(0, i)}${res}`;\n}\nfunction getMessage(key, msg, args) {\n  if (typeof msg === 'function') {\n    assert(msg.length <= args.length,\n    // Default options do not count.\n    `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`);\n    return msg(...args);\n  }\n  const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;\n  assert(expectedLength === args.length, `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`);\n  if (args.length === 0) {\n    return msg;\n  }\n  return format(msg, ...args);\n}\nfunction E(code, message, Base) {\n  if (!Base) {\n    Base = Error;\n  }\n  class NodeError extends Base {\n    constructor(...args) {\n      super(getMessage(code, message, args));\n    }\n    toString() {\n      return `${this.name} [${code}]: ${this.message}`;\n    }\n  }\n  Object.defineProperties(NodeError.prototype, {\n    name: {\n      value: Base.name,\n      writable: true,\n      enumerable: false,\n      configurable: true\n    },\n    toString: {\n      value() {\n        return `${this.name} [${code}]: ${this.message}`;\n      },\n      writable: true,\n      enumerable: false,\n      configurable: true\n    }\n  });\n  NodeError.prototype.code = code;\n  NodeError.prototype[kIsNodeError] = true;\n  codes[code] = NodeError;\n}\nfunction hideStackFrames(fn) {\n  // We rename the functions that will be hidden to cut off the stacktrace\n  // at the outermost one\n  const hidden = nodeInternalPrefix + fn.name;\n  Object.defineProperty(fn, 'name', {\n    value: hidden\n  });\n  return fn;\n}\nfunction aggregateTwoErrors(innerError, outerError) {\n  if (innerError && outerError && innerError !== outerError) {\n    if (Array.isArray(outerError.errors)) {\n      // If `outerError` is already an `AggregateError`.\n      outerError.errors.push(innerError);\n      return outerError;\n    }\n    const err = new AggregateError([outerError, innerError], outerError.message);\n    err.code = outerError.code;\n    return err;\n  }\n  return innerError || outerError;\n}\nclass AbortError extends Error {\n  constructor(message = 'The operation was aborted', options = undefined) {\n    if (options !== undefined && typeof options !== 'object') {\n      throw new codes.ERR_INVALID_ARG_TYPE('options', 'Object', options);\n    }\n    super(message, options);\n    this.code = 'ABORT_ERR';\n    this.name = 'AbortError';\n  }\n}\nE('ERR_ASSERTION', '%s', Error);\nE('ERR_INVALID_ARG_TYPE', (name, expected, actual) => {\n  assert(typeof name === 'string', \"'name' must be a string\");\n  if (!Array.isArray(expected)) {\n    expected = [expected];\n  }\n  let msg = 'The ';\n  if (name.endsWith(' argument')) {\n    // For cases like 'first argument'\n    msg += `${name} `;\n  } else {\n    msg += `\"${name}\" ${name.includes('.') ? 'property' : 'argument'} `;\n  }\n  msg += 'must be ';\n  const types = [];\n  const instances = [];\n  const other = [];\n  for (const value of expected) {\n    assert(typeof value === 'string', 'All expected entries have to be of type string');\n    if (kTypes.includes(value)) {\n      types.push(value.toLowerCase());\n    } else if (classRegExp.test(value)) {\n      instances.push(value);\n    } else {\n      assert(value !== 'object', 'The value \"object\" should be written as \"Object\"');\n      other.push(value);\n    }\n  }\n\n  // Special handle `object` in case other instances are allowed to outline\n  // the differences between each other.\n  if (instances.length > 0) {\n    const pos = types.indexOf('object');\n    if (pos !== -1) {\n      types.splice(types, pos, 1);\n      instances.push('Object');\n    }\n  }\n  if (types.length > 0) {\n    switch (types.length) {\n      case 1:\n        msg += `of type ${types[0]}`;\n        break;\n      case 2:\n        msg += `one of type ${types[0]} or ${types[1]}`;\n        break;\n      default:\n        {\n          const last = types.pop();\n          msg += `one of type ${types.join(', ')}, or ${last}`;\n        }\n    }\n    if (instances.length > 0 || other.length > 0) {\n      msg += ' or ';\n    }\n  }\n  if (instances.length > 0) {\n    switch (instances.length) {\n      case 1:\n        msg += `an instance of ${instances[0]}`;\n        break;\n      case 2:\n        msg += `an instance of ${instances[0]} or ${instances[1]}`;\n        break;\n      default:\n        {\n          const last = instances.pop();\n          msg += `an instance of ${instances.join(', ')}, or ${last}`;\n        }\n    }\n    if (other.length > 0) {\n      msg += ' or ';\n    }\n  }\n  switch (other.length) {\n    case 0:\n      break;\n    case 1:\n      if (other[0].toLowerCase() !== other[0]) {\n        msg += 'an ';\n      }\n      msg += `${other[0]}`;\n      break;\n    case 2:\n      msg += `one of ${other[0]} or ${other[1]}`;\n      break;\n    default:\n      {\n        const last = other.pop();\n        msg += `one of ${other.join(', ')}, or ${last}`;\n      }\n  }\n  if (actual == null) {\n    msg += `. Received ${actual}`;\n  } else if (typeof actual === 'function' && actual.name) {\n    msg += `. Received function ${actual.name}`;\n  } else if (typeof actual === 'object') {\n    var _actual$constructor;\n    if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== undefined && _actual$constructor.name) {\n      msg += `. Received an instance of ${actual.constructor.name}`;\n    } else {\n      const inspected = inspect(actual, {\n        depth: -1\n      });\n      msg += `. Received ${inspected}`;\n    }\n  } else {\n    let inspected = inspect(actual, {\n      colors: false\n    });\n    if (inspected.length > 25) {\n      inspected = `${inspected.slice(0, 25)}...`;\n    }\n    msg += `. Received type ${typeof actual} (${inspected})`;\n  }\n  return msg;\n}, TypeError);\nE('ERR_INVALID_ARG_VALUE', (name, value, reason = 'is invalid') => {\n  let inspected = inspect(value);\n  if (inspected.length > 128) {\n    inspected = inspected.slice(0, 128) + '...';\n  }\n  const type = name.includes('.') ? 'property' : 'argument';\n  return `The ${type} '${name}' ${reason}. Received ${inspected}`;\n}, TypeError);\nE('ERR_INVALID_RETURN_VALUE', (input, name, value) => {\n  var _value$constructor;\n  const type = value !== null && value !== undefined && (_value$constructor = value.constructor) !== null && _value$constructor !== undefined && _value$constructor.name ? `instance of ${value.constructor.name}` : `type ${typeof value}`;\n  return `Expected ${input} to be returned from the \"${name}\"` + ` function but got ${type}.`;\n}, TypeError);\nE('ERR_MISSING_ARGS', (...args) => {\n  assert(args.length > 0, 'At least one arg needs to be specified');\n  let msg;\n  const len = args.length;\n  args = (Array.isArray(args) ? args : [args]).map(a => `\"${a}\"`).join(' or ');\n  switch (len) {\n    case 1:\n      msg += `The ${args[0]} argument`;\n      break;\n    case 2:\n      msg += `The ${args[0]} and ${args[1]} arguments`;\n      break;\n    default:\n      {\n        const last = args.pop();\n        msg += `The ${args.join(', ')}, and ${last} arguments`;\n      }\n      break;\n  }\n  return `${msg} must be specified`;\n}, TypeError);\nE('ERR_OUT_OF_RANGE', (str, range, input) => {\n  assert(range, 'Missing \"range\" argument');\n  let received;\n  if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n    received = addNumericalSeparator(String(input));\n  } else if (typeof input === 'bigint') {\n    received = String(input);\n    const limit = BigInt(2) ** BigInt(32);\n    if (input > limit || input < -limit) {\n      received = addNumericalSeparator(received);\n    }\n    received += 'n';\n  } else {\n    received = inspect(input);\n  }\n  return `The value of \"${str}\" is out of range. It must be ${range}. Received ${received}`;\n}, RangeError);\nE('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times', Error);\nE('ERR_METHOD_NOT_IMPLEMENTED', 'The %s method is not implemented', Error);\nE('ERR_STREAM_ALREADY_FINISHED', 'Cannot call %s after a stream was finished', Error);\nE('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable', Error);\nE('ERR_STREAM_DESTROYED', 'Cannot call %s after a stream was destroyed', Error);\nE('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);\nE('ERR_STREAM_PREMATURE_CLOSE', 'Premature close', Error);\nE('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF', Error);\nE('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event', Error);\nE('ERR_STREAM_WRITE_AFTER_END', 'write after end', Error);\nE('ERR_UNKNOWN_ENCODING', 'Unknown encoding: %s', TypeError);\nmodule.exports = {\n  AbortError,\n  aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),\n  hideStackFrames,\n  codes\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}