{"ast":null,"code":"import { getAction } from '../../utils/getAction.js';\nimport { observe } from '../../utils/observe.js';\nimport { poll } from '../../utils/poll.js';\nimport { stringify } from '../../utils/stringify.js';\nimport { createPendingTransactionFilter } from './createPendingTransactionFilter.js';\nimport { getFilterChanges } from './getFilterChanges.js';\nimport { uninstallFilter } from './uninstallFilter.js';\n/**\n * Watches and returns pending transaction hashes.\n *\n * - Docs: https://viem.sh/docs/actions/public/watchPendingTransactions\n * - JSON-RPC Methods:\n *   - When `poll: true`\n *     - Calls [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter) to initialize the filter.\n *     - Calls [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getFilterChanges) on a polling interval.\n *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `\"newPendingTransactions\"` event.\n *\n * This Action will batch up all the pending transactions found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchPendingTransactions#pollinginterval-optional), and invoke them via [`onTransactions`](https://viem.sh/docs/actions/public/watchPendingTransactions#ontransactions).\n *\n * @param client - Client to use\n * @param parameters - {@link WatchPendingTransactionsParameters}\n * @returns A function that can be invoked to stop watching for new pending transaction hashes. {@link WatchPendingTransactionsReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { watchPendingTransactions } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = await watchPendingTransactions(client, {\n *   onTransactions: (hashes) => console.log(hashes),\n * })\n */\nexport function watchPendingTransactions(client, {\n  batch = true,\n  onError,\n  onTransactions,\n  poll: poll_,\n  pollingInterval = client.pollingInterval\n}) {\n  const enablePolling = typeof poll_ !== 'undefined' ? poll_ : client.transport.type !== 'webSocket';\n  const pollPendingTransactions = () => {\n    const observerId = stringify(['watchPendingTransactions', client.uid, batch, pollingInterval]);\n    return observe(observerId, {\n      onTransactions,\n      onError\n    }, emit => {\n      let filter;\n      const unwatch = poll(async () => {\n        try {\n          if (!filter) {\n            try {\n              filter = await getAction(client, createPendingTransactionFilter, 'createPendingTransactionFilter')({});\n              return;\n            } catch (err) {\n              unwatch();\n              throw err;\n            }\n          }\n          const hashes = await getAction(client, getFilterChanges, 'getFilterChanges')({\n            filter\n          });\n          if (hashes.length === 0) return;\n          if (batch) emit.onTransactions(hashes);else for (const hash of hashes) emit.onTransactions([hash]);\n        } catch (err) {\n          emit.onError?.(err);\n        }\n      }, {\n        emitOnBegin: true,\n        interval: pollingInterval\n      });\n      return async () => {\n        if (filter) await getAction(client, uninstallFilter, 'uninstallFilter')({\n          filter\n        });\n        unwatch();\n      };\n    });\n  };\n  const subscribePendingTransactions = () => {\n    let active = true;\n    let unsubscribe = () => active = false;\n    (async () => {\n      try {\n        const {\n          unsubscribe: unsubscribe_\n        } = await client.transport.subscribe({\n          params: ['newPendingTransactions'],\n          onData(data) {\n            if (!active) return;\n            const transaction = data.result;\n            onTransactions([transaction]);\n          },\n          onError(error) {\n            onError?.(error);\n          }\n        });\n        unsubscribe = unsubscribe_;\n        if (!active) unsubscribe();\n      } catch (err) {\n        onError?.(err);\n      }\n    })();\n    return () => unsubscribe();\n  };\n  return enablePolling ? pollPendingTransactions() : subscribePendingTransactions();\n}\n//# sourceMappingURL=watchPendingTransactions.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}