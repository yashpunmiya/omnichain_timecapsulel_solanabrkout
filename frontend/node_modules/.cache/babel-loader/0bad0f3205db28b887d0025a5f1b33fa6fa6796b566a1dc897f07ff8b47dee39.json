{"ast":null,"code":"'use strict';\n\nvar callBound = require('call-bound');\nvar hasToStringTag = require('has-tostringtag/shams')();\nvar hasOwn = require('hasown');\nvar gOPD = require('gopd');\n\n/** @type {import('.')} */\nvar fn;\nif (hasToStringTag) {\n  /** @type {(receiver: ThisParameterType<typeof RegExp.prototype.exec>, ...args: Parameters<typeof RegExp.prototype.exec>) => ReturnType<typeof RegExp.prototype.exec>} */\n  var $exec = callBound('RegExp.prototype.exec');\n  /** @type {object} */\n  var isRegexMarker = {};\n  var throwRegexMarker = function () {\n    throw isRegexMarker;\n  };\n  /** @type {{ toString(): never, valueOf(): never, [Symbol.toPrimitive]?(): never }} */\n  var badStringifier = {\n    toString: throwRegexMarker,\n    valueOf: throwRegexMarker\n  };\n  if (typeof Symbol.toPrimitive === 'symbol') {\n    badStringifier[Symbol.toPrimitive] = throwRegexMarker;\n  }\n\n  /** @type {import('.')} */\n  // @ts-expect-error TS can't figure out that the $exec call always throws\n  // eslint-disable-next-line consistent-return\n  fn = function isRegex(value) {\n    if (!value || typeof value !== 'object') {\n      return false;\n    }\n\n    // eslint-disable-next-line no-extra-parens\n    var descriptor = /** @type {NonNullable<typeof gOPD>} */gOPD(/** @type {{ lastIndex?: unknown }} */value, 'lastIndex');\n    var hasLastIndexDataProperty = descriptor && hasOwn(descriptor, 'value');\n    if (!hasLastIndexDataProperty) {\n      return false;\n    }\n    try {\n      // eslint-disable-next-line no-extra-parens\n      $exec(value, /** @type {string} */ /** @type {unknown} */badStringifier);\n    } catch (e) {\n      return e === isRegexMarker;\n    }\n  };\n} else {\n  /** @type {(receiver: ThisParameterType<typeof Object.prototype.toString>, ...args: Parameters<typeof Object.prototype.toString>) => ReturnType<typeof Object.prototype.toString>} */\n  var $toString = callBound('Object.prototype.toString');\n  /** @const @type {'[object RegExp]'} */\n  var regexClass = '[object RegExp]';\n\n  /** @type {import('.')} */\n  fn = function isRegex(value) {\n    // In older browsers, typeof regex incorrectly returns 'function'\n    if (!value || typeof value !== 'object' && typeof value !== 'function') {\n      return false;\n    }\n    return $toString(value) === regexClass;\n  };\n}\nmodule.exports = fn;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}