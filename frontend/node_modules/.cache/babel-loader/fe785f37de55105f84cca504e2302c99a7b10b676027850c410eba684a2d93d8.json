{"ast":null,"code":"'use strict';\n\nconst bufferModule = require('buffer');\nconst {\n  format,\n  inspect\n} = require('./util/inspect');\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE\n  }\n} = require('./errors');\nconst {\n  kResistStopPropagation,\n  AggregateError,\n  SymbolDispose\n} = require('./primordials');\nconst AbortSignal = globalThis.AbortSignal || require('abort-controller').AbortSignal;\nconst AbortController = globalThis.AbortController || require('abort-controller').AbortController;\nconst AsyncFunction = Object.getPrototypeOf(async function () {}).constructor;\nconst Blob = globalThis.Blob || bufferModule.Blob;\n/* eslint-disable indent */\nconst isBlob = typeof Blob !== 'undefined' ? function isBlob(b) {\n  // eslint-disable-next-line indent\n  return b instanceof Blob;\n} : function isBlob(b) {\n  return false;\n};\n/* eslint-enable indent */\n\nconst validateAbortSignal = (signal, name) => {\n  if (signal !== undefined && (signal === null || typeof signal !== 'object' || !('aborted' in signal))) {\n    throw new ERR_INVALID_ARG_TYPE(name, 'AbortSignal', signal);\n  }\n};\nconst validateFunction = (value, name) => {\n  if (typeof value !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE(name, 'Function', value);\n  }\n};\nmodule.exports = {\n  AggregateError,\n  kEmptyObject: Object.freeze({}),\n  once(callback) {\n    let called = false;\n    return function (...args) {\n      if (called) {\n        return;\n      }\n      called = true;\n      callback.apply(this, args);\n    };\n  },\n  createDeferredPromise: function () {\n    let resolve;\n    let reject;\n\n    // eslint-disable-next-line promise/param-names\n    const promise = new Promise((res, rej) => {\n      resolve = res;\n      reject = rej;\n    });\n    return {\n      promise,\n      resolve,\n      reject\n    };\n  },\n  promisify(fn) {\n    return new Promise((resolve, reject) => {\n      fn((err, ...args) => {\n        if (err) {\n          return reject(err);\n        }\n        return resolve(...args);\n      });\n    });\n  },\n  debuglog() {\n    return function () {};\n  },\n  format,\n  inspect,\n  types: {\n    isAsyncFunction(fn) {\n      return fn instanceof AsyncFunction;\n    },\n    isArrayBufferView(arr) {\n      return ArrayBuffer.isView(arr);\n    }\n  },\n  isBlob,\n  deprecate(fn, message) {\n    return fn;\n  },\n  addAbortListener: require('events').addAbortListener || function addAbortListener(signal, listener) {\n    if (signal === undefined) {\n      throw new ERR_INVALID_ARG_TYPE('signal', 'AbortSignal', signal);\n    }\n    validateAbortSignal(signal, 'signal');\n    validateFunction(listener, 'listener');\n    let removeEventListener;\n    if (signal.aborted) {\n      queueMicrotask(() => listener());\n    } else {\n      signal.addEventListener('abort', listener, {\n        __proto__: null,\n        once: true,\n        [kResistStopPropagation]: true\n      });\n      removeEventListener = () => {\n        signal.removeEventListener('abort', listener);\n      };\n    }\n    return {\n      __proto__: null,\n      [SymbolDispose]() {\n        var _removeEventListener;\n        (_removeEventListener = removeEventListener) === null || _removeEventListener === undefined ? undefined : _removeEventListener();\n      }\n    };\n  },\n  AbortSignalAny: AbortSignal.any || function AbortSignalAny(signals) {\n    // Fast path if there is only one signal.\n    if (signals.length === 1) {\n      return signals[0];\n    }\n    const ac = new AbortController();\n    const abort = () => ac.abort();\n    signals.forEach(signal => {\n      validateAbortSignal(signal, 'signals');\n      signal.addEventListener('abort', abort, {\n        once: true\n      });\n    });\n    ac.signal.addEventListener('abort', () => {\n      signals.forEach(signal => signal.removeEventListener('abort', abort));\n    }, {\n      once: true\n    });\n    return ac.signal;\n  }\n};\nmodule.exports.promisify.custom = Symbol.for('nodejs.util.promisify.custom');","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}