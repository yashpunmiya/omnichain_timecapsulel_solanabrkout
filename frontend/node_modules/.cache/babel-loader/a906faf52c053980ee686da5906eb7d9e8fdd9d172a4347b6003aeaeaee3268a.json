{"ast":null,"code":"var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _SolanaWalletAdapterWalletAccount_adapter, _SolanaWalletAdapterWallet_instances, _SolanaWalletAdapterWallet_listeners, _SolanaWalletAdapterWallet_adapter, _SolanaWalletAdapterWallet_supportedTransactionVersions, _SolanaWalletAdapterWallet_chain, _SolanaWalletAdapterWallet_endpoint, _SolanaWalletAdapterWallet_account, _SolanaWalletAdapterWallet_connected, _SolanaWalletAdapterWallet_disconnected, _SolanaWalletAdapterWallet_connect, _SolanaWalletAdapterWallet_disconnect, _SolanaWalletAdapterWallet_on, _SolanaWalletAdapterWallet_emit, _SolanaWalletAdapterWallet_off, _SolanaWalletAdapterWallet_deserializeTransaction, _SolanaWalletAdapterWallet_signAndSendTransaction, _SolanaWalletAdapterWallet_signTransaction, _SolanaWalletAdapterWallet_signMessage, _SolanaWalletAdapterWallet_signIn;\nimport { isVersionedTransaction, WalletReadyState } from '@solana/wallet-adapter-base';\nimport { isSolanaChain } from '@solana/wallet-standard-chains';\nimport { SolanaSignAndSendTransaction, SolanaSignIn, SolanaSignMessage, SolanaSignTransaction } from '@solana/wallet-standard-features';\nimport { getEndpointForChain } from '@solana/wallet-standard-util';\nimport { Connection, Transaction, VersionedTransaction } from '@solana/web3.js';\nimport { getWallets } from '@wallet-standard/app';\nimport { StandardConnect, StandardDisconnect, StandardEvents } from '@wallet-standard/features';\nimport { arraysEqual, bytesEqual, ReadonlyWalletAccount } from '@wallet-standard/wallet';\nimport bs58 from 'bs58';\n/** TODO: docs */\nexport class SolanaWalletAdapterWalletAccount extends ReadonlyWalletAccount {\n  constructor({\n    adapter,\n    address,\n    publicKey,\n    chains\n  }) {\n    const features = [SolanaSignAndSendTransaction];\n    if ('signTransaction' in adapter) {\n      features.push(SolanaSignTransaction);\n    }\n    if ('signMessage' in adapter) {\n      features.push(SolanaSignMessage);\n    }\n    if ('signIn' in adapter) {\n      features.push(SolanaSignIn);\n    }\n    super({\n      address,\n      publicKey,\n      chains,\n      features\n    });\n    // eslint-disable-next-line no-unused-private-class-members\n    _SolanaWalletAdapterWalletAccount_adapter.set(this, void 0);\n    if (new.target === SolanaWalletAdapterWalletAccount) {\n      Object.freeze(this);\n    }\n    __classPrivateFieldSet(this, _SolanaWalletAdapterWalletAccount_adapter, adapter, \"f\");\n  }\n}\n_SolanaWalletAdapterWalletAccount_adapter = new WeakMap();\n/** TODO: docs */\nexport class SolanaWalletAdapterWallet {\n  get version() {\n    return '1.0.0';\n  }\n  get name() {\n    return __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_adapter, \"f\").name;\n  }\n  get icon() {\n    return __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_adapter, \"f\").icon;\n  }\n  get chains() {\n    return [__classPrivateFieldGet(this, _SolanaWalletAdapterWallet_chain, \"f\")];\n  }\n  get features() {\n    const features = {\n      [StandardConnect]: {\n        version: '1.0.0',\n        connect: __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_connect, \"f\")\n      },\n      [StandardDisconnect]: {\n        version: '1.0.0',\n        disconnect: __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_disconnect, \"f\")\n      },\n      [StandardEvents]: {\n        version: '1.0.0',\n        on: __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_on, \"f\")\n      },\n      [SolanaSignAndSendTransaction]: {\n        version: '1.0.0',\n        supportedTransactionVersions: __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_supportedTransactionVersions, \"f\"),\n        signAndSendTransaction: __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_signAndSendTransaction, \"f\")\n      }\n    };\n    let signTransactionFeature;\n    if ('signTransaction' in __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_adapter, \"f\")) {\n      signTransactionFeature = {\n        [SolanaSignTransaction]: {\n          version: '1.0.0',\n          supportedTransactionVersions: __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_supportedTransactionVersions, \"f\"),\n          signTransaction: __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_signTransaction, \"f\")\n        }\n      };\n    }\n    let signMessageFeature;\n    if ('signMessage' in __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_adapter, \"f\")) {\n      signMessageFeature = {\n        [SolanaSignMessage]: {\n          version: '1.0.0',\n          signMessage: __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_signMessage, \"f\")\n        }\n      };\n    }\n    let signInFeature;\n    if ('signIn' in __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_adapter, \"f\")) {\n      signInFeature = {\n        [SolanaSignIn]: {\n          version: '1.0.0',\n          signIn: __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_signIn, \"f\")\n        }\n      };\n    }\n    return {\n      ...features,\n      ...signTransactionFeature,\n      ...signMessageFeature\n    };\n  }\n  get accounts() {\n    return __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_account, \"f\") ? [__classPrivateFieldGet(this, _SolanaWalletAdapterWallet_account, \"f\")] : [];\n  }\n  get endpoint() {\n    return __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_endpoint, \"f\");\n  }\n  constructor(adapter, chain, endpoint) {\n    _SolanaWalletAdapterWallet_instances.add(this);\n    _SolanaWalletAdapterWallet_listeners.set(this, {});\n    _SolanaWalletAdapterWallet_adapter.set(this, void 0);\n    _SolanaWalletAdapterWallet_supportedTransactionVersions.set(this, void 0);\n    _SolanaWalletAdapterWallet_chain.set(this, void 0);\n    _SolanaWalletAdapterWallet_endpoint.set(this, void 0);\n    _SolanaWalletAdapterWallet_account.set(this, void 0);\n    _SolanaWalletAdapterWallet_connect.set(this, async ({\n      silent\n    } = {}) => {\n      if (!silent && !__classPrivateFieldGet(this, _SolanaWalletAdapterWallet_adapter, \"f\").connected) {\n        await __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_adapter, \"f\").connect();\n      }\n      __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_instances, \"m\", _SolanaWalletAdapterWallet_connected).call(this);\n      return {\n        accounts: this.accounts\n      };\n    });\n    _SolanaWalletAdapterWallet_disconnect.set(this, async () => {\n      await __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_adapter, \"f\").disconnect();\n    });\n    _SolanaWalletAdapterWallet_on.set(this, (event, listener) => {\n      __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_listeners, \"f\")[event]?.push(listener) || (__classPrivateFieldGet(this, _SolanaWalletAdapterWallet_listeners, \"f\")[event] = [listener]);\n      return () => __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_instances, \"m\", _SolanaWalletAdapterWallet_off).call(this, event, listener);\n    });\n    _SolanaWalletAdapterWallet_signAndSendTransaction.set(this, async (...inputs) => {\n      const outputs = [];\n      if (inputs.length === 1) {\n        const input = inputs[0];\n        if (input.account !== __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_account, \"f\")) throw new Error('invalid account');\n        if (!isSolanaChain(input.chain)) throw new Error('invalid chain');\n        const transaction = __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_instances, \"m\", _SolanaWalletAdapterWallet_deserializeTransaction).call(this, input.transaction);\n        const {\n          commitment,\n          preflightCommitment,\n          skipPreflight,\n          maxRetries,\n          minContextSlot\n        } = input.options || {};\n        const endpoint = getEndpointForChain(input.chain, __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_endpoint, \"f\"));\n        const connection = new Connection(endpoint, commitment || 'confirmed');\n        const latestBlockhash = commitment ? await connection.getLatestBlockhash({\n          commitment: preflightCommitment || commitment,\n          minContextSlot\n        }) : undefined;\n        const signature = await __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_adapter, \"f\").sendTransaction(transaction, connection, {\n          preflightCommitment,\n          skipPreflight,\n          maxRetries,\n          minContextSlot\n        });\n        if (latestBlockhash) {\n          await connection.confirmTransaction({\n            ...latestBlockhash,\n            signature\n          }, commitment || 'confirmed');\n        }\n        outputs.push({\n          signature: bs58.decode(signature)\n        });\n      } else if (inputs.length > 1) {\n        // Adapters have no `sendAllTransactions` method, so just sign and send each transaction in serial.\n        for (const input of inputs) {\n          outputs.push(...(await __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_signAndSendTransaction, \"f\").call(this, input)));\n        }\n      }\n      return outputs;\n    });\n    _SolanaWalletAdapterWallet_signTransaction.set(this, async (...inputs) => {\n      if (!('signTransaction' in __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_adapter, \"f\"))) throw new Error('signTransaction not implemented by adapter');\n      const outputs = [];\n      if (inputs.length === 1) {\n        const input = inputs[0];\n        if (input.account !== __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_account, \"f\")) throw new Error('invalid account');\n        if (input.chain && !isSolanaChain(input.chain)) throw new Error('invalid chain');\n        const transaction = __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_instances, \"m\", _SolanaWalletAdapterWallet_deserializeTransaction).call(this, input.transaction);\n        const signedTransaction = await __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_adapter, \"f\").signTransaction(transaction);\n        const serializedTransaction = isVersionedTransaction(signedTransaction) ? signedTransaction.serialize() : new Uint8Array(signedTransaction.serialize({\n          requireAllSignatures: false,\n          verifySignatures: false\n        }));\n        outputs.push({\n          signedTransaction: serializedTransaction\n        });\n      } else if (inputs.length > 1) {\n        for (const input of inputs) {\n          if (input.account !== __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_account, \"f\")) throw new Error('invalid account');\n          if (input.chain && !isSolanaChain(input.chain)) throw new Error('invalid chain');\n        }\n        const transactions = inputs.map(({\n          transaction\n        }) => __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_instances, \"m\", _SolanaWalletAdapterWallet_deserializeTransaction).call(this, transaction));\n        const signedTransactions = await __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_adapter, \"f\").signAllTransactions(transactions);\n        outputs.push(...signedTransactions.map(signedTransaction => {\n          const serializedTransaction = isVersionedTransaction(signedTransaction) ? signedTransaction.serialize() : new Uint8Array(signedTransaction.serialize({\n            requireAllSignatures: false,\n            verifySignatures: false\n          }));\n          return {\n            signedTransaction: serializedTransaction\n          };\n        }));\n      }\n      return outputs;\n    });\n    _SolanaWalletAdapterWallet_signMessage.set(this, async (...inputs) => {\n      if (!('signMessage' in __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_adapter, \"f\"))) throw new Error('signMessage not implemented by adapter');\n      const outputs = [];\n      if (inputs.length === 1) {\n        const input = inputs[0];\n        if (input.account !== __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_account, \"f\")) throw new Error('invalid account');\n        const signature = await __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_adapter, \"f\").signMessage(input.message);\n        outputs.push({\n          signedMessage: input.message,\n          signature\n        });\n      } else if (inputs.length > 1) {\n        // Adapters have no `signAllMessages` method, so just sign each message in serial.\n        for (const input of inputs) {\n          outputs.push(...(await __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_signMessage, \"f\").call(this, input)));\n        }\n      }\n      return outputs;\n    });\n    _SolanaWalletAdapterWallet_signIn.set(this, async (...inputs) => {\n      if (!('signIn' in __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_adapter, \"f\"))) throw new Error('signIn not implemented by adapter');\n      if (inputs.length > 1) {\n        // Adapters don't support `signIn` with multiple inputs, so just sign in with each input in serial.\n        const outputs = [];\n        for (const input of inputs) {\n          outputs.push(await __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_adapter, \"f\").signIn(input));\n        }\n        return outputs;\n      } else {\n        return [await __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_adapter, \"f\").signIn(inputs[0])];\n      }\n    });\n    if (new.target === SolanaWalletAdapterWallet) {\n      Object.freeze(this);\n    }\n    const supportedTransactionVersions = [...(adapter.supportedTransactionVersions || ['legacy'])];\n    if (!supportedTransactionVersions.length) {\n      supportedTransactionVersions.push('legacy');\n    }\n    __classPrivateFieldSet(this, _SolanaWalletAdapterWallet_adapter, adapter, \"f\");\n    __classPrivateFieldSet(this, _SolanaWalletAdapterWallet_supportedTransactionVersions, supportedTransactionVersions, \"f\");\n    __classPrivateFieldSet(this, _SolanaWalletAdapterWallet_chain, chain, \"f\");\n    __classPrivateFieldSet(this, _SolanaWalletAdapterWallet_endpoint, endpoint, \"f\");\n    adapter.on('connect', __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_instances, \"m\", _SolanaWalletAdapterWallet_connected), this);\n    adapter.on('disconnect', __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_instances, \"m\", _SolanaWalletAdapterWallet_disconnected), this);\n    __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_instances, \"m\", _SolanaWalletAdapterWallet_connected).call(this);\n  }\n  destroy() {\n    __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_adapter, \"f\").off('connect', __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_instances, \"m\", _SolanaWalletAdapterWallet_connected), this);\n    __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_adapter, \"f\").off('disconnect', __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_instances, \"m\", _SolanaWalletAdapterWallet_disconnected), this);\n  }\n}\n_SolanaWalletAdapterWallet_listeners = new WeakMap(), _SolanaWalletAdapterWallet_adapter = new WeakMap(), _SolanaWalletAdapterWallet_supportedTransactionVersions = new WeakMap(), _SolanaWalletAdapterWallet_chain = new WeakMap(), _SolanaWalletAdapterWallet_endpoint = new WeakMap(), _SolanaWalletAdapterWallet_account = new WeakMap(), _SolanaWalletAdapterWallet_connect = new WeakMap(), _SolanaWalletAdapterWallet_disconnect = new WeakMap(), _SolanaWalletAdapterWallet_on = new WeakMap(), _SolanaWalletAdapterWallet_signAndSendTransaction = new WeakMap(), _SolanaWalletAdapterWallet_signTransaction = new WeakMap(), _SolanaWalletAdapterWallet_signMessage = new WeakMap(), _SolanaWalletAdapterWallet_signIn = new WeakMap(), _SolanaWalletAdapterWallet_instances = new WeakSet(), _SolanaWalletAdapterWallet_connected = function _SolanaWalletAdapterWallet_connected() {\n  const publicKey = __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_adapter, \"f\").publicKey?.toBytes();\n  if (publicKey) {\n    const address = __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_adapter, \"f\").publicKey.toBase58();\n    const account = __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_account, \"f\");\n    if (!account || account.address !== address || account.chains.includes(__classPrivateFieldGet(this, _SolanaWalletAdapterWallet_chain, \"f\")) || !bytesEqual(account.publicKey, publicKey)) {\n      __classPrivateFieldSet(this, _SolanaWalletAdapterWallet_account, new SolanaWalletAdapterWalletAccount({\n        adapter: __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_adapter, \"f\"),\n        address,\n        publicKey,\n        chains: [__classPrivateFieldGet(this, _SolanaWalletAdapterWallet_chain, \"f\")]\n      }), \"f\");\n      __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_instances, \"m\", _SolanaWalletAdapterWallet_emit).call(this, 'change', {\n        accounts: this.accounts\n      });\n    }\n  }\n}, _SolanaWalletAdapterWallet_disconnected = function _SolanaWalletAdapterWallet_disconnected() {\n  if (__classPrivateFieldGet(this, _SolanaWalletAdapterWallet_account, \"f\")) {\n    __classPrivateFieldSet(this, _SolanaWalletAdapterWallet_account, undefined, \"f\");\n    __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_instances, \"m\", _SolanaWalletAdapterWallet_emit).call(this, 'change', {\n      accounts: this.accounts\n    });\n  }\n}, _SolanaWalletAdapterWallet_emit = function _SolanaWalletAdapterWallet_emit(event, ...args) {\n  // eslint-disable-next-line prefer-spread\n  __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_listeners, \"f\")[event]?.forEach(listener => listener.apply(null, args));\n}, _SolanaWalletAdapterWallet_off = function _SolanaWalletAdapterWallet_off(event, listener) {\n  __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_listeners, \"f\")[event] = __classPrivateFieldGet(this, _SolanaWalletAdapterWallet_listeners, \"f\")[event]?.filter(existingListener => listener !== existingListener);\n}, _SolanaWalletAdapterWallet_deserializeTransaction = function _SolanaWalletAdapterWallet_deserializeTransaction(serializedTransaction) {\n  const transaction = VersionedTransaction.deserialize(serializedTransaction);\n  if (!__classPrivateFieldGet(this, _SolanaWalletAdapterWallet_supportedTransactionVersions, \"f\").includes(transaction.version)) throw new Error('unsupported transaction version');\n  if (transaction.version === 'legacy' && arraysEqual(__classPrivateFieldGet(this, _SolanaWalletAdapterWallet_supportedTransactionVersions, \"f\"), ['legacy'])) return Transaction.from(serializedTransaction);\n  return transaction;\n};\n/** TODO: docs */\nexport function registerWalletAdapter(adapter, chain, endpoint, match = wallet => wallet.name === adapter.name) {\n  const {\n    register,\n    get,\n    on\n  } = getWallets();\n  const destructors = [];\n  function destroy() {\n    destructors.forEach(destroy => destroy());\n    destructors.length = 0;\n  }\n  function setup() {\n    // If the adapter is unsupported, or a standard wallet that matches it has already been registered, do nothing.\n    if (adapter.readyState === WalletReadyState.Unsupported || get().some(match)) return true;\n    // If the adapter isn't ready, try again later.\n    const ready = adapter.readyState === WalletReadyState.Installed || adapter.readyState === WalletReadyState.Loadable;\n    if (ready) {\n      const wallet = new SolanaWalletAdapterWallet(adapter, chain, endpoint);\n      destructors.push(() => wallet.destroy());\n      // Register the adapter wrapped as a standard wallet, and receive a function to unregister the adapter.\n      destructors.push(register(wallet));\n      // Whenever a standard wallet is registered ...\n      destructors.push(on('register', (...wallets) => {\n        // ... check if it matches the adapter.\n        if (wallets.some(match)) {\n          // If it does, remove the event listener and unregister the adapter.\n          destroy();\n        }\n      }));\n    }\n    return ready;\n  }\n  if (!setup()) {\n    function listener() {\n      if (setup()) {\n        adapter.off('readyStateChange', listener);\n      }\n    }\n    adapter.on('readyStateChange', listener);\n    destructors.push(() => adapter.off('readyStateChange', listener));\n  }\n  return destroy;\n}\n//# sourceMappingURL=wallet.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}