{"ast":null,"code":"import { proxy } from 'valtio/vanilla';\nimport { ConstantsUtil } from '../utils/ConstantsUtil.js';\nimport { CoreHelperUtil } from '../utils/CoreHelperUtil.js';\nimport { FetchUtil } from '../utils/FetchUtil.js';\nimport { StorageUtil } from '../utils/StorageUtil.js';\nimport { AccountController } from './AccountController.js';\nimport { ChainController } from './ChainController.js';\nimport { OptionsController } from './OptionsController.js';\nimport { SnackController } from './SnackController.js';\nconst DEFAULT_OPTIONS = {\n  purchaseCurrencies: [{\n    id: '2b92315d-eab7-5bef-84fa-089a131333f5',\n    name: 'USD Coin',\n    symbol: 'USDC',\n    networks: [{\n      name: 'ethereum-mainnet',\n      display_name: 'Ethereum',\n      chain_id: '1',\n      contract_address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'\n    }, {\n      name: 'polygon-mainnet',\n      display_name: 'Polygon',\n      chain_id: '137',\n      contract_address: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174'\n    }]\n  }, {\n    id: '2b92315d-eab7-5bef-84fa-089a131333f5',\n    name: 'Ether',\n    symbol: 'ETH',\n    networks: [{\n      name: 'ethereum-mainnet',\n      display_name: 'Ethereum',\n      chain_id: '1',\n      contract_address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'\n    }, {\n      name: 'polygon-mainnet',\n      display_name: 'Polygon',\n      chain_id: '137',\n      contract_address: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174'\n    }]\n  }],\n  paymentCurrencies: [{\n    id: 'USD',\n    payment_method_limits: [{\n      id: 'card',\n      min: '10.00',\n      max: '7500.00'\n    }, {\n      id: 'ach_bank_account',\n      min: '10.00',\n      max: '25000.00'\n    }]\n  }, {\n    id: 'EUR',\n    payment_method_limits: [{\n      id: 'card',\n      min: '10.00',\n      max: '7500.00'\n    }, {\n      id: 'ach_bank_account',\n      min: '10.00',\n      max: '25000.00'\n    }]\n  }]\n};\n// -- Helpers ------------------------------------------- //\nconst baseUrl = CoreHelperUtil.getBlockchainApiUrl();\n// -- State --------------------------------------------- //\nconst state = proxy({\n  clientId: null,\n  api: new FetchUtil({\n    baseUrl,\n    clientId: null\n  }),\n  supportedChains: {\n    http: [],\n    ws: []\n  }\n});\n// -- Controller ---------------------------------------- //\nexport const BlockchainApiController = {\n  state,\n  async get(request) {\n    const {\n      st,\n      sv\n    } = BlockchainApiController.getSdkProperties();\n    const projectId = OptionsController.state.projectId;\n    const params = {\n      ...(request.params || {}),\n      st,\n      sv,\n      projectId\n    };\n    return state.api.get({\n      ...request,\n      params\n    });\n  },\n  getSdkProperties() {\n    const {\n      sdkType,\n      sdkVersion\n    } = OptionsController.state;\n    return {\n      st: sdkType || 'unknown',\n      sv: sdkVersion || 'unknown'\n    };\n  },\n  async isNetworkSupported(networkId) {\n    if (!networkId) {\n      return false;\n    }\n    try {\n      if (!state.supportedChains.http.length) {\n        await BlockchainApiController.getSupportedNetworks();\n      }\n    } catch (e) {\n      return false;\n    }\n    return state.supportedChains.http.includes(networkId);\n  },\n  async getSupportedNetworks() {\n    const supportedChains = await BlockchainApiController.get({\n      path: 'v1/supported-chains'\n    });\n    state.supportedChains = supportedChains;\n    return supportedChains;\n  },\n  async fetchIdentity({\n    address,\n    caipNetworkId\n  }) {\n    const isSupported = await BlockchainApiController.isNetworkSupported(caipNetworkId);\n    if (!isSupported) {\n      return {\n        avatar: '',\n        name: ''\n      };\n    }\n    const identityCache = StorageUtil.getIdentityFromCacheForAddress(address);\n    if (identityCache) {\n      return identityCache;\n    }\n    const result = await BlockchainApiController.get({\n      path: `/v1/identity/${address}`,\n      params: {\n        sender: ChainController.state.activeCaipAddress ? CoreHelperUtil.getPlainAddress(ChainController.state.activeCaipAddress) : undefined\n      }\n    });\n    StorageUtil.updateIdentityCache({\n      address,\n      identity: result,\n      timestamp: Date.now()\n    });\n    return result;\n  },\n  async fetchTransactions({\n    account,\n    cursor,\n    onramp,\n    signal,\n    cache,\n    chainId\n  }) {\n    const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);\n    if (!isSupported) {\n      return {\n        data: [],\n        next: undefined\n      };\n    }\n    return BlockchainApiController.get({\n      path: `/v1/account/${account}/history`,\n      params: {\n        cursor,\n        onramp,\n        chainId\n      },\n      signal,\n      cache\n    });\n  },\n  async fetchSwapQuote({\n    amount,\n    userAddress,\n    from,\n    to,\n    gasPrice\n  }) {\n    const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);\n    if (!isSupported) {\n      return {\n        quotes: []\n      };\n    }\n    return BlockchainApiController.get({\n      path: `/v1/convert/quotes`,\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      params: {\n        amount,\n        userAddress,\n        from,\n        to,\n        gasPrice\n      }\n    });\n  },\n  async fetchSwapTokens({\n    chainId\n  }) {\n    const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);\n    if (!isSupported) {\n      return {\n        tokens: []\n      };\n    }\n    return BlockchainApiController.get({\n      path: `/v1/convert/tokens`,\n      params: {\n        chainId\n      }\n    });\n  },\n  async fetchTokenPrice({\n    addresses\n  }) {\n    const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);\n    if (!isSupported) {\n      return {\n        fungibles: []\n      };\n    }\n    return state.api.post({\n      path: '/v1/fungible/price',\n      body: {\n        currency: 'usd',\n        addresses,\n        projectId: OptionsController.state.projectId\n      },\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    });\n  },\n  async fetchSwapAllowance({\n    tokenAddress,\n    userAddress\n  }) {\n    const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);\n    if (!isSupported) {\n      return {\n        allowance: '0'\n      };\n    }\n    return BlockchainApiController.get({\n      path: `/v1/convert/allowance`,\n      params: {\n        tokenAddress,\n        userAddress\n      },\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    });\n  },\n  async fetchGasPrice({\n    chainId\n  }) {\n    const {\n      st,\n      sv\n    } = BlockchainApiController.getSdkProperties();\n    const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);\n    if (!isSupported) {\n      throw new Error('Network not supported for Gas Price');\n    }\n    return BlockchainApiController.get({\n      path: `/v1/convert/gas-price`,\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      params: {\n        chainId,\n        st,\n        sv\n      }\n    });\n  },\n  async generateSwapCalldata({\n    amount,\n    from,\n    to,\n    userAddress,\n    disableEstimate\n  }) {\n    const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);\n    if (!isSupported) {\n      throw new Error('Network not supported for Swaps');\n    }\n    return state.api.post({\n      path: '/v1/convert/build-transaction',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: {\n        amount,\n        eip155: {\n          slippage: ConstantsUtil.CONVERT_SLIPPAGE_TOLERANCE\n        },\n        projectId: OptionsController.state.projectId,\n        from,\n        to,\n        userAddress,\n        disableEstimate\n      }\n    });\n  },\n  async generateApproveCalldata({\n    from,\n    to,\n    userAddress\n  }) {\n    const {\n      st,\n      sv\n    } = BlockchainApiController.getSdkProperties();\n    const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);\n    if (!isSupported) {\n      throw new Error('Network not supported for Swaps');\n    }\n    return BlockchainApiController.get({\n      path: `/v1/convert/build-approve`,\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      params: {\n        userAddress,\n        from,\n        to,\n        st,\n        sv\n      }\n    });\n  },\n  async getBalance(address, chainId, forceUpdate) {\n    const {\n      st,\n      sv\n    } = BlockchainApiController.getSdkProperties();\n    const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);\n    if (!isSupported) {\n      SnackController.showError('Token Balance Unavailable');\n      return {\n        balances: []\n      };\n    }\n    const caipAddress = `${chainId}:${address}`;\n    const cachedBalance = StorageUtil.getBalanceCacheForCaipAddress(caipAddress);\n    if (cachedBalance) {\n      return cachedBalance;\n    }\n    const balance = await BlockchainApiController.get({\n      path: `/v1/account/${address}/balance`,\n      params: {\n        currency: 'usd',\n        chainId,\n        forceUpdate,\n        st,\n        sv\n      }\n    });\n    StorageUtil.updateBalanceCache({\n      caipAddress,\n      balance,\n      timestamp: Date.now()\n    });\n    return balance;\n  },\n  async lookupEnsName(name) {\n    const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);\n    if (!isSupported) {\n      return {\n        addresses: {},\n        attributes: []\n      };\n    }\n    return BlockchainApiController.get({\n      path: `/v1/profile/account/${name}`,\n      params: {\n        apiVersion: '2'\n      }\n    });\n  },\n  async reverseLookupEnsName({\n    address\n  }) {\n    const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);\n    if (!isSupported) {\n      return [];\n    }\n    return BlockchainApiController.get({\n      path: `/v1/profile/reverse/${address}`,\n      params: {\n        sender: AccountController.state.address,\n        apiVersion: '2'\n      }\n    });\n  },\n  async getEnsNameSuggestions(name) {\n    const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);\n    if (!isSupported) {\n      return {\n        suggestions: []\n      };\n    }\n    return BlockchainApiController.get({\n      path: `/v1/profile/suggestions/${name}`,\n      params: {\n        zone: 'reown.id'\n      }\n    });\n  },\n  async registerEnsName({\n    coinType,\n    address,\n    message,\n    signature\n  }) {\n    const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);\n    if (!isSupported) {\n      return {\n        success: false\n      };\n    }\n    return state.api.post({\n      path: `/v1/profile/account`,\n      body: {\n        coin_type: coinType,\n        address,\n        message,\n        signature\n      },\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    });\n  },\n  async generateOnRampURL({\n    destinationWallets,\n    partnerUserId,\n    defaultNetwork,\n    purchaseAmount,\n    paymentAmount\n  }) {\n    const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);\n    if (!isSupported) {\n      return '';\n    }\n    const response = await state.api.post({\n      path: `/v1/generators/onrampurl`,\n      params: {\n        projectId: OptionsController.state.projectId\n      },\n      body: {\n        destinationWallets,\n        defaultNetwork,\n        partnerUserId,\n        defaultExperience: 'buy',\n        presetCryptoAmount: purchaseAmount,\n        presetFiatAmount: paymentAmount\n      }\n    });\n    return response.url;\n  },\n  async getOnrampOptions() {\n    const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);\n    if (!isSupported) {\n      return {\n        paymentCurrencies: [],\n        purchaseCurrencies: []\n      };\n    }\n    try {\n      const response = await BlockchainApiController.get({\n        path: `/v1/onramp/options`\n      });\n      return response;\n    } catch (e) {\n      return DEFAULT_OPTIONS;\n    }\n  },\n  async getOnrampQuote({\n    purchaseCurrency,\n    paymentCurrency,\n    amount,\n    network\n  }) {\n    try {\n      const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);\n      if (!isSupported) {\n        return null;\n      }\n      const response = await state.api.post({\n        path: `/v1/onramp/quote`,\n        params: {\n          projectId: OptionsController.state.projectId\n        },\n        body: {\n          purchaseCurrency,\n          paymentCurrency,\n          amount,\n          network\n        }\n      });\n      return response;\n    } catch (e) {\n      // Mocking response as 1:1 until endpoint is ready\n      return {\n        coinbaseFee: {\n          amount,\n          currency: paymentCurrency.id\n        },\n        networkFee: {\n          amount,\n          currency: paymentCurrency.id\n        },\n        paymentSubtotal: {\n          amount,\n          currency: paymentCurrency.id\n        },\n        paymentTotal: {\n          amount,\n          currency: paymentCurrency.id\n        },\n        purchaseAmount: {\n          amount,\n          currency: paymentCurrency.id\n        },\n        quoteId: 'mocked-quote-id'\n      };\n    }\n  },\n  async getSmartSessions(caipAddress) {\n    const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);\n    if (!isSupported) {\n      return [];\n    }\n    return BlockchainApiController.get({\n      path: `/v1/sessions/${caipAddress}`\n    });\n  },\n  async revokeSmartSession(address, pci, signature) {\n    const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);\n    if (!isSupported) {\n      return {\n        success: false\n      };\n    }\n    return state.api.post({\n      path: `/v1/sessions/${address}/revoke`,\n      params: {\n        projectId: OptionsController.state.projectId\n      },\n      body: {\n        pci,\n        signature\n      }\n    });\n  },\n  setClientId(clientId) {\n    state.clientId = clientId;\n    state.api = new FetchUtil({\n      baseUrl,\n      clientId\n    });\n  }\n};\n//# sourceMappingURL=BlockchainApiController.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}