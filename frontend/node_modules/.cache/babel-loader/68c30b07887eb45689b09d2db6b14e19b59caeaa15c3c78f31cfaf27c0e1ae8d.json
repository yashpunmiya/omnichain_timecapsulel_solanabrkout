{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CryptoKeypath = void 0;\nconst lib_1 = require(\"./lib\");\nconst PathComponent_1 = require(\"./PathComponent\");\nconst RegistryItem_1 = require(\"./RegistryItem\");\nconst RegistryType_1 = require(\"./RegistryType\");\nvar Keys;\n(function (Keys) {\n  Keys[Keys[\"components\"] = 1] = \"components\";\n  Keys[Keys[\"source_fingerprint\"] = 2] = \"source_fingerprint\";\n  Keys[Keys[\"depth\"] = 3] = \"depth\";\n})(Keys || (Keys = {}));\nclass CryptoKeypath extends RegistryItem_1.RegistryItem {\n  constructor(components = [], sourceFingerprint, depth) {\n    super();\n    this.components = components;\n    this.sourceFingerprint = sourceFingerprint;\n    this.depth = depth;\n    this.getRegistryType = () => {\n      return RegistryType_1.RegistryTypes.CRYPTO_KEYPATH;\n    };\n    this.getPath = () => {\n      if (this.components.length === 0) {\n        return undefined;\n      }\n      const components = this.components.map(component => {\n        return `${component.isWildcard() ? '*' : component.getIndex()}${component.isHardened() ? \"'\" : ''}`;\n      });\n      return components.join('/');\n    };\n    this.getComponents = () => this.components;\n    this.getSourceFingerprint = () => this.sourceFingerprint;\n    this.getDepth = () => this.depth;\n    this.toDataItem = () => {\n      const map = {};\n      const components = [];\n      this.components && this.components.forEach(component => {\n        if (component.isWildcard()) {\n          components.push([]);\n        } else {\n          components.push(component.getIndex());\n        }\n        components.push(component.isHardened());\n      });\n      map[Keys.components] = components;\n      if (this.sourceFingerprint) {\n        map[Keys.source_fingerprint] = this.sourceFingerprint.readUInt32BE(0);\n      }\n      if (this.depth !== undefined) {\n        map[Keys.depth] = this.depth;\n      }\n      return new lib_1.DataItem(map);\n    };\n  }\n}\nexports.CryptoKeypath = CryptoKeypath;\nCryptoKeypath.fromDataItem = dataItem => {\n  const map = dataItem.getData();\n  const pathComponents = [];\n  const components = map[Keys.components];\n  if (components) {\n    for (let i = 0; i < components.length; i += 2) {\n      const isHardened = components[i + 1];\n      const path = components[i];\n      if (typeof path === 'number') {\n        pathComponents.push(new PathComponent_1.PathComponent({\n          index: path,\n          hardened: isHardened\n        }));\n      } else {\n        pathComponents.push(new PathComponent_1.PathComponent({\n          hardened: isHardened\n        }));\n      }\n    }\n  }\n  const _sourceFingerprint = map[Keys.source_fingerprint];\n  let sourceFingerprint;\n  if (_sourceFingerprint) {\n    sourceFingerprint = Buffer.alloc(4);\n    sourceFingerprint.writeUInt32BE(_sourceFingerprint, 0);\n  }\n  const depth = map[Keys.depth];\n  return new CryptoKeypath(pathComponents, sourceFingerprint, depth);\n};\nCryptoKeypath.fromCBOR = _cborPayload => {\n  const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);\n  return CryptoKeypath.fromDataItem(dataItem);\n};","map":{"version":3,"names":["lib_1","require","PathComponent_1","RegistryItem_1","RegistryType_1","Keys","CryptoKeypath","RegistryItem","constructor","components","sourceFingerprint","depth","getRegistryType","RegistryTypes","CRYPTO_KEYPATH","getPath","length","undefined","map","component","isWildcard","getIndex","isHardened","join","getComponents","getSourceFingerprint","getDepth","toDataItem","forEach","push","source_fingerprint","readUInt32BE","DataItem","exports","fromDataItem","dataItem","getData","pathComponents","i","path","PathComponent","index","hardened","_sourceFingerprint","Buffer","alloc","writeUInt32BE","fromCBOR","_cborPayload","decodeToDataItem"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@keystonehq\\bc-ur-registry-sol\\node_modules\\@keystonehq\\bc-ur-registry\\src\\CryptoKeypath.ts"],"sourcesContent":["import { decodeToDataItem, DataItem } from './lib';\nimport { PathComponent } from './PathComponent';\nimport { RegistryItem } from './RegistryItem';\nimport { RegistryTypes } from './RegistryType';\nimport { DataItemMap } from './types';\n\nenum Keys {\n  components = 1,\n  source_fingerprint,\n  depth,\n}\n\nexport class CryptoKeypath extends RegistryItem {\n  getRegistryType = () => {\n    return RegistryTypes.CRYPTO_KEYPATH;\n  };\n\n  constructor(\n    private components: PathComponent[] = [],\n    private sourceFingerprint?: Buffer,\n    private depth?: number,\n  ) {\n    super();\n  }\n\n  public getPath = () => {\n    if (this.components.length === 0) {\n      return undefined;\n    }\n\n    const components = this.components.map((component) => {\n      return `${component.isWildcard() ? '*' : component.getIndex()}${\n        component.isHardened() ? \"'\" : ''\n      }`;\n    });\n    return components.join('/');\n  };\n\n  public getComponents = () => this.components;\n  public getSourceFingerprint = () => this.sourceFingerprint;\n  public getDepth = () => this.depth;\n\n  toDataItem = () => {\n    const map: DataItemMap = {};\n    const components: (number | boolean | any[])[] = [];\n    this.components &&\n      this.components.forEach((component) => {\n        if (component.isWildcard()) {\n          components.push([]);\n        } else {\n          components.push(component.getIndex() as number);\n        }\n        components.push(component.isHardened());\n      });\n    map[Keys.components] = components;\n    if (this.sourceFingerprint) {\n      map[Keys.source_fingerprint] = this.sourceFingerprint.readUInt32BE(0);\n    }\n    if (this.depth !== undefined) {\n      map[Keys.depth] = this.depth;\n    }\n    return new DataItem(map);\n  };\n\n  static fromDataItem = (dataItem: DataItem) => {\n    const map: Record<string, any> = dataItem.getData();\n    const pathComponents: PathComponent[] = [];\n    const components = map[Keys.components] as any[];\n    if (components) {\n      for (let i = 0; i < components.length; i += 2) {\n        const isHardened = components[i + 1];\n        const path = components[i];\n        if (typeof path === 'number') {\n          pathComponents.push(\n            new PathComponent({ index: path, hardened: isHardened }),\n          );\n        } else {\n          pathComponents.push(new PathComponent({ hardened: isHardened }));\n        }\n      }\n    }\n    const _sourceFingerprint = map[Keys.source_fingerprint];\n    let sourceFingerprint: Buffer | undefined;\n    if (_sourceFingerprint) {\n      sourceFingerprint = Buffer.alloc(4);\n      sourceFingerprint.writeUInt32BE(_sourceFingerprint, 0);\n    }\n    const depth = map[Keys.depth];\n    return new CryptoKeypath(pathComponents, sourceFingerprint, depth);\n  };\n\n  public static fromCBOR = (_cborPayload: Buffer) => {\n    const dataItem = decodeToDataItem(_cborPayload);\n    return CryptoKeypath.fromDataItem(dataItem);\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}