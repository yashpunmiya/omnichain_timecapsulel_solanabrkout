{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TypeSystem = exports.TypeSystemDuplicateFormat = exports.TypeSystemDuplicateTypeKind = void 0;\nconst index_1 = require(\"../type/registry/index\");\nconst index_2 = require(\"../type/unsafe/index\");\nconst index_3 = require(\"../type/symbols/index\");\nconst index_4 = require(\"../type/error/index\");\n// ------------------------------------------------------------------\n// Errors\n// ------------------------------------------------------------------\nclass TypeSystemDuplicateTypeKind extends index_4.TypeBoxError {\n  constructor(kind) {\n    super(`Duplicate type kind '${kind}' detected`);\n  }\n}\nexports.TypeSystemDuplicateTypeKind = TypeSystemDuplicateTypeKind;\nclass TypeSystemDuplicateFormat extends index_4.TypeBoxError {\n  constructor(kind) {\n    super(`Duplicate string format '${kind}' detected`);\n  }\n}\nexports.TypeSystemDuplicateFormat = TypeSystemDuplicateFormat;\n/** Creates user defined types and formats and provides overrides for value checking behaviours */\nvar TypeSystem;\n(function (TypeSystem) {\n  /** Creates a new type */\n  function Type(kind, check) {\n    if (index_1.TypeRegistry.Has(kind)) throw new TypeSystemDuplicateTypeKind(kind);\n    index_1.TypeRegistry.Set(kind, check);\n    return (options = {}) => (0, index_2.Unsafe)({\n      ...options,\n      [index_3.Kind]: kind\n    });\n  }\n  TypeSystem.Type = Type;\n  /** Creates a new string format */\n  function Format(format, check) {\n    if (index_1.FormatRegistry.Has(format)) throw new TypeSystemDuplicateFormat(format);\n    index_1.FormatRegistry.Set(format, check);\n    return format;\n  }\n  TypeSystem.Format = Format;\n})(TypeSystem || (exports.TypeSystem = TypeSystem = {}));","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}