{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport EventEmitter from \"events\";\nimport { TransportRaceCondition, TransportError, StatusCodes, getAltStatusMessage, TransportStatusError } from \"@ledgerhq/errors\";\nimport { LocalTracer } from \"@ledgerhq/logs\";\nexport { TransportError, TransportStatusError, StatusCodes, getAltStatusMessage };\nconst DEFAULT_LOG_TYPE = \"transport\";\n/**\n * The Transport class defines a generic interface for communicating with a Ledger hardware wallet.\n * There are different kind of transports based on the technology (channels like U2F, HID, Bluetooth, Webusb) and environment (Node, Web,...).\n * It is an abstract class that needs to be implemented.\n */\nclass Transport {\n  constructor({\n    context,\n    logType\n  } = {}) {\n    this.exchangeTimeout = 30000;\n    this.unresponsiveTimeout = 15000;\n    this.deviceModel = null;\n    this._events = new EventEmitter();\n    /**\n     * Send data to the device using the higher level API.\n     *\n     * @param {number} cla - The instruction class for the command.\n     * @param {number} ins - The instruction code for the command.\n     * @param {number} p1 - The first parameter for the instruction.\n     * @param {number} p2 - The second parameter for the instruction.\n     * @param {Buffer} data - The data to be sent. Defaults to an empty buffer.\n     * @param {Array<number>} statusList - A list of acceptable status codes for the response. Defaults to [StatusCodes.OK].\n     * @param {Object} options - Contains optional options for the exchange function\n     *  - abortTimeoutMs: stop the send after a given timeout. Another timeout exists\n     *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.\n     * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.\n     */\n    this.send = (cla_1, ins_1, p1_1, p2_1, ...args_1) => __awaiter(this, [cla_1, ins_1, p1_1, p2_1, ...args_1], void 0, function* (cla, ins, p1, p2, data = Buffer.alloc(0), statusList = [StatusCodes.OK], {\n      abortTimeoutMs\n    } = {}) {\n      const tracer = this.tracer.withUpdatedContext({\n        function: \"send\"\n      });\n      if (data.length >= 256) {\n        tracer.trace(\"data.length exceeded 256 bytes limit\", {\n          dataLength: data.length\n        });\n        throw new TransportError(\"data.length exceed 256 bytes limit. Got: \" + data.length, \"DataLengthTooBig\");\n      }\n      tracer.trace(\"Starting an exchange\", {\n        abortTimeoutMs\n      });\n      const response = yield this.exchange(\n      // The size of the data is added in 1 byte just before `data`\n      Buffer.concat([Buffer.from([cla, ins, p1, p2]), Buffer.from([data.length]), data]), {\n        abortTimeoutMs\n      });\n      tracer.trace(\"Received response from exchange\");\n      const sw = response.readUInt16BE(response.length - 2);\n      if (!statusList.some(s => s === sw)) {\n        throw new TransportStatusError(sw);\n      }\n      return response;\n    });\n    this._appAPIlock = null;\n    this.tracer = new LocalTracer(logType !== null && logType !== void 0 ? logType : DEFAULT_LOG_TYPE, context);\n  }\n  /**\n   * Send data to the device using a low level API.\n   * It's recommended to use the \"send\" method for a higher level API.\n   * @param {Buffer} apdu - The data to send.\n   * @param {Object} options - Contains optional options for the exchange function\n   *  - abortTimeoutMs: stop the exchange after a given timeout. Another timeout exists\n   *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.\n   * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.\n   */\n  exchange(_apdu, {\n    abortTimeoutMs: _abortTimeoutMs\n  } = {}) {\n    throw new Error(\"exchange not implemented\");\n  }\n  /**\n   * Send apdus in batch to the device using a low level API.\n   * The default implementation is to call exchange for each apdu.\n   * @param {Array<Buffer>} apdus - array of apdus to send.\n   * @param {Observer<Buffer>} observer - an observer that will receive the response of each apdu.\n   * @returns {Subscription} A Subscription object on which you can call \".unsubscribe()\" to stop sending apdus.\n   */\n  exchangeBulk(apdus, observer) {\n    let unsubscribed = false;\n    const unsubscribe = () => {\n      unsubscribed = true;\n    };\n    const main = () => __awaiter(this, void 0, void 0, function* () {\n      if (unsubscribed) return;\n      for (const apdu of apdus) {\n        const r = yield this.exchange(apdu);\n        if (unsubscribed) return;\n        const status = r.readUInt16BE(r.length - 2);\n        if (status !== StatusCodes.OK) {\n          throw new TransportStatusError(status);\n        }\n        observer.next(r);\n      }\n    });\n    main().then(() => !unsubscribed && observer.complete(), e => !unsubscribed && observer.error(e));\n    return {\n      unsubscribe\n    };\n  }\n  /**\n   * Set the \"scramble key\" for the next data exchanges with the device.\n   * Each app can have a different scramble key and it is set internally during instantiation.\n   * @param {string} key - The scramble key to set.\n   * deprecated This method is no longer needed for modern transports and should be migrated away from.\n   * no @ before deprecated as it breaks documentationjs on version 14.0.2\n   * https://github.com/documentationjs/documentation/issues/1596\n   */\n  setScrambleKey(_key) {}\n  /**\n   * Close the connection with the device.\n   *\n   * Note: for certain transports (hw-transport-node-hid-singleton for ex), once the promise resolved,\n   * the transport instance is actually still cached, and the device is disconnected only after a defined timeout.\n   * But for the consumer of the Transport, this does not matter and it can consider the transport to be closed.\n   *\n   * @returns {Promise<void>} A promise that resolves when the transport is closed.\n   */\n  close() {\n    return Promise.resolve();\n  }\n  /**\n   * Listen for an event on the transport instance.\n   * Transport implementations may have specific events. Common events include:\n   * \"disconnect\" : triggered when the transport is disconnected.\n   * @param {string} eventName - The name of the event to listen for.\n   * @param {(...args: Array<any>) => any} cb - The callback function to be invoked when the event occurs.\n   */\n  on(eventName, cb) {\n    this._events.on(eventName, cb);\n  }\n  /**\n   * Stop listening to an event on an instance of transport.\n   */\n  off(eventName, cb) {\n    this._events.removeListener(eventName, cb);\n  }\n  emit(event, ...args) {\n    this._events.emit(event, ...args);\n  }\n  /**\n   * Enable or not logs of the binary exchange\n   */\n  setDebugMode() {\n    console.warn(\"setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.\");\n  }\n  /**\n   * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)\n   */\n  setExchangeTimeout(exchangeTimeout) {\n    this.exchangeTimeout = exchangeTimeout;\n  }\n  /**\n   * Define the delay before emitting \"unresponsive\" on an exchange that does not respond\n   */\n  setExchangeUnresponsiveTimeout(unresponsiveTimeout) {\n    this.unresponsiveTimeout = unresponsiveTimeout;\n  }\n  /**\n   * create() allows to open the first descriptor available or\n   * throw if there is none or if timeout is reached.\n   * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)\n   * @example\n  TransportFoo.create().then(transport => ...)\n   */\n  static create(openTimeout = 3000, listenTimeout) {\n    return new Promise((resolve, reject) => {\n      let found = false;\n      const sub = this.listen({\n        next: e => {\n          found = true;\n          if (sub) sub.unsubscribe();\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          this.open(e.descriptor, openTimeout).then(resolve, reject);\n        },\n        error: e => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          reject(e);\n        },\n        complete: () => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          if (!found) {\n            reject(new TransportError(this.ErrorMessage_NoDeviceFound, \"NoDeviceFound\"));\n          }\n        }\n      });\n      const listenTimeoutId = listenTimeout ? setTimeout(() => {\n        sub.unsubscribe();\n        reject(new TransportError(this.ErrorMessage_ListenTimeout, \"ListenTimeout\"));\n      }, listenTimeout) : null;\n    });\n  }\n  /**\n   * Wrapper to make an exchange \"atomic\" (blocking any other exchange)\n   *\n   * It also handles \"unresponsiveness\" by emitting \"unresponsive\" and \"responsive\" events.\n   *\n   * @param f The exchange job, using the transport to run\n   * @returns a Promise resolving with the output of the given job\n   */\n  exchangeAtomicImpl(f) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const tracer = this.tracer.withUpdatedContext({\n        function: \"exchangeAtomicImpl\",\n        unresponsiveTimeout: this.unresponsiveTimeout\n      });\n      if (this.exchangeBusyPromise) {\n        tracer.trace(\"Atomic exchange is already busy\");\n        throw new TransportRaceCondition(\"An action was already pending on the Ledger device. Please deny or reconnect.\");\n      }\n      // Sets the atomic guard\n      let resolveBusy;\n      const busyPromise = new Promise(r => {\n        resolveBusy = r;\n      });\n      this.exchangeBusyPromise = busyPromise;\n      // The device unresponsiveness handler\n      let unresponsiveReached = false;\n      const timeout = setTimeout(() => {\n        tracer.trace(`Timeout reached, emitting Transport event \"unresponsive\"`, {\n          unresponsiveTimeout: this.unresponsiveTimeout\n        });\n        unresponsiveReached = true;\n        this.emit(\"unresponsive\");\n      }, this.unresponsiveTimeout);\n      try {\n        const res = yield f();\n        if (unresponsiveReached) {\n          tracer.trace(\"Device was unresponsive, emitting responsive\");\n          this.emit(\"responsive\");\n        }\n        return res;\n      } finally {\n        tracer.trace(\"Finalize, clearing busy guard\");\n        clearTimeout(timeout);\n        if (resolveBusy) resolveBusy();\n        this.exchangeBusyPromise = null;\n      }\n    });\n  }\n  decorateAppAPIMethods(self, methods, scrambleKey) {\n    for (const methodName of methods) {\n      self[methodName] = this.decorateAppAPIMethod(methodName, self[methodName], self, scrambleKey);\n    }\n  }\n  decorateAppAPIMethod(methodName, f, ctx, scrambleKey) {\n    return (...args) => __awaiter(this, void 0, void 0, function* () {\n      const {\n        _appAPIlock\n      } = this;\n      if (_appAPIlock) {\n        return Promise.reject(new TransportError(\"Ledger Device is busy (lock \" + _appAPIlock + \")\", \"TransportLocked\"));\n      }\n      try {\n        this._appAPIlock = methodName;\n        this.setScrambleKey(scrambleKey);\n        return yield f.apply(ctx, args);\n      } finally {\n        this._appAPIlock = null;\n      }\n    });\n  }\n  /**\n   * Sets the context used by the logging/tracing mechanism\n   *\n   * Useful when re-using (cached) the same Transport instance,\n   * but with a new tracing context.\n   *\n   * @param context A TraceContext, that can undefined to reset the context\n   */\n  setTraceContext(context) {\n    this.tracer = this.tracer.withContext(context);\n  }\n  /**\n   * Updates the context used by the logging/tracing mechanism\n   *\n   * The update only overrides the key-value that are already defined in the current context.\n   *\n   * @param contextToAdd A TraceContext that will be added to the current context\n   */\n  updateTraceContext(contextToAdd) {\n    this.tracer.updateContext(contextToAdd);\n  }\n  /**\n   * Gets the tracing context of the transport instance\n   */\n  getTraceContext() {\n    return this.tracer.getContext();\n  }\n}\nTransport.ErrorMessage_ListenTimeout = \"No Ledger device found (timeout)\";\nTransport.ErrorMessage_NoDeviceFound = \"No Ledger device found\";\nexport default Transport;","map":{"version":3,"names":["EventEmitter","TransportRaceCondition","TransportError","StatusCodes","getAltStatusMessage","TransportStatusError","LocalTracer","DEFAULT_LOG_TYPE","Transport","constructor","context","logType","exchangeTimeout","unresponsiveTimeout","deviceModel","_events","send","cla_1","ins_1","p1_1","p2_1","args_1","__awaiter","cla","ins","p1","p2","data","Buffer","alloc","statusList","OK","abortTimeoutMs","tracer","withUpdatedContext","function","length","trace","dataLength","response","exchange","concat","from","sw","readUInt16BE","some","s","_appAPIlock","_apdu","_abortTimeoutMs","Error","exchangeBulk","apdus","observer","unsubscribed","unsubscribe","main","apdu","r","status","next","then","complete","e","error","setScrambleKey","_key","close","Promise","resolve","on","eventName","cb","off","removeListener","emit","event","args","setDebugMode","console","warn","setExchangeTimeout","setExchangeUnresponsiveTimeout","create","openTimeout","listenTimeout","reject","found","sub","listen","listenTimeoutId","clearTimeout","open","descriptor","ErrorMessage_NoDeviceFound","setTimeout","ErrorMessage_ListenTimeout","exchangeAtomicImpl","f","exchangeBusyPromise","resolveBusy","busyPromise","unresponsiveReached","timeout","res","decorateAppAPIMethods","self","methods","scrambleKey","methodName","decorateAppAPIMethod","ctx","apply","setTraceContext","withContext","updateTraceContext","contextToAdd","updateContext","getTraceContext","getContext"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@ledgerhq\\hw-transport\\src\\Transport.ts"],"sourcesContent":["import EventEmitter from \"events\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport {\n  TransportRaceCondition,\n  TransportError,\n  StatusCodes,\n  getAltStatusMessage,\n  TransportStatusError,\n} from \"@ledgerhq/errors\";\nimport { LocalTracer, TraceContext, LogType } from \"@ledgerhq/logs\";\nexport { TransportError, TransportStatusError, StatusCodes, getAltStatusMessage };\n\nconst DEFAULT_LOG_TYPE = \"transport\";\n\n/**\n */\nexport type Subscription = {\n  unsubscribe: () => void;\n};\n\n/**\n */\nexport type Device = any; // Should be a union type of all possible Device object's shape\n\nexport type DescriptorEventType = \"add\" | \"remove\";\n/**\n * A \"descriptor\" is a parameter that is specific to the implementation, and can be an ID, file path, or URL.\n * type: add or remove event\n * descriptor: a parameter that can be passed to open(descriptor)\n * deviceModel: device info on the model (is it a nano s, nano x, ...)\n * device: transport specific device info\n */\nexport interface DescriptorEvent<Descriptor> {\n  type: DescriptorEventType;\n  descriptor: Descriptor;\n  deviceModel?: DeviceModel | null | undefined;\n  device?: Device;\n}\n\n/**\n * Observer generic type, following the Observer pattern\n */\nexport type Observer<EventType, EventError = unknown> = Readonly<{\n  next: (event: EventType) => unknown;\n  error: (e: EventError) => unknown;\n  complete: () => unknown;\n}>;\n\n/**\n * The Transport class defines a generic interface for communicating with a Ledger hardware wallet.\n * There are different kind of transports based on the technology (channels like U2F, HID, Bluetooth, Webusb) and environment (Node, Web,...).\n * It is an abstract class that needs to be implemented.\n */\nexport default class Transport {\n  exchangeTimeout = 30000;\n  unresponsiveTimeout = 15000;\n  deviceModel: DeviceModel | null | undefined = null;\n  tracer: LocalTracer;\n\n  constructor({ context, logType }: { context?: TraceContext; logType?: LogType } = {}) {\n    this.tracer = new LocalTracer(logType ?? DEFAULT_LOG_TYPE, context);\n  }\n\n  /**\n   * Check if the transport is supported on the current platform/browser.\n   * @returns {Promise<boolean>} A promise that resolves with a boolean indicating support.\n   */\n  static readonly isSupported: () => Promise<boolean>;\n\n  /**\n   * List all available descriptors for the transport.\n   * For a better granularity, checkout `listen()`.\n   *\n   * @returns {Promise<Array<any>>} A promise that resolves with an array of descriptors.\n   * @example\n   * TransportFoo.list().then(descriptors => ...)\n   */\n  static readonly list: () => Promise<Array<any>>;\n\n  /**\n   * Listen for device events for the transport. The method takes an observer of DescriptorEvent and returns a Subscription.\n   * A DescriptorEvent is an object containing a \"descriptor\" and a \"type\" field. The \"type\" field can be \"add\" or \"remove\", and the \"descriptor\" field can be passed to the \"open\" method.\n   * The \"listen\" method will first emit all currently connected devices and then will emit events as they occur, such as when a USB device is plugged in or a Bluetooth device becomes discoverable.\n   * @param {Observer<DescriptorEvent<any>>} observer - An object with \"next\", \"error\", and \"complete\" functions, following the observer pattern.\n   * @returns {Subscription} A Subscription object on which you can call \".unsubscribe()\" to stop listening to descriptors.\n   * @example\n  const sub = TransportFoo.listen({\n  next: e => {\n    if (e.type===\"add\") {\n      sub.unsubscribe();\n      const transport = await TransportFoo.open(e.descriptor);\n      ...\n    }\n  },\n  error: error => {},\n  complete: () => {}\n  })\n   */\n  static readonly listen: (observer: Observer<DescriptorEvent<any>>) => Subscription;\n\n  /**\n   * Attempt to create a Transport instance with a specific descriptor.\n   * @param {any} descriptor - The descriptor to open the transport with.\n   * @param {number} timeout - An optional timeout for the transport connection.\n   * @param {TraceContext} context Optional tracing/log context\n   * @returns {Promise<Transport>} A promise that resolves with a Transport instance.\n   * @example\n  TransportFoo.open(descriptor).then(transport => ...)\n   */\n  static readonly open: (\n    descriptor?: any,\n    timeoutMs?: number,\n    context?: TraceContext,\n  ) => Promise<Transport>;\n\n  /**\n   * Send data to the device using a low level API.\n   * It's recommended to use the \"send\" method for a higher level API.\n   * @param {Buffer} apdu - The data to send.\n   * @param {Object} options - Contains optional options for the exchange function\n   *  - abortTimeoutMs: stop the exchange after a given timeout. Another timeout exists\n   *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.\n   * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.\n   */\n  exchange(\n    _apdu: Buffer,\n    { abortTimeoutMs: _abortTimeoutMs }: { abortTimeoutMs?: number } = {},\n  ): Promise<Buffer> {\n    throw new Error(\"exchange not implemented\");\n  }\n\n  /**\n   * Send apdus in batch to the device using a low level API.\n   * The default implementation is to call exchange for each apdu.\n   * @param {Array<Buffer>} apdus - array of apdus to send.\n   * @param {Observer<Buffer>} observer - an observer that will receive the response of each apdu.\n   * @returns {Subscription} A Subscription object on which you can call \".unsubscribe()\" to stop sending apdus.\n   */\n  exchangeBulk(apdus: Buffer[], observer: Observer<Buffer>): Subscription {\n    let unsubscribed = false;\n    const unsubscribe = () => {\n      unsubscribed = true;\n    };\n\n    const main = async () => {\n      if (unsubscribed) return;\n      for (const apdu of apdus) {\n        const r = await this.exchange(apdu);\n        if (unsubscribed) return;\n        const status = r.readUInt16BE(r.length - 2);\n        if (status !== StatusCodes.OK) {\n          throw new TransportStatusError(status);\n        }\n        observer.next(r);\n      }\n    };\n\n    main().then(\n      () => !unsubscribed && observer.complete(),\n      e => !unsubscribed && observer.error(e),\n    );\n\n    return { unsubscribe };\n  }\n\n  /**\n   * Set the \"scramble key\" for the next data exchanges with the device.\n   * Each app can have a different scramble key and it is set internally during instantiation.\n   * @param {string} key - The scramble key to set.\n   * deprecated This method is no longer needed for modern transports and should be migrated away from.\n   * no @ before deprecated as it breaks documentationjs on version 14.0.2\n   * https://github.com/documentationjs/documentation/issues/1596\n   */\n  setScrambleKey(_key: string) {}\n\n  /**\n   * Close the connection with the device.\n   *\n   * Note: for certain transports (hw-transport-node-hid-singleton for ex), once the promise resolved,\n   * the transport instance is actually still cached, and the device is disconnected only after a defined timeout.\n   * But for the consumer of the Transport, this does not matter and it can consider the transport to be closed.\n   *\n   * @returns {Promise<void>} A promise that resolves when the transport is closed.\n   */\n  close(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  _events = new EventEmitter();\n\n  /**\n   * Listen for an event on the transport instance.\n   * Transport implementations may have specific events. Common events include:\n   * \"disconnect\" : triggered when the transport is disconnected.\n   * @param {string} eventName - The name of the event to listen for.\n   * @param {(...args: Array<any>) => any} cb - The callback function to be invoked when the event occurs.\n   */\n  on(eventName: string, cb: (...args: Array<any>) => any): void {\n    this._events.on(eventName, cb);\n  }\n\n  /**\n   * Stop listening to an event on an instance of transport.\n   */\n  off(eventName: string, cb: (...args: Array<any>) => any): void {\n    this._events.removeListener(eventName, cb);\n  }\n\n  emit(event: string, ...args: any): void {\n    this._events.emit(event, ...args);\n  }\n\n  /**\n   * Enable or not logs of the binary exchange\n   */\n  setDebugMode() {\n    console.warn(\n      \"setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.\",\n    );\n  }\n\n  /**\n   * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)\n   */\n  setExchangeTimeout(exchangeTimeout: number): void {\n    this.exchangeTimeout = exchangeTimeout;\n  }\n\n  /**\n   * Define the delay before emitting \"unresponsive\" on an exchange that does not respond\n   */\n  setExchangeUnresponsiveTimeout(unresponsiveTimeout: number): void {\n    this.unresponsiveTimeout = unresponsiveTimeout;\n  }\n\n  /**\n   * Send data to the device using the higher level API.\n   *\n   * @param {number} cla - The instruction class for the command.\n   * @param {number} ins - The instruction code for the command.\n   * @param {number} p1 - The first parameter for the instruction.\n   * @param {number} p2 - The second parameter for the instruction.\n   * @param {Buffer} data - The data to be sent. Defaults to an empty buffer.\n   * @param {Array<number>} statusList - A list of acceptable status codes for the response. Defaults to [StatusCodes.OK].\n   * @param {Object} options - Contains optional options for the exchange function\n   *  - abortTimeoutMs: stop the send after a given timeout. Another timeout exists\n   *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.\n   * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.\n   */\n  send = async (\n    cla: number,\n    ins: number,\n    p1: number,\n    p2: number,\n    data: Buffer = Buffer.alloc(0),\n    statusList: Array<number> = [StatusCodes.OK],\n    { abortTimeoutMs }: { abortTimeoutMs?: number } = {},\n  ): Promise<Buffer> => {\n    const tracer = this.tracer.withUpdatedContext({ function: \"send\" });\n\n    if (data.length >= 256) {\n      tracer.trace(\"data.length exceeded 256 bytes limit\", { dataLength: data.length });\n      throw new TransportError(\n        \"data.length exceed 256 bytes limit. Got: \" + data.length,\n        \"DataLengthTooBig\",\n      );\n    }\n\n    tracer.trace(\"Starting an exchange\", { abortTimeoutMs });\n    const response = await this.exchange(\n      // The size of the data is added in 1 byte just before `data`\n      Buffer.concat([Buffer.from([cla, ins, p1, p2]), Buffer.from([data.length]), data]),\n      { abortTimeoutMs },\n    );\n    tracer.trace(\"Received response from exchange\");\n    const sw = response.readUInt16BE(response.length - 2);\n\n    if (!statusList.some(s => s === sw)) {\n      throw new TransportStatusError(sw);\n    }\n\n    return response;\n  };\n\n  /**\n   * create() allows to open the first descriptor available or\n   * throw if there is none or if timeout is reached.\n   * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)\n   * @example\n  TransportFoo.create().then(transport => ...)\n   */\n  static create(openTimeout = 3000, listenTimeout?: number): Promise<Transport> {\n    return new Promise((resolve, reject) => {\n      let found = false;\n      const sub = this.listen({\n        next: e => {\n          found = true;\n          if (sub) sub.unsubscribe();\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          this.open(e.descriptor, openTimeout).then(resolve, reject);\n        },\n        error: e => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          reject(e);\n        },\n        complete: () => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n\n          if (!found) {\n            reject(new TransportError(this.ErrorMessage_NoDeviceFound, \"NoDeviceFound\"));\n          }\n        },\n      });\n      const listenTimeoutId = listenTimeout\n        ? setTimeout(() => {\n            sub.unsubscribe();\n            reject(new TransportError(this.ErrorMessage_ListenTimeout, \"ListenTimeout\"));\n          }, listenTimeout)\n        : null;\n    });\n  }\n\n  // Blocks other exchange to happen concurrently\n  exchangeBusyPromise: Promise<void> | null | undefined;\n\n  /**\n   * Wrapper to make an exchange \"atomic\" (blocking any other exchange)\n   *\n   * It also handles \"unresponsiveness\" by emitting \"unresponsive\" and \"responsive\" events.\n   *\n   * @param f The exchange job, using the transport to run\n   * @returns a Promise resolving with the output of the given job\n   */\n  async exchangeAtomicImpl<Output>(f: () => Promise<Output>): Promise<Output> {\n    const tracer = this.tracer.withUpdatedContext({\n      function: \"exchangeAtomicImpl\",\n      unresponsiveTimeout: this.unresponsiveTimeout,\n    });\n\n    if (this.exchangeBusyPromise) {\n      tracer.trace(\"Atomic exchange is already busy\");\n      throw new TransportRaceCondition(\n        \"An action was already pending on the Ledger device. Please deny or reconnect.\",\n      );\n    }\n\n    // Sets the atomic guard\n    let resolveBusy;\n    const busyPromise: Promise<void> = new Promise(r => {\n      resolveBusy = r;\n    });\n    this.exchangeBusyPromise = busyPromise;\n\n    // The device unresponsiveness handler\n    let unresponsiveReached = false;\n    const timeout = setTimeout(() => {\n      tracer.trace(`Timeout reached, emitting Transport event \"unresponsive\"`, {\n        unresponsiveTimeout: this.unresponsiveTimeout,\n      });\n      unresponsiveReached = true;\n      this.emit(\"unresponsive\");\n    }, this.unresponsiveTimeout);\n\n    try {\n      const res = await f();\n\n      if (unresponsiveReached) {\n        tracer.trace(\"Device was unresponsive, emitting responsive\");\n        this.emit(\"responsive\");\n      }\n\n      return res;\n    } finally {\n      tracer.trace(\"Finalize, clearing busy guard\");\n\n      clearTimeout(timeout);\n      if (resolveBusy) resolveBusy();\n      this.exchangeBusyPromise = null;\n    }\n  }\n\n  decorateAppAPIMethods(self: Record<string, any>, methods: Array<string>, scrambleKey: string) {\n    for (const methodName of methods) {\n      self[methodName] = this.decorateAppAPIMethod(methodName, self[methodName], self, scrambleKey);\n    }\n  }\n\n  _appAPIlock: string | null = null;\n\n  decorateAppAPIMethod<R, A extends any[]>(\n    methodName: string,\n    f: (...args: A) => Promise<R>,\n    ctx: any,\n    scrambleKey: string,\n  ): (...args: A) => Promise<R> {\n    return async (...args) => {\n      const { _appAPIlock } = this;\n\n      if (_appAPIlock) {\n        return Promise.reject(\n          new TransportError(\"Ledger Device is busy (lock \" + _appAPIlock + \")\", \"TransportLocked\"),\n        );\n      }\n\n      try {\n        this._appAPIlock = methodName;\n        this.setScrambleKey(scrambleKey);\n        return await f.apply(ctx, args);\n      } finally {\n        this._appAPIlock = null;\n      }\n    };\n  }\n\n  /**\n   * Sets the context used by the logging/tracing mechanism\n   *\n   * Useful when re-using (cached) the same Transport instance,\n   * but with a new tracing context.\n   *\n   * @param context A TraceContext, that can undefined to reset the context\n   */\n  setTraceContext(context?: TraceContext) {\n    this.tracer = this.tracer.withContext(context);\n  }\n\n  /**\n   * Updates the context used by the logging/tracing mechanism\n   *\n   * The update only overrides the key-value that are already defined in the current context.\n   *\n   * @param contextToAdd A TraceContext that will be added to the current context\n   */\n  updateTraceContext(contextToAdd: TraceContext) {\n    this.tracer.updateContext(contextToAdd);\n  }\n\n  /**\n   * Gets the tracing context of the transport instance\n   */\n  getTraceContext(): TraceContext | undefined {\n    return this.tracer.getContext();\n  }\n\n  static ErrorMessage_ListenTimeout = \"No Ledger device found (timeout)\";\n  static ErrorMessage_NoDeviceFound = \"No Ledger device found\";\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}