{"ast":null,"code":"var precomputeAlias = function (p, n) {\n  var sum = p.reduce(function (acc, val) {\n    if (val < 0) {\n      throw new Error('Probability must be a positive: p[' + p.indexOf(val) + ']=' + val);\n    }\n    return acc + val;\n  }, 0);\n  if (sum === 0) {\n    throw new Error('Probability sum must be greater than zero.');\n  }\n  var scaledProbabilities = p.map(function (prob) {\n    return prob * n / sum;\n  });\n  var aliasData = {\n    prob: new Array(n),\n    alias: new Array(n)\n  };\n  var small = [];\n  var large = [];\n  for (var i = n - 1; i >= 0; i--) {\n    if (scaledProbabilities[i] < 1) {\n      small.push(i);\n    } else {\n      large.push(i);\n    }\n  }\n  while (small.length > 0 && large.length > 0) {\n    var less = small.pop();\n    var more = large.pop();\n    aliasData.prob[less] = scaledProbabilities[less];\n    aliasData.alias[less] = more;\n    scaledProbabilities[more] = scaledProbabilities[more] + scaledProbabilities[less] - 1;\n    if (scaledProbabilities[more] < 1) {\n      small.push(more);\n    } else {\n      large.push(more);\n    }\n  }\n  while (large.length > 0) {\n    aliasData.prob[large.pop()] = 1;\n  }\n  while (small.length > 0) {\n    aliasData.prob[small.pop()] = 1;\n  }\n  return aliasData;\n};\nvar draw = function (aliasData, outcomes, rng) {\n  var c = Math.floor(rng() * aliasData.prob.length);\n  return outcomes[rng() < aliasData.prob[c] ? c : aliasData.alias[c]];\n};\nvar next = function (aliasData, outcomes, rng, numOfSamples) {\n  if (numOfSamples === void 0) {\n    numOfSamples = 1;\n  }\n  if (numOfSamples === 1) {\n    return draw(aliasData, outcomes, rng);\n  }\n  var samples = [];\n  for (var i = 0; i < numOfSamples; i++) {\n    samples.push(draw(aliasData, outcomes, rng));\n  }\n  return samples;\n};\nvar sample = function (probabilities, outcomes, rng) {\n  if (rng === void 0) {\n    rng = Math.random;\n  }\n  if (!Array.isArray(probabilities)) {\n    throw new Error('Probabilities must be an array.');\n  }\n  if (probabilities.length === 0) {\n    throw new Error('Probabilities array must not be empty.');\n  }\n  var n = probabilities.length;\n  var indexedOutcomes = outcomes !== null && outcomes !== void 0 ? outcomes : Array.from({\n    length: n\n  }, function (_, i) {\n    return i;\n  });\n  var aliasData = precomputeAlias(probabilities, n);\n  return {\n    next: function (numOfSamples) {\n      if (numOfSamples === void 0) {\n        numOfSamples = 1;\n      }\n      return next(aliasData, indexedOutcomes, rng, numOfSamples);\n    }\n  };\n};\nexport default sample;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}