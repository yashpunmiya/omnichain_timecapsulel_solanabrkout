{"ast":null,"code":"import { pad } from '../../utils/data/pad.js';\nimport { toBytes } from '../../utils/encoding/toBytes.js';\nimport { sha256 } from '../../utils/hash/sha256.js';\nimport { maxBytecodeSize } from '../constants/number.js';\nimport { BytecodeLengthExceedsMaxSizeError, BytecodeLengthInWordsMustBeOddError, BytecodeLengthMustBeDivisibleBy32Error } from '../errors/bytecode.js';\nexport function hashBytecode(bytecode) {\n  const bytecodeBytes = toBytes(bytecode);\n  if (bytecodeBytes.length % 32 !== 0) throw new BytecodeLengthMustBeDivisibleBy32Error({\n    givenLength: bytecodeBytes.length\n  });\n  if (bytecodeBytes.length > maxBytecodeSize) throw new BytecodeLengthExceedsMaxSizeError({\n    givenLength: bytecodeBytes.length,\n    maxBytecodeSize\n  });\n  const hashStr = sha256(bytecodeBytes);\n  const hash = toBytes(hashStr);\n  // Note that the length of the bytecode\n  // should be provided in 32-byte words.\n  const bytecodeLengthInWords = bytecodeBytes.length / 32;\n  if (bytecodeLengthInWords % 2 === 0) {\n    throw new BytecodeLengthInWordsMustBeOddError({\n      givenLengthInWords: bytecodeLengthInWords\n    });\n  }\n  const bytecodeLength = toBytes(bytecodeLengthInWords);\n  // The bytecode should always take the first 2 bytes of the bytecode hash,\n  // so we pad it from the left in case the length is smaller than 2 bytes.\n  const bytecodeLengthPadded = pad(bytecodeLength, {\n    size: 2\n  });\n  const codeHashVersion = new Uint8Array([1, 0]);\n  hash.set(codeHashVersion, 0);\n  hash.set(bytecodeLengthPadded, 2);\n  return hash;\n}","map":{"version":3,"names":["pad","toBytes","sha256","maxBytecodeSize","BytecodeLengthExceedsMaxSizeError","BytecodeLengthInWordsMustBeOddError","BytecodeLengthMustBeDivisibleBy32Error","hashBytecode","bytecode","bytecodeBytes","length","givenLength","hashStr","hash","bytecodeLengthInWords","givenLengthInWords","bytecodeLength","bytecodeLengthPadded","size","codeHashVersion","Uint8Array","set"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\viem\\zksync\\utils\\hashBytecode.ts"],"sourcesContent":["import type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport { pad } from '../../utils/data/pad.js'\nimport { type ToBytesErrorType, toBytes } from '../../utils/encoding/toBytes.js'\nimport { type Sha256ErrorType, sha256 } from '../../utils/hash/sha256.js'\nimport { maxBytecodeSize } from '../constants/number.js'\nimport {\n  BytecodeLengthExceedsMaxSizeError,\n  type BytecodeLengthExceedsMaxSizeErrorType,\n  BytecodeLengthInWordsMustBeOddError,\n  type BytecodeLengthInWordsMustBeOddErrorType,\n  BytecodeLengthMustBeDivisibleBy32Error,\n  type BytecodeLengthMustBeDivisibleBy32ErrorType,\n} from '../errors/bytecode.js'\n\nexport type HashBytecodeErrorType =\n  | BytecodeLengthExceedsMaxSizeErrorType\n  | BytecodeLengthInWordsMustBeOddErrorType\n  | BytecodeLengthMustBeDivisibleBy32ErrorType\n  | Sha256ErrorType\n  | ToBytesErrorType\n  | ErrorType\n\nexport function hashBytecode(bytecode: Hex): Uint8Array {\n  const bytecodeBytes = toBytes(bytecode)\n  if (bytecodeBytes.length % 32 !== 0)\n    throw new BytecodeLengthMustBeDivisibleBy32Error({\n      givenLength: bytecodeBytes.length,\n    })\n\n  if (bytecodeBytes.length > maxBytecodeSize)\n    throw new BytecodeLengthExceedsMaxSizeError({\n      givenLength: bytecodeBytes.length,\n      maxBytecodeSize,\n    })\n\n  const hashStr = sha256(bytecodeBytes)\n  const hash = toBytes(hashStr)\n\n  // Note that the length of the bytecode\n  // should be provided in 32-byte words.\n  const bytecodeLengthInWords = bytecodeBytes.length / 32\n  if (bytecodeLengthInWords % 2 === 0) {\n    throw new BytecodeLengthInWordsMustBeOddError({\n      givenLengthInWords: bytecodeLengthInWords,\n    })\n  }\n\n  const bytecodeLength = toBytes(bytecodeLengthInWords)\n\n  // The bytecode should always take the first 2 bytes of the bytecode hash,\n  // so we pad it from the left in case the length is smaller than 2 bytes.\n  const bytecodeLengthPadded = pad(bytecodeLength, { size: 2 })\n\n  const codeHashVersion = new Uint8Array([1, 0])\n  hash.set(codeHashVersion, 0)\n  hash.set(bytecodeLengthPadded, 2)\n\n  return hash\n}\n"],"mappings":"AAEA,SAASA,GAAG,QAAQ,yBAAyB;AAC7C,SAAgCC,OAAO,QAAQ,iCAAiC;AAChF,SAA+BC,MAAM,QAAQ,4BAA4B;AACzE,SAASC,eAAe,QAAQ,wBAAwB;AACxD,SACEC,iCAAiC,EAEjCC,mCAAmC,EAEnCC,sCAAsC,QAEjC,uBAAuB;AAU9B,OAAM,SAAUC,YAAYA,CAACC,QAAa;EACxC,MAAMC,aAAa,GAAGR,OAAO,CAACO,QAAQ,CAAC;EACvC,IAAIC,aAAa,CAACC,MAAM,GAAG,EAAE,KAAK,CAAC,EACjC,MAAM,IAAIJ,sCAAsC,CAAC;IAC/CK,WAAW,EAAEF,aAAa,CAACC;GAC5B,CAAC;EAEJ,IAAID,aAAa,CAACC,MAAM,GAAGP,eAAe,EACxC,MAAM,IAAIC,iCAAiC,CAAC;IAC1CO,WAAW,EAAEF,aAAa,CAACC,MAAM;IACjCP;GACD,CAAC;EAEJ,MAAMS,OAAO,GAAGV,MAAM,CAACO,aAAa,CAAC;EACrC,MAAMI,IAAI,GAAGZ,OAAO,CAACW,OAAO,CAAC;EAE7B;EACA;EACA,MAAME,qBAAqB,GAAGL,aAAa,CAACC,MAAM,GAAG,EAAE;EACvD,IAAII,qBAAqB,GAAG,CAAC,KAAK,CAAC,EAAE;IACnC,MAAM,IAAIT,mCAAmC,CAAC;MAC5CU,kBAAkB,EAAED;KACrB,CAAC;EACJ;EAEA,MAAME,cAAc,GAAGf,OAAO,CAACa,qBAAqB,CAAC;EAErD;EACA;EACA,MAAMG,oBAAoB,GAAGjB,GAAG,CAACgB,cAAc,EAAE;IAAEE,IAAI,EAAE;EAAC,CAAE,CAAC;EAE7D,MAAMC,eAAe,GAAG,IAAIC,UAAU,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;EAC9CP,IAAI,CAACQ,GAAG,CAACF,eAAe,EAAE,CAAC,CAAC;EAC5BN,IAAI,CAACQ,GAAG,CAACJ,oBAAoB,EAAE,CAAC,CAAC;EAEjC,OAAOJ,IAAI;AACb","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}