{"ast":null,"code":"/** @internal */\nexport const listenersCache = /*#__PURE__*/new Map();\n/** @internal */\nexport const cleanupCache = /*#__PURE__*/new Map();\nlet callbackCount = 0;\n/**\n * @description Sets up an observer for a given function. If another function\n * is set up under the same observer id, the function will only be called once\n * for both instances of the observer.\n */\nexport function observe(observerId, callbacks, fn) {\n  const callbackId = ++callbackCount;\n  const getListeners = () => listenersCache.get(observerId) || [];\n  const unsubscribe = () => {\n    const listeners = getListeners();\n    listenersCache.set(observerId, listeners.filter(cb => cb.id !== callbackId));\n  };\n  const unwatch = () => {\n    const listeners = getListeners();\n    if (!listeners.some(cb => cb.id === callbackId)) return;\n    const cleanup = cleanupCache.get(observerId);\n    if (listeners.length === 1 && cleanup) cleanup();\n    unsubscribe();\n  };\n  const listeners = getListeners();\n  listenersCache.set(observerId, [...listeners, {\n    id: callbackId,\n    fns: callbacks\n  }]);\n  if (listeners && listeners.length > 0) return unwatch;\n  const emit = {};\n  for (const key in callbacks) {\n    emit[key] = (...args) => {\n      const listeners = getListeners();\n      if (listeners.length === 0) return;\n      for (const listener of listeners) listener.fns[key]?.(...args);\n    };\n  }\n  const cleanup = fn(emit);\n  if (typeof cleanup === 'function') cleanupCache.set(observerId, cleanup);\n  return unwatch;\n}\n//# sourceMappingURL=observe.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}