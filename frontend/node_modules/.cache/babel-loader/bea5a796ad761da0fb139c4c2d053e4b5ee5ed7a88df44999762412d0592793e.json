{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FountainDecoderPart = void 0;\nconst utils_1 = require(\"./utils\");\nconst fountainUtils_1 = require(\"./fountainUtils\");\nconst errors_1 = require(\"./errors\");\nclass FountainDecoderPart {\n  constructor(_indexes, _fragment) {\n    this._indexes = _indexes;\n    this._fragment = _fragment;\n  }\n  get indexes() {\n    return this._indexes;\n  }\n  get fragment() {\n    return this._fragment;\n  }\n  static fromEncoderPart(encoderPart) {\n    const indexes = fountainUtils_1.chooseFragments(encoderPart.seqNum, encoderPart.seqLength, encoderPart.checksum);\n    const fragment = encoderPart.fragment;\n    return new FountainDecoderPart(indexes, fragment);\n  }\n  isSimple() {\n    return this.indexes.length === 1;\n  }\n}\nexports.FountainDecoderPart = FountainDecoderPart;\nclass FountainDecoder {\n  constructor() {\n    this.result = undefined;\n    this.expectedMessageLength = 0;\n    this.expectedChecksum = 0;\n    this.expectedFragmentLength = 0;\n    this.processedPartsCount = 0;\n    this.expectedPartIndexes = [];\n    this.lastPartIndexes = [];\n    this.queuedParts = [];\n    this.receivedPartIndexes = [];\n    this.mixedParts = [];\n    this.simpleParts = [];\n  }\n  validatePart(part) {\n    // If this is the first part we've seen\n    if (this.expectedPartIndexes.length === 0) {\n      // Record the things that all the other parts we see will have to match to be valid.\n      [...new Array(part.seqLength)].forEach((_, index) => this.expectedPartIndexes.push(index));\n      this.expectedMessageLength = part.messageLength;\n      this.expectedChecksum = part.checksum;\n      this.expectedFragmentLength = part.fragment.length;\n    } else {\n      // If this part's values don't match the first part's values, throw away the part\n      if (this.expectedPartIndexes.length !== part.seqLength) {\n        return false;\n      }\n      if (this.expectedMessageLength !== part.messageLength) {\n        return false;\n      }\n      if (this.expectedChecksum !== part.checksum) {\n        return false;\n      }\n      if (this.expectedFragmentLength !== part.fragment.length) {\n        return false;\n      }\n    }\n    // This part should be processed\n    return true;\n  }\n  reducePartByPart(a, b) {\n    // If the fragments mixed into `b` are a strict (proper) subset of those in `a`...\n    if (utils_1.arrayContains(a.indexes, b.indexes)) {\n      const newIndexes = utils_1.setDifference(a.indexes, b.indexes);\n      const newFragment = utils_1.bufferXOR(a.fragment, b.fragment);\n      return new FountainDecoderPart(newIndexes, newFragment);\n    } else {\n      // `a` is not reducable by `b`, so return a\n      return a;\n    }\n  }\n  reduceMixedBy(part) {\n    const newMixed = [];\n    this.mixedParts.map(({\n      value: mixedPart\n    }) => this.reducePartByPart(mixedPart, part)).forEach(reducedPart => {\n      if (reducedPart.isSimple()) {\n        this.queuedParts.push(reducedPart);\n      } else {\n        newMixed.push({\n          key: reducedPart.indexes,\n          value: reducedPart\n        });\n      }\n    });\n    this.mixedParts = newMixed;\n  }\n  processSimplePart(part) {\n    // Don't process duplicate parts\n    const fragmentIndex = part.indexes[0];\n    if (this.receivedPartIndexes.includes(fragmentIndex)) {\n      return;\n    }\n    this.simpleParts.push({\n      key: part.indexes,\n      value: part\n    });\n    this.receivedPartIndexes.push(fragmentIndex);\n    // If we've received all the parts\n    if (utils_1.arraysEqual(this.receivedPartIndexes, this.expectedPartIndexes)) {\n      // Reassemble the message from its fragments\n      const sortedParts = this.simpleParts.map(({\n        value\n      }) => value).sort((a, b) => a.indexes[0] - b.indexes[0]);\n      const message = FountainDecoder.joinFragments(sortedParts.map(part => part.fragment), this.expectedMessageLength);\n      const checksum = utils_1.getCRC(message);\n      if (checksum === this.expectedChecksum) {\n        this.result = message;\n      } else {\n        this.error = new errors_1.InvalidChecksumError();\n      }\n    } else {\n      this.reduceMixedBy(part);\n    }\n  }\n  processMixedPart(part) {\n    // Don't process duplicate parts\n    if (this.mixedParts.some(({\n      key: indexes\n    }) => utils_1.arraysEqual(indexes, part.indexes))) {\n      return;\n    }\n    // Reduce this part by all the others\n    let p2 = this.simpleParts.reduce((acc, {\n      value: p\n    }) => this.reducePartByPart(acc, p), part);\n    p2 = this.mixedParts.reduce((acc, {\n      value: p\n    }) => this.reducePartByPart(acc, p), p2);\n    // If the part is now simple\n    if (p2.isSimple()) {\n      // Add it to the queue\n      this.queuedParts.push(p2);\n    } else {\n      this.reduceMixedBy(p2);\n      this.mixedParts.push({\n        key: p2.indexes,\n        value: p2\n      });\n    }\n  }\n  processQueuedItem() {\n    if (this.queuedParts.length === 0) {\n      return;\n    }\n    const part = this.queuedParts.shift();\n    if (part.isSimple()) {\n      this.processSimplePart(part);\n    } else {\n      this.processMixedPart(part);\n    }\n  }\n  receivePart(encoderPart) {\n    if (this.isComplete()) {\n      return false;\n    }\n    if (!this.validatePart(encoderPart)) {\n      return false;\n    }\n    const decoderPart = FountainDecoderPart.fromEncoderPart(encoderPart);\n    this.lastPartIndexes = decoderPart.indexes;\n    this.queuedParts.push(decoderPart);\n    while (!this.isComplete() && this.queuedParts.length > 0) {\n      this.processQueuedItem();\n    }\n    ;\n    this.processedPartsCount += 1;\n    return true;\n  }\n  isComplete() {\n    return Boolean(this.result !== undefined && this.result.length > 0);\n  }\n  isSuccess() {\n    return Boolean(this.error === undefined && this.isComplete());\n  }\n  resultMessage() {\n    return this.isSuccess() ? this.result : Buffer.from([]);\n  }\n  isFailure() {\n    return this.error !== undefined;\n  }\n  resultError() {\n    return this.error ? this.error.message : '';\n  }\n  expectedPartCount() {\n    return this.expectedPartIndexes.length;\n  }\n  getExpectedPartIndexes() {\n    return [...this.expectedPartIndexes];\n  }\n  getReceivedPartIndexes() {\n    return [...this.receivedPartIndexes];\n  }\n  getLastPartIndexes() {\n    return [...this.lastPartIndexes];\n  }\n  estimatedPercentComplete() {\n    if (this.isComplete()) {\n      return 1;\n    }\n    const expectedPartCount = this.expectedPartCount();\n    if (expectedPartCount === 0) {\n      return 0;\n    }\n    // We multiply the expectedPartCount by `1.75` as a way to compensate for the facet\n    // that `this.processedPartsCount` also tracks the duplicate parts that have been\n    // processeed.\n    return Math.min(0.99, this.processedPartsCount / (expectedPartCount * 1.75));\n  }\n  getProgress() {\n    if (this.isComplete()) {\n      return 1;\n    }\n    const expectedPartCount = this.expectedPartCount();\n    if (expectedPartCount === 0) {\n      return 0;\n    }\n    return this.receivedPartIndexes.length / expectedPartCount;\n  }\n}\nexports.default = FountainDecoder;\nFountainDecoder.joinFragments = (fragments, messageLength) => {\n  return Buffer.concat(fragments).slice(0, messageLength);\n};\n//# sourceMappingURL=fountainDecoder.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}