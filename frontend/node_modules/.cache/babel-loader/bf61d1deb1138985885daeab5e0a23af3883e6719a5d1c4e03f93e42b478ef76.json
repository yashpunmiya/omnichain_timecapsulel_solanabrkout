{"ast":null,"code":"import { getAction } from '../../utils/getAction.js';\nimport { observe } from '../../utils/observe.js';\nimport { poll } from '../../utils/poll.js';\nimport { stringify } from '../../utils/stringify.js';\nimport { getBlock } from './getBlock.js';\n/**\n * Watches and returns information for incoming blocks.\n *\n * - Docs: https://viem.sh/docs/actions/public/watchBlocks\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks_watching-blocks\n * - JSON-RPC Methods:\n *   - When `poll: true`, calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getBlockByNumber) on a polling interval.\n *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `\"newHeads\"` event.\n *\n * @param client - Client to use\n * @param parameters - {@link WatchBlocksParameters}\n * @returns A function that can be invoked to stop watching for new block numbers. {@link WatchBlocksReturnType}\n *\n * @example\n * import { createPublicClient, watchBlocks, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = watchBlocks(client, {\n *   onBlock: (block) => console.log(block),\n * })\n */\nexport function watchBlocks(client, {\n  blockTag = 'latest',\n  emitMissed = false,\n  emitOnBegin = false,\n  onBlock,\n  onError,\n  includeTransactions: includeTransactions_,\n  poll: poll_,\n  pollingInterval = client.pollingInterval\n}) {\n  const enablePolling = (() => {\n    if (typeof poll_ !== 'undefined') return poll_;\n    if (client.transport.type === 'webSocket') return false;\n    if (client.transport.type === 'fallback' && client.transport.transports[0].config.type === 'webSocket') return false;\n    return true;\n  })();\n  const includeTransactions = includeTransactions_ ?? false;\n  let prevBlock;\n  const pollBlocks = () => {\n    const observerId = stringify(['watchBlocks', client.uid, blockTag, emitMissed, emitOnBegin, includeTransactions, pollingInterval]);\n    return observe(observerId, {\n      onBlock,\n      onError\n    }, emit => poll(async () => {\n      try {\n        const block = await getAction(client, getBlock, 'getBlock')({\n          blockTag,\n          includeTransactions\n        });\n        if (block.number !== null && prevBlock?.number != null) {\n          // If the current block number is the same as the previous,\n          // we can skip.\n          if (block.number === prevBlock.number) return;\n          // If we have missed out on some previous blocks, and the\n          // `emitMissed` flag is truthy, let's emit those blocks.\n          if (block.number - prevBlock.number > 1 && emitMissed) {\n            for (let i = prevBlock?.number + 1n; i < block.number; i++) {\n              const block = await getAction(client, getBlock, 'getBlock')({\n                blockNumber: i,\n                includeTransactions\n              });\n              emit.onBlock(block, prevBlock);\n              prevBlock = block;\n            }\n          }\n        }\n        if (\n        // If no previous block exists, emit.\n        prevBlock?.number == null ||\n        // If the block tag is \"pending\" with no block number, emit.\n        blockTag === 'pending' && block?.number == null ||\n        // If the next block number is greater than the previous block number, emit.\n        // We don't want to emit blocks in the past.\n        block.number !== null && block.number > prevBlock.number) {\n          emit.onBlock(block, prevBlock);\n          prevBlock = block;\n        }\n      } catch (err) {\n        emit.onError?.(err);\n      }\n    }, {\n      emitOnBegin,\n      interval: pollingInterval\n    }));\n  };\n  const subscribeBlocks = () => {\n    let active = true;\n    let emitFetched = true;\n    let unsubscribe = () => active = false;\n    (async () => {\n      try {\n        if (emitOnBegin) {\n          getAction(client, getBlock, 'getBlock')({\n            blockTag,\n            includeTransactions\n          }).then(block => {\n            if (!active) return;\n            if (!emitFetched) return;\n            onBlock(block, undefined);\n            emitFetched = false;\n          });\n        }\n        const transport = (() => {\n          if (client.transport.type === 'fallback') {\n            const transport = client.transport.transports.find(transport => transport.config.type === 'webSocket');\n            if (!transport) return client.transport;\n            return transport.value;\n          }\n          return client.transport;\n        })();\n        const {\n          unsubscribe: unsubscribe_\n        } = await transport.subscribe({\n          params: ['newHeads'],\n          async onData(data) {\n            if (!active) return;\n            const block = await getAction(client, getBlock, 'getBlock')({\n              blockNumber: data.blockNumber,\n              includeTransactions\n            }).catch(() => {});\n            if (!active) return;\n            onBlock(block, prevBlock);\n            emitFetched = false;\n            prevBlock = block;\n          },\n          onError(error) {\n            onError?.(error);\n          }\n        });\n        unsubscribe = unsubscribe_;\n        if (!active) unsubscribe();\n      } catch (err) {\n        onError?.(err);\n      }\n    })();\n    return () => unsubscribe();\n  };\n  return enablePolling ? pollBlocks() : subscribeBlocks();\n}","map":{"version":3,"names":["getAction","observe","poll","stringify","getBlock","watchBlocks","client","blockTag","emitMissed","emitOnBegin","onBlock","onError","includeTransactions","includeTransactions_","poll_","pollingInterval","enablePolling","transport","type","transports","config","prevBlock","pollBlocks","observerId","uid","emit","block","number","i","blockNumber","err","interval","subscribeBlocks","active","emitFetched","unsubscribe","then","undefined","find","value","unsubscribe_","subscribe","params","onData","data","catch","error"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\viem\\actions\\public\\watchBlocks.ts"],"sourcesContent":["import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { HasTransportType } from '../../types/transport.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { observe } from '../../utils/observe.js'\nimport { type PollErrorType, poll } from '../../utils/poll.js'\nimport { type StringifyErrorType, stringify } from '../../utils/stringify.js'\n\nimport { type GetBlockReturnType, getBlock } from './getBlock.js'\n\nexport type OnBlockParameter<\n  chain extends Chain | undefined = Chain,\n  includeTransactions extends boolean = false,\n  blockTag extends BlockTag = 'latest',\n> = GetBlockReturnType<chain, includeTransactions, blockTag>\n\nexport type OnBlock<\n  chain extends Chain | undefined = Chain,\n  includeTransactions extends boolean = false,\n  blockTag extends BlockTag = 'latest',\n> = (\n  block: OnBlockParameter<chain, includeTransactions, blockTag>,\n  prevBlock: OnBlockParameter<chain, includeTransactions, blockTag> | undefined,\n) => void\n\nexport type WatchBlocksParameters<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain,\n  includeTransactions extends boolean = false,\n  blockTag extends BlockTag = 'latest',\n> = {\n  /** The callback to call when a new block is received. */\n  onBlock: OnBlock<chain, includeTransactions, blockTag>\n  /** The callback to call when an error occurred when trying to get for a new block. */\n  onError?: ((error: Error) => void) | undefined\n} & (\n  | (HasTransportType<transport, 'webSocket'> extends true\n      ? {\n          blockTag?: undefined\n          emitMissed?: undefined\n          emitOnBegin?: undefined\n          includeTransactions?: undefined\n          /** Whether or not the WebSocket Transport should poll the JSON-RPC, rather than using `eth_subscribe`. */\n          poll?: false | undefined\n          pollingInterval?: undefined\n        }\n      : never)\n  | {\n      /** The block tag. Defaults to \"latest\". */\n      blockTag?: blockTag | BlockTag | undefined\n      /** Whether or not to emit the missed blocks to the callback. */\n      emitMissed?: boolean | undefined\n      /** Whether or not to emit the block to the callback when the subscription opens. */\n      emitOnBegin?: boolean | undefined\n      /** Whether or not to include transaction data in the response. */\n      includeTransactions?: includeTransactions | undefined\n      poll?: true | undefined\n      /** Polling frequency (in ms). Defaults to the client's pollingInterval config. */\n      pollingInterval?: number | undefined\n    }\n)\n\nexport type WatchBlocksReturnType = () => void\n\nexport type WatchBlocksErrorType =\n  | StringifyErrorType\n  | PollErrorType\n  | ErrorType\n\n/**\n * Watches and returns information for incoming blocks.\n *\n * - Docs: https://viem.sh/docs/actions/public/watchBlocks\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks_watching-blocks\n * - JSON-RPC Methods:\n *   - When `poll: true`, calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getBlockByNumber) on a polling interval.\n *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `\"newHeads\"` event.\n *\n * @param client - Client to use\n * @param parameters - {@link WatchBlocksParameters}\n * @returns A function that can be invoked to stop watching for new block numbers. {@link WatchBlocksReturnType}\n *\n * @example\n * import { createPublicClient, watchBlocks, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = watchBlocks(client, {\n *   onBlock: (block) => console.log(block),\n * })\n */\nexport function watchBlocks<\n  transport extends Transport,\n  chain extends Chain | undefined,\n  includeTransactions extends boolean = false,\n  blockTag extends BlockTag = 'latest',\n>(\n  client: Client<transport, chain>,\n  {\n    blockTag = 'latest',\n    emitMissed = false,\n    emitOnBegin = false,\n    onBlock,\n    onError,\n    includeTransactions: includeTransactions_,\n    poll: poll_,\n    pollingInterval = client.pollingInterval,\n  }: WatchBlocksParameters<transport, chain, includeTransactions, blockTag>,\n): WatchBlocksReturnType {\n  const enablePolling = (() => {\n    if (typeof poll_ !== 'undefined') return poll_\n    if (client.transport.type === 'webSocket') return false\n    if (\n      client.transport.type === 'fallback' &&\n      client.transport.transports[0].config.type === 'webSocket'\n    )\n      return false\n    return true\n  })()\n  const includeTransactions = includeTransactions_ ?? false\n\n  let prevBlock:\n    | GetBlockReturnType<chain, false | includeTransactions, 'latest'>\n    | undefined\n\n  const pollBlocks = () => {\n    const observerId = stringify([\n      'watchBlocks',\n      client.uid,\n      blockTag,\n      emitMissed,\n      emitOnBegin,\n      includeTransactions,\n      pollingInterval,\n    ])\n\n    return observe(observerId, { onBlock, onError }, (emit) =>\n      poll(\n        async () => {\n          try {\n            const block = await getAction(\n              client,\n              getBlock,\n              'getBlock',\n            )({\n              blockTag,\n              includeTransactions,\n            })\n            if (block.number !== null && prevBlock?.number != null) {\n              // If the current block number is the same as the previous,\n              // we can skip.\n              if (block.number === prevBlock.number) return\n\n              // If we have missed out on some previous blocks, and the\n              // `emitMissed` flag is truthy, let's emit those blocks.\n              if (block.number - prevBlock.number > 1 && emitMissed) {\n                for (let i = prevBlock?.number + 1n; i < block.number; i++) {\n                  const block = (await getAction(\n                    client,\n                    getBlock,\n                    'getBlock',\n                  )({\n                    blockNumber: i,\n                    includeTransactions,\n                  })) as GetBlockReturnType<chain>\n                  emit.onBlock(block as any, prevBlock as any)\n                  prevBlock = block\n                }\n              }\n            }\n\n            if (\n              // If no previous block exists, emit.\n              prevBlock?.number == null ||\n              // If the block tag is \"pending\" with no block number, emit.\n              (blockTag === 'pending' && block?.number == null) ||\n              // If the next block number is greater than the previous block number, emit.\n              // We don't want to emit blocks in the past.\n              (block.number !== null && block.number > prevBlock.number)\n            ) {\n              emit.onBlock(block as any, prevBlock as any)\n              prevBlock = block as any\n            }\n          } catch (err) {\n            emit.onError?.(err as Error)\n          }\n        },\n        {\n          emitOnBegin,\n          interval: pollingInterval,\n        },\n      ),\n    )\n  }\n\n  const subscribeBlocks = () => {\n    let active = true\n    let emitFetched = true\n    let unsubscribe = () => (active = false)\n    ;(async () => {\n      try {\n        if (emitOnBegin) {\n          getAction(\n            client,\n            getBlock,\n            'getBlock',\n          )({\n            blockTag,\n            includeTransactions,\n          }).then((block) => {\n            if (!active) return\n            if (!emitFetched) return\n            onBlock(block as any, undefined)\n            emitFetched = false\n          })\n        }\n\n        const transport = (() => {\n          if (client.transport.type === 'fallback') {\n            const transport = client.transport.transports.find(\n              (transport: ReturnType<Transport>) =>\n                transport.config.type === 'webSocket',\n            )\n            if (!transport) return client.transport\n            return transport.value\n          }\n          return client.transport\n        })()\n\n        const { unsubscribe: unsubscribe_ } = await transport.subscribe({\n          params: ['newHeads'],\n          async onData(data: any) {\n            if (!active) return\n            const block = (await getAction(\n              client,\n              getBlock,\n              'getBlock',\n            )({\n              blockNumber: data.blockNumber,\n              includeTransactions,\n            }).catch(() => {})) as GetBlockReturnType<chain>\n            if (!active) return\n            onBlock(block as any, prevBlock as any)\n            emitFetched = false\n            prevBlock = block\n          },\n          onError(error: Error) {\n            onError?.(error)\n          },\n        })\n        unsubscribe = unsubscribe_\n        if (!active) unsubscribe()\n      } catch (err) {\n        onError?.(err as Error)\n      }\n    })()\n    return () => unsubscribe()\n  }\n\n  return enablePolling ? pollBlocks() : subscribeBlocks()\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}