{"ast":null,"code":"let id = 0;\nconst subscribers = [];\n/**\n * Logs something\n *\n * @param type a namespaced identifier of the log (it is not a level like \"debug\", \"error\" but more like \"apdu-in\", \"apdu-out\", etc...)\n * @param message a clear message of the log associated to the type\n */\nexport const log = (type, message, data) => {\n  const obj = {\n    type,\n    id: String(++id),\n    date: new Date()\n  };\n  if (message) obj.message = message;\n  if (data) obj.data = data;\n  dispatch(obj);\n};\n/**\n * A simple tracer function, only expanding the existing log function\n *\n * Its goal is to capture more context than a log function.\n * This is simple for now, but can be improved later.\n *\n * @param context Anything representing the context where the log occurred\n */\nexport const trace = ({\n  type,\n  message,\n  data,\n  context\n}) => {\n  const obj = {\n    type,\n    id: String(++id),\n    date: new Date()\n  };\n  if (message) obj.message = message;\n  if (data) obj.data = data;\n  if (context) obj.context = context;\n  dispatch(obj);\n};\n/**\n * A simple tracer class, that can be used to avoid repetition when using the `trace` function\n *\n * Its goal is to capture more context than a log function.\n * This is simple for now, but can be improved later.\n *\n * @param type A given type (not level) for the current local tracer (\"hw\", \"withDevice\", etc.)\n * @param context Anything representing the context where the log occurred\n */\nexport class LocalTracer {\n  constructor(type, context) {\n    this.type = type;\n    this.context = context;\n  }\n  trace(message, data) {\n    trace({\n      type: this.type,\n      message,\n      data,\n      context: this.context\n    });\n  }\n  getContext() {\n    return this.context;\n  }\n  setContext(context) {\n    this.context = context;\n  }\n  updateContext(contextToAdd) {\n    this.context = Object.assign(Object.assign({}, this.context), contextToAdd);\n  }\n  getType() {\n    return this.type;\n  }\n  setType(type) {\n    this.type = type;\n  }\n  /**\n   * Create a new instance of the LocalTracer with an updated `type`\n   *\n   * It does not mutate the calling instance, but returns a new LocalTracer,\n   * following a simple builder pattern.\n   */\n  withType(type) {\n    return new LocalTracer(type, this.context);\n  }\n  /**\n   * Create a new instance of the LocalTracer with a new `context`\n   *\n   * It does not mutate the calling instance, but returns a new LocalTracer,\n   * following a simple builder pattern.\n   *\n   * @param context A TraceContext, that can undefined to reset the context\n   */\n  withContext(context) {\n    return new LocalTracer(this.type, context);\n  }\n  /**\n   * Create a new instance of the LocalTracer with an updated `context`,\n   * on which an additional context is merged with the existing one.\n   *\n   * It does not mutate the calling instance, but returns a new LocalTracer,\n   * following a simple builder pattern.\n   */\n  withUpdatedContext(contextToAdd) {\n    return new LocalTracer(this.type, Object.assign(Object.assign({}, this.context), contextToAdd));\n  }\n}\n/**\n * Adds a subscribers to the emitted logs.\n *\n * @param cb that is called for each future log() with the Log object\n * @return a function that can be called to unsubscribe the listener\n */\nexport const listen = cb => {\n  subscribers.push(cb);\n  return () => {\n    const i = subscribers.indexOf(cb);\n    if (i !== -1) {\n      // equivalent of subscribers.splice(i, 1) // https://twitter.com/Rich_Harris/status/1125850391155965952\n      subscribers[i] = subscribers[subscribers.length - 1];\n      subscribers.pop();\n    }\n  };\n};\nfunction dispatch(log) {\n  for (let i = 0; i < subscribers.length; i++) {\n    try {\n      subscribers[i](log);\n    } catch (e) {\n      console.error(e);\n    }\n  }\n}\nif (typeof window !== \"undefined\") {\n  window.__ledgerLogsListen = listen;\n}","map":{"version":3,"names":["id","subscribers","log","type","message","data","obj","String","date","Date","dispatch","trace","context","LocalTracer","constructor","getContext","setContext","updateContext","contextToAdd","Object","assign","getType","setType","withType","withContext","withUpdatedContext","listen","cb","push","i","indexOf","length","pop","e","console","error","window","__ledgerLogsListen"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@ledgerhq\\logs\\src\\index.ts"],"sourcesContent":["export type TraceContext = Record<string, unknown>;\nexport type LogData = any;\nexport type LogType = string;\n\n/**\n * A Log object\n */\nexport interface Log {\n  /**\n   * A namespaced identifier of the log (not a level like \"debug\", \"error\" but more like \"apdu\", \"hw\", etc...)\n   */\n  type: LogType;\n  message?: string;\n  /**\n   * Data associated to the log event\n   */\n  data?: LogData;\n  /**\n   * Context data, coming for example from the caller's parent, to enable a simple tracing system\n   */\n  context?: TraceContext;\n  /**\n   * Unique id among all logs\n   */\n  id: string;\n  /*\n   * Date when the log occurred\n   */\n  date: Date;\n}\n\nexport type Unsubscribe = () => void;\nexport type Subscriber = (arg0: Log) => void;\n\nlet id = 0;\nconst subscribers: Subscriber[] = [];\n\n/**\n * Logs something\n *\n * @param type a namespaced identifier of the log (it is not a level like \"debug\", \"error\" but more like \"apdu-in\", \"apdu-out\", etc...)\n * @param message a clear message of the log associated to the type\n */\nexport const log = (type: LogType, message?: string, data?: LogData) => {\n  const obj: Log = {\n    type,\n    id: String(++id),\n    date: new Date(),\n  };\n  if (message) obj.message = message;\n  if (data) obj.data = data;\n  dispatch(obj);\n};\n\n/**\n * A simple tracer function, only expanding the existing log function\n *\n * Its goal is to capture more context than a log function.\n * This is simple for now, but can be improved later.\n *\n * @param context Anything representing the context where the log occurred\n */\nexport const trace = ({\n  type,\n  message,\n  data,\n  context,\n}: {\n  type: LogType;\n  message?: string;\n  data?: LogData;\n  context?: TraceContext;\n}) => {\n  const obj: Log = {\n    type,\n    id: String(++id),\n    date: new Date(),\n  };\n\n  if (message) obj.message = message;\n  if (data) obj.data = data;\n  if (context) obj.context = context;\n\n  dispatch(obj);\n};\n\n/**\n * A simple tracer class, that can be used to avoid repetition when using the `trace` function\n *\n * Its goal is to capture more context than a log function.\n * This is simple for now, but can be improved later.\n *\n * @param type A given type (not level) for the current local tracer (\"hw\", \"withDevice\", etc.)\n * @param context Anything representing the context where the log occurred\n */\nexport class LocalTracer {\n  constructor(\n    private type: LogType,\n    private context?: TraceContext,\n  ) {}\n\n  trace(message: string, data?: TraceContext) {\n    trace({\n      type: this.type,\n      message,\n      data,\n      context: this.context,\n    });\n  }\n\n  getContext(): TraceContext | undefined {\n    return this.context;\n  }\n\n  setContext(context?: TraceContext) {\n    this.context = context;\n  }\n\n  updateContext(contextToAdd: TraceContext) {\n    this.context = { ...this.context, ...contextToAdd };\n  }\n\n  getType(): LogType {\n    return this.type;\n  }\n\n  setType(type: LogType) {\n    this.type = type;\n  }\n\n  /**\n   * Create a new instance of the LocalTracer with an updated `type`\n   *\n   * It does not mutate the calling instance, but returns a new LocalTracer,\n   * following a simple builder pattern.\n   */\n  withType(type: LogType): LocalTracer {\n    return new LocalTracer(type, this.context);\n  }\n\n  /**\n   * Create a new instance of the LocalTracer with a new `context`\n   *\n   * It does not mutate the calling instance, but returns a new LocalTracer,\n   * following a simple builder pattern.\n   *\n   * @param context A TraceContext, that can undefined to reset the context\n   */\n  withContext(context?: TraceContext): LocalTracer {\n    return new LocalTracer(this.type, context);\n  }\n\n  /**\n   * Create a new instance of the LocalTracer with an updated `context`,\n   * on which an additional context is merged with the existing one.\n   *\n   * It does not mutate the calling instance, but returns a new LocalTracer,\n   * following a simple builder pattern.\n   */\n  withUpdatedContext(contextToAdd: TraceContext): LocalTracer {\n    return new LocalTracer(this.type, { ...this.context, ...contextToAdd });\n  }\n}\n\n/**\n * Adds a subscribers to the emitted logs.\n *\n * @param cb that is called for each future log() with the Log object\n * @return a function that can be called to unsubscribe the listener\n */\nexport const listen = (cb: Subscriber): Unsubscribe => {\n  subscribers.push(cb);\n  return () => {\n    const i = subscribers.indexOf(cb);\n\n    if (i !== -1) {\n      // equivalent of subscribers.splice(i, 1) // https://twitter.com/Rich_Harris/status/1125850391155965952\n      subscribers[i] = subscribers[subscribers.length - 1];\n      subscribers.pop();\n    }\n  };\n};\n\nfunction dispatch(log: Log) {\n  for (let i = 0; i < subscribers.length; i++) {\n    try {\n      subscribers[i](log);\n    } catch (e) {\n      console.error(e);\n    }\n  }\n}\n\n// for debug purpose\n\ndeclare global {\n  interface Window {\n    __ledgerLogsListen: any;\n  }\n}\n\nif (typeof window !== \"undefined\") {\n  window.__ledgerLogsListen = listen;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}