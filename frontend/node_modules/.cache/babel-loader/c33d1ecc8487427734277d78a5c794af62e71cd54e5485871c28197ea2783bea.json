{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst assert_1 = __importDefault(require(\"assert\"));\nconst utils_1 = require(\"./utils\");\nconst bytewords = 'ableacidalsoapexaquaarchatomauntawayaxisbackbaldbarnbeltbetabiasbluebodybragbrewbulbbuzzcalmcashcatschefcityclawcodecolacookcostcruxcurlcuspcyandarkdatadaysdelidicedietdoordowndrawdropdrumdulldutyeacheasyechoedgeepicevenexamexiteyesfactfairfernfigsfilmfishfizzflapflewfluxfoxyfreefrogfuelfundgalagamegeargemsgiftgirlglowgoodgraygrimgurugushgyrohalfhanghardhawkheathelphighhillholyhopehornhutsicedideaidleinchinkyintoirisironitemjadejazzjoinjoltjowljudojugsjumpjunkjurykeepkenokeptkeyskickkilnkingkitekiwiknoblamblavalazyleaflegsliarlimplionlistlogoloudloveluaulucklungmainmanymathmazememomenumeowmildmintmissmonknailnavyneednewsnextnoonnotenumbobeyoboeomitonyxopenovalowlspaidpartpeckplaypluspoempoolposepuffpumapurrquadquizraceramprealredorichroadrockroofrubyruinrunsrustsafesagascarsetssilkskewslotsoapsolosongstubsurfswantacotasktaxitenttiedtimetinytoiltombtoystriptunatwinuglyundouniturgeuservastveryvetovialvibeviewvisavoidvowswallwandwarmwaspwavewaxywebswhatwhenwhizwolfworkyankyawnyellyogayurtzapszerozestzinczonezoom';\nlet bytewordsLookUpTable = [];\nconst BYTEWORDS_NUM = 256;\nconst BYTEWORD_LENGTH = 4;\nconst MINIMAL_BYTEWORD_LENGTH = 2;\nvar STYLES;\n(function (STYLES) {\n  STYLES[\"STANDARD\"] = \"standard\";\n  STYLES[\"URI\"] = \"uri\";\n  STYLES[\"MINIMAL\"] = \"minimal\";\n})(STYLES || (STYLES = {}));\nconst getWord = index => {\n  return bytewords.slice(index * BYTEWORD_LENGTH, index * BYTEWORD_LENGTH + BYTEWORD_LENGTH);\n};\nconst getMinimalWord = index => {\n  const byteword = getWord(index);\n  return `${byteword[0]}${byteword[BYTEWORD_LENGTH - 1]}`;\n};\nconst addCRC = string => {\n  const crc = utils_1.getCRCHex(Buffer.from(string, 'hex'));\n  return `${string}${crc}`;\n};\nconst encodeWithSeparator = (word, separator) => {\n  const crcAppendedWord = addCRC(word);\n  const crcWordBuff = Buffer.from(crcAppendedWord, 'hex');\n  const result = crcWordBuff.reduce((result, w) => [...result, getWord(w)], []);\n  return result.join(separator);\n};\nconst encodeMinimal = word => {\n  const crcAppendedWord = addCRC(word);\n  const crcWordBuff = Buffer.from(crcAppendedWord, 'hex');\n  const result = crcWordBuff.reduce((result, w) => result + getMinimalWord(w), '');\n  return result;\n};\nconst decodeWord = (word, wordLength) => {\n  assert_1.default(word.length === wordLength, 'Invalid Bytewords: word.length does not match wordLength provided');\n  const dim = 26;\n  // Since the first and last letters of each Byteword are unique,\n  // we can use them as indexes into a two-dimensional lookup table.\n  // This table is generated lazily.\n  if (bytewordsLookUpTable.length === 0) {\n    const array_len = dim * dim;\n    bytewordsLookUpTable = [...new Array(array_len)].map(() => -1);\n    for (let i = 0; i < BYTEWORDS_NUM; i++) {\n      const byteword = getWord(i);\n      let x = byteword[0].charCodeAt(0) - 'a'.charCodeAt(0);\n      let y = byteword[3].charCodeAt(0) - 'a'.charCodeAt(0);\n      let offset = y * dim + x;\n      bytewordsLookUpTable[offset] = i;\n    }\n  }\n  // If the coordinates generated by the first and last letters are out of bounds,\n  // or the lookup table contains -1 at the coordinates, then the word is not valid.\n  let x = word[0].toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0);\n  let y = word[wordLength == 4 ? 3 : 1].toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0);\n  assert_1.default(0 <= x && x < dim && 0 <= y && y < dim, 'Invalid Bytewords: invalid word');\n  let offset = y * dim + x;\n  let value = bytewordsLookUpTable[offset];\n  assert_1.default(value !== -1, 'Invalid Bytewords: value not in lookup table');\n  // If we're decoding a full four-letter word, verify that the two middle letters are correct.\n  if (wordLength == BYTEWORD_LENGTH) {\n    const byteword = getWord(value);\n    let c1 = word[1].toLowerCase();\n    let c2 = word[2].toLowerCase();\n    assert_1.default(c1 === byteword[1] && c2 === byteword[2], 'Invalid Bytewords: invalid middle letters of word');\n  }\n  // Successful decode.\n  return Buffer.from([value]).toString('hex');\n};\nconst _decode = (string, separator, wordLength) => {\n  const words = wordLength == BYTEWORD_LENGTH ? string.split(separator) : utils_1.partition(string, 2);\n  const decodedString = words.map(word => decodeWord(word, wordLength)).join('');\n  assert_1.default(decodedString.length >= 5, 'Invalid Bytewords: invalid decoded string length');\n  const [body, bodyChecksum] = utils_1.split(Buffer.from(decodedString, 'hex'), 4);\n  const checksum = utils_1.getCRCHex(body); // convert to hex\n  assert_1.default(checksum === bodyChecksum.toString('hex'), 'Invalid Checksum');\n  return body.toString('hex');\n};\nconst decode = (string, style = STYLES.MINIMAL) => {\n  switch (style) {\n    case STYLES.STANDARD:\n      return _decode(string, ' ', BYTEWORD_LENGTH);\n    case STYLES.URI:\n      return _decode(string, '-', BYTEWORD_LENGTH);\n    case STYLES.MINIMAL:\n      return _decode(string, '', MINIMAL_BYTEWORD_LENGTH);\n    default:\n      throw new Error(`Invalid style ${style}`);\n  }\n};\nconst encode = (string, style = STYLES.MINIMAL) => {\n  switch (style) {\n    case STYLES.STANDARD:\n      return encodeWithSeparator(string, ' ');\n    case STYLES.URI:\n      return encodeWithSeparator(string, '-');\n    case STYLES.MINIMAL:\n      return encodeMinimal(string);\n    default:\n      throw new Error(`Invalid style ${style}`);\n  }\n};\nexports.default = {\n  decode,\n  encode,\n  STYLES\n};\n//# sourceMappingURL=bytewords.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}