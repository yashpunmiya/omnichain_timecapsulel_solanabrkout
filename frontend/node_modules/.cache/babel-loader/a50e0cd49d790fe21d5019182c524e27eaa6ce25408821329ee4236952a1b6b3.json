{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __esm = (fn, res) => function __init() {\n  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n};\nvar __export = (target, all) => {\n  for (var name2 in all) __defProp(target, name2, {\n    get: all[name2],\n    enumerable: true\n  });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n  value: true\n}), mod);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = value => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = value => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = x => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// package.json\nvar package_exports = {};\n__export(package_exports, {\n  default: () => package_default,\n  dependencies: () => dependencies,\n  devDependencies: () => devDependencies,\n  files: () => files,\n  gitHead: () => gitHead,\n  license: () => license,\n  main: () => main,\n  module: () => module,\n  name: () => name,\n  peerDependencies: () => peerDependencies,\n  publishConfig: () => publishConfig,\n  scripts: () => scripts,\n  type: () => type,\n  types: () => types,\n  version: () => version\n});\nvar name, version, files, type, main, module, types, license, publishConfig, dependencies, peerDependencies, devDependencies, scripts, gitHead, package_default;\nvar init_package = __esm({\n  \"package.json\"() {\n    name = \"@particle-network/solana-wallet\";\n    version = \"1.3.2\";\n    files = [\"es\", \"lib\", \"LICENSE\"];\n    type = \"module\";\n    main = \"lib/index.js\";\n    module = \"es/index.js\";\n    types = \"lib/types/index.d.ts\";\n    license = \"Apache-2.0\";\n    publishConfig = {\n      access: \"public\"\n    };\n    dependencies = {\n      \"@particle-network/auth\": \"^1.3.1\"\n    };\n    peerDependencies = {\n      \"@solana/web3.js\": \"^1.50.1\",\n      bs58: \"^4.0.1\"\n    };\n    devDependencies = {\n      \"@solana/web3.js\": \"^1.50.1\",\n      \"@types/bs58\": \"^4.0.1\",\n      bs58: \"^4.0.1\",\n      \"ts-loader\": \"^9.3.1\",\n      \"webpack-cli\": \"^4.10.0\"\n    };\n    scripts = {\n      clean: \"shx rm -rf lib/* && shx rm -rf es/*\",\n      package: `shx echo '{ \"type\": \"commonjs\" }' > lib/package.json`,\n      build: \"yarn clean && node ./esBuild.js && tsc --emitDeclarationOnly -p tsconfig.json && yarn package\",\n      \"build:min.js\": \"webpack\",\n      version: \"yarn build\"\n    };\n    gitHead = \"cc999e430ebfb1dd821783f7cf099ddd51f3495a\";\n    package_default = {\n      name,\n      version,\n      files,\n      type,\n      main,\n      module,\n      types,\n      license,\n      publishConfig,\n      dependencies,\n      peerDependencies,\n      devDependencies,\n      scripts,\n      gitHead\n    };\n  }\n});\n\n// src/solana-wallet.ts\nimport { rpcUrl } from \"@particle-network/auth\";\nimport { Connection, PublicKey, Transaction } from \"@solana/web3.js\";\nimport bs58 from \"bs58\";\nimport { Buffer as Buffer2 } from \"buffer\";\nimport { EventEmitter } from \"events\";\n\n// src/utils.ts\nfunction getVersion() {\n  const packages = (init_package(), __toCommonJS(package_exports));\n  return `web_${packages.version}`;\n}\n\n// src/solana-wallet.ts\nvar SolanaWallet = class {\n  constructor(auth) {\n    this.auth = auth;\n    this.isParticleNetwork = true;\n    this.name = \"Particle\";\n    this.url = \"https://particle.network\";\n    this.icon = \"https://static.particle.network/wallet-icons/Particle.png\";\n    this.events = new EventEmitter();\n    this.auth = auth;\n    this._connecting = false;\n    const userInfo = this.auth.getUserInfo();\n    if (userInfo) {\n      const wallet = userInfo.wallets.find(w => w.chain_name === \"solana\" && w.public_address.length > 0);\n      if (wallet) {\n        this._publicKey = new PublicKey(wallet.public_address);\n      } else {\n        this._publicKey = null;\n      }\n    } else {\n      this._publicKey = null;\n    }\n    this.auth.on(\"connect\", userInfo2 => {\n      const wallet = userInfo2.wallets.find(w => w.chain_name === \"solana\" && w.public_address.length > 0);\n      if (wallet) {\n        this._publicKey = new PublicKey(wallet.public_address);\n        this.events.emit(\"connect\", this._publicKey);\n      }\n    });\n    this.auth.on(\"disconnect\", () => {\n      this._publicKey = null;\n      this.events.emit(\"disconnect\");\n    });\n    if (typeof window !== \"undefined\" && window.particle) {\n      window.particle.solanaWallet = this;\n    }\n  }\n  get version() {\n    return getVersion();\n  }\n  on(event, listener) {\n    this.events.on(event, listener);\n  }\n  once(event, listener) {\n    this.events.once(event, listener);\n  }\n  off(event, listener) {\n    this.events.off(event, listener);\n  }\n  removeListener(event, listener) {\n    this.events.removeListener(event, listener);\n  }\n  get connecting() {\n    return this._connecting;\n  }\n  get connected() {\n    return this._publicKey !== null;\n  }\n  get publicKey() {\n    return this._publicKey;\n  }\n  connect(config) {\n    return __async(this, null, function* () {\n      try {\n        this._connecting = true;\n        let wallet = this.auth.getWallet();\n        if (wallet) {\n          this._publicKey = new PublicKey(wallet.public_address);\n          return Promise.resolve();\n        }\n        yield this.auth.login(config);\n        wallet = this.auth.getWallet();\n        if (wallet) {\n          this._publicKey = new PublicKey(wallet.public_address);\n          return Promise.resolve();\n        } else {\n          return Promise.reject(\"wallet create failed\");\n        }\n      } catch (e) {\n        return Promise.reject(e);\n      } finally {\n        this._connecting = false;\n      }\n    });\n  }\n  disconnect() {\n    return __async(this, null, function* () {\n      yield this.auth.logout();\n      this._publicKey = null;\n      return Promise.resolve();\n    });\n  }\n  signTransaction(transaction) {\n    return __async(this, null, function* () {\n      const signature = yield this.auth.sign(\"signTransaction\", bs58.encode(transaction.serialize({\n        requireAllSignatures: false,\n        verifySignatures: false\n      })));\n      return Transaction.from(Buffer2.from(signature, \"base64\"));\n    });\n  }\n  signAllTransactions(transactions) {\n    return __async(this, null, function* () {\n      const signatures = yield this.auth.signAllTransactions(transactions.map(tx => bs58.encode(tx.serialize({\n        requireAllSignatures: false,\n        verifySignatures: false\n      }))));\n      return signatures.map(signed => Transaction.from(Buffer2.from(signed, \"base64\")));\n    });\n  }\n  signAndSendTransaction(transaction) {\n    return __async(this, null, function* () {\n      return this.auth.sendTransaction(bs58.encode(transaction.serialize({\n        requireAllSignatures: false,\n        verifySignatures: false\n      })));\n    });\n  }\n  signMessage(message) {\n    return __async(this, null, function* () {\n      const signature = yield this.auth.sign(\"signMessage\", bs58.encode(message));\n      return Buffer2.from(signature, \"base64\");\n    });\n  }\n  getConnection(config) {\n    const url = `${rpcUrl()}/solana`;\n    return new Connection(`${url}?chainId=${this.auth.getChainId()}&projectUuid=${this.auth.config.projectId}&projectKey=${this.auth.config.clientKey}`, {\n      commitment: config == null ? void 0 : config.commitment,\n      wsEndpoint: config == null ? void 0 : config.wsEndpoint,\n      httpHeaders: {\n        Authorization: this.auth.basicCredentials()\n      },\n      fetch: config == null ? void 0 : config.fetch,\n      fetchMiddleware: config == null ? void 0 : config.fetchMiddleware,\n      disableRetryOnRateLimit: config == null ? void 0 : config.disableRetryOnRateLimit,\n      confirmTransactionInitialTimeout: config == null ? void 0 : config.confirmTransactionInitialTimeout\n    });\n  }\n};\n\n// src/index.ts\nimport { ParticleNetwork } from \"@particle-network/auth\";\nexport { ParticleNetwork, SolanaWallet };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}