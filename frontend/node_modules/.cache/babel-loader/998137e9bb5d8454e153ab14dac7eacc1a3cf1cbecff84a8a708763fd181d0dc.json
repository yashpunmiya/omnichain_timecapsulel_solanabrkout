{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.scheduleAction = void 0;\nconst isArray = attempts => Array.isArray(attempts);\nconst resolveAfterMs = (ms, clear) => new Promise((resolve, reject) => {\n  if (clear.aborted) return reject();\n  if (ms === undefined) return resolve();\n  let timeout;\n  const onClear = () => {\n    clearTimeout(timeout);\n    clear.removeEventListener('abort', onClear);\n    reject();\n  };\n  timeout = setTimeout(() => {\n    clear.removeEventListener('abort', onClear);\n    resolve();\n  }, ms);\n  clear.addEventListener('abort', onClear);\n});\nconst rejectAfterMs = (ms, reason, clear) => new Promise((_, reject) => {\n  if (clear.aborted) return reject();\n  let timeout;\n  const onClear = () => {\n    clearTimeout(timeout);\n    clear.removeEventListener('abort', onClear);\n    reject();\n  };\n  timeout = setTimeout(() => {\n    clear.removeEventListener('abort', onClear);\n    reject(reason);\n  }, ms);\n  clear.addEventListener('abort', onClear);\n});\nconst maybeRejectAfterMs = (ms, reason, clear) => ms === undefined ? [] : [rejectAfterMs(ms, reason, clear)];\nconst rejectWhenAborted = (signal, clear) => new Promise((_, reject) => {\n  if (clear.aborted) return reject();\n  const errorSignal = new Error('Aborted by signal');\n  if (signal?.aborted) return reject(errorSignal);\n  const onAbort = () => reject(errorSignal);\n  signal?.addEventListener('abort', onAbort);\n  const onClear = () => {\n    signal?.removeEventListener('abort', onAbort);\n    clear.removeEventListener('abort', onClear);\n    reject();\n  };\n  clear.addEventListener('abort', onClear);\n});\nconst resolveAction = async (action, clear) => {\n  const aborter = new AbortController();\n  if (clear.aborted) aborter.abort();\n  const onClear = () => {\n    clear.removeEventListener('abort', onClear);\n    aborter.abort();\n  };\n  clear.addEventListener('abort', onClear);\n  try {\n    return await new Promise(resolve => resolve(action(aborter.signal)));\n  } finally {\n    if (!clear.aborted) clear.removeEventListener('abort', onClear);\n  }\n};\nconst attemptLoop = async (attempts, attempt, failure, clear) => {\n  for (let a = 0; a < attempts - 1; a++) {\n    if (clear.aborted) break;\n    const aborter = new AbortController();\n    const onClear = () => aborter.abort();\n    clear.addEventListener('abort', onClear);\n    try {\n      return await attempt(a, aborter.signal);\n    } catch (error) {\n      onClear();\n      await failure(a, error);\n    } finally {\n      clear.removeEventListener('abort', onClear);\n    }\n  }\n  return clear.aborted ? Promise.reject() : attempt(attempts - 1, clear);\n};\nconst scheduleAction = async (action, params) => {\n  const {\n    signal,\n    delay,\n    attempts,\n    timeout,\n    deadline,\n    gap,\n    attemptFailureHandler\n  } = params;\n  const deadlineMs = deadline && deadline - Date.now();\n  const attemptCount = isArray(attempts) ? attempts.length : attempts ?? (deadline ? Infinity : 1);\n  const clearAborter = new AbortController();\n  const clear = clearAborter.signal;\n  const getParams = isArray(attempts) ? attempt => attempts[attempt] : () => ({\n    timeout,\n    gap\n  });\n  const errorDeadline = new Error('Aborted by deadline');\n  const errorTimeout = new Error('Aborted by timeout');\n  try {\n    return await Promise.race([rejectWhenAborted(signal, clear), ...maybeRejectAfterMs(deadlineMs, errorDeadline, clear), resolveAfterMs(delay, clear).then(() => attemptLoop(attemptCount, (attempt, abort) => Promise.race([...maybeRejectAfterMs(getParams(attempt).timeout, errorTimeout, clear), resolveAction(action, abort)]), (attempt, error) => {\n      const errorHandlerResult = attemptFailureHandler?.(error);\n      return errorHandlerResult ? Promise.reject(errorHandlerResult) : resolveAfterMs(getParams(attempt).gap ?? 0, clear);\n    }, clear))]);\n  } finally {\n    clearAborter.abort();\n  }\n};\nexports.scheduleAction = scheduleAction;\n//# sourceMappingURL=scheduleAction.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}