{"ast":null,"code":"/**\n * this is a set which automatically forgets\n * a given entry when a new entry is set and the ttl\n * of the old one is over\n */\nexport class ObliviousSet {\n  ttl;\n  map = new Map();\n  /**\n   * Creating calls to setTimeout() is expensive,\n   * so we only do that if there is not timeout already open.\n   */\n  _to = false;\n  constructor(ttl) {\n    this.ttl = ttl;\n  }\n  has(value) {\n    return this.map.has(value);\n  }\n  add(value) {\n    this.map.set(value, now());\n    /**\n     * When a new value is added,\n     * start the cleanup at the next tick\n     * to not block the cpu for more important stuff\n     * that might happen.\n     */\n    if (!this._to) {\n      this._to = true;\n      setTimeout(() => {\n        this._to = false;\n        removeTooOldValues(this);\n      }, 0);\n    }\n  }\n  clear() {\n    this.map.clear();\n  }\n}\n/**\n * Removes all entries from the set\n * where the TTL has expired\n */\nexport function removeTooOldValues(obliviousSet) {\n  const olderThen = now() - obliviousSet.ttl;\n  const iterator = obliviousSet.map[Symbol.iterator]();\n  /**\n   * Because we can assume the new values are added at the bottom,\n   * we start from the top and stop as soon as we reach a non-too-old value.\n   */\n  while (true) {\n    const next = iterator.next().value;\n    if (!next) {\n      return; // no more elements\n    }\n    const value = next[0];\n    const time = next[1];\n    if (time < olderThen) {\n      obliviousSet.map.delete(value);\n    } else {\n      // We reached a value that is not old enough\n      return;\n    }\n  }\n}\nexport function now() {\n  return Date.now();\n}","map":{"version":3,"names":["ObliviousSet","ttl","map","Map","_to","constructor","has","value","add","set","now","setTimeout","removeTooOldValues","clear","obliviousSet","olderThen","iterator","Symbol","next","time","delete","Date"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\oblivious-set\\src\\index.ts"],"sourcesContent":["\n/**\n * this is a set which automatically forgets\n * a given entry when a new entry is set and the ttl\n * of the old one is over\n */\nexport class ObliviousSet<T = any> {\n    public readonly map = new Map();\n\n    /**\n     * Creating calls to setTimeout() is expensive,\n     * so we only do that if there is not timeout already open.\n     */\n    public _to: boolean = false;\n    constructor(\n        public readonly ttl: number\n    ) { }\n\n    has(value: T): boolean {\n        return this.map.has(value);\n    }\n\n    add(value: T): void {\n        this.map.set(value, now());\n\n        /**\n         * When a new value is added,\n         * start the cleanup at the next tick\n         * to not block the cpu for more important stuff\n         * that might happen.\n         */\n        if (!this._to) {\n            this._to = true;\n            setTimeout(() => {\n                this._to = false;\n                removeTooOldValues(this);\n            }, 0);\n        }\n    }\n\n    clear() {\n        this.map.clear();\n    }\n}\n\n\n/**\n * Removes all entries from the set\n * where the TTL has expired\n */\nexport function removeTooOldValues(\n    obliviousSet: ObliviousSet\n) {\n    const olderThen = now() - obliviousSet.ttl;\n    const iterator = obliviousSet.map[Symbol.iterator]();\n\n    /**\n     * Because we can assume the new values are added at the bottom,\n     * we start from the top and stop as soon as we reach a non-too-old value.\n     */\n    while (true) {\n\n        const next = iterator.next().value;\n\n        if (!next) {\n            return; // no more elements\n        }\n        const value = next[0];\n        const time = next[1];\n        if (time < olderThen) {\n            obliviousSet.map.delete(value);\n        } else {\n            // We reached a value that is not old enough\n            return;\n        }\n    }\n}\n\nexport function now(): number {\n    return Date.now();\n}\n\n\n"],"mappings":"AACA;;;;;AAKA,OAAM,MAAOA,YAAY;EASDC,GAAA;EARJC,GAAG,GAAG,IAAIC,GAAG,EAAE;EAE/B;;;;EAIOC,GAAG,GAAY,KAAK;EAC3BC,YACoBJ,GAAW;IAAX,KAAAA,GAAG,GAAHA,GAAG;EACnB;EAEJK,GAAGA,CAACC,KAAQ;IACR,OAAO,IAAI,CAACL,GAAG,CAACI,GAAG,CAACC,KAAK,CAAC;EAC9B;EAEAC,GAAGA,CAACD,KAAQ;IACR,IAAI,CAACL,GAAG,CAACO,GAAG,CAACF,KAAK,EAAEG,GAAG,EAAE,CAAC;IAE1B;;;;;;IAMA,IAAI,CAAC,IAAI,CAACN,GAAG,EAAE;MACX,IAAI,CAACA,GAAG,GAAG,IAAI;MACfO,UAAU,CAAC,MAAK;QACZ,IAAI,CAACP,GAAG,GAAG,KAAK;QAChBQ,kBAAkB,CAAC,IAAI,CAAC;MAC5B,CAAC,EAAE,CAAC,CAAC;;EAEb;EAEAC,KAAKA,CAAA;IACD,IAAI,CAACX,GAAG,CAACW,KAAK,EAAE;EACpB;;AAIJ;;;;AAIA,OAAM,SAAUD,kBAAkBA,CAC9BE,YAA0B;EAE1B,MAAMC,SAAS,GAAGL,GAAG,EAAE,GAAGI,YAAY,CAACb,GAAG;EAC1C,MAAMe,QAAQ,GAAGF,YAAY,CAACZ,GAAG,CAACe,MAAM,CAACD,QAAQ,CAAC,EAAE;EAEpD;;;;EAIA,OAAO,IAAI,EAAE;IAET,MAAME,IAAI,GAAGF,QAAQ,CAACE,IAAI,EAAE,CAACX,KAAK;IAElC,IAAI,CAACW,IAAI,EAAE;MACP,OAAO,CAAC;;IAEZ,MAAMX,KAAK,GAAGW,IAAI,CAAC,CAAC,CAAC;IACrB,MAAMC,IAAI,GAAGD,IAAI,CAAC,CAAC,CAAC;IACpB,IAAIC,IAAI,GAAGJ,SAAS,EAAE;MAClBD,YAAY,CAACZ,GAAG,CAACkB,MAAM,CAACb,KAAK,CAAC;KACjC,MAAM;MACH;MACA;;;AAGZ;AAEA,OAAM,SAAUG,GAAGA,CAAA;EACf,OAAOW,IAAI,CAACX,GAAG,EAAE;AACrB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}