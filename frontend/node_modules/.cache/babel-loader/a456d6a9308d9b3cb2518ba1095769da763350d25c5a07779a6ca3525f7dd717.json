{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MappedFunctionReturnType = MappedFunctionReturnType;\nexports.Mapped = Mapped;\nconst index_1 = require(\"../symbols/index\");\nconst index_2 = require(\"../discard/index\");\n// evaluation types\nconst index_3 = require(\"../array/index\");\nconst index_4 = require(\"../async-iterator/index\");\nconst index_5 = require(\"../constructor/index\");\nconst index_6 = require(\"../function/index\");\nconst index_7 = require(\"../indexed/index\");\nconst index_8 = require(\"../intersect/index\");\nconst index_9 = require(\"../iterator/index\");\nconst index_10 = require(\"../literal/index\");\nconst index_11 = require(\"../object/index\");\nconst index_12 = require(\"../optional/index\");\nconst index_13 = require(\"../promise/index\");\nconst index_14 = require(\"../readonly/index\");\nconst index_15 = require(\"../tuple/index\");\nconst index_16 = require(\"../union/index\");\n// operator\nconst index_17 = require(\"../sets/index\");\n// mapping types\nconst mapped_result_1 = require(\"./mapped-result\");\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nconst kind_1 = require(\"../guard/kind\");\n// prettier-ignore\nfunction FromMappedResult(K, P) {\n  return K in P ? FromSchemaType(K, P[K]) : (0, mapped_result_1.MappedResult)(P);\n}\n// prettier-ignore\nfunction MappedKeyToKnownMappedResultProperties(K) {\n  return {\n    [K]: (0, index_10.Literal)(K)\n  };\n}\n// prettier-ignore\nfunction MappedKeyToUnknownMappedResultProperties(P) {\n  const Acc = {};\n  for (const L of P) Acc[L] = (0, index_10.Literal)(L);\n  return Acc;\n}\n// prettier-ignore\nfunction MappedKeyToMappedResultProperties(K, P) {\n  return (0, index_17.SetIncludes)(P, K) ? MappedKeyToKnownMappedResultProperties(K) : MappedKeyToUnknownMappedResultProperties(P);\n}\n// prettier-ignore\nfunction FromMappedKey(K, P) {\n  const R = MappedKeyToMappedResultProperties(K, P);\n  return FromMappedResult(K, R);\n}\n// prettier-ignore\nfunction FromRest(K, T) {\n  return T.map(L => FromSchemaType(K, L));\n}\n// prettier-ignore\nfunction FromProperties(K, T) {\n  const Acc = {};\n  for (const K2 of globalThis.Object.getOwnPropertyNames(T)) Acc[K2] = FromSchemaType(K, T[K2]);\n  return Acc;\n}\n// prettier-ignore\nfunction FromSchemaType(K, T) {\n  // required to retain user defined options for mapped type\n  const options = {\n    ...T\n  };\n  return (\n    // unevaluated modifier types\n    (0, kind_1.IsOptional)(T) ? (0, index_12.Optional)(FromSchemaType(K, (0, index_2.Discard)(T, [index_1.OptionalKind]))) : (0, kind_1.IsReadonly)(T) ? (0, index_14.Readonly)(FromSchemaType(K, (0, index_2.Discard)(T, [index_1.ReadonlyKind]))) :\n    // unevaluated mapped types\n    (0, kind_1.IsMappedResult)(T) ? FromMappedResult(K, T.properties) : (0, kind_1.IsMappedKey)(T) ? FromMappedKey(K, T.keys) :\n    // unevaluated types\n    (0, kind_1.IsConstructor)(T) ? (0, index_5.Constructor)(FromRest(K, T.parameters), FromSchemaType(K, T.returns), options) : (0, kind_1.IsFunction)(T) ? (0, index_6.Function)(FromRest(K, T.parameters), FromSchemaType(K, T.returns), options) : (0, kind_1.IsAsyncIterator)(T) ? (0, index_4.AsyncIterator)(FromSchemaType(K, T.items), options) : (0, kind_1.IsIterator)(T) ? (0, index_9.Iterator)(FromSchemaType(K, T.items), options) : (0, kind_1.IsIntersect)(T) ? (0, index_8.Intersect)(FromRest(K, T.allOf), options) : (0, kind_1.IsUnion)(T) ? (0, index_16.Union)(FromRest(K, T.anyOf), options) : (0, kind_1.IsTuple)(T) ? (0, index_15.Tuple)(FromRest(K, T.items ?? []), options) : (0, kind_1.IsObject)(T) ? (0, index_11.Object)(FromProperties(K, T.properties), options) : (0, kind_1.IsArray)(T) ? (0, index_3.Array)(FromSchemaType(K, T.items), options) : (0, kind_1.IsPromise)(T) ? (0, index_13.Promise)(FromSchemaType(K, T.item), options) : T\n  );\n}\n// prettier-ignore\nfunction MappedFunctionReturnType(K, T) {\n  const Acc = {};\n  for (const L of K) Acc[L] = FromSchemaType(L, T);\n  return Acc;\n}\n/** `[Json]` Creates a Mapped object type */\nfunction Mapped(key, map, options) {\n  const K = (0, kind_1.IsSchema)(key) ? (0, index_7.IndexPropertyKeys)(key) : key;\n  const RT = map({\n    [index_1.Kind]: 'MappedKey',\n    keys: K\n  });\n  const R = MappedFunctionReturnType(K, RT);\n  return (0, index_11.Object)(R, options);\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}