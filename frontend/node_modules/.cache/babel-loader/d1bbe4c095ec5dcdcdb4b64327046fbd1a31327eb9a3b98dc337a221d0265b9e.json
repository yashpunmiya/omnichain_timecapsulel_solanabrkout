{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport EventEmitter from \"events\";\nimport { TransportRaceCondition, TransportError, StatusCodes, getAltStatusMessage, TransportStatusError } from \"@ledgerhq/errors\";\nimport { LocalTracer } from \"@ledgerhq/logs\";\nexport { TransportError, TransportStatusError, StatusCodes, getAltStatusMessage };\nconst DEFAULT_LOG_TYPE = \"transport\";\n/**\n * The Transport class defines a generic interface for communicating with a Ledger hardware wallet.\n * There are different kind of transports based on the technology (channels like U2F, HID, Bluetooth, Webusb) and environment (Node, Web,...).\n * It is an abstract class that needs to be implemented.\n */\nclass Transport {\n  constructor({\n    context,\n    logType\n  } = {}) {\n    this.exchangeTimeout = 30000;\n    this.unresponsiveTimeout = 15000;\n    this.deviceModel = null;\n    this._events = new EventEmitter();\n    /**\n     * Send data to the device using the higher level API.\n     *\n     * @param {number} cla - The instruction class for the command.\n     * @param {number} ins - The instruction code for the command.\n     * @param {number} p1 - The first parameter for the instruction.\n     * @param {number} p2 - The second parameter for the instruction.\n     * @param {Buffer} data - The data to be sent. Defaults to an empty buffer.\n     * @param {Array<number>} statusList - A list of acceptable status codes for the response. Defaults to [StatusCodes.OK].\n     * @param {Object} options - Contains optional options for the exchange function\n     *  - abortTimeoutMs: stop the send after a given timeout. Another timeout exists\n     *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.\n     * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.\n     */\n    this.send = (cla_1, ins_1, p1_1, p2_1, ...args_1) => __awaiter(this, [cla_1, ins_1, p1_1, p2_1, ...args_1], void 0, function* (cla, ins, p1, p2, data = Buffer.alloc(0), statusList = [StatusCodes.OK], {\n      abortTimeoutMs\n    } = {}) {\n      const tracer = this.tracer.withUpdatedContext({\n        function: \"send\"\n      });\n      if (data.length >= 256) {\n        tracer.trace(\"data.length exceeded 256 bytes limit\", {\n          dataLength: data.length\n        });\n        throw new TransportError(\"data.length exceed 256 bytes limit. Got: \" + data.length, \"DataLengthTooBig\");\n      }\n      tracer.trace(\"Starting an exchange\", {\n        abortTimeoutMs\n      });\n      const response = yield this.exchange(\n      // The size of the data is added in 1 byte just before `data`\n      Buffer.concat([Buffer.from([cla, ins, p1, p2]), Buffer.from([data.length]), data]), {\n        abortTimeoutMs\n      });\n      tracer.trace(\"Received response from exchange\");\n      const sw = response.readUInt16BE(response.length - 2);\n      if (!statusList.some(s => s === sw)) {\n        throw new TransportStatusError(sw);\n      }\n      return response;\n    });\n    this._appAPIlock = null;\n    this.tracer = new LocalTracer(logType !== null && logType !== void 0 ? logType : DEFAULT_LOG_TYPE, context);\n  }\n  /**\n   * Send data to the device using a low level API.\n   * It's recommended to use the \"send\" method for a higher level API.\n   * @param {Buffer} apdu - The data to send.\n   * @param {Object} options - Contains optional options for the exchange function\n   *  - abortTimeoutMs: stop the exchange after a given timeout. Another timeout exists\n   *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.\n   * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.\n   */\n  exchange(_apdu, {\n    abortTimeoutMs: _abortTimeoutMs\n  } = {}) {\n    throw new Error(\"exchange not implemented\");\n  }\n  /**\n   * Send apdus in batch to the device using a low level API.\n   * The default implementation is to call exchange for each apdu.\n   * @param {Array<Buffer>} apdus - array of apdus to send.\n   * @param {Observer<Buffer>} observer - an observer that will receive the response of each apdu.\n   * @returns {Subscription} A Subscription object on which you can call \".unsubscribe()\" to stop sending apdus.\n   */\n  exchangeBulk(apdus, observer) {\n    let unsubscribed = false;\n    const unsubscribe = () => {\n      unsubscribed = true;\n    };\n    const main = () => __awaiter(this, void 0, void 0, function* () {\n      if (unsubscribed) return;\n      for (const apdu of apdus) {\n        const r = yield this.exchange(apdu);\n        if (unsubscribed) return;\n        const status = r.readUInt16BE(r.length - 2);\n        if (status !== StatusCodes.OK) {\n          throw new TransportStatusError(status);\n        }\n        observer.next(r);\n      }\n    });\n    main().then(() => !unsubscribed && observer.complete(), e => !unsubscribed && observer.error(e));\n    return {\n      unsubscribe\n    };\n  }\n  /**\n   * Set the \"scramble key\" for the next data exchanges with the device.\n   * Each app can have a different scramble key and it is set internally during instantiation.\n   * @param {string} key - The scramble key to set.\n   * deprecated This method is no longer needed for modern transports and should be migrated away from.\n   * no @ before deprecated as it breaks documentationjs on version 14.0.2\n   * https://github.com/documentationjs/documentation/issues/1596\n   */\n  setScrambleKey(_key) {}\n  /**\n   * Close the connection with the device.\n   *\n   * Note: for certain transports (hw-transport-node-hid-singleton for ex), once the promise resolved,\n   * the transport instance is actually still cached, and the device is disconnected only after a defined timeout.\n   * But for the consumer of the Transport, this does not matter and it can consider the transport to be closed.\n   *\n   * @returns {Promise<void>} A promise that resolves when the transport is closed.\n   */\n  close() {\n    return Promise.resolve();\n  }\n  /**\n   * Listen for an event on the transport instance.\n   * Transport implementations may have specific events. Common events include:\n   * \"disconnect\" : triggered when the transport is disconnected.\n   * @param {string} eventName - The name of the event to listen for.\n   * @param {(...args: Array<any>) => any} cb - The callback function to be invoked when the event occurs.\n   */\n  on(eventName, cb) {\n    this._events.on(eventName, cb);\n  }\n  /**\n   * Stop listening to an event on an instance of transport.\n   */\n  off(eventName, cb) {\n    this._events.removeListener(eventName, cb);\n  }\n  emit(event, ...args) {\n    this._events.emit(event, ...args);\n  }\n  /**\n   * Enable or not logs of the binary exchange\n   */\n  setDebugMode() {\n    console.warn(\"setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.\");\n  }\n  /**\n   * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)\n   */\n  setExchangeTimeout(exchangeTimeout) {\n    this.exchangeTimeout = exchangeTimeout;\n  }\n  /**\n   * Define the delay before emitting \"unresponsive\" on an exchange that does not respond\n   */\n  setExchangeUnresponsiveTimeout(unresponsiveTimeout) {\n    this.unresponsiveTimeout = unresponsiveTimeout;\n  }\n  /**\n   * create() allows to open the first descriptor available or\n   * throw if there is none or if timeout is reached.\n   * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)\n   * @example\n  TransportFoo.create().then(transport => ...)\n   */\n  static create(openTimeout = 3000, listenTimeout) {\n    return new Promise((resolve, reject) => {\n      let found = false;\n      const sub = this.listen({\n        next: e => {\n          found = true;\n          if (sub) sub.unsubscribe();\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          this.open(e.descriptor, openTimeout).then(resolve, reject);\n        },\n        error: e => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          reject(e);\n        },\n        complete: () => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          if (!found) {\n            reject(new TransportError(this.ErrorMessage_NoDeviceFound, \"NoDeviceFound\"));\n          }\n        }\n      });\n      const listenTimeoutId = listenTimeout ? setTimeout(() => {\n        sub.unsubscribe();\n        reject(new TransportError(this.ErrorMessage_ListenTimeout, \"ListenTimeout\"));\n      }, listenTimeout) : null;\n    });\n  }\n  /**\n   * Wrapper to make an exchange \"atomic\" (blocking any other exchange)\n   *\n   * It also handles \"unresponsiveness\" by emitting \"unresponsive\" and \"responsive\" events.\n   *\n   * @param f The exchange job, using the transport to run\n   * @returns a Promise resolving with the output of the given job\n   */\n  exchangeAtomicImpl(f) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const tracer = this.tracer.withUpdatedContext({\n        function: \"exchangeAtomicImpl\",\n        unresponsiveTimeout: this.unresponsiveTimeout\n      });\n      if (this.exchangeBusyPromise) {\n        tracer.trace(\"Atomic exchange is already busy\");\n        throw new TransportRaceCondition(\"An action was already pending on the Ledger device. Please deny or reconnect.\");\n      }\n      // Sets the atomic guard\n      let resolveBusy;\n      const busyPromise = new Promise(r => {\n        resolveBusy = r;\n      });\n      this.exchangeBusyPromise = busyPromise;\n      // The device unresponsiveness handler\n      let unresponsiveReached = false;\n      const timeout = setTimeout(() => {\n        tracer.trace(`Timeout reached, emitting Transport event \"unresponsive\"`, {\n          unresponsiveTimeout: this.unresponsiveTimeout\n        });\n        unresponsiveReached = true;\n        this.emit(\"unresponsive\");\n      }, this.unresponsiveTimeout);\n      try {\n        const res = yield f();\n        if (unresponsiveReached) {\n          tracer.trace(\"Device was unresponsive, emitting responsive\");\n          this.emit(\"responsive\");\n        }\n        return res;\n      } finally {\n        tracer.trace(\"Finalize, clearing busy guard\");\n        clearTimeout(timeout);\n        if (resolveBusy) resolveBusy();\n        this.exchangeBusyPromise = null;\n      }\n    });\n  }\n  decorateAppAPIMethods(self, methods, scrambleKey) {\n    for (const methodName of methods) {\n      self[methodName] = this.decorateAppAPIMethod(methodName, self[methodName], self, scrambleKey);\n    }\n  }\n  decorateAppAPIMethod(methodName, f, ctx, scrambleKey) {\n    return (...args) => __awaiter(this, void 0, void 0, function* () {\n      const {\n        _appAPIlock\n      } = this;\n      if (_appAPIlock) {\n        return Promise.reject(new TransportError(\"Ledger Device is busy (lock \" + _appAPIlock + \")\", \"TransportLocked\"));\n      }\n      try {\n        this._appAPIlock = methodName;\n        this.setScrambleKey(scrambleKey);\n        return yield f.apply(ctx, args);\n      } finally {\n        this._appAPIlock = null;\n      }\n    });\n  }\n  /**\n   * Sets the context used by the logging/tracing mechanism\n   *\n   * Useful when re-using (cached) the same Transport instance,\n   * but with a new tracing context.\n   *\n   * @param context A TraceContext, that can undefined to reset the context\n   */\n  setTraceContext(context) {\n    this.tracer = this.tracer.withContext(context);\n  }\n  /**\n   * Updates the context used by the logging/tracing mechanism\n   *\n   * The update only overrides the key-value that are already defined in the current context.\n   *\n   * @param contextToAdd A TraceContext that will be added to the current context\n   */\n  updateTraceContext(contextToAdd) {\n    this.tracer.updateContext(contextToAdd);\n  }\n  /**\n   * Gets the tracing context of the transport instance\n   */\n  getTraceContext() {\n    return this.tracer.getContext();\n  }\n}\nTransport.ErrorMessage_ListenTimeout = \"No Ledger device found (timeout)\";\nTransport.ErrorMessage_NoDeviceFound = \"No Ledger device found\";\nexport default Transport;\n//# sourceMappingURL=Transport.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}