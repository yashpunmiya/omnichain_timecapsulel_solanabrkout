{"ast":null,"code":"/*!\n * Unidragger v3.0.1\n * Draggable base class\n * MIT license\n */\n\n(function (window, factory) {\n  // universal module definition\n  if (typeof module == 'object' && module.exports) {\n    // CommonJS\n    module.exports = factory(window, require('ev-emitter'));\n  } else {\n    // browser global\n    window.Unidragger = factory(window, window.EvEmitter);\n  }\n})(typeof window != 'undefined' ? window : this, function factory(window, EvEmitter) {\n  function Unidragger() {}\n\n  // inherit EvEmitter\n  let proto = Unidragger.prototype = Object.create(EvEmitter.prototype);\n\n  // ----- bind start ----- //\n\n  // trigger handler methods for events\n  proto.handleEvent = function (event) {\n    let method = 'on' + event.type;\n    if (this[method]) {\n      this[method](event);\n    }\n  };\n  let startEvent, activeEvents;\n  if ('ontouchstart' in window) {\n    // HACK prefer Touch Events as you can preventDefault on touchstart to\n    // disable scroll in iOS & mobile Chrome metafizzy/flickity#1177\n    startEvent = 'touchstart';\n    activeEvents = ['touchmove', 'touchend', 'touchcancel'];\n  } else if (window.PointerEvent) {\n    // Pointer Events\n    startEvent = 'pointerdown';\n    activeEvents = ['pointermove', 'pointerup', 'pointercancel'];\n  } else {\n    // mouse events\n    startEvent = 'mousedown';\n    activeEvents = ['mousemove', 'mouseup'];\n  }\n\n  // prototype so it can be overwriteable by Flickity\n  proto.touchActionValue = 'none';\n  proto.bindHandles = function () {\n    this._bindHandles('addEventListener', this.touchActionValue);\n  };\n  proto.unbindHandles = function () {\n    this._bindHandles('removeEventListener', '');\n  };\n\n  /**\n   * Add or remove start event\n   * @param {String} bindMethod - addEventListener or removeEventListener\n   * @param {String} touchAction - value for touch-action CSS property\n   */\n  proto._bindHandles = function (bindMethod, touchAction) {\n    this.handles.forEach(handle => {\n      handle[bindMethod](startEvent, this);\n      handle[bindMethod]('click', this);\n      // touch-action: none to override browser touch gestures. metafizzy/flickity#540\n      if (window.PointerEvent) handle.style.touchAction = touchAction;\n    });\n  };\n  proto.bindActivePointerEvents = function () {\n    activeEvents.forEach(eventName => {\n      window.addEventListener(eventName, this);\n    });\n  };\n  proto.unbindActivePointerEvents = function () {\n    activeEvents.forEach(eventName => {\n      window.removeEventListener(eventName, this);\n    });\n  };\n\n  // ----- event handler helpers ----- //\n\n  // trigger method with matching pointer\n  proto.withPointer = function (methodName, event) {\n    if (event.pointerId === this.pointerIdentifier) {\n      this[methodName](event, event);\n    }\n  };\n\n  // trigger method with matching touch\n  proto.withTouch = function (methodName, event) {\n    let touch;\n    for (let changedTouch of event.changedTouches) {\n      if (changedTouch.identifier === this.pointerIdentifier) {\n        touch = changedTouch;\n      }\n    }\n    if (touch) this[methodName](event, touch);\n  };\n\n  // ----- start event ----- //\n\n  proto.onmousedown = function (event) {\n    this.pointerDown(event, event);\n  };\n  proto.ontouchstart = function (event) {\n    this.pointerDown(event, event.changedTouches[0]);\n  };\n  proto.onpointerdown = function (event) {\n    this.pointerDown(event, event);\n  };\n\n  // nodes that have text fields\n  const cursorNodes = ['TEXTAREA', 'INPUT', 'SELECT', 'OPTION'];\n  // input types that do not have text fields\n  const clickTypes = ['radio', 'checkbox', 'button', 'submit', 'image', 'file'];\n\n  /**\n   * any time you set `event, pointer` it refers to:\n   * @param {Event} event\n   * @param {Event | Touch} pointer\n   */\n  proto.pointerDown = function (event, pointer) {\n    // dismiss multi-touch taps, right clicks, and clicks on text fields\n    let isCursorNode = cursorNodes.includes(event.target.nodeName);\n    let isClickType = clickTypes.includes(event.target.type);\n    let isOkayElement = !isCursorNode || isClickType;\n    let isOkay = !this.isPointerDown && !event.button && isOkayElement;\n    if (!isOkay) return;\n    this.isPointerDown = true;\n    // save pointer identifier to match up touch events\n    this.pointerIdentifier = pointer.pointerId !== undefined ?\n    // pointerId for pointer events, touch.indentifier for touch events\n    pointer.pointerId : pointer.identifier;\n    // track position for move\n    this.pointerDownPointer = {\n      pageX: pointer.pageX,\n      pageY: pointer.pageY\n    };\n    this.bindActivePointerEvents();\n    this.emitEvent('pointerDown', [event, pointer]);\n  };\n\n  // ----- move ----- //\n\n  proto.onmousemove = function (event) {\n    this.pointerMove(event, event);\n  };\n  proto.onpointermove = function (event) {\n    this.withPointer('pointerMove', event);\n  };\n  proto.ontouchmove = function (event) {\n    this.withTouch('pointerMove', event);\n  };\n  proto.pointerMove = function (event, pointer) {\n    let moveVector = {\n      x: pointer.pageX - this.pointerDownPointer.pageX,\n      y: pointer.pageY - this.pointerDownPointer.pageY\n    };\n    this.emitEvent('pointerMove', [event, pointer, moveVector]);\n    // start drag if pointer has moved far enough to start drag\n    let isDragStarting = !this.isDragging && this.hasDragStarted(moveVector);\n    if (isDragStarting) this.dragStart(event, pointer);\n    if (this.isDragging) this.dragMove(event, pointer, moveVector);\n  };\n\n  // condition if pointer has moved far enough to start drag\n  proto.hasDragStarted = function (moveVector) {\n    return Math.abs(moveVector.x) > 3 || Math.abs(moveVector.y) > 3;\n  };\n\n  // ----- drag ----- //\n\n  proto.dragStart = function (event, pointer) {\n    this.isDragging = true;\n    this.isPreventingClicks = true; // set flag to prevent clicks\n    this.emitEvent('dragStart', [event, pointer]);\n  };\n  proto.dragMove = function (event, pointer, moveVector) {\n    this.emitEvent('dragMove', [event, pointer, moveVector]);\n  };\n\n  // ----- end ----- //\n\n  proto.onmouseup = function (event) {\n    this.pointerUp(event, event);\n  };\n  proto.onpointerup = function (event) {\n    this.withPointer('pointerUp', event);\n  };\n  proto.ontouchend = function (event) {\n    this.withTouch('pointerUp', event);\n  };\n  proto.pointerUp = function (event, pointer) {\n    this.pointerDone();\n    this.emitEvent('pointerUp', [event, pointer]);\n    if (this.isDragging) {\n      this.dragEnd(event, pointer);\n    } else {\n      // pointer didn't move enough for drag to start\n      this.staticClick(event, pointer);\n    }\n  };\n  proto.dragEnd = function (event, pointer) {\n    this.isDragging = false; // reset flag\n    // re-enable clicking async\n    setTimeout(() => delete this.isPreventingClicks);\n    this.emitEvent('dragEnd', [event, pointer]);\n  };\n\n  // triggered on pointer up & pointer cancel\n  proto.pointerDone = function () {\n    this.isPointerDown = false;\n    delete this.pointerIdentifier;\n    this.unbindActivePointerEvents();\n    this.emitEvent('pointerDone');\n  };\n\n  // ----- cancel ----- //\n\n  proto.onpointercancel = function (event) {\n    this.withPointer('pointerCancel', event);\n  };\n  proto.ontouchcancel = function (event) {\n    this.withTouch('pointerCancel', event);\n  };\n  proto.pointerCancel = function (event, pointer) {\n    this.pointerDone();\n    this.emitEvent('pointerCancel', [event, pointer]);\n  };\n\n  // ----- click ----- //\n\n  // handle all clicks and prevent clicks when dragging\n  proto.onclick = function (event) {\n    if (this.isPreventingClicks) event.preventDefault();\n  };\n\n  // triggered after pointer down & up with no/tiny movement\n  proto.staticClick = function (event, pointer) {\n    // ignore emulated mouse up clicks\n    let isMouseup = event.type === 'mouseup';\n    if (isMouseup && this.isIgnoringMouseUp) return;\n    this.emitEvent('staticClick', [event, pointer]);\n\n    // set flag for emulated clicks 300ms after touchend\n    if (isMouseup) {\n      this.isIgnoringMouseUp = true;\n      // reset flag after 400ms\n      setTimeout(() => {\n        delete this.isIgnoringMouseUp;\n      }, 400);\n    }\n  };\n\n  // -----  ----- //\n\n  return Unidragger;\n});","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}