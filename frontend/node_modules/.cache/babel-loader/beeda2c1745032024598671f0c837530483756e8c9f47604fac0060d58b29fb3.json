{"ast":null,"code":"import * as AbiConstructor from 'ox/AbiConstructor';\nimport * as AbiFunction from 'ox/AbiFunction';\nimport { parseAccount } from '../../accounts/utils/parseAccount.js';\nimport { ethAddress, zeroAddress } from '../../constants/address.js';\nimport { deploylessCallViaBytecodeBytecode } from '../../constants/contracts.js';\nimport { BaseError } from '../../errors/base.js';\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js';\nimport { hexToBigInt } from '../../utils/index.js';\nimport { createAccessList } from './createAccessList.js';\nimport { simulateBlocks } from './simulateBlocks.js';\nconst getBalanceCode = '0x6080604052348015600e575f80fd5b5061016d8061001c5f395ff3fe608060405234801561000f575f80fd5b5060043610610029575f3560e01c8063f8b2cb4f1461002d575b5f80fd5b610047600480360381019061004291906100db565b61005d565b604051610054919061011e565b60405180910390f35b5f8173ffffffffffffffffffffffffffffffffffffffff16319050919050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6100aa82610081565b9050919050565b6100ba816100a0565b81146100c4575f80fd5b50565b5f813590506100d5816100b1565b92915050565b5f602082840312156100f0576100ef61007d565b5b5f6100fd848285016100c7565b91505092915050565b5f819050919050565b61011881610106565b82525050565b5f6020820190506101315f83018461010f565b9291505056fea26469706673582212203b9fe929fe995c7cf9887f0bdba8a36dd78e8b73f149b17d2d9ad7cd09d2dc6264736f6c634300081a0033';\n/**\n * Simulates execution of a batch of calls.\n *\n * @param client - Client to use\n * @param parameters - {@link SimulateCallsParameters}\n * @returns Results. {@link SimulateCallsReturnType}\n *\n * @example\n * ```ts\n * import { createPublicClient, http, parseEther } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { simulateCalls } from 'viem/actions'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const result = await simulateCalls(client, {\n *   account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',\n *   calls: [{\n *     {\n *       data: '0xdeadbeef',\n *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *     },\n *     {\n *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *       value: parseEther('1'),\n *     },\n *   ]\n * })\n * ```\n */\nexport async function simulateCalls(client, parameters) {\n  const {\n    blockNumber,\n    blockTag,\n    calls,\n    stateOverrides,\n    traceAssetChanges,\n    traceTransfers,\n    validation\n  } = parameters;\n  const account = parameters.account ? parseAccount(parameters.account) : undefined;\n  if (traceAssetChanges && !account) throw new BaseError('`account` is required when `traceAssetChanges` is true');\n  // Derive bytecode to extract ETH balance via a contract call.\n  const getBalanceData = account ? AbiConstructor.encode(AbiConstructor.from('constructor(bytes, bytes)'), {\n    bytecode: deploylessCallViaBytecodeBytecode,\n    args: [getBalanceCode, AbiFunction.encodeData(AbiFunction.from('function getBalance(address)'), [account.address])]\n  }) : undefined;\n  // Fetch ERC20/721 addresses that were \"touched\" from the calls.\n  const assetAddresses = traceAssetChanges ? await Promise.all(parameters.calls.map(async call => {\n    if (!call.data && !call.abi) return;\n    const {\n      accessList\n    } = await createAccessList(client, {\n      account: account.address,\n      ...call,\n      data: call.abi ? encodeFunctionData(call) : call.data\n    });\n    return accessList.map(({\n      address,\n      storageKeys\n    }) => storageKeys.length > 0 ? address : null);\n  })).then(x => x.flat().filter(Boolean)) : [];\n  const resultsStateOverrides = stateOverrides?.map(override => {\n    if (override.address === account?.address) return {\n      ...override,\n      nonce: 0\n    };\n    return override;\n  });\n  const blocks = await simulateBlocks(client, {\n    blockNumber,\n    blockTag: blockTag,\n    blocks: [...(traceAssetChanges ? [\n    // ETH pre balances\n    {\n      calls: [{\n        data: getBalanceData\n      }],\n      stateOverrides\n    },\n    // Asset pre balances\n    {\n      calls: assetAddresses.map((address, i) => ({\n        abi: [AbiFunction.from('function balanceOf(address) returns (uint256)')],\n        functionName: 'balanceOf',\n        args: [account.address],\n        to: address,\n        from: zeroAddress,\n        nonce: i\n      })),\n      stateOverrides: [{\n        address: zeroAddress,\n        nonce: 0\n      }]\n    }] : []), {\n      calls: [...calls, {}].map((call, index) => ({\n        ...call,\n        from: account?.address,\n        nonce: index\n      })),\n      stateOverrides: resultsStateOverrides\n    }, ...(traceAssetChanges ? [\n    // ETH post balances\n    {\n      calls: [{\n        data: getBalanceData\n      }]\n    },\n    // Asset post balances\n    {\n      calls: assetAddresses.map((address, i) => ({\n        abi: [AbiFunction.from('function balanceOf(address) returns (uint256)')],\n        functionName: 'balanceOf',\n        args: [account.address],\n        to: address,\n        from: zeroAddress,\n        nonce: i\n      })),\n      stateOverrides: [{\n        address: zeroAddress,\n        nonce: 0\n      }]\n    },\n    // Decimals\n    {\n      calls: assetAddresses.map((address, i) => ({\n        to: address,\n        abi: [AbiFunction.from('function decimals() returns (uint256)')],\n        functionName: 'decimals',\n        from: zeroAddress,\n        nonce: i\n      })),\n      stateOverrides: [{\n        address: zeroAddress,\n        nonce: 0\n      }]\n    },\n    // Token URI\n    {\n      calls: assetAddresses.map((address, i) => ({\n        to: address,\n        abi: [AbiFunction.from('function tokenURI(uint256) returns (string)')],\n        functionName: 'tokenURI',\n        args: [0n],\n        from: zeroAddress,\n        nonce: i\n      })),\n      stateOverrides: [{\n        address: zeroAddress,\n        nonce: 0\n      }]\n    },\n    // Symbols\n    {\n      calls: assetAddresses.map((address, i) => ({\n        to: address,\n        abi: [AbiFunction.from('function symbol() returns (string)')],\n        functionName: 'symbol',\n        from: zeroAddress,\n        nonce: i\n      })),\n      stateOverrides: [{\n        address: zeroAddress,\n        nonce: 0\n      }]\n    }] : [])],\n    traceTransfers,\n    validation\n  });\n  const block_results = traceAssetChanges ? blocks[2] : blocks[0];\n  const [block_ethPre, block_assetsPre,, block_ethPost, block_assetsPost, block_decimals, block_tokenURI, block_symbols] = traceAssetChanges ? blocks : [];\n  // Extract call results from the simulation.\n  const {\n    calls: block_calls,\n    ...block\n  } = block_results;\n  const results = block_calls.slice(0, -1) ?? [];\n  // Extract pre-execution ETH and asset balances.\n  const ethPre = block_ethPre?.calls ?? [];\n  const assetsPre = block_assetsPre?.calls ?? [];\n  const balancesPre = [...ethPre, ...assetsPre].map(call => call.status === 'success' ? hexToBigInt(call.data) : null);\n  // Extract post-execution ETH and asset balances.\n  const ethPost = block_ethPost?.calls ?? [];\n  const assetsPost = block_assetsPost?.calls ?? [];\n  const balancesPost = [...ethPost, ...assetsPost].map(call => call.status === 'success' ? hexToBigInt(call.data) : null);\n  // Extract asset symbols & decimals.\n  const decimals = (block_decimals?.calls ?? []).map(x => x.status === 'success' ? x.result : null);\n  const symbols = (block_symbols?.calls ?? []).map(x => x.status === 'success' ? x.result : null);\n  const tokenURI = (block_tokenURI?.calls ?? []).map(x => x.status === 'success' ? x.result : null);\n  const changes = [];\n  for (const [i, balancePost] of balancesPost.entries()) {\n    const balancePre = balancesPre[i];\n    if (typeof balancePost !== 'bigint') continue;\n    if (typeof balancePre !== 'bigint') continue;\n    const decimals_ = decimals[i - 1];\n    const symbol_ = symbols[i - 1];\n    const tokenURI_ = tokenURI[i - 1];\n    const token = (() => {\n      if (i === 0) return {\n        address: ethAddress,\n        decimals: 18,\n        symbol: 'ETH'\n      };\n      return {\n        address: assetAddresses[i - 1],\n        decimals: tokenURI_ || decimals_ ? Number(decimals_ ?? 1) : undefined,\n        symbol: symbol_ ?? undefined\n      };\n    })();\n    if (changes.some(change => change.token.address === token.address)) continue;\n    changes.push({\n      token,\n      value: {\n        pre: balancePre,\n        post: balancePost,\n        diff: balancePost - balancePre\n      }\n    });\n  }\n  return {\n    assetChanges: changes,\n    block,\n    results\n  };\n}","map":{"version":3,"names":["AbiConstructor","AbiFunction","parseAccount","ethAddress","zeroAddress","deploylessCallViaBytecodeBytecode","BaseError","encodeFunctionData","hexToBigInt","createAccessList","simulateBlocks","getBalanceCode","simulateCalls","client","parameters","blockNumber","blockTag","calls","stateOverrides","traceAssetChanges","traceTransfers","validation","account","undefined","getBalanceData","encode","from","bytecode","args","encodeData","address","assetAddresses","Promise","all","map","call","data","abi","accessList","storageKeys","length","then","x","flat","filter","Boolean","resultsStateOverrides","override","nonce","blocks","i","functionName","to","index","block_results","block_ethPre","block_assetsPre","block_ethPost","block_assetsPost","block_decimals","block_tokenURI","block_symbols","block_calls","block","results","slice","ethPre","assetsPre","balancesPre","status","ethPost","assetsPost","balancesPost","decimals","result","symbols","tokenURI","changes","balancePost","entries","balancePre","decimals_","symbol_","tokenURI_","token","symbol","Number","some","change","push","value","pre","post","diff","assetChanges"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@reown\\appkit-controllers\\node_modules\\@walletconnect\\utils\\node_modules\\viem\\actions\\public\\simulateCalls.ts"],"sourcesContent":["import type { AbiStateMutability, Address, Narrow } from 'abitype'\nimport * as AbiConstructor from 'ox/AbiConstructor'\nimport * as AbiFunction from 'ox/AbiFunction'\n\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { ethAddress, zeroAddress } from '../../constants/address.js'\nimport { deploylessCallViaBytecodeBytecode } from '../../constants/contracts.js'\nimport { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Block } from '../../types/block.js'\nimport type { Call, Calls } from '../../types/calls.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Log } from '../../types/log.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { MulticallResults } from '../../types/multicall.js'\nimport type { StateOverride } from '../../types/stateOverride.js'\nimport type { Mutable } from '../../types/utils.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport { hexToBigInt } from '../../utils/index.js'\nimport {\n  type CreateAccessListErrorType,\n  createAccessList,\n} from './createAccessList.js'\nimport {\n  type SimulateBlocksErrorType,\n  type SimulateBlocksParameters,\n  simulateBlocks,\n} from './simulateBlocks.js'\n\nconst getBalanceCode =\n  '0x6080604052348015600e575f80fd5b5061016d8061001c5f395ff3fe608060405234801561000f575f80fd5b5060043610610029575f3560e01c8063f8b2cb4f1461002d575b5f80fd5b610047600480360381019061004291906100db565b61005d565b604051610054919061011e565b60405180910390f35b5f8173ffffffffffffffffffffffffffffffffffffffff16319050919050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6100aa82610081565b9050919050565b6100ba816100a0565b81146100c4575f80fd5b50565b5f813590506100d5816100b1565b92915050565b5f602082840312156100f0576100ef61007d565b5b5f6100fd848285016100c7565b91505092915050565b5f819050919050565b61011881610106565b82525050565b5f6020820190506101315f83018461010f565b9291505056fea26469706673582212203b9fe929fe995c7cf9887f0bdba8a36dd78e8b73f149b17d2d9ad7cd09d2dc6264736f6c634300081a0033'\n\nexport type SimulateCallsParameters<\n  calls extends readonly unknown[] = readonly unknown[],\n  account extends Account | Address | undefined = Account | Address | undefined,\n> = Omit<SimulateBlocksParameters, 'blocks' | 'returnFullTransactions'> & {\n  /** Account attached to the calls (msg.sender). */\n  account?: account | undefined\n  /** Calls to simulate. */\n  calls: Calls<Narrow<calls>>\n  /** State overrides. */\n  stateOverrides?: StateOverride | undefined\n  /** Whether to trace asset changes. */\n  traceAssetChanges?: boolean | undefined\n}\n\nexport type SimulateCallsReturnType<\n  calls extends readonly unknown[] = readonly unknown[],\n> = {\n  /** Asset changes. */\n  assetChanges: readonly {\n    token: {\n      address: Address\n      decimals?: number | undefined\n      symbol?: string | undefined\n    }\n    value: { pre: bigint; post: bigint; diff: bigint }\n  }[]\n  /** Block results. */\n  block: Block\n  /** Call results. */\n  results: MulticallResults<\n    Narrow<calls>,\n    true,\n    {\n      extraProperties: {\n        data: Hex\n        gasUsed: bigint\n        logs?: Log[] | undefined\n      }\n      error: Error\n      mutability: AbiStateMutability\n    }\n  >\n}\n\nexport type SimulateCallsErrorType =\n  | AbiFunction.encodeData.ErrorType\n  | AbiFunction.from.ErrorType\n  | CreateAccessListErrorType\n  | EncodeFunctionDataErrorType\n  | SimulateBlocksErrorType\n  | ErrorType\n\n/**\n * Simulates execution of a batch of calls.\n *\n * @param client - Client to use\n * @param parameters - {@link SimulateCallsParameters}\n * @returns Results. {@link SimulateCallsReturnType}\n *\n * @example\n * ```ts\n * import { createPublicClient, http, parseEther } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { simulateCalls } from 'viem/actions'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const result = await simulateCalls(client, {\n *   account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',\n *   calls: [{\n *     {\n *       data: '0xdeadbeef',\n *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *     },\n *     {\n *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *       value: parseEther('1'),\n *     },\n *   ]\n * })\n * ```\n */\nexport async function simulateCalls<\n  const calls extends readonly unknown[],\n  chain extends Chain | undefined,\n  account extends Account | Address | undefined = undefined,\n>(\n  client: Client<Transport, chain>,\n  parameters: SimulateCallsParameters<calls, account>,\n): Promise<SimulateCallsReturnType<calls>> {\n  const {\n    blockNumber,\n    blockTag,\n    calls,\n    stateOverrides,\n    traceAssetChanges,\n    traceTransfers,\n    validation,\n  } = parameters\n\n  const account = parameters.account\n    ? parseAccount(parameters.account)\n    : undefined\n\n  if (traceAssetChanges && !account)\n    throw new BaseError(\n      '`account` is required when `traceAssetChanges` is true',\n    )\n\n  // Derive bytecode to extract ETH balance via a contract call.\n  const getBalanceData = account\n    ? AbiConstructor.encode(AbiConstructor.from('constructor(bytes, bytes)'), {\n        bytecode: deploylessCallViaBytecodeBytecode,\n        args: [\n          getBalanceCode,\n          AbiFunction.encodeData(\n            AbiFunction.from('function getBalance(address)'),\n            [account.address],\n          ),\n        ],\n      })\n    : undefined\n\n  // Fetch ERC20/721 addresses that were \"touched\" from the calls.\n  const assetAddresses = traceAssetChanges\n    ? await Promise.all(\n        parameters.calls.map(async (call: any) => {\n          if (!call.data && !call.abi) return\n          const { accessList } = await createAccessList(client, {\n            account: account!.address,\n            ...call,\n            data: call.abi ? encodeFunctionData(call) : call.data,\n          })\n          return accessList.map(({ address, storageKeys }) =>\n            storageKeys.length > 0 ? address : null,\n          )\n        }),\n      ).then((x) => x.flat().filter(Boolean))\n    : []\n\n  const resultsStateOverrides = stateOverrides?.map((override) => {\n    if (override.address === account?.address)\n      return {\n        ...override,\n        nonce: 0,\n      }\n    return override\n  })\n\n  const blocks = await simulateBlocks(client, {\n    blockNumber,\n    blockTag: blockTag as undefined,\n    blocks: [\n      ...(traceAssetChanges\n        ? [\n            // ETH pre balances\n            {\n              calls: [{ data: getBalanceData }],\n              stateOverrides,\n            },\n\n            // Asset pre balances\n            {\n              calls: assetAddresses.map((address, i) => ({\n                abi: [\n                  AbiFunction.from(\n                    'function balanceOf(address) returns (uint256)',\n                  ),\n                ],\n                functionName: 'balanceOf',\n                args: [account!.address],\n                to: address,\n                from: zeroAddress,\n                nonce: i,\n              })),\n              stateOverrides: [\n                {\n                  address: zeroAddress,\n                  nonce: 0,\n                },\n              ],\n            },\n          ]\n        : []),\n\n      {\n        calls: [...calls, {}].map((call, index) => ({\n          ...(call as Call),\n          from: account?.address,\n          nonce: index,\n        })) as any,\n        stateOverrides: resultsStateOverrides,\n      },\n\n      ...(traceAssetChanges\n        ? [\n            // ETH post balances\n            {\n              calls: [{ data: getBalanceData }],\n            },\n\n            // Asset post balances\n            {\n              calls: assetAddresses.map((address, i) => ({\n                abi: [\n                  AbiFunction.from(\n                    'function balanceOf(address) returns (uint256)',\n                  ),\n                ],\n                functionName: 'balanceOf',\n                args: [account!.address],\n                to: address,\n                from: zeroAddress,\n                nonce: i,\n              })),\n              stateOverrides: [\n                {\n                  address: zeroAddress,\n                  nonce: 0,\n                },\n              ],\n            },\n\n            // Decimals\n            {\n              calls: assetAddresses.map((address, i) => ({\n                to: address,\n                abi: [\n                  AbiFunction.from('function decimals() returns (uint256)'),\n                ],\n                functionName: 'decimals',\n                from: zeroAddress,\n                nonce: i,\n              })),\n              stateOverrides: [\n                {\n                  address: zeroAddress,\n                  nonce: 0,\n                },\n              ],\n            },\n\n            // Token URI\n            {\n              calls: assetAddresses.map((address, i) => ({\n                to: address,\n                abi: [\n                  AbiFunction.from(\n                    'function tokenURI(uint256) returns (string)',\n                  ),\n                ],\n                functionName: 'tokenURI',\n                args: [0n],\n                from: zeroAddress,\n                nonce: i,\n              })),\n              stateOverrides: [\n                {\n                  address: zeroAddress,\n                  nonce: 0,\n                },\n              ],\n            },\n\n            // Symbols\n            {\n              calls: assetAddresses.map((address, i) => ({\n                to: address,\n                abi: [AbiFunction.from('function symbol() returns (string)')],\n                functionName: 'symbol',\n                from: zeroAddress,\n                nonce: i,\n              })),\n              stateOverrides: [\n                {\n                  address: zeroAddress,\n                  nonce: 0,\n                },\n              ],\n            },\n          ]\n        : []),\n    ],\n    traceTransfers,\n    validation,\n  })\n\n  const block_results = traceAssetChanges ? blocks[2] : blocks[0]\n  const [\n    block_ethPre,\n    block_assetsPre,\n    ,\n    block_ethPost,\n    block_assetsPost,\n    block_decimals,\n    block_tokenURI,\n    block_symbols,\n  ] = traceAssetChanges ? blocks : []\n\n  // Extract call results from the simulation.\n  const { calls: block_calls, ...block } = block_results\n  const results = block_calls.slice(0, -1) ?? []\n\n  // Extract pre-execution ETH and asset balances.\n  const ethPre = block_ethPre?.calls ?? []\n  const assetsPre = block_assetsPre?.calls ?? []\n  const balancesPre = [...ethPre, ...assetsPre].map((call) =>\n    call.status === 'success' ? hexToBigInt(call.data) : null,\n  )\n\n  // Extract post-execution ETH and asset balances.\n  const ethPost = block_ethPost?.calls ?? []\n  const assetsPost = block_assetsPost?.calls ?? []\n  const balancesPost = [...ethPost, ...assetsPost].map((call) =>\n    call.status === 'success' ? hexToBigInt(call.data) : null,\n  )\n\n  // Extract asset symbols & decimals.\n  const decimals = (block_decimals?.calls ?? []).map((x) =>\n    x.status === 'success' ? x.result : null,\n  ) as (number | null)[]\n  const symbols = (block_symbols?.calls ?? []).map((x) =>\n    x.status === 'success' ? x.result : null,\n  ) as (string | null)[]\n  const tokenURI = (block_tokenURI?.calls ?? []).map((x) =>\n    x.status === 'success' ? x.result : null,\n  ) as (string | null)[]\n\n  const changes: Mutable<SimulateCallsReturnType<calls>['assetChanges']> = []\n  for (const [i, balancePost] of balancesPost.entries()) {\n    const balancePre = balancesPre[i]\n\n    if (typeof balancePost !== 'bigint') continue\n    if (typeof balancePre !== 'bigint') continue\n\n    const decimals_ = decimals[i - 1]\n    const symbol_ = symbols[i - 1]\n    const tokenURI_ = tokenURI[i - 1]\n\n    const token = (() => {\n      if (i === 0)\n        return {\n          address: ethAddress,\n          decimals: 18,\n          symbol: 'ETH',\n        }\n\n      return {\n        address: assetAddresses[i - 1]! as Address,\n        decimals: tokenURI_ || decimals_ ? Number(decimals_ ?? 1) : undefined,\n        symbol: symbol_ ?? undefined,\n      }\n    })()\n\n    if (changes.some((change) => change.token.address === token.address))\n      continue\n\n    changes.push({\n      token,\n      value: {\n        pre: balancePre,\n        post: balancePost,\n        diff: balancePost - balancePre,\n      },\n    })\n  }\n\n  return {\n    assetChanges: changes,\n    block,\n    results,\n  } as unknown as SimulateCallsReturnType<calls>\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}