{"ast":null,"code":"import * as AbiParameters from '../AbiParameters.js';\nimport * as Address from '../Address.js';\nimport * as Bytes from '../Bytes.js';\nimport * as Errors from '../Errors.js';\nimport * as Hex from '../Hex.js';\nimport { integerRegex } from '../Solidity.js';\n/** @internal */\nexport function decodeParameter(cursor, param, options) {\n  const {\n    checksumAddress,\n    staticPosition\n  } = options;\n  const arrayComponents = getArrayComponents(param.type);\n  if (arrayComponents) {\n    const [length, type] = arrayComponents;\n    return decodeArray(cursor, {\n      ...param,\n      type\n    }, {\n      checksumAddress,\n      length,\n      staticPosition\n    });\n  }\n  if (param.type === 'tuple') return decodeTuple(cursor, param, {\n    checksumAddress,\n    staticPosition\n  });\n  if (param.type === 'address') return decodeAddress(cursor, {\n    checksum: checksumAddress\n  });\n  if (param.type === 'bool') return decodeBool(cursor);\n  if (param.type.startsWith('bytes')) return decodeBytes(cursor, param, {\n    staticPosition\n  });\n  if (param.type.startsWith('uint') || param.type.startsWith('int')) return decodeNumber(cursor, param);\n  if (param.type === 'string') return decodeString(cursor, {\n    staticPosition\n  });\n  throw new AbiParameters.InvalidTypeError(param.type);\n}\nconst sizeOfLength = 32;\nconst sizeOfOffset = 32;\n/** @internal */\nexport function decodeAddress(cursor, options = {}) {\n  const {\n    checksum = false\n  } = options;\n  const value = cursor.readBytes(32);\n  const wrap = address => checksum ? Address.checksum(address) : address;\n  return [wrap(Hex.fromBytes(Bytes.slice(value, -20))), 32];\n}\n/** @internal */\nexport function decodeArray(cursor, param, options) {\n  const {\n    checksumAddress,\n    length,\n    staticPosition\n  } = options;\n  // If the length of the array is not known in advance (dynamic array),\n  // this means we will need to wonder off to the pointer and decode.\n  if (!length) {\n    // Dealing with a dynamic type, so get the offset of the array data.\n    const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset));\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset;\n    const startOfData = start + sizeOfLength;\n    // Get the length of the array from the offset.\n    cursor.setPosition(start);\n    const length = Bytes.toNumber(cursor.readBytes(sizeOfLength));\n    // Check if the array has any dynamic children.\n    const dynamicChild = hasDynamicChild(param);\n    let consumed = 0;\n    const value = [];\n    for (let i = 0; i < length; ++i) {\n      // If any of the children is dynamic, then all elements will be offset pointer, thus size of one slot (32 bytes).\n      // Otherwise, elements will be the size of their encoding (consumed bytes).\n      cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed));\n      const [data, consumed_] = decodeParameter(cursor, param, {\n        checksumAddress,\n        staticPosition: startOfData\n      });\n      consumed += consumed_;\n      value.push(data);\n    }\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32);\n    return [value, 32];\n  }\n  // If the length of the array is known in advance,\n  // and the length of an element deeply nested in the array is not known,\n  // we need to decode the offset of the array data.\n  if (hasDynamicChild(param)) {\n    // Dealing with dynamic types, so get the offset of the array data.\n    const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset));\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset;\n    const value = [];\n    for (let i = 0; i < length; ++i) {\n      // Move cursor along to the next slot (next offset pointer).\n      cursor.setPosition(start + i * 32);\n      const [data] = decodeParameter(cursor, param, {\n        checksumAddress,\n        staticPosition: start\n      });\n      value.push(data);\n    }\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32);\n    return [value, 32];\n  }\n  // If the length of the array is known in advance and the array is deeply static,\n  // then we can just decode each element in sequence.\n  let consumed = 0;\n  const value = [];\n  for (let i = 0; i < length; ++i) {\n    const [data, consumed_] = decodeParameter(cursor, param, {\n      checksumAddress,\n      staticPosition: staticPosition + consumed\n    });\n    consumed += consumed_;\n    value.push(data);\n  }\n  return [value, consumed];\n}\n/** @internal */\nexport function decodeBool(cursor) {\n  return [Bytes.toBoolean(cursor.readBytes(32), {\n    size: 32\n  }), 32];\n}\n/** @internal */\nexport function decodeBytes(cursor, param, {\n  staticPosition\n}) {\n  const [_, size] = param.type.split('bytes');\n  if (!size) {\n    // Dealing with dynamic types, so get the offset of the bytes data.\n    const offset = Bytes.toNumber(cursor.readBytes(32));\n    // Set position of the cursor to start of bytes data.\n    cursor.setPosition(staticPosition + offset);\n    const length = Bytes.toNumber(cursor.readBytes(32));\n    // If there is no length, we have zero data.\n    if (length === 0) {\n      // As we have gone wondering, restore to the original position + next slot.\n      cursor.setPosition(staticPosition + 32);\n      return ['0x', 32];\n    }\n    const data = cursor.readBytes(length);\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32);\n    return [Hex.fromBytes(data), 32];\n  }\n  const value = Hex.fromBytes(cursor.readBytes(Number.parseInt(size), 32));\n  return [value, 32];\n}\n/** @internal */\nexport function decodeNumber(cursor, param) {\n  const signed = param.type.startsWith('int');\n  const size = Number.parseInt(param.type.split('int')[1] || '256');\n  const value = cursor.readBytes(32);\n  return [size > 48 ? Bytes.toBigInt(value, {\n    signed\n  }) : Bytes.toNumber(value, {\n    signed\n  }), 32];\n}\n/** @internal */\nexport function decodeTuple(cursor, param, options) {\n  const {\n    checksumAddress,\n    staticPosition\n  } = options;\n  // Tuples can have unnamed components (i.e. they are arrays), so we must\n  // determine whether the tuple is named or unnamed. In the case of a named\n  // tuple, the value will be an object where each property is the name of the\n  // component. In the case of an unnamed tuple, the value will be an array.\n  const hasUnnamedChild = param.components.length === 0 || param.components.some(({\n    name\n  }) => !name);\n  // Initialize the value to an object or an array, depending on whether the\n  // tuple is named or unnamed.\n  const value = hasUnnamedChild ? [] : {};\n  let consumed = 0;\n  // If the tuple has a dynamic child, we must first decode the offset to the\n  // tuple data.\n  if (hasDynamicChild(param)) {\n    // Dealing with dynamic types, so get the offset of the tuple data.\n    const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset));\n    // Start is the static position of referencing slot + offset.\n    const start = staticPosition + offset;\n    for (let i = 0; i < param.components.length; ++i) {\n      const component = param.components[i];\n      cursor.setPosition(start + consumed);\n      const [data, consumed_] = decodeParameter(cursor, component, {\n        checksumAddress,\n        staticPosition: start\n      });\n      consumed += consumed_;\n      value[hasUnnamedChild ? i : component?.name] = data;\n    }\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32);\n    return [value, 32];\n  }\n  // If the tuple has static children, we can just decode each component\n  // in sequence.\n  for (let i = 0; i < param.components.length; ++i) {\n    const component = param.components[i];\n    const [data, consumed_] = decodeParameter(cursor, component, {\n      checksumAddress,\n      staticPosition\n    });\n    value[hasUnnamedChild ? i : component?.name] = data;\n    consumed += consumed_;\n  }\n  return [value, consumed];\n}\n/** @internal */\nexport function decodeString(cursor, {\n  staticPosition\n}) {\n  // Get offset to start of string data.\n  const offset = Bytes.toNumber(cursor.readBytes(32));\n  // Start is the static position of current slot + offset.\n  const start = staticPosition + offset;\n  cursor.setPosition(start);\n  const length = Bytes.toNumber(cursor.readBytes(32));\n  // If there is no length, we have zero data (empty string).\n  if (length === 0) {\n    cursor.setPosition(staticPosition + 32);\n    return ['', 32];\n  }\n  const data = cursor.readBytes(length, 32);\n  const value = Bytes.toString(Bytes.trimLeft(data));\n  // As we have gone wondering, restore to the original position + next slot.\n  cursor.setPosition(staticPosition + 32);\n  return [value, 32];\n}\n/** @internal */\nexport function prepareParameters({\n  checksumAddress,\n  parameters,\n  values\n}) {\n  const preparedParameters = [];\n  for (let i = 0; i < parameters.length; i++) {\n    preparedParameters.push(prepareParameter({\n      checksumAddress,\n      parameter: parameters[i],\n      value: values[i]\n    }));\n  }\n  return preparedParameters;\n}\n/** @internal */\nexport function prepareParameter({\n  checksumAddress = false,\n  parameter: parameter_,\n  value\n}) {\n  const parameter = parameter_;\n  const arrayComponents = getArrayComponents(parameter.type);\n  if (arrayComponents) {\n    const [length, type] = arrayComponents;\n    return encodeArray(value, {\n      checksumAddress,\n      length,\n      parameter: {\n        ...parameter,\n        type\n      }\n    });\n  }\n  if (parameter.type === 'tuple') {\n    return encodeTuple(value, {\n      checksumAddress,\n      parameter: parameter\n    });\n  }\n  if (parameter.type === 'address') {\n    return encodeAddress(value, {\n      checksum: checksumAddress\n    });\n  }\n  if (parameter.type === 'bool') {\n    return encodeBoolean(value);\n  }\n  if (parameter.type.startsWith('uint') || parameter.type.startsWith('int')) {\n    const signed = parameter.type.startsWith('int');\n    const [,, size = '256'] = integerRegex.exec(parameter.type) ?? [];\n    return encodeNumber(value, {\n      signed,\n      size: Number(size)\n    });\n  }\n  if (parameter.type.startsWith('bytes')) {\n    return encodeBytes(value, {\n      type: parameter.type\n    });\n  }\n  if (parameter.type === 'string') {\n    return encodeString(value);\n  }\n  throw new AbiParameters.InvalidTypeError(parameter.type);\n}\n/** @internal */\nexport function encode(preparedParameters) {\n  // 1. Compute the size of the static part of the parameters.\n  let staticSize = 0;\n  for (let i = 0; i < preparedParameters.length; i++) {\n    const {\n      dynamic,\n      encoded\n    } = preparedParameters[i];\n    if (dynamic) staticSize += 32;else staticSize += Hex.size(encoded);\n  }\n  // 2. Split the parameters into static and dynamic parts.\n  const staticParameters = [];\n  const dynamicParameters = [];\n  let dynamicSize = 0;\n  for (let i = 0; i < preparedParameters.length; i++) {\n    const {\n      dynamic,\n      encoded\n    } = preparedParameters[i];\n    if (dynamic) {\n      staticParameters.push(Hex.fromNumber(staticSize + dynamicSize, {\n        size: 32\n      }));\n      dynamicParameters.push(encoded);\n      dynamicSize += Hex.size(encoded);\n    } else {\n      staticParameters.push(encoded);\n    }\n  }\n  // 3. Concatenate static and dynamic parts.\n  return Hex.concat(...staticParameters, ...dynamicParameters);\n}\n/** @internal */\nexport function encodeAddress(value, options) {\n  const {\n    checksum = false\n  } = options;\n  Address.assert(value, {\n    strict: checksum\n  });\n  return {\n    dynamic: false,\n    encoded: Hex.padLeft(value.toLowerCase())\n  };\n}\n/** @internal */\nexport function encodeArray(value, options) {\n  const {\n    checksumAddress,\n    length,\n    parameter\n  } = options;\n  const dynamic = length === null;\n  if (!Array.isArray(value)) throw new AbiParameters.InvalidArrayError(value);\n  if (!dynamic && value.length !== length) throw new AbiParameters.ArrayLengthMismatchError({\n    expectedLength: length,\n    givenLength: value.length,\n    type: `${parameter.type}[${length}]`\n  });\n  let dynamicChild = false;\n  const preparedParameters = [];\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParameter({\n      checksumAddress,\n      parameter,\n      value: value[i]\n    });\n    if (preparedParam.dynamic) dynamicChild = true;\n    preparedParameters.push(preparedParam);\n  }\n  if (dynamic || dynamicChild) {\n    const data = encode(preparedParameters);\n    if (dynamic) {\n      const length = Hex.fromNumber(preparedParameters.length, {\n        size: 32\n      });\n      return {\n        dynamic: true,\n        encoded: preparedParameters.length > 0 ? Hex.concat(length, data) : length\n      };\n    }\n    if (dynamicChild) return {\n      dynamic: true,\n      encoded: data\n    };\n  }\n  return {\n    dynamic: false,\n    encoded: Hex.concat(...preparedParameters.map(({\n      encoded\n    }) => encoded))\n  };\n}\n/** @internal */\nexport function encodeBytes(value, {\n  type\n}) {\n  const [, parametersize] = type.split('bytes');\n  const bytesSize = Hex.size(value);\n  if (!parametersize) {\n    let value_ = value;\n    // If the size is not divisible by 32 bytes, pad the end\n    // with empty bytes to the ceiling 32 bytes.\n    if (bytesSize % 32 !== 0) value_ = Hex.padRight(value_, Math.ceil((value.length - 2) / 2 / 32) * 32);\n    return {\n      dynamic: true,\n      encoded: Hex.concat(Hex.padLeft(Hex.fromNumber(bytesSize, {\n        size: 32\n      })), value_)\n    };\n  }\n  if (bytesSize !== Number.parseInt(parametersize)) throw new AbiParameters.BytesSizeMismatchError({\n    expectedSize: Number.parseInt(parametersize),\n    value\n  });\n  return {\n    dynamic: false,\n    encoded: Hex.padRight(value)\n  };\n}\n/** @internal */\nexport function encodeBoolean(value) {\n  if (typeof value !== 'boolean') throw new Errors.BaseError(`Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`);\n  return {\n    dynamic: false,\n    encoded: Hex.padLeft(Hex.fromBoolean(value))\n  };\n}\n/** @internal */\nexport function encodeNumber(value, {\n  signed,\n  size\n}) {\n  if (typeof size === 'number') {\n    const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n;\n    const min = signed ? -max - 1n : 0n;\n    if (value > max || value < min) throw new Hex.IntegerOutOfRangeError({\n      max: max.toString(),\n      min: min.toString(),\n      signed,\n      size: size / 8,\n      value: value.toString()\n    });\n  }\n  return {\n    dynamic: false,\n    encoded: Hex.fromNumber(value, {\n      size: 32,\n      signed\n    })\n  };\n}\n/** @internal */\nexport function encodeString(value) {\n  const hexValue = Hex.fromString(value);\n  const partsLength = Math.ceil(Hex.size(hexValue) / 32);\n  const parts = [];\n  for (let i = 0; i < partsLength; i++) {\n    parts.push(Hex.padRight(Hex.slice(hexValue, i * 32, (i + 1) * 32)));\n  }\n  return {\n    dynamic: true,\n    encoded: Hex.concat(Hex.padRight(Hex.fromNumber(Hex.size(hexValue), {\n      size: 32\n    })), ...parts)\n  };\n}\n/** @internal */\nexport function encodeTuple(value, options) {\n  const {\n    checksumAddress,\n    parameter\n  } = options;\n  let dynamic = false;\n  const preparedParameters = [];\n  for (let i = 0; i < parameter.components.length; i++) {\n    const param_ = parameter.components[i];\n    const index = Array.isArray(value) ? i : param_.name;\n    const preparedParam = prepareParameter({\n      checksumAddress,\n      parameter: param_,\n      value: value[index]\n    });\n    preparedParameters.push(preparedParam);\n    if (preparedParam.dynamic) dynamic = true;\n  }\n  return {\n    dynamic,\n    encoded: dynamic ? encode(preparedParameters) : Hex.concat(...preparedParameters.map(({\n      encoded\n    }) => encoded))\n  };\n}\n/** @internal */\nexport function getArrayComponents(type) {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/);\n  return matches ?\n  // Return `null` if the array is dynamic.\n  [matches[2] ? Number(matches[2]) : null, matches[1]] : undefined;\n}\n/** @internal */\nexport function hasDynamicChild(param) {\n  const {\n    type\n  } = param;\n  if (type === 'string') return true;\n  if (type === 'bytes') return true;\n  if (type.endsWith('[]')) return true;\n  if (type === 'tuple') return param.components?.some(hasDynamicChild);\n  const arrayComponents = getArrayComponents(param.type);\n  if (arrayComponents && hasDynamicChild({\n    ...param,\n    type: arrayComponents[1]\n  })) return true;\n  return false;\n}\n//# sourceMappingURL=abiParameters.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}