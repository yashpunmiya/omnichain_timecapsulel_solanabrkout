{"ast":null,"code":"// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n\n'use strict';\n\n/* replacement start */\nconst process = require('process/');\n\n/* replacement end */\n\nconst {\n  AbortError,\n  codes\n} = require('../../ours/errors');\nconst {\n  ERR_INVALID_ARG_TYPE,\n  ERR_STREAM_PREMATURE_CLOSE\n} = codes;\nconst {\n  kEmptyObject,\n  once\n} = require('../../ours/util');\nconst {\n  validateAbortSignal,\n  validateFunction,\n  validateObject,\n  validateBoolean\n} = require('../validators');\nconst {\n  Promise,\n  PromisePrototypeThen,\n  SymbolDispose\n} = require('../../ours/primordials');\nconst {\n  isClosed,\n  isReadable,\n  isReadableNodeStream,\n  isReadableStream,\n  isReadableFinished,\n  isReadableErrored,\n  isWritable,\n  isWritableNodeStream,\n  isWritableStream,\n  isWritableFinished,\n  isWritableErrored,\n  isNodeStream,\n  willEmitClose: _willEmitClose,\n  kIsClosedPromise\n} = require('./utils');\nlet addAbortListener;\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\nconst nop = () => {};\nfunction eos(stream, options, callback) {\n  var _options$readable, _options$writable;\n  if (arguments.length === 2) {\n    callback = options;\n    options = kEmptyObject;\n  } else if (options == null) {\n    options = kEmptyObject;\n  } else {\n    validateObject(options, 'options');\n  }\n  validateFunction(callback, 'callback');\n  validateAbortSignal(options.signal, 'options.signal');\n  callback = once(callback);\n  if (isReadableStream(stream) || isWritableStream(stream)) {\n    return eosWeb(stream, options, callback);\n  }\n  if (!isNodeStream(stream)) {\n    throw new ERR_INVALID_ARG_TYPE('stream', ['ReadableStream', 'WritableStream', 'Stream'], stream);\n  }\n  const readable = (_options$readable = options.readable) !== null && _options$readable !== undefined ? _options$readable : isReadableNodeStream(stream);\n  const writable = (_options$writable = options.writable) !== null && _options$writable !== undefined ? _options$writable : isWritableNodeStream(stream);\n  const wState = stream._writableState;\n  const rState = stream._readableState;\n  const onlegacyfinish = () => {\n    if (!stream.writable) {\n      onfinish();\n    }\n  };\n\n  // TODO (ronag): Improve soft detection to include core modules and\n  // common ecosystem modules that do properly emit 'close' but fail\n  // this generic check.\n  let willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable;\n  let writableFinished = isWritableFinished(stream, false);\n  const onfinish = () => {\n    writableFinished = true;\n    // Stream should not be destroyed here. If it is that\n    // means that user space is doing something differently and\n    // we cannot trust willEmitClose.\n    if (stream.destroyed) {\n      willEmitClose = false;\n    }\n    if (willEmitClose && (!stream.readable || readable)) {\n      return;\n    }\n    if (!readable || readableFinished) {\n      callback.call(stream);\n    }\n  };\n  let readableFinished = isReadableFinished(stream, false);\n  const onend = () => {\n    readableFinished = true;\n    // Stream should not be destroyed here. If it is that\n    // means that user space is doing something differently and\n    // we cannot trust willEmitClose.\n    if (stream.destroyed) {\n      willEmitClose = false;\n    }\n    if (willEmitClose && (!stream.writable || writable)) {\n      return;\n    }\n    if (!writable || writableFinished) {\n      callback.call(stream);\n    }\n  };\n  const onerror = err => {\n    callback.call(stream, err);\n  };\n  let closed = isClosed(stream);\n  const onclose = () => {\n    closed = true;\n    const errored = isWritableErrored(stream) || isReadableErrored(stream);\n    if (errored && typeof errored !== 'boolean') {\n      return callback.call(stream, errored);\n    }\n    if (readable && !readableFinished && isReadableNodeStream(stream, true)) {\n      if (!isReadableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());\n    }\n    if (writable && !writableFinished) {\n      if (!isWritableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());\n    }\n    callback.call(stream);\n  };\n  const onclosed = () => {\n    closed = true;\n    const errored = isWritableErrored(stream) || isReadableErrored(stream);\n    if (errored && typeof errored !== 'boolean') {\n      return callback.call(stream, errored);\n    }\n    callback.call(stream);\n  };\n  const onrequest = () => {\n    stream.req.on('finish', onfinish);\n  };\n  if (isRequest(stream)) {\n    stream.on('complete', onfinish);\n    if (!willEmitClose) {\n      stream.on('abort', onclose);\n    }\n    if (stream.req) {\n      onrequest();\n    } else {\n      stream.on('request', onrequest);\n    }\n  } else if (writable && !wState) {\n    // legacy streams\n    stream.on('end', onlegacyfinish);\n    stream.on('close', onlegacyfinish);\n  }\n\n  // Not all streams will emit 'close' after 'aborted'.\n  if (!willEmitClose && typeof stream.aborted === 'boolean') {\n    stream.on('aborted', onclose);\n  }\n  stream.on('end', onend);\n  stream.on('finish', onfinish);\n  if (options.error !== false) {\n    stream.on('error', onerror);\n  }\n  stream.on('close', onclose);\n  if (closed) {\n    process.nextTick(onclose);\n  } else if (wState !== null && wState !== undefined && wState.errorEmitted || rState !== null && rState !== undefined && rState.errorEmitted) {\n    if (!willEmitClose) {\n      process.nextTick(onclosed);\n    }\n  } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === false)) {\n    process.nextTick(onclosed);\n  } else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === false)) {\n    process.nextTick(onclosed);\n  } else if (rState && stream.req && stream.aborted) {\n    process.nextTick(onclosed);\n  }\n  const cleanup = () => {\n    callback = nop;\n    stream.removeListener('aborted', onclose);\n    stream.removeListener('complete', onfinish);\n    stream.removeListener('abort', onclose);\n    stream.removeListener('request', onrequest);\n    if (stream.req) stream.req.removeListener('finish', onfinish);\n    stream.removeListener('end', onlegacyfinish);\n    stream.removeListener('close', onlegacyfinish);\n    stream.removeListener('finish', onfinish);\n    stream.removeListener('end', onend);\n    stream.removeListener('error', onerror);\n    stream.removeListener('close', onclose);\n  };\n  if (options.signal && !closed) {\n    const abort = () => {\n      // Keep it because cleanup removes it.\n      const endCallback = callback;\n      cleanup();\n      endCallback.call(stream, new AbortError(undefined, {\n        cause: options.signal.reason\n      }));\n    };\n    if (options.signal.aborted) {\n      process.nextTick(abort);\n    } else {\n      addAbortListener = addAbortListener || require('../../ours/util').addAbortListener;\n      const disposable = addAbortListener(options.signal, abort);\n      const originalCallback = callback;\n      callback = once((...args) => {\n        disposable[SymbolDispose]();\n        originalCallback.apply(stream, args);\n      });\n    }\n  }\n  return cleanup;\n}\nfunction eosWeb(stream, options, callback) {\n  let isAborted = false;\n  let abort = nop;\n  if (options.signal) {\n    abort = () => {\n      isAborted = true;\n      callback.call(stream, new AbortError(undefined, {\n        cause: options.signal.reason\n      }));\n    };\n    if (options.signal.aborted) {\n      process.nextTick(abort);\n    } else {\n      addAbortListener = addAbortListener || require('../../ours/util').addAbortListener;\n      const disposable = addAbortListener(options.signal, abort);\n      const originalCallback = callback;\n      callback = once((...args) => {\n        disposable[SymbolDispose]();\n        originalCallback.apply(stream, args);\n      });\n    }\n  }\n  const resolverFn = (...args) => {\n    if (!isAborted) {\n      process.nextTick(() => callback.apply(stream, args));\n    }\n  };\n  PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn);\n  return nop;\n}\nfunction finished(stream, opts) {\n  var _opts;\n  let autoCleanup = false;\n  if (opts === null) {\n    opts = kEmptyObject;\n  }\n  if ((_opts = opts) !== null && _opts !== undefined && _opts.cleanup) {\n    validateBoolean(opts.cleanup, 'cleanup');\n    autoCleanup = opts.cleanup;\n  }\n  return new Promise((resolve, reject) => {\n    const cleanup = eos(stream, opts, err => {\n      if (autoCleanup) {\n        cleanup();\n      }\n      if (err) {\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n  });\n}\nmodule.exports = eos;\nmodule.exports.finished = finished;","map":{"version":3,"names":["process","require","AbortError","codes","ERR_INVALID_ARG_TYPE","ERR_STREAM_PREMATURE_CLOSE","kEmptyObject","once","validateAbortSignal","validateFunction","validateObject","validateBoolean","Promise","PromisePrototypeThen","SymbolDispose","isClosed","isReadable","isReadableNodeStream","isReadableStream","isReadableFinished","isReadableErrored","isWritable","isWritableNodeStream","isWritableStream","isWritableFinished","isWritableErrored","isNodeStream","willEmitClose","_willEmitClose","kIsClosedPromise","addAbortListener","isRequest","stream","setHeader","abort","nop","eos","options","callback","_options$readable","_options$writable","arguments","length","signal","eosWeb","readable","undefined","writable","wState","_writableState","rState","_readableState","onlegacyfinish","onfinish","writableFinished","destroyed","readableFinished","call","onend","onerror","err","closed","onclose","errored","onclosed","onrequest","req","on","aborted","error","nextTick","errorEmitted","cleanup","removeListener","endCallback","cause","reason","disposable","originalCallback","args","apply","isAborted","resolverFn","promise","finished","opts","_opts","autoCleanup","resolve","reject","module","exports"],"sources":["C:/Users/yyash/Coding/solana-brkout/frontend/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"],"sourcesContent":["// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n\n'use strict'\n\n/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */\n\nconst { AbortError, codes } = require('../../ours/errors')\nconst { ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE } = codes\nconst { kEmptyObject, once } = require('../../ours/util')\nconst { validateAbortSignal, validateFunction, validateObject, validateBoolean } = require('../validators')\nconst { Promise, PromisePrototypeThen, SymbolDispose } = require('../../ours/primordials')\nconst {\n  isClosed,\n  isReadable,\n  isReadableNodeStream,\n  isReadableStream,\n  isReadableFinished,\n  isReadableErrored,\n  isWritable,\n  isWritableNodeStream,\n  isWritableStream,\n  isWritableFinished,\n  isWritableErrored,\n  isNodeStream,\n  willEmitClose: _willEmitClose,\n  kIsClosedPromise\n} = require('./utils')\nlet addAbortListener\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function'\n}\nconst nop = () => {}\nfunction eos(stream, options, callback) {\n  var _options$readable, _options$writable\n  if (arguments.length === 2) {\n    callback = options\n    options = kEmptyObject\n  } else if (options == null) {\n    options = kEmptyObject\n  } else {\n    validateObject(options, 'options')\n  }\n  validateFunction(callback, 'callback')\n  validateAbortSignal(options.signal, 'options.signal')\n  callback = once(callback)\n  if (isReadableStream(stream) || isWritableStream(stream)) {\n    return eosWeb(stream, options, callback)\n  }\n  if (!isNodeStream(stream)) {\n    throw new ERR_INVALID_ARG_TYPE('stream', ['ReadableStream', 'WritableStream', 'Stream'], stream)\n  }\n  const readable =\n    (_options$readable = options.readable) !== null && _options$readable !== undefined\n      ? _options$readable\n      : isReadableNodeStream(stream)\n  const writable =\n    (_options$writable = options.writable) !== null && _options$writable !== undefined\n      ? _options$writable\n      : isWritableNodeStream(stream)\n  const wState = stream._writableState\n  const rState = stream._readableState\n  const onlegacyfinish = () => {\n    if (!stream.writable) {\n      onfinish()\n    }\n  }\n\n  // TODO (ronag): Improve soft detection to include core modules and\n  // common ecosystem modules that do properly emit 'close' but fail\n  // this generic check.\n  let willEmitClose =\n    _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable\n  let writableFinished = isWritableFinished(stream, false)\n  const onfinish = () => {\n    writableFinished = true\n    // Stream should not be destroyed here. If it is that\n    // means that user space is doing something differently and\n    // we cannot trust willEmitClose.\n    if (stream.destroyed) {\n      willEmitClose = false\n    }\n    if (willEmitClose && (!stream.readable || readable)) {\n      return\n    }\n    if (!readable || readableFinished) {\n      callback.call(stream)\n    }\n  }\n  let readableFinished = isReadableFinished(stream, false)\n  const onend = () => {\n    readableFinished = true\n    // Stream should not be destroyed here. If it is that\n    // means that user space is doing something differently and\n    // we cannot trust willEmitClose.\n    if (stream.destroyed) {\n      willEmitClose = false\n    }\n    if (willEmitClose && (!stream.writable || writable)) {\n      return\n    }\n    if (!writable || writableFinished) {\n      callback.call(stream)\n    }\n  }\n  const onerror = (err) => {\n    callback.call(stream, err)\n  }\n  let closed = isClosed(stream)\n  const onclose = () => {\n    closed = true\n    const errored = isWritableErrored(stream) || isReadableErrored(stream)\n    if (errored && typeof errored !== 'boolean') {\n      return callback.call(stream, errored)\n    }\n    if (readable && !readableFinished && isReadableNodeStream(stream, true)) {\n      if (!isReadableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE())\n    }\n    if (writable && !writableFinished) {\n      if (!isWritableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE())\n    }\n    callback.call(stream)\n  }\n  const onclosed = () => {\n    closed = true\n    const errored = isWritableErrored(stream) || isReadableErrored(stream)\n    if (errored && typeof errored !== 'boolean') {\n      return callback.call(stream, errored)\n    }\n    callback.call(stream)\n  }\n  const onrequest = () => {\n    stream.req.on('finish', onfinish)\n  }\n  if (isRequest(stream)) {\n    stream.on('complete', onfinish)\n    if (!willEmitClose) {\n      stream.on('abort', onclose)\n    }\n    if (stream.req) {\n      onrequest()\n    } else {\n      stream.on('request', onrequest)\n    }\n  } else if (writable && !wState) {\n    // legacy streams\n    stream.on('end', onlegacyfinish)\n    stream.on('close', onlegacyfinish)\n  }\n\n  // Not all streams will emit 'close' after 'aborted'.\n  if (!willEmitClose && typeof stream.aborted === 'boolean') {\n    stream.on('aborted', onclose)\n  }\n  stream.on('end', onend)\n  stream.on('finish', onfinish)\n  if (options.error !== false) {\n    stream.on('error', onerror)\n  }\n  stream.on('close', onclose)\n  if (closed) {\n    process.nextTick(onclose)\n  } else if (\n    (wState !== null && wState !== undefined && wState.errorEmitted) ||\n    (rState !== null && rState !== undefined && rState.errorEmitted)\n  ) {\n    if (!willEmitClose) {\n      process.nextTick(onclosed)\n    }\n  } else if (\n    !readable &&\n    (!willEmitClose || isReadable(stream)) &&\n    (writableFinished || isWritable(stream) === false)\n  ) {\n    process.nextTick(onclosed)\n  } else if (\n    !writable &&\n    (!willEmitClose || isWritable(stream)) &&\n    (readableFinished || isReadable(stream) === false)\n  ) {\n    process.nextTick(onclosed)\n  } else if (rState && stream.req && stream.aborted) {\n    process.nextTick(onclosed)\n  }\n  const cleanup = () => {\n    callback = nop\n    stream.removeListener('aborted', onclose)\n    stream.removeListener('complete', onfinish)\n    stream.removeListener('abort', onclose)\n    stream.removeListener('request', onrequest)\n    if (stream.req) stream.req.removeListener('finish', onfinish)\n    stream.removeListener('end', onlegacyfinish)\n    stream.removeListener('close', onlegacyfinish)\n    stream.removeListener('finish', onfinish)\n    stream.removeListener('end', onend)\n    stream.removeListener('error', onerror)\n    stream.removeListener('close', onclose)\n  }\n  if (options.signal && !closed) {\n    const abort = () => {\n      // Keep it because cleanup removes it.\n      const endCallback = callback\n      cleanup()\n      endCallback.call(\n        stream,\n        new AbortError(undefined, {\n          cause: options.signal.reason\n        })\n      )\n    }\n    if (options.signal.aborted) {\n      process.nextTick(abort)\n    } else {\n      addAbortListener = addAbortListener || require('../../ours/util').addAbortListener\n      const disposable = addAbortListener(options.signal, abort)\n      const originalCallback = callback\n      callback = once((...args) => {\n        disposable[SymbolDispose]()\n        originalCallback.apply(stream, args)\n      })\n    }\n  }\n  return cleanup\n}\nfunction eosWeb(stream, options, callback) {\n  let isAborted = false\n  let abort = nop\n  if (options.signal) {\n    abort = () => {\n      isAborted = true\n      callback.call(\n        stream,\n        new AbortError(undefined, {\n          cause: options.signal.reason\n        })\n      )\n    }\n    if (options.signal.aborted) {\n      process.nextTick(abort)\n    } else {\n      addAbortListener = addAbortListener || require('../../ours/util').addAbortListener\n      const disposable = addAbortListener(options.signal, abort)\n      const originalCallback = callback\n      callback = once((...args) => {\n        disposable[SymbolDispose]()\n        originalCallback.apply(stream, args)\n      })\n    }\n  }\n  const resolverFn = (...args) => {\n    if (!isAborted) {\n      process.nextTick(() => callback.apply(stream, args))\n    }\n  }\n  PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn)\n  return nop\n}\nfunction finished(stream, opts) {\n  var _opts\n  let autoCleanup = false\n  if (opts === null) {\n    opts = kEmptyObject\n  }\n  if ((_opts = opts) !== null && _opts !== undefined && _opts.cleanup) {\n    validateBoolean(opts.cleanup, 'cleanup')\n    autoCleanup = opts.cleanup\n  }\n  return new Promise((resolve, reject) => {\n    const cleanup = eos(stream, opts, (err) => {\n      if (autoCleanup) {\n        cleanup()\n      }\n      if (err) {\n        reject(err)\n      } else {\n        resolve()\n      }\n    })\n  })\n}\nmodule.exports = eos\nmodule.exports.finished = finished\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}