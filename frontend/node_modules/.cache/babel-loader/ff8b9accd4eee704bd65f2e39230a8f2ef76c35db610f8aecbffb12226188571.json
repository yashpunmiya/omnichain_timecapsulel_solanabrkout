{"ast":null,"code":"import { proxy, subscribe as sub } from 'valtio/vanilla';\nimport { subscribeKey as subKey } from 'valtio/vanilla/utils';\nimport { NumberUtil } from '@reown/appkit-common';\nimport { ConstantsUtil as CommonConstantsUtil } from '@reown/appkit-common';\nimport { W3mFrameRpcConstants } from '@reown/appkit-wallet/utils';\nimport { ConstantsUtil } from '../utils/ConstantsUtil.js';\nimport { CoreHelperUtil } from '../utils/CoreHelperUtil.js';\nimport { SendApiUtil } from '../utils/SendApiUtil.js';\nimport { SwapApiUtil } from '../utils/SwapApiUtil.js';\nimport { SwapCalculationUtil } from '../utils/SwapCalculationUtil.js';\nimport { AccountController } from './AccountController.js';\nimport { AlertController } from './AlertController.js';\nimport { BlockchainApiController } from './BlockchainApiController.js';\nimport { ChainController } from './ChainController.js';\nimport { ConnectionController } from './ConnectionController.js';\nimport { ConnectorController } from './ConnectorController.js';\nimport { EventsController } from './EventsController.js';\nimport { RouterController } from './RouterController.js';\nimport { SnackController } from './SnackController.js';\n// -- Constants ---------------------------------------- //\nexport const INITIAL_GAS_LIMIT = 150000;\nexport const TO_AMOUNT_DECIMALS = 6;\nclass TransactionError extends Error {\n  constructor(message, shortMessage) {\n    super(message);\n    this.name = 'TransactionError';\n    this.shortMessage = shortMessage;\n  }\n}\n// -- State --------------------------------------------- //\nconst initialState = {\n  // Loading states\n  initializing: false,\n  initialized: false,\n  loadingPrices: false,\n  loadingQuote: false,\n  loadingApprovalTransaction: false,\n  loadingBuildTransaction: false,\n  loadingTransaction: false,\n  // Error states\n  fetchError: false,\n  // Approval & Swap transaction states\n  approvalTransaction: undefined,\n  swapTransaction: undefined,\n  transactionError: undefined,\n  // Input values\n  sourceToken: undefined,\n  sourceTokenAmount: '',\n  sourceTokenPriceInUSD: 0,\n  toToken: undefined,\n  toTokenAmount: '',\n  toTokenPriceInUSD: 0,\n  networkPrice: '0',\n  networkBalanceInUSD: '0',\n  networkTokenSymbol: '',\n  inputError: undefined,\n  // Request values\n  slippage: ConstantsUtil.CONVERT_SLIPPAGE_TOLERANCE,\n  // Tokens\n  tokens: undefined,\n  popularTokens: undefined,\n  suggestedTokens: undefined,\n  foundTokens: undefined,\n  myTokensWithBalance: undefined,\n  tokensPriceMap: {},\n  // Calculations\n  gasFee: '0',\n  gasPriceInUSD: 0,\n  priceImpact: undefined,\n  maxSlippage: undefined,\n  providerFee: undefined\n};\nconst state = proxy(initialState);\n// -- Controller ---------------------------------------- //\nexport const SwapController = {\n  state,\n  subscribe(callback) {\n    return sub(state, () => callback(state));\n  },\n  subscribeKey(key, callback) {\n    return subKey(state, key, callback);\n  },\n  getParams() {\n    const caipAddress = ChainController.state.activeCaipAddress;\n    const namespace = ChainController.state.activeChain;\n    const address = CoreHelperUtil.getPlainAddress(caipAddress);\n    const networkAddress = ChainController.getActiveNetworkTokenAddress();\n    const connectorId = ConnectorController.getConnectorId(namespace);\n    if (!address) {\n      throw new Error('No address found to swap the tokens from.');\n    }\n    const invalidToToken = !state.toToken?.address || !state.toToken?.decimals;\n    const invalidSourceToken = !state.sourceToken?.address || !state.sourceToken?.decimals || !NumberUtil.bigNumber(state.sourceTokenAmount).gt(0);\n    const invalidSourceTokenAmount = !state.sourceTokenAmount;\n    return {\n      networkAddress,\n      fromAddress: address,\n      fromCaipAddress: caipAddress,\n      sourceTokenAddress: state.sourceToken?.address,\n      toTokenAddress: state.toToken?.address,\n      toTokenAmount: state.toTokenAmount,\n      toTokenDecimals: state.toToken?.decimals,\n      sourceTokenAmount: state.sourceTokenAmount,\n      sourceTokenDecimals: state.sourceToken?.decimals,\n      invalidToToken,\n      invalidSourceToken,\n      invalidSourceTokenAmount,\n      availableToSwap: caipAddress && !invalidToToken && !invalidSourceToken && !invalidSourceTokenAmount,\n      isAuthConnector: connectorId === CommonConstantsUtil.CONNECTOR_ID.AUTH\n    };\n  },\n  setSourceToken(sourceToken) {\n    if (!sourceToken) {\n      state.sourceToken = sourceToken;\n      state.sourceTokenAmount = '';\n      state.sourceTokenPriceInUSD = 0;\n      return;\n    }\n    state.sourceToken = sourceToken;\n    this.setTokenPrice(sourceToken.address, 'sourceToken');\n  },\n  setSourceTokenAmount(amount) {\n    state.sourceTokenAmount = amount;\n  },\n  setToToken(toToken) {\n    if (!toToken) {\n      state.toToken = toToken;\n      state.toTokenAmount = '';\n      state.toTokenPriceInUSD = 0;\n      return;\n    }\n    state.toToken = toToken;\n    this.setTokenPrice(toToken.address, 'toToken');\n  },\n  setToTokenAmount(amount) {\n    state.toTokenAmount = amount ? NumberUtil.formatNumberToLocalString(amount, TO_AMOUNT_DECIMALS) : '';\n  },\n  async setTokenPrice(address, target) {\n    let price = state.tokensPriceMap[address] || 0;\n    if (!price) {\n      state.loadingPrices = true;\n      price = await this.getAddressPrice(address);\n    }\n    if (target === 'sourceToken') {\n      state.sourceTokenPriceInUSD = price;\n    } else if (target === 'toToken') {\n      state.toTokenPriceInUSD = price;\n    }\n    if (state.loadingPrices) {\n      state.loadingPrices = false;\n    }\n    if (this.getParams().availableToSwap) {\n      this.swapTokens();\n    }\n  },\n  switchTokens() {\n    if (state.initializing || !state.initialized) {\n      return;\n    }\n    const newSourceToken = state.toToken ? {\n      ...state.toToken\n    } : undefined;\n    const newToToken = state.sourceToken ? {\n      ...state.sourceToken\n    } : undefined;\n    const newSourceTokenAmount = newSourceToken && state.toTokenAmount === '' ? '1' : state.toTokenAmount;\n    this.setSourceToken(newSourceToken);\n    this.setToToken(newToToken);\n    this.setSourceTokenAmount(newSourceTokenAmount);\n    this.setToTokenAmount('');\n    this.swapTokens();\n  },\n  resetState() {\n    state.myTokensWithBalance = initialState.myTokensWithBalance;\n    state.tokensPriceMap = initialState.tokensPriceMap;\n    state.initialized = initialState.initialized;\n    state.sourceToken = initialState.sourceToken;\n    state.sourceTokenAmount = initialState.sourceTokenAmount;\n    state.sourceTokenPriceInUSD = initialState.sourceTokenPriceInUSD;\n    state.toToken = initialState.toToken;\n    state.toTokenAmount = initialState.toTokenAmount;\n    state.toTokenPriceInUSD = initialState.toTokenPriceInUSD;\n    state.networkPrice = initialState.networkPrice;\n    state.networkTokenSymbol = initialState.networkTokenSymbol;\n    state.networkBalanceInUSD = initialState.networkBalanceInUSD;\n    state.inputError = initialState.inputError;\n  },\n  resetValues() {\n    const {\n      networkAddress\n    } = this.getParams();\n    const networkToken = state.tokens?.find(token => token.address === networkAddress);\n    this.setSourceToken(networkToken);\n    this.setToToken(undefined);\n  },\n  getApprovalLoadingState() {\n    return state.loadingApprovalTransaction;\n  },\n  clearError() {\n    state.transactionError = undefined;\n  },\n  async initializeState() {\n    if (state.initializing) {\n      return;\n    }\n    state.initializing = true;\n    if (!state.initialized) {\n      try {\n        await this.fetchTokens();\n        state.initialized = true;\n      } catch (error) {\n        state.initialized = false;\n        SnackController.showError('Failed to initialize swap');\n        RouterController.goBack();\n      }\n    }\n    state.initializing = false;\n  },\n  async fetchTokens() {\n    const {\n      networkAddress\n    } = this.getParams();\n    await this.getTokenList();\n    await this.getNetworkTokenPrice();\n    await this.getMyTokensWithBalance();\n    const networkToken = state.tokens?.find(token => token.address === networkAddress);\n    if (networkToken) {\n      state.networkTokenSymbol = networkToken.symbol;\n      this.setSourceToken(networkToken);\n      this.setSourceTokenAmount('1');\n    }\n  },\n  async getTokenList() {\n    const tokens = await SwapApiUtil.getTokenList();\n    state.tokens = tokens;\n    state.popularTokens = tokens.sort((aTokenInfo, bTokenInfo) => {\n      if (aTokenInfo.symbol < bTokenInfo.symbol) {\n        return -1;\n      }\n      if (aTokenInfo.symbol > bTokenInfo.symbol) {\n        return 1;\n      }\n      return 0;\n    });\n    state.suggestedTokens = tokens.filter(token => {\n      if (ConstantsUtil.SWAP_SUGGESTED_TOKENS.includes(token.symbol)) {\n        return true;\n      }\n      return false;\n    }, {});\n  },\n  async getAddressPrice(address) {\n    const existPrice = state.tokensPriceMap[address];\n    if (existPrice) {\n      return existPrice;\n    }\n    const response = await BlockchainApiController.fetchTokenPrice({\n      addresses: [address]\n    });\n    const fungibles = response?.fungibles || [];\n    const allTokens = [...(state.tokens || []), ...(state.myTokensWithBalance || [])];\n    const symbol = allTokens?.find(token => token.address === address)?.symbol;\n    const price = fungibles.find(p => p.symbol.toLowerCase() === symbol?.toLowerCase())?.price || 0;\n    const priceAsFloat = parseFloat(price.toString());\n    state.tokensPriceMap[address] = priceAsFloat;\n    return priceAsFloat;\n  },\n  async getNetworkTokenPrice() {\n    const {\n      networkAddress\n    } = this.getParams();\n    const response = await BlockchainApiController.fetchTokenPrice({\n      addresses: [networkAddress]\n    }).catch(() => {\n      SnackController.showError('Failed to fetch network token price');\n      return {\n        fungibles: []\n      };\n    });\n    const token = response.fungibles?.[0];\n    const price = token?.price.toString() || '0';\n    state.tokensPriceMap[networkAddress] = parseFloat(price);\n    state.networkTokenSymbol = token?.symbol || '';\n    state.networkPrice = price;\n  },\n  async getMyTokensWithBalance(forceUpdate) {\n    const balances = await SendApiUtil.getMyTokensWithBalance(forceUpdate);\n    const swapBalances = SendApiUtil.mapBalancesToSwapTokens(balances);\n    if (!swapBalances) {\n      return;\n    }\n    await this.getInitialGasPrice();\n    this.setBalances(swapBalances);\n  },\n  setBalances(balances) {\n    const {\n      networkAddress\n    } = this.getParams();\n    const caipNetwork = ChainController.state.activeCaipNetwork;\n    if (!caipNetwork) {\n      return;\n    }\n    const networkToken = balances.find(token => token.address === networkAddress);\n    balances.forEach(token => {\n      state.tokensPriceMap[token.address] = token.price || 0;\n    });\n    state.myTokensWithBalance = balances.filter(token => token.address.startsWith(caipNetwork.caipNetworkId));\n    state.networkBalanceInUSD = networkToken ? NumberUtil.multiply(networkToken.quantity.numeric, networkToken.price).toString() : '0';\n  },\n  async getInitialGasPrice() {\n    const res = await SwapApiUtil.fetchGasPrice();\n    if (!res) {\n      return {\n        gasPrice: null,\n        gasPriceInUSD: null\n      };\n    }\n    switch (ChainController.state?.activeCaipNetwork?.chainNamespace) {\n      case 'solana':\n        state.gasFee = res.standard ?? '0';\n        state.gasPriceInUSD = NumberUtil.multiply(res.standard, state.networkPrice).div(1e9).toNumber();\n        return {\n          gasPrice: BigInt(state.gasFee),\n          gasPriceInUSD: Number(state.gasPriceInUSD)\n        };\n      case 'eip155':\n      default:\n        // eslint-disable-next-line no-case-declarations\n        const value = res.standard ?? '0';\n        // eslint-disable-next-line no-case-declarations\n        const gasFee = BigInt(value);\n        // eslint-disable-next-line no-case-declarations\n        const gasLimit = BigInt(INITIAL_GAS_LIMIT);\n        // eslint-disable-next-line no-case-declarations\n        const gasPrice = SwapCalculationUtil.getGasPriceInUSD(state.networkPrice, gasLimit, gasFee);\n        state.gasFee = value;\n        state.gasPriceInUSD = gasPrice;\n        return {\n          gasPrice: gasFee,\n          gasPriceInUSD: gasPrice\n        };\n    }\n  },\n  // -- Swap -------------------------------------- //\n  async swapTokens() {\n    const address = AccountController.state.address;\n    const sourceToken = state.sourceToken;\n    const toToken = state.toToken;\n    const haveSourceTokenAmount = NumberUtil.bigNumber(state.sourceTokenAmount).gt(0);\n    if (!haveSourceTokenAmount) {\n      this.setToTokenAmount('');\n    }\n    if (!toToken || !sourceToken || state.loadingPrices || !haveSourceTokenAmount) {\n      return;\n    }\n    state.loadingQuote = true;\n    const amountDecimal = NumberUtil.bigNumber(state.sourceTokenAmount).times(10 ** sourceToken.decimals).round(0);\n    try {\n      const quoteResponse = await BlockchainApiController.fetchSwapQuote({\n        userAddress: address,\n        from: sourceToken.address,\n        to: toToken.address,\n        gasPrice: state.gasFee,\n        amount: amountDecimal.toString()\n      });\n      state.loadingQuote = false;\n      const quoteToAmount = quoteResponse?.quotes?.[0]?.toAmount;\n      if (!quoteToAmount) {\n        AlertController.open({\n          shortMessage: 'Incorrect amount',\n          longMessage: 'Please enter a valid amount'\n        }, 'error');\n        return;\n      }\n      const toTokenAmount = NumberUtil.bigNumber(quoteToAmount).div(10 ** toToken.decimals).toString();\n      this.setToTokenAmount(toTokenAmount);\n      const isInsufficientToken = this.hasInsufficientToken(state.sourceTokenAmount, sourceToken.address);\n      if (isInsufficientToken) {\n        state.inputError = 'Insufficient balance';\n      } else {\n        state.inputError = undefined;\n        this.setTransactionDetails();\n      }\n    } catch (error) {\n      state.loadingQuote = false;\n      state.inputError = 'Insufficient balance';\n    }\n  },\n  // -- Create Transactions -------------------------------------- //\n  async getTransaction() {\n    const {\n      fromCaipAddress,\n      availableToSwap\n    } = this.getParams();\n    const sourceToken = state.sourceToken;\n    const toToken = state.toToken;\n    if (!fromCaipAddress || !availableToSwap || !sourceToken || !toToken || state.loadingQuote) {\n      return undefined;\n    }\n    try {\n      state.loadingBuildTransaction = true;\n      const hasAllowance = await SwapApiUtil.fetchSwapAllowance({\n        userAddress: fromCaipAddress,\n        tokenAddress: sourceToken.address,\n        sourceTokenAmount: state.sourceTokenAmount,\n        sourceTokenDecimals: sourceToken.decimals\n      });\n      let transaction = undefined;\n      if (hasAllowance) {\n        transaction = await this.createSwapTransaction();\n      } else {\n        transaction = await this.createAllowanceTransaction();\n      }\n      state.loadingBuildTransaction = false;\n      state.fetchError = false;\n      return transaction;\n    } catch (error) {\n      RouterController.goBack();\n      SnackController.showError('Failed to check allowance');\n      state.loadingBuildTransaction = false;\n      state.approvalTransaction = undefined;\n      state.swapTransaction = undefined;\n      state.fetchError = true;\n      return undefined;\n    }\n  },\n  async createAllowanceTransaction() {\n    const {\n      fromCaipAddress,\n      sourceTokenAddress,\n      fromAddress,\n      toTokenAddress\n    } = this.getParams();\n    if (!fromCaipAddress || !toTokenAddress) {\n      return undefined;\n    }\n    if (!sourceTokenAddress) {\n      throw new Error('createAllowanceTransaction - No source token address found.');\n    }\n    try {\n      const response = await BlockchainApiController.generateApproveCalldata({\n        from: sourceTokenAddress,\n        to: toTokenAddress,\n        userAddress: fromCaipAddress\n      });\n      const gasLimit = await ConnectionController.estimateGas({\n        chainNamespace: CommonConstantsUtil.CHAIN.EVM,\n        address: fromAddress,\n        to: CoreHelperUtil.getPlainAddress(response.tx.to),\n        data: response.tx.data\n      });\n      const transaction = {\n        data: response.tx.data,\n        to: CoreHelperUtil.getPlainAddress(response.tx.from),\n        gas: gasLimit,\n        gasPrice: BigInt(response.tx.eip155.gasPrice),\n        value: BigInt(response.tx.value),\n        toAmount: state.toTokenAmount\n      };\n      state.swapTransaction = undefined;\n      state.approvalTransaction = {\n        data: transaction.data,\n        to: transaction.to,\n        gas: transaction.gas ?? BigInt(0),\n        gasPrice: transaction.gasPrice,\n        value: transaction.value,\n        toAmount: transaction.toAmount\n      };\n      return {\n        data: transaction.data,\n        to: transaction.to,\n        gas: transaction.gas ?? BigInt(0),\n        gasPrice: transaction.gasPrice,\n        value: transaction.value,\n        toAmount: transaction.toAmount\n      };\n    } catch (error) {\n      RouterController.goBack();\n      SnackController.showError('Failed to create approval transaction');\n      state.approvalTransaction = undefined;\n      state.swapTransaction = undefined;\n      state.fetchError = true;\n      return undefined;\n    }\n  },\n  async createSwapTransaction() {\n    const {\n      networkAddress,\n      fromCaipAddress,\n      sourceTokenAmount\n    } = this.getParams();\n    const sourceToken = state.sourceToken;\n    const toToken = state.toToken;\n    if (!fromCaipAddress || !sourceTokenAmount || !sourceToken || !toToken) {\n      return undefined;\n    }\n    const amount = ConnectionController.parseUnits(sourceTokenAmount, sourceToken.decimals)?.toString();\n    try {\n      const response = await BlockchainApiController.generateSwapCalldata({\n        userAddress: fromCaipAddress,\n        from: sourceToken.address,\n        to: toToken.address,\n        amount: amount,\n        disableEstimate: true\n      });\n      const isSourceTokenIsNetworkToken = sourceToken.address === networkAddress;\n      const gas = BigInt(response.tx.eip155.gas);\n      const gasPrice = BigInt(response.tx.eip155.gasPrice);\n      const transaction = {\n        data: response.tx.data,\n        to: CoreHelperUtil.getPlainAddress(response.tx.to),\n        gas,\n        gasPrice,\n        value: isSourceTokenIsNetworkToken ? BigInt(amount ?? '0') : BigInt('0'),\n        toAmount: state.toTokenAmount\n      };\n      state.gasPriceInUSD = SwapCalculationUtil.getGasPriceInUSD(state.networkPrice, gas, gasPrice);\n      state.approvalTransaction = undefined;\n      state.swapTransaction = transaction;\n      return transaction;\n    } catch (error) {\n      RouterController.goBack();\n      SnackController.showError('Failed to create transaction');\n      state.approvalTransaction = undefined;\n      state.swapTransaction = undefined;\n      state.fetchError = true;\n      return undefined;\n    }\n  },\n  // -- Send Transactions --------------------------------- //\n  async sendTransactionForApproval(data) {\n    const {\n      fromAddress,\n      isAuthConnector\n    } = this.getParams();\n    state.loadingApprovalTransaction = true;\n    const approveLimitMessage = `Approve limit increase in your wallet`;\n    if (isAuthConnector) {\n      RouterController.pushTransactionStack({\n        view: null,\n        goBack: true,\n        onSuccess() {\n          SnackController.showLoading(approveLimitMessage);\n        }\n      });\n    } else {\n      SnackController.showLoading(approveLimitMessage);\n    }\n    try {\n      await ConnectionController.sendTransaction({\n        address: fromAddress,\n        to: data.to,\n        data: data.data,\n        value: data.value,\n        chainNamespace: 'eip155'\n      });\n      await this.swapTokens();\n      await this.getTransaction();\n      state.approvalTransaction = undefined;\n      state.loadingApprovalTransaction = false;\n    } catch (err) {\n      const error = err;\n      state.transactionError = error?.shortMessage;\n      state.loadingApprovalTransaction = false;\n      SnackController.showError(error?.shortMessage || 'Transaction error');\n      EventsController.sendEvent({\n        type: 'track',\n        event: 'SWAP_APPROVAL_ERROR',\n        properties: {\n          message: error?.shortMessage || error?.message || 'Unknown',\n          network: ChainController.state.activeCaipNetwork?.caipNetworkId || '',\n          swapFromToken: this.state.sourceToken?.symbol || '',\n          swapToToken: this.state.toToken?.symbol || '',\n          swapFromAmount: this.state.sourceTokenAmount || '',\n          swapToAmount: this.state.toTokenAmount || '',\n          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT\n        }\n      });\n    }\n  },\n  async sendTransactionForSwap(data) {\n    if (!data) {\n      return undefined;\n    }\n    const {\n      fromAddress,\n      toTokenAmount,\n      isAuthConnector\n    } = this.getParams();\n    state.loadingTransaction = true;\n    const snackbarPendingMessage = `Swapping ${state.sourceToken?.symbol} to ${NumberUtil.formatNumberToLocalString(toTokenAmount, 3)} ${state.toToken?.symbol}`;\n    const snackbarSuccessMessage = `Swapped ${state.sourceToken?.symbol} to ${NumberUtil.formatNumberToLocalString(toTokenAmount, 3)} ${state.toToken?.symbol}`;\n    if (isAuthConnector) {\n      RouterController.pushTransactionStack({\n        view: 'Account',\n        goBack: false,\n        onSuccess() {\n          SnackController.showLoading(snackbarPendingMessage);\n          SwapController.resetState();\n        }\n      });\n    } else {\n      SnackController.showLoading('Confirm transaction in your wallet');\n    }\n    try {\n      const forceUpdateAddresses = [state.sourceToken?.address, state.toToken?.address].join(',');\n      const transactionHash = await ConnectionController.sendTransaction({\n        address: fromAddress,\n        to: data.to,\n        data: data.data,\n        value: data.value,\n        chainNamespace: 'eip155'\n      });\n      state.loadingTransaction = false;\n      SnackController.showSuccess(snackbarSuccessMessage);\n      EventsController.sendEvent({\n        type: 'track',\n        event: 'SWAP_SUCCESS',\n        properties: {\n          network: ChainController.state.activeCaipNetwork?.caipNetworkId || '',\n          swapFromToken: this.state.sourceToken?.symbol || '',\n          swapToToken: this.state.toToken?.symbol || '',\n          swapFromAmount: this.state.sourceTokenAmount || '',\n          swapToAmount: this.state.toTokenAmount || '',\n          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT\n        }\n      });\n      SwapController.resetState();\n      if (!isAuthConnector) {\n        RouterController.replace('Account');\n      }\n      SwapController.getMyTokensWithBalance(forceUpdateAddresses);\n      return transactionHash;\n    } catch (err) {\n      const error = err;\n      state.transactionError = error?.shortMessage;\n      state.loadingTransaction = false;\n      SnackController.showError(error?.shortMessage || 'Transaction error');\n      EventsController.sendEvent({\n        type: 'track',\n        event: 'SWAP_ERROR',\n        properties: {\n          message: error?.shortMessage || error?.message || 'Unknown',\n          network: ChainController.state.activeCaipNetwork?.caipNetworkId || '',\n          swapFromToken: this.state.sourceToken?.symbol || '',\n          swapToToken: this.state.toToken?.symbol || '',\n          swapFromAmount: this.state.sourceTokenAmount || '',\n          swapToAmount: this.state.toTokenAmount || '',\n          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT\n        }\n      });\n      return undefined;\n    }\n  },\n  // -- Checks -------------------------------------------- //\n  hasInsufficientToken(sourceTokenAmount, sourceTokenAddress) {\n    const isInsufficientSourceTokenForSwap = SwapCalculationUtil.isInsufficientSourceTokenForSwap(sourceTokenAmount, sourceTokenAddress, state.myTokensWithBalance);\n    let insufficientNetworkTokenForGas = true;\n    if (AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT) {\n      // Smart Accounts may pay gas in any ERC20 token\n      insufficientNetworkTokenForGas = false;\n    } else {\n      insufficientNetworkTokenForGas = SwapCalculationUtil.isInsufficientNetworkTokenForGas(state.networkBalanceInUSD, state.gasPriceInUSD);\n    }\n    return insufficientNetworkTokenForGas || isInsufficientSourceTokenForSwap;\n  },\n  // -- Calculations -------------------------------------- //\n  setTransactionDetails() {\n    const {\n      toTokenAddress,\n      toTokenDecimals\n    } = this.getParams();\n    if (!toTokenAddress || !toTokenDecimals) {\n      return;\n    }\n    state.gasPriceInUSD = SwapCalculationUtil.getGasPriceInUSD(state.networkPrice, BigInt(state.gasFee), BigInt(INITIAL_GAS_LIMIT));\n    state.priceImpact = SwapCalculationUtil.getPriceImpact({\n      sourceTokenAmount: state.sourceTokenAmount,\n      sourceTokenPriceInUSD: state.sourceTokenPriceInUSD,\n      toTokenPriceInUSD: state.toTokenPriceInUSD,\n      toTokenAmount: state.toTokenAmount\n    });\n    state.maxSlippage = SwapCalculationUtil.getMaxSlippage(state.slippage, state.toTokenAmount);\n    state.providerFee = SwapCalculationUtil.getProviderFee(state.sourceTokenAmount);\n  }\n};\n//# sourceMappingURL=SwapController.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}