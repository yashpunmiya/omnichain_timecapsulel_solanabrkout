{"ast":null,"code":"import { hexToBytes } from '../encoding/toBytes.js';\nimport { bytesToHex } from '../encoding/toHex.js';\n/**\n * Compute the proofs for a list of blobs and their commitments.\n *\n * @example\n * ```ts\n * import {\n *   blobsToCommitments,\n *   toBlobs\n * } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = toBlobs({ data: '0x1234' })\n * const commitments = blobsToCommitments({ blobs, kzg })\n * const proofs = blobsToProofs({ blobs, commitments, kzg })\n * ```\n */\nexport function blobsToProofs(parameters) {\n  const {\n    kzg\n  } = parameters;\n  const to = parameters.to ?? (typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes');\n  const blobs = typeof parameters.blobs[0] === 'string' ? parameters.blobs.map(x => hexToBytes(x)) : parameters.blobs;\n  const commitments = typeof parameters.commitments[0] === 'string' ? parameters.commitments.map(x => hexToBytes(x)) : parameters.commitments;\n  const proofs = [];\n  for (let i = 0; i < blobs.length; i++) {\n    const blob = blobs[i];\n    const commitment = commitments[i];\n    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)));\n  }\n  return to === 'bytes' ? proofs : proofs.map(x => bytesToHex(x));\n}","map":{"version":3,"names":["hexToBytes","bytesToHex","blobsToProofs","parameters","kzg","to","blobs","map","x","commitments","proofs","i","length","blob","commitment","push","Uint8Array","from","computeBlobKzgProof"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@reown\\appkit\\node_modules\\@walletconnect\\utils\\node_modules\\viem\\utils\\blob\\blobsToProofs.ts"],"sourcesContent":["import type { ErrorType } from '../../errors/utils.js'\nimport type { Kzg } from '../../types/kzg.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type blobsToProofsParameters<\n  blobs extends readonly ByteArray[] | readonly Hex[],\n  commitments extends readonly ByteArray[] | readonly Hex[],\n  to extends To =\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n  ///\n  _blobsType =\n    | (blobs extends readonly Hex[] ? readonly Hex[] : never)\n    | (blobs extends readonly ByteArray[] ? readonly ByteArray[] : never),\n> = {\n  /** Blobs to transform into proofs. */\n  blobs: blobs\n  /** Commitments for the blobs. */\n  commitments: commitments &\n    (commitments extends _blobsType\n      ? {}\n      : `commitments must be the same type as blobs`)\n  /** KZG implementation. */\n  kzg: Pick<Kzg, 'computeBlobKzgProof'>\n  /** Return type. */\n  to?: to | To | undefined\n}\n\nexport type blobsToProofsReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray[] : never)\n  | (to extends 'hex' ? Hex[] : never)\n\nexport type blobsToProofsErrorType =\n  | BytesToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\n/**\n * Compute the proofs for a list of blobs and their commitments.\n *\n * @example\n * ```ts\n * import {\n *   blobsToCommitments,\n *   toBlobs\n * } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = toBlobs({ data: '0x1234' })\n * const commitments = blobsToCommitments({ blobs, kzg })\n * const proofs = blobsToProofs({ blobs, commitments, kzg })\n * ```\n */\nexport function blobsToProofs<\n  const blobs extends readonly ByteArray[] | readonly Hex[],\n  const commitments extends readonly ByteArray[] | readonly Hex[],\n  to extends To =\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n>(\n  parameters: blobsToProofsParameters<blobs, commitments, to>,\n): blobsToProofsReturnType<to> {\n  const { kzg } = parameters\n\n  const to =\n    parameters.to ?? (typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes')\n\n  const blobs = (\n    typeof parameters.blobs[0] === 'string'\n      ? parameters.blobs.map((x) => hexToBytes(x as any))\n      : parameters.blobs\n  ) as ByteArray[]\n  const commitments = (\n    typeof parameters.commitments[0] === 'string'\n      ? parameters.commitments.map((x) => hexToBytes(x as any))\n      : parameters.commitments\n  ) as ByteArray[]\n\n  const proofs: ByteArray[] = []\n  for (let i = 0; i < blobs.length; i++) {\n    const blob = blobs[i]\n    const commitment = commitments[i]\n    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)))\n  }\n\n  return (to === 'bytes'\n    ? proofs\n    : proofs.map((x) => bytesToHex(x))) as {} as blobsToProofsReturnType<to>\n}\n"],"mappings":"AAGA,SAAmCA,UAAU,QAAQ,wBAAwB;AAC7E,SAAmCC,UAAU,QAAQ,sBAAsB;AAqC3E;;;;;;;;;;;;;;;;AAgBA,OAAM,SAAUC,aAAaA,CAO3BC,UAA2D;EAE3D,MAAM;IAAEC;EAAG,CAAE,GAAGD,UAAU;EAE1B,MAAME,EAAE,GACNF,UAAU,CAACE,EAAE,KAAK,OAAOF,UAAU,CAACG,KAAK,CAAC,CAAC,CAAC,KAAK,QAAQ,GAAG,KAAK,GAAG,OAAO,CAAC;EAE9E,MAAMA,KAAK,GACT,OAAOH,UAAU,CAACG,KAAK,CAAC,CAAC,CAAC,KAAK,QAAQ,GACnCH,UAAU,CAACG,KAAK,CAACC,GAAG,CAAEC,CAAC,IAAKR,UAAU,CAACQ,CAAQ,CAAC,CAAC,GACjDL,UAAU,CAACG,KACD;EAChB,MAAMG,WAAW,GACf,OAAON,UAAU,CAACM,WAAW,CAAC,CAAC,CAAC,KAAK,QAAQ,GACzCN,UAAU,CAACM,WAAW,CAACF,GAAG,CAAEC,CAAC,IAAKR,UAAU,CAACQ,CAAQ,CAAC,CAAC,GACvDL,UAAU,CAACM,WACD;EAEhB,MAAMC,MAAM,GAAgB,EAAE;EAC9B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,KAAK,CAACM,MAAM,EAAED,CAAC,EAAE,EAAE;IACrC,MAAME,IAAI,GAAGP,KAAK,CAACK,CAAC,CAAC;IACrB,MAAMG,UAAU,GAAGL,WAAW,CAACE,CAAC,CAAC;IACjCD,MAAM,CAACK,IAAI,CAACC,UAAU,CAACC,IAAI,CAACb,GAAG,CAACc,mBAAmB,CAACL,IAAI,EAAEC,UAAU,CAAC,CAAC,CAAC;EACzE;EAEA,OAAQT,EAAE,KAAK,OAAO,GAClBK,MAAM,GACNA,MAAM,CAACH,GAAG,CAAEC,CAAC,IAAKP,UAAU,CAACO,CAAC,CAAC,CAAC;AACtC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}