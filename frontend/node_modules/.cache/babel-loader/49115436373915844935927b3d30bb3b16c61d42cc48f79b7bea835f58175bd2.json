{"ast":null,"code":"import { solidityError, solidityPanic } from '../../constants/solidity.js';\nimport { AbiDecodingZeroDataError, AbiErrorSignatureNotFoundError } from '../../errors/abi.js';\nimport { slice } from '../data/slice.js';\nimport { toFunctionSelector } from '../hash/toFunctionSelector.js';\nimport { decodeAbiParameters } from './decodeAbiParameters.js';\nimport { formatAbiItem } from './formatAbiItem.js';\nexport function decodeErrorResult(parameters) {\n  const {\n    abi,\n    data\n  } = parameters;\n  const signature = slice(data, 0, 4);\n  if (signature === '0x') throw new AbiDecodingZeroDataError();\n  const abi_ = [...(abi || []), solidityError, solidityPanic];\n  const abiItem = abi_.find(x => x.type === 'error' && signature === toFunctionSelector(formatAbiItem(x)));\n  if (!abiItem) throw new AbiErrorSignatureNotFoundError(signature, {\n    docsPath: '/docs/contract/decodeErrorResult'\n  });\n  return {\n    abiItem,\n    args: 'inputs' in abiItem && abiItem.inputs && abiItem.inputs.length > 0 ? decodeAbiParameters(abiItem.inputs, slice(data, 4)) : undefined,\n    errorName: abiItem.name\n  };\n}","map":{"version":3,"names":["solidityError","solidityPanic","AbiDecodingZeroDataError","AbiErrorSignatureNotFoundError","slice","toFunctionSelector","decodeAbiParameters","formatAbiItem","decodeErrorResult","parameters","abi","data","signature","abi_","abiItem","find","x","type","docsPath","args","inputs","length","undefined","errorName","name"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\utils\\node_modules\\viem\\utils\\abi\\decodeErrorResult.ts"],"sourcesContent":["import type { Abi, ExtractAbiError } from 'abitype'\n\nimport { solidityError, solidityPanic } from '../../constants/solidity.js'\nimport {\n  AbiDecodingZeroDataError,\n  type AbiDecodingZeroDataErrorType,\n  AbiErrorSignatureNotFoundError,\n  type AbiErrorSignatureNotFoundErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  AbiItem,\n  ContractErrorArgs,\n  ContractErrorName,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { IsNarrowable, UnionEvaluate } from '../../types/utils.js'\nimport { slice } from '../data/slice.js'\nimport {\n  type ToFunctionSelectorErrorType,\n  toFunctionSelector,\n} from '../hash/toFunctionSelector.js'\nimport {\n  type DecodeAbiParametersErrorType,\n  decodeAbiParameters,\n} from './decodeAbiParameters.js'\nimport { type FormatAbiItemErrorType, formatAbiItem } from './formatAbiItem.js'\n\nexport type DecodeErrorResultParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n> = { abi?: abi | undefined; data: Hex }\n\nexport type DecodeErrorResultReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  ///\n  allErrorNames extends ContractErrorName<abi> = ContractErrorName<abi>,\n> = IsNarrowable<abi, Abi> extends true\n  ? UnionEvaluate<\n      {\n        [errorName in allErrorNames]: {\n          abiItem: abi extends Abi\n            ? Abi extends abi\n              ? AbiItem\n              : ExtractAbiError<abi, errorName>\n            : AbiItem\n          args: ContractErrorArgs<abi, errorName>\n          errorName: errorName\n        }\n      }[allErrorNames]\n    >\n  : {\n      abiItem: AbiItem\n      args: readonly unknown[] | undefined\n      errorName: string\n    }\n\nexport type DecodeErrorResultErrorType =\n  | AbiDecodingZeroDataErrorType\n  | AbiErrorSignatureNotFoundErrorType\n  | DecodeAbiParametersErrorType\n  | FormatAbiItemErrorType\n  | ToFunctionSelectorErrorType\n  | ErrorType\n\nexport function decodeErrorResult<const abi extends Abi | readonly unknown[]>(\n  parameters: DecodeErrorResultParameters<abi>,\n): DecodeErrorResultReturnType<abi> {\n  const { abi, data } = parameters as DecodeErrorResultParameters\n\n  const signature = slice(data, 0, 4)\n  if (signature === '0x') throw new AbiDecodingZeroDataError()\n\n  const abi_ = [...(abi || []), solidityError, solidityPanic]\n  const abiItem = abi_.find(\n    (x) =>\n      x.type === 'error' && signature === toFunctionSelector(formatAbiItem(x)),\n  )\n  if (!abiItem)\n    throw new AbiErrorSignatureNotFoundError(signature, {\n      docsPath: '/docs/contract/decodeErrorResult',\n    })\n  return {\n    abiItem,\n    args:\n      'inputs' in abiItem && abiItem.inputs && abiItem.inputs.length > 0\n        ? decodeAbiParameters(abiItem.inputs, slice(data, 4))\n        : undefined,\n    errorName: (abiItem as { name: string }).name,\n  } as DecodeErrorResultReturnType<abi>\n}\n"],"mappings":"AAEA,SAASA,aAAa,EAAEC,aAAa,QAAQ,6BAA6B;AAC1E,SACEC,wBAAwB,EAExBC,8BAA8B,QAEzB,qBAAqB;AAS5B,SAASC,KAAK,QAAQ,kBAAkB;AACxC,SAEEC,kBAAkB,QACb,+BAA+B;AACtC,SAEEC,mBAAmB,QACd,0BAA0B;AACjC,SAAsCC,aAAa,QAAQ,oBAAoB;AAsC/E,OAAM,SAAUC,iBAAiBA,CAC/BC,UAA4C;EAE5C,MAAM;IAAEC,GAAG;IAAEC;EAAI,CAAE,GAAGF,UAAyC;EAE/D,MAAMG,SAAS,GAAGR,KAAK,CAACO,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC;EACnC,IAAIC,SAAS,KAAK,IAAI,EAAE,MAAM,IAAIV,wBAAwB,EAAE;EAE5D,MAAMW,IAAI,GAAG,CAAC,IAAIH,GAAG,IAAI,EAAE,CAAC,EAAEV,aAAa,EAAEC,aAAa,CAAC;EAC3D,MAAMa,OAAO,GAAGD,IAAI,CAACE,IAAI,CACtBC,CAAC,IACAA,CAAC,CAACC,IAAI,KAAK,OAAO,IAAIL,SAAS,KAAKP,kBAAkB,CAACE,aAAa,CAACS,CAAC,CAAC,CAAC,CAC3E;EACD,IAAI,CAACF,OAAO,EACV,MAAM,IAAIX,8BAA8B,CAACS,SAAS,EAAE;IAClDM,QAAQ,EAAE;GACX,CAAC;EACJ,OAAO;IACLJ,OAAO;IACPK,IAAI,EACF,QAAQ,IAAIL,OAAO,IAAIA,OAAO,CAACM,MAAM,IAAIN,OAAO,CAACM,MAAM,CAACC,MAAM,GAAG,CAAC,GAC9Df,mBAAmB,CAACQ,OAAO,CAACM,MAAM,EAAEhB,KAAK,CAACO,IAAI,EAAE,CAAC,CAAC,CAAC,GACnDW,SAAS;IACfC,SAAS,EAAGT,OAA4B,CAACU;GACN;AACvC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}