{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CloneType = exports.Optional = exports.Type = void 0;\nexports.Validate = Validate;\nexports.Assert = Assert;\nexports.AssertWeak = AssertWeak;\nconst typebox_1 = require(\"@sinclair/typebox\");\nObject.defineProperty(exports, \"CloneType\", {\n  enumerable: true,\n  get: function () {\n    return typebox_1.CloneType;\n  }\n});\nObject.defineProperty(exports, \"Optional\", {\n  enumerable: true,\n  get: function () {\n    return typebox_1.Optional;\n  }\n});\nconst errors_1 = require(\"@sinclair/typebox/errors\");\nconst ts_mixer_1 = require(\"ts-mixer\");\nconst custom_types_1 = require(\"./custom-types\");\nconst errors_2 = require(\"./errors\");\nconst utils_1 = require(\"./utils\");\nclass CustomTypeBuilder extends (0, ts_mixer_1.Mixin)(typebox_1.JavaScriptTypeBuilder, custom_types_1.ArrayBufferBuilder, custom_types_1.BufferBuilder, custom_types_1.KeyofEnumBuilder, custom_types_1.UintBuilder) {}\nfunction Validate(schema, value) {\n  try {\n    Assert(schema, value);\n    return true;\n  } catch {\n    return false;\n  }\n}\nfunction FindErrorInUnion(error) {\n  const currentValue = error.value;\n  const unionMembers = error.schema.anyOf;\n  const hasValidMember = unionMembers.find(unionSchema => Validate(unionSchema, currentValue));\n  if (!hasValidMember) {\n    const possibleMatchesByLiterals = unionMembers.filter(unionSchema => {\n      if (unionSchema[typebox_1.Kind] !== 'Object') return false;\n      return !Object.entries(unionSchema.properties).find(([property, propertySchema]) => propertySchema.const && propertySchema.const !== currentValue[property]);\n    });\n    if (possibleMatchesByLiterals.length === 1) {\n      Assert(possibleMatchesByLiterals[0], currentValue);\n    } else if (possibleMatchesByLiterals.length > 1) {\n      const errorsOfPossibleMatches = possibleMatchesByLiterals.map(matchSchema => ({\n        schema: matchSchema,\n        errors: [...(0, errors_1.Errors)(matchSchema, currentValue)]\n      }));\n      const sortedErrors = errorsOfPossibleMatches.sort((a, b) => a.errors.length - b.errors.length);\n      const [bestMatch] = sortedErrors;\n      Assert(bestMatch.schema, currentValue);\n    }\n    throw new errors_2.InvalidParameter(error.message, error.path, error.type, error.value);\n  }\n}\nfunction Assert(schema, value) {\n  const errors = [...(0, errors_1.Errors)(schema, value)];\n  let [error] = errors;\n  while (error) {\n    if (error.path === '/' && errors.length > 1) {} else if (error.value == null && error.schema[typebox_1.OptionalKind] === 'Optional') {} else if (error.type === errors_1.ValueErrorType.Union) {\n      FindErrorInUnion(error);\n    } else if (error.type === errors_1.ValueErrorType.Number && typeof error.value === 'string') {\n      const currentValue = error.value;\n      const parsedNumber = Number(currentValue);\n      if (!Number.isNaN(parsedNumber) && currentValue === parsedNumber.toString()) {\n        const pathParts = error.path.slice(1).split('/');\n        (0, utils_1.setDeepValue)(value, pathParts, parsedNumber);\n      } else {\n        throw new errors_2.InvalidParameter(error.message, error.path, error.type, error.value);\n      }\n    } else {\n      throw new errors_2.InvalidParameter(error.message, error.path, error.type, error.value);\n    }\n    errors.shift();\n    [error] = errors;\n  }\n}\nfunction AssertWeak(schema, value) {\n  try {\n    Assert(schema, value);\n  } catch (e) {\n    if (e instanceof errors_2.InvalidParameter) {\n      if (e.type === errors_1.ValueErrorType.ObjectRequiredProperty) {\n        throw e;\n      }\n      console.warn('Method params validation failed', e);\n    } else {\n      throw e;\n    }\n  }\n}\nexports.Type = new CustomTypeBuilder();\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}