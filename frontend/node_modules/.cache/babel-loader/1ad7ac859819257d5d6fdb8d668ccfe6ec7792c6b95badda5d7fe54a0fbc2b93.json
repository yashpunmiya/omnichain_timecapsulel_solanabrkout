{"ast":null,"code":"import { BaseError } from '../../errors/base.js';\nimport { isHex } from '../data/isHex.js';\nimport { pad } from '../data/pad.js';\nimport { assertSize } from './fromHex.js';\nimport { numberToHex } from './toHex.js';\nconst encoder = /*#__PURE__*/new TextEncoder();\n/**\n * Encodes a UTF-8 string, hex value, bigint, number or boolean to a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes\n * - Example: https://viem.sh/docs/utilities/toBytes#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes('Hello world')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function toBytes(value, opts = {}) {\n  if (typeof value === 'number' || typeof value === 'bigint') return numberToBytes(value, opts);\n  if (typeof value === 'boolean') return boolToBytes(value, opts);\n  if (isHex(value)) return hexToBytes(value, opts);\n  return stringToBytes(value, opts);\n}\n/**\n * Encodes a boolean into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#booltobytes\n *\n * @param value Boolean value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true)\n * // Uint8Array([1])\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true, { size: 32 })\n * // Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n */\nexport function boolToBytes(value, opts = {}) {\n  const bytes = new Uint8Array(1);\n  bytes[0] = Number(value);\n  if (typeof opts.size === 'number') {\n    assertSize(bytes, {\n      size: opts.size\n    });\n    return pad(bytes, {\n      size: opts.size\n    });\n  }\n  return bytes;\n}\n// We use very optimized technique to convert hex string to byte array\nconst charCodeMap = {\n  zero: 48,\n  nine: 57,\n  A: 65,\n  F: 70,\n  a: 97,\n  f: 102\n};\nfunction charCodeToBase16(char) {\n  if (char >= charCodeMap.zero && char <= charCodeMap.nine) return char - charCodeMap.zero;\n  if (char >= charCodeMap.A && char <= charCodeMap.F) return char - (charCodeMap.A - 10);\n  if (char >= charCodeMap.a && char <= charCodeMap.f) return char - (charCodeMap.a - 10);\n  return undefined;\n}\n/**\n * Encodes a hex string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#hextobytes\n *\n * @param hex Hex string to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function hexToBytes(hex_, opts = {}) {\n  let hex = hex_;\n  if (opts.size) {\n    assertSize(hex, {\n      size: opts.size\n    });\n    hex = pad(hex, {\n      dir: 'right',\n      size: opts.size\n    });\n  }\n  let hexString = hex.slice(2);\n  if (hexString.length % 2) hexString = `0${hexString}`;\n  const length = hexString.length / 2;\n  const bytes = new Uint8Array(length);\n  for (let index = 0, j = 0; index < length; index++) {\n    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));\n    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));\n    if (nibbleLeft === undefined || nibbleRight === undefined) {\n      throw new BaseError(`Invalid byte sequence (\"${hexString[j - 2]}${hexString[j - 1]}\" in \"${hexString}\").`);\n    }\n    bytes[index] = nibbleLeft * 16 + nibbleRight;\n  }\n  return bytes;\n}\n/**\n * Encodes a number into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#numbertobytes\n *\n * @param value Number to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function numberToBytes(value, opts) {\n  const hex = numberToHex(value, opts);\n  return hexToBytes(hex);\n}\n/**\n * Encodes a UTF-8 string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#stringtobytes\n *\n * @param value String to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function stringToBytes(value, opts = {}) {\n  const bytes = encoder.encode(value);\n  if (typeof opts.size === 'number') {\n    assertSize(bytes, {\n      size: opts.size\n    });\n    return pad(bytes, {\n      dir: 'right',\n      size: opts.size\n    });\n  }\n  return bytes;\n}","map":{"version":3,"names":["BaseError","isHex","pad","assertSize","numberToHex","encoder","TextEncoder","toBytes","value","opts","numberToBytes","boolToBytes","hexToBytes","stringToBytes","bytes","Uint8Array","Number","size","charCodeMap","zero","nine","A","F","a","f","charCodeToBase16","char","undefined","hex_","hex","dir","hexString","slice","length","index","j","nibbleLeft","charCodeAt","nibbleRight","encode"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@reown\\appkit\\node_modules\\@walletconnect\\utils\\node_modules\\viem\\utils\\encoding\\toBytes.ts"],"sourcesContent":["import { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type PadErrorType, pad } from '../data/pad.js'\n\nimport { type AssertSizeErrorType, assertSize } from './fromHex.js'\nimport {\n  type NumberToHexErrorType,\n  type NumberToHexOpts,\n  numberToHex,\n} from './toHex.js'\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\n\nexport type ToBytesParameters = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type ToBytesErrorType =\n  | NumberToBytesErrorType\n  | BoolToBytesErrorType\n  | HexToBytesErrorType\n  | StringToBytesErrorType\n  | IsHexErrorType\n  | ErrorType\n\n/**\n * Encodes a UTF-8 string, hex value, bigint, number or boolean to a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes\n * - Example: https://viem.sh/docs/utilities/toBytes#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes('Hello world')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function toBytes(\n  value: string | bigint | number | boolean | Hex,\n  opts: ToBytesParameters = {},\n): ByteArray {\n  if (typeof value === 'number' || typeof value === 'bigint')\n    return numberToBytes(value, opts)\n  if (typeof value === 'boolean') return boolToBytes(value, opts)\n  if (isHex(value)) return hexToBytes(value, opts)\n  return stringToBytes(value, opts)\n}\n\nexport type BoolToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type BoolToBytesErrorType =\n  | AssertSizeErrorType\n  | PadErrorType\n  | ErrorType\n\n/**\n * Encodes a boolean into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#booltobytes\n *\n * @param value Boolean value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true)\n * // Uint8Array([1])\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true, { size: 32 })\n * // Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n */\nexport function boolToBytes(value: boolean, opts: BoolToBytesOpts = {}) {\n  const bytes = new Uint8Array(1)\n  bytes[0] = Number(value)\n  if (typeof opts.size === 'number') {\n    assertSize(bytes, { size: opts.size })\n    return pad(bytes, { size: opts.size })\n  }\n  return bytes\n}\n\n// We use very optimized technique to convert hex string to byte array\nconst charCodeMap = {\n  zero: 48,\n  nine: 57,\n  A: 65,\n  F: 70,\n  a: 97,\n  f: 102,\n} as const\n\nfunction charCodeToBase16(char: number) {\n  if (char >= charCodeMap.zero && char <= charCodeMap.nine)\n    return char - charCodeMap.zero\n  if (char >= charCodeMap.A && char <= charCodeMap.F)\n    return char - (charCodeMap.A - 10)\n  if (char >= charCodeMap.a && char <= charCodeMap.f)\n    return char - (charCodeMap.a - 10)\n  return undefined\n}\n\nexport type HexToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type HexToBytesErrorType = AssertSizeErrorType | PadErrorType | ErrorType\n\n/**\n * Encodes a hex string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#hextobytes\n *\n * @param hex Hex string to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function hexToBytes(hex_: Hex, opts: HexToBytesOpts = {}): ByteArray {\n  let hex = hex_\n  if (opts.size) {\n    assertSize(hex, { size: opts.size })\n    hex = pad(hex, { dir: 'right', size: opts.size })\n  }\n\n  let hexString = hex.slice(2) as string\n  if (hexString.length % 2) hexString = `0${hexString}`\n\n  const length = hexString.length / 2\n  const bytes = new Uint8Array(length)\n  for (let index = 0, j = 0; index < length; index++) {\n    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++))\n    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++))\n    if (nibbleLeft === undefined || nibbleRight === undefined) {\n      throw new BaseError(\n        `Invalid byte sequence (\"${hexString[j - 2]}${\n          hexString[j - 1]\n        }\" in \"${hexString}\").`,\n      )\n    }\n    bytes[index] = nibbleLeft * 16 + nibbleRight\n  }\n  return bytes\n}\n\nexport type NumberToBytesErrorType =\n  | NumberToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\n/**\n * Encodes a number into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#numbertobytes\n *\n * @param value Number to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function numberToBytes(\n  value: bigint | number,\n  opts?: NumberToHexOpts | undefined,\n) {\n  const hex = numberToHex(value, opts)\n  return hexToBytes(hex)\n}\n\nexport type StringToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type StringToBytesErrorType =\n  | AssertSizeErrorType\n  | PadErrorType\n  | ErrorType\n\n/**\n * Encodes a UTF-8 string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#stringtobytes\n *\n * @param value String to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function stringToBytes(\n  value: string,\n  opts: StringToBytesOpts = {},\n): ByteArray {\n  const bytes = encoder.encode(value)\n  if (typeof opts.size === 'number') {\n    assertSize(bytes, { size: opts.size })\n    return pad(bytes, { dir: 'right', size: opts.size })\n  }\n  return bytes\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}