{"ast":null,"code":"import { WalletConnectionError, isVersionedTransaction } from '@solana/wallet-adapter-base';\nimport { PublicKey, Transaction, VersionedTransaction } from '@solana/web3.js';\nimport { UniversalProvider } from '@walletconnect/universal-provider';\nimport { parseAccountId } from '@walletconnect/utils';\nimport { createAppKit } from '@reown/appkit/core';\nimport { solana, solanaDevnet, solanaTestnet } from '@reown/appkit/networks';\nimport base58 from 'bs58';\nimport { WalletConnectRPCMethods } from './constants.js';\nimport { ClientNotInitializedError } from './errors/ClientNotInitializedError.js';\nimport { WalletConnectFeatureNotSupportedError } from './errors/WalletConnectNotSupportedError.js';\nimport { getConnectParams, getDefaultChainFromSession } from './utils.js';\nimport { QRCodeModalError } from './errors/QRCodeModalError.js';\nexport class WalletConnectWallet {\n  _UniversalProvider;\n  _session;\n  _modal;\n  _projectId;\n  _network;\n  _ConnectQueueResolver;\n  constructor(config) {\n    this.initClient(config.options);\n    this._network = config.network;\n    if (!config.options.projectId) {\n      throw Error('WalletConnect Adapter: Project ID is undefined');\n    }\n    this._projectId = config.options.projectId;\n  }\n  async connect() {\n    if (!this._UniversalProvider) {\n      await new Promise(res => {\n        this._ConnectQueueResolver = res;\n      });\n    }\n    if (!this._UniversalProvider) {\n      throw new Error(\"WalletConnect Adapter - Universal Provider was undefined while calling 'connect()'\");\n    }\n    if (this._UniversalProvider.session) {\n      this._session = this._UniversalProvider.session;\n      const defaultNetwork = getDefaultChainFromSession(this._session, this._network);\n      this._network = defaultNetwork;\n      this._UniversalProvider.setDefaultChain(defaultNetwork);\n      return {\n        publicKey: this.publicKey\n      };\n    }\n    await this.initModal();\n    const params = getConnectParams(this._network);\n    this._modal?.open();\n    // Create an abort controller to handle modal close\n    const controller = new AbortController();\n    const signal = controller.signal;\n    this._modal?.subscribeState(state => {\n      if (!state.open) {\n        controller.abort(new QRCodeModalError());\n      }\n    });\n    try {\n      const session = await Promise.race([this._UniversalProvider?.connect(params), new Promise((_, reject) => {\n        signal.addEventListener('abort', () => {\n          reject(signal.reason);\n        });\n      })]);\n      this._modal?.close();\n      this._session = session;\n      if (!session) {\n        throw new WalletConnectionError();\n      }\n      const defaultNetwork = getDefaultChainFromSession(session, this._network);\n      this._network = defaultNetwork;\n      this._UniversalProvider?.setDefaultChain(defaultNetwork);\n      return {\n        publicKey: this.publicKey\n      };\n    } catch (error) {\n      this._modal?.close();\n      throw error;\n    }\n  }\n  async disconnect() {\n    if (this._UniversalProvider?.session) {\n      await this.initModal();\n      if (!this._modal) {\n        throw Error('WalletConnect Adapter -Modal is undefined: unable to disconnect');\n      }\n      await this.client.disconnect();\n      // await this._modal.disconnect()\n      this._session = undefined;\n    } else {\n      throw new ClientNotInitializedError();\n    }\n  }\n  get client() {\n    if (this._UniversalProvider) {\n      return this._UniversalProvider;\n    }\n    throw new ClientNotInitializedError();\n  }\n  get session() {\n    if (!this._session) {\n      throw new ClientNotInitializedError();\n    }\n    return this._session;\n  }\n  get publicKey() {\n    if (this._UniversalProvider?.session && this._session) {\n      const {\n        address\n      } = parseAccountId(this._session?.namespaces['solana']?.accounts[0] ?? '');\n      return new PublicKey(address);\n    }\n    throw new ClientNotInitializedError();\n  }\n  async signTransaction(transaction) {\n    this.checkIfWalletSupportsMethod(WalletConnectRPCMethods.signTransaction);\n    const isVersioned = isVersionedTransaction(transaction);\n    const legacyTransaction = isVersioned ? {} : transaction;\n    const {\n      signature,\n      transaction: signedSerializedTransaction\n    } = await this.client.client.request({\n      chainId: this._network,\n      topic: this.session.topic,\n      request: {\n        method: WalletConnectRPCMethods.signTransaction,\n        params: {\n          /*\n           * Passing ...legacyTransaction is deprecated.\n           * All new clients should rely on the `transaction` parameter.\n           * The future versions will stop passing ...legacyTransaction.\n           */\n          ...legacyTransaction,\n          // New base64-encoded serialized transaction request parameter\n          transaction: this.serialize(transaction)\n        }\n      }\n    });\n    if (signedSerializedTransaction) {\n      return this.deserialize(signedSerializedTransaction, isVersioned);\n    }\n    transaction.addSignature(this.publicKey, Buffer.from(base58.decode(signature)));\n    return transaction;\n  }\n  async signMessage(message) {\n    this.checkIfWalletSupportsMethod(WalletConnectRPCMethods.signMessage);\n    const {\n      signature\n    } = await this.client.client.request({\n      // The network does not change the output of message signing, but this is a required parameter for SignClient\n      chainId: this._network,\n      topic: this.session.topic,\n      request: {\n        method: WalletConnectRPCMethods.signMessage,\n        params: {\n          pubkey: this.publicKey.toString(),\n          message: base58.encode(message)\n        }\n      }\n    });\n    return base58.decode(signature);\n  }\n  async signAndSendTransaction(transaction) {\n    this.checkIfWalletSupportsMethod(WalletConnectRPCMethods.signAndSendTransaction);\n    const {\n      signature\n    } = await this.client.client.request({\n      chainId: this._network,\n      topic: this.session.topic,\n      request: {\n        method: WalletConnectRPCMethods.signAndSendTransaction,\n        params: {\n          transaction: this.serialize(transaction)\n        }\n      }\n    });\n    return signature;\n  }\n  async signAllTransactions(transactions) {\n    try {\n      this.checkIfWalletSupportsMethod(WalletConnectRPCMethods.signAllTransactions);\n      const serializedTransactions = transactions.map(transaction => this.serialize(transaction));\n      const {\n        transactions: serializedSignedTransactions\n      } = await this.client.client.request({\n        chainId: this._network,\n        topic: this.session.topic,\n        request: {\n          method: WalletConnectRPCMethods.signAllTransactions,\n          params: {\n            transactions: serializedTransactions\n          }\n        }\n      });\n      return transactions.map((transaction, index) => {\n        if (isVersionedTransaction(transaction)) {\n          return this.deserialize(serializedSignedTransactions[index] ?? '', true);\n        }\n        return this.deserialize(serializedSignedTransactions[index] ?? '');\n      });\n    } catch (error) {\n      if (error instanceof WalletConnectFeatureNotSupportedError) {\n        const promises = transactions.map(transaction => this.signTransaction(transaction));\n        const signedTransactions = await Promise.all(promises);\n        return signedTransactions;\n      }\n      throw error;\n    }\n  }\n  async initClient(options) {\n    const provider = await UniversalProvider.init(options);\n    this._UniversalProvider = provider;\n    if (this._ConnectQueueResolver) {\n      this._ConnectQueueResolver(true);\n    }\n  }\n  async initModal() {\n    if (this._modal) {\n      return;\n    }\n    if (!this._UniversalProvider) {\n      throw new Error('WalletConnect Adapter - cannot init modal when Universal Provider is undefined');\n    }\n    this._modal = createAppKit({\n      projectId: this._projectId,\n      universalProvider: this._UniversalProvider,\n      networks: [solana, solanaDevnet, solanaTestnet],\n      manualWCControl: true\n    });\n  }\n  serialize(transaction) {\n    return Buffer.from(transaction.serialize({\n      verifySignatures: false\n    })).toString('base64');\n  }\n  deserialize(serializedTransaction, versioned = false) {\n    if (versioned) {\n      return VersionedTransaction.deserialize(Buffer.from(serializedTransaction, 'base64'));\n    }\n    return Transaction.from(Buffer.from(serializedTransaction, 'base64'));\n  }\n  checkIfWalletSupportsMethod(method) {\n    if (!this.session.namespaces['solana']?.methods.includes(method)) {\n      throw new WalletConnectFeatureNotSupportedError(method);\n    }\n  }\n}\n//# sourceMappingURL=core.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}