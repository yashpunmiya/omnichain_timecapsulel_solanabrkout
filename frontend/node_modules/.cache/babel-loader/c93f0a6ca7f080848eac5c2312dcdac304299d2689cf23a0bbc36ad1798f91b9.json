{"ast":null,"code":"(function (i, _) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? module.exports = _() : \"function\" == typeof define && define.amd ? define(_) : (i = i || self, i.JSBI = _());\n})(this, function () {\n  'use strict';\n\n  var i = Math.imul,\n    _ = Math.clz32,\n    t = Math.abs,\n    e = Math.max,\n    g = Math.floor;\n  class o extends Array {\n    constructor(i, _) {\n      if (super(i), this.sign = _, i > o.__kMaxLength) throw new RangeError(\"Maximum BigInt size exceeded\");\n    }\n    static BigInt(i) {\n      var _ = Number.isFinite;\n      if (\"number\" == typeof i) {\n        if (0 === i) return o.__zero();\n        if (o.__isOneDigitInt(i)) return 0 > i ? o.__oneDigit(-i, !0) : o.__oneDigit(i, !1);\n        if (!_(i) || g(i) !== i) throw new RangeError(\"The number \" + i + \" cannot be converted to BigInt because it is not an integer\");\n        return o.__fromDouble(i);\n      }\n      if (\"string\" == typeof i) {\n        const _ = o.__fromString(i);\n        if (null === _) throw new SyntaxError(\"Cannot convert \" + i + \" to a BigInt\");\n        return _;\n      }\n      if (\"boolean\" == typeof i) return !0 === i ? o.__oneDigit(1, !1) : o.__zero();\n      if (\"object\" == typeof i) {\n        if (i.constructor === o) return i;\n        const _ = o.__toPrimitive(i);\n        return o.BigInt(_);\n      }\n      throw new TypeError(\"Cannot convert \" + i + \" to a BigInt\");\n    }\n    toDebugString() {\n      const i = [\"BigInt[\"];\n      for (const _ of this) i.push((_ ? (_ >>> 0).toString(16) : _) + \", \");\n      return i.push(\"]\"), i.join(\"\");\n    }\n    toString(i = 10) {\n      if (2 > i || 36 < i) throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n      return 0 === this.length ? \"0\" : 0 == (i & i - 1) ? o.__toStringBasePowerOfTwo(this, i) : o.__toStringGeneric(this, i, !1);\n    }\n    static toNumber(i) {\n      const _ = i.length;\n      if (0 === _) return 0;\n      if (1 === _) {\n        const _ = i.__unsignedDigit(0);\n        return i.sign ? -_ : _;\n      }\n      const t = i.__digit(_ - 1),\n        e = o.__clz30(t),\n        n = 30 * _ - e;\n      if (1024 < n) return i.sign ? -Infinity : 1 / 0;\n      let g = n - 1,\n        s = t,\n        l = _ - 1;\n      const r = e + 3;\n      let a = 32 === r ? 0 : s << r;\n      a >>>= 12;\n      const u = r - 12;\n      let d = 12 <= r ? 0 : s << 20 + r,\n        h = 20 + r;\n      for (0 < u && 0 < l && (l--, s = i.__digit(l), a |= s >>> 30 - u, d = s << u + 2, h = u + 2); 0 < h && 0 < l;) l--, s = i.__digit(l), d |= 30 <= h ? s << h - 30 : s >>> 30 - h, h -= 30;\n      const m = o.__decideRounding(i, h, l, s);\n      if ((1 === m || 0 === m && 1 == (1 & d)) && (d = d + 1 >>> 0, 0 === d && (a++, 0 != a >>> 20 && (a = 0, g++, 1023 < g)))) return i.sign ? -Infinity : 1 / 0;\n      const b = i.sign ? -2147483648 : 0;\n      return g = g + 1023 << 20, o.__kBitConversionInts[1] = b | g | a, o.__kBitConversionInts[0] = d, o.__kBitConversionDouble[0];\n    }\n    static unaryMinus(i) {\n      if (0 === i.length) return i;\n      const _ = i.__copy();\n      return _.sign = !i.sign, _;\n    }\n    static bitwiseNot(i) {\n      return i.sign ? o.__absoluteSubOne(i).__trim() : o.__absoluteAddOne(i, !0);\n    }\n    static exponentiate(i, _) {\n      if (_.sign) throw new RangeError(\"Exponent must be positive\");\n      if (0 === _.length) return o.__oneDigit(1, !1);\n      if (0 === i.length) return i;\n      if (1 === i.length && 1 === i.__digit(0)) return i.sign && 0 == (1 & _.__digit(0)) ? o.unaryMinus(i) : i;\n      if (1 < _.length) throw new RangeError(\"BigInt too big\");\n      let t = _.__unsignedDigit(0);\n      if (1 === t) return i;\n      if (t >= o.__kMaxLengthBits) throw new RangeError(\"BigInt too big\");\n      if (1 === i.length && 2 === i.__digit(0)) {\n        const _ = 1 + (0 | t / 30),\n          e = i.sign && 0 != (1 & t),\n          n = new o(_, e);\n        n.__initializeDigits();\n        const g = 1 << t % 30;\n        return n.__setDigit(_ - 1, g), n;\n      }\n      let e = null,\n        n = i;\n      for (0 != (1 & t) && (e = i), t >>= 1; 0 !== t; t >>= 1) n = o.multiply(n, n), 0 != (1 & t) && (null === e ? e = n : e = o.multiply(e, n));\n      return e;\n    }\n    static multiply(_, t) {\n      if (0 === _.length) return _;\n      if (0 === t.length) return t;\n      let i = _.length + t.length;\n      30 <= _.__clzmsd() + t.__clzmsd() && i--;\n      const e = new o(i, _.sign !== t.sign);\n      e.__initializeDigits();\n      for (let n = 0; n < _.length; n++) o.__multiplyAccumulate(t, _.__digit(n), e, n);\n      return e.__trim();\n    }\n    static divide(i, _) {\n      if (0 === _.length) throw new RangeError(\"Division by zero\");\n      if (0 > o.__absoluteCompare(i, _)) return o.__zero();\n      const t = i.sign !== _.sign,\n        e = _.__unsignedDigit(0);\n      let n;\n      if (1 === _.length && 32767 >= e) {\n        if (1 === e) return t === i.sign ? i : o.unaryMinus(i);\n        n = o.__absoluteDivSmall(i, e, null);\n      } else n = o.__absoluteDivLarge(i, _, !0, !1);\n      return n.sign = t, n.__trim();\n    }\n    static remainder(i, _) {\n      if (0 === _.length) throw new RangeError(\"Division by zero\");\n      if (0 > o.__absoluteCompare(i, _)) return i;\n      const t = _.__unsignedDigit(0);\n      if (1 === _.length && 32767 >= t) {\n        if (1 === t) return o.__zero();\n        const _ = o.__absoluteModSmall(i, t);\n        return 0 === _ ? o.__zero() : o.__oneDigit(_, i.sign);\n      }\n      const e = o.__absoluteDivLarge(i, _, !1, !0);\n      return e.sign = i.sign, e.__trim();\n    }\n    static add(i, _) {\n      const t = i.sign;\n      return t === _.sign ? o.__absoluteAdd(i, _, t) : 0 <= o.__absoluteCompare(i, _) ? o.__absoluteSub(i, _, t) : o.__absoluteSub(_, i, !t);\n    }\n    static subtract(i, _) {\n      const t = i.sign;\n      return t === _.sign ? 0 <= o.__absoluteCompare(i, _) ? o.__absoluteSub(i, _, t) : o.__absoluteSub(_, i, !t) : o.__absoluteAdd(i, _, t);\n    }\n    static leftShift(i, _) {\n      return 0 === _.length || 0 === i.length ? i : _.sign ? o.__rightShiftByAbsolute(i, _) : o.__leftShiftByAbsolute(i, _);\n    }\n    static signedRightShift(i, _) {\n      return 0 === _.length || 0 === i.length ? i : _.sign ? o.__leftShiftByAbsolute(i, _) : o.__rightShiftByAbsolute(i, _);\n    }\n    static unsignedRightShift() {\n      throw new TypeError(\"BigInts have no unsigned right shift; use >> instead\");\n    }\n    static lessThan(i, _) {\n      return 0 > o.__compareToBigInt(i, _);\n    }\n    static lessThanOrEqual(i, _) {\n      return 0 >= o.__compareToBigInt(i, _);\n    }\n    static greaterThan(i, _) {\n      return 0 < o.__compareToBigInt(i, _);\n    }\n    static greaterThanOrEqual(i, _) {\n      return 0 <= o.__compareToBigInt(i, _);\n    }\n    static equal(_, t) {\n      if (_.sign !== t.sign) return !1;\n      if (_.length !== t.length) return !1;\n      for (let e = 0; e < _.length; e++) if (_.__digit(e) !== t.__digit(e)) return !1;\n      return !0;\n    }\n    static notEqual(i, _) {\n      return !o.equal(i, _);\n    }\n    static bitwiseAnd(i, _) {\n      if (!i.sign && !_.sign) return o.__absoluteAnd(i, _).__trim();\n      if (i.sign && _.sign) {\n        const t = e(i.length, _.length) + 1;\n        let n = o.__absoluteSubOne(i, t);\n        const g = o.__absoluteSubOne(_);\n        return n = o.__absoluteOr(n, g, n), o.__absoluteAddOne(n, !0, n).__trim();\n      }\n      return i.sign && ([i, _] = [_, i]), o.__absoluteAndNot(i, o.__absoluteSubOne(_)).__trim();\n    }\n    static bitwiseXor(i, _) {\n      if (!i.sign && !_.sign) return o.__absoluteXor(i, _).__trim();\n      if (i.sign && _.sign) {\n        const t = e(i.length, _.length),\n          n = o.__absoluteSubOne(i, t),\n          g = o.__absoluteSubOne(_);\n        return o.__absoluteXor(n, g, n).__trim();\n      }\n      const t = e(i.length, _.length) + 1;\n      i.sign && ([i, _] = [_, i]);\n      let n = o.__absoluteSubOne(_, t);\n      return n = o.__absoluteXor(n, i, n), o.__absoluteAddOne(n, !0, n).__trim();\n    }\n    static bitwiseOr(i, _) {\n      const t = e(i.length, _.length);\n      if (!i.sign && !_.sign) return o.__absoluteOr(i, _).__trim();\n      if (i.sign && _.sign) {\n        let e = o.__absoluteSubOne(i, t);\n        const n = o.__absoluteSubOne(_);\n        return e = o.__absoluteAnd(e, n, e), o.__absoluteAddOne(e, !0, e).__trim();\n      }\n      i.sign && ([i, _] = [_, i]);\n      let n = o.__absoluteSubOne(_, t);\n      return n = o.__absoluteAndNot(n, i, n), o.__absoluteAddOne(n, !0, n).__trim();\n    }\n    static asIntN(_, t) {\n      if (0 === t.length) return t;\n      if (_ = g(_), 0 > _) throw new RangeError(\"Invalid value: not (convertible to) a safe integer\");\n      if (0 === _) return o.__zero();\n      if (_ >= o.__kMaxLengthBits) return t;\n      const e = 0 | (_ + 29) / 30;\n      if (t.length < e) return t;\n      const s = t.__unsignedDigit(e - 1),\n        l = 1 << (_ - 1) % 30;\n      if (t.length === e && s < l) return t;\n      if (!((s & l) === l)) return o.__truncateToNBits(_, t);\n      if (!t.sign) return o.__truncateAndSubFromPowerOfTwo(_, t, !0);\n      if (0 == (s & l - 1)) {\n        for (let n = e - 2; 0 <= n; n--) if (0 !== t.__digit(n)) return o.__truncateAndSubFromPowerOfTwo(_, t, !1);\n        return t.length === e && s === l ? t : o.__truncateToNBits(_, t);\n      }\n      return o.__truncateAndSubFromPowerOfTwo(_, t, !1);\n    }\n    static asUintN(i, _) {\n      if (0 === _.length) return _;\n      if (i = g(i), 0 > i) throw new RangeError(\"Invalid value: not (convertible to) a safe integer\");\n      if (0 === i) return o.__zero();\n      if (_.sign) {\n        if (i > o.__kMaxLengthBits) throw new RangeError(\"BigInt too big\");\n        return o.__truncateAndSubFromPowerOfTwo(i, _, !1);\n      }\n      if (i >= o.__kMaxLengthBits) return _;\n      const t = 0 | (i + 29) / 30;\n      if (_.length < t) return _;\n      const e = i % 30;\n      if (_.length == t) {\n        if (0 === e) return _;\n        const i = _.__digit(t - 1);\n        if (0 == i >>> e) return _;\n      }\n      return o.__truncateToNBits(i, _);\n    }\n    static ADD(i, _) {\n      if (i = o.__toPrimitive(i), _ = o.__toPrimitive(_), \"string\" == typeof i) return \"string\" != typeof _ && (_ = _.toString()), i + _;\n      if (\"string\" == typeof _) return i.toString() + _;\n      if (i = o.__toNumeric(i), _ = o.__toNumeric(_), o.__isBigInt(i) && o.__isBigInt(_)) return o.add(i, _);\n      if (\"number\" == typeof i && \"number\" == typeof _) return i + _;\n      throw new TypeError(\"Cannot mix BigInt and other types, use explicit conversions\");\n    }\n    static LT(i, _) {\n      return o.__compare(i, _, 0);\n    }\n    static LE(i, _) {\n      return o.__compare(i, _, 1);\n    }\n    static GT(i, _) {\n      return o.__compare(i, _, 2);\n    }\n    static GE(i, _) {\n      return o.__compare(i, _, 3);\n    }\n    static EQ(i, _) {\n      for (;;) {\n        if (o.__isBigInt(i)) return o.__isBigInt(_) ? o.equal(i, _) : o.EQ(_, i);\n        if (\"number\" == typeof i) {\n          if (o.__isBigInt(_)) return o.__equalToNumber(_, i);\n          if (\"object\" != typeof _) return i == _;\n          _ = o.__toPrimitive(_);\n        } else if (\"string\" == typeof i) {\n          if (o.__isBigInt(_)) return i = o.__fromString(i), null !== i && o.equal(i, _);\n          if (\"object\" != typeof _) return i == _;\n          _ = o.__toPrimitive(_);\n        } else if (\"boolean\" == typeof i) {\n          if (o.__isBigInt(_)) return o.__equalToNumber(_, +i);\n          if (\"object\" != typeof _) return i == _;\n          _ = o.__toPrimitive(_);\n        } else if (\"symbol\" == typeof i) {\n          if (o.__isBigInt(_)) return !1;\n          if (\"object\" != typeof _) return i == _;\n          _ = o.__toPrimitive(_);\n        } else if (\"object\" == typeof i) {\n          if (\"object\" == typeof _ && _.constructor !== o) return i == _;\n          i = o.__toPrimitive(i);\n        } else return i == _;\n      }\n    }\n    static NE(i, _) {\n      return !o.EQ(i, _);\n    }\n    static __zero() {\n      return new o(0, !1);\n    }\n    static __oneDigit(i, _) {\n      const t = new o(1, _);\n      return t.__setDigit(0, i), t;\n    }\n    __copy() {\n      const _ = new o(this.length, this.sign);\n      for (let t = 0; t < this.length; t++) _[t] = this[t];\n      return _;\n    }\n    __trim() {\n      let i = this.length,\n        _ = this[i - 1];\n      for (; 0 === _;) i--, _ = this[i - 1], this.pop();\n      return 0 === i && (this.sign = !1), this;\n    }\n    __initializeDigits() {\n      for (let _ = 0; _ < this.length; _++) this[_] = 0;\n    }\n    static __decideRounding(i, _, t, e) {\n      if (0 < _) return -1;\n      let n;\n      if (0 > _) n = -_ - 1;else {\n        if (0 === t) return -1;\n        t--, e = i.__digit(t), n = 29;\n      }\n      let g = 1 << n;\n      if (0 == (e & g)) return -1;\n      if (g -= 1, 0 != (e & g)) return 1;\n      for (; 0 < t;) if (t--, 0 !== i.__digit(t)) return 1;\n      return 0;\n    }\n    static __fromDouble(i) {\n      o.__kBitConversionDouble[0] = i;\n      const _ = 2047 & o.__kBitConversionInts[1] >>> 20,\n        t = _ - 1023,\n        e = (0 | t / 30) + 1,\n        n = new o(e, 0 > i);\n      let g = 1048575 & o.__kBitConversionInts[1] | 1048576,\n        s = o.__kBitConversionInts[0];\n      const l = 20,\n        r = t % 30;\n      let a,\n        u = 0;\n      if (20 > r) {\n        const i = l - r;\n        u = i + 32, a = g >>> i, g = g << 32 - i | s >>> i, s <<= 32 - i;\n      } else if (20 === r) u = 32, a = g, g = s, s = 0;else {\n        const i = r - l;\n        u = 32 - i, a = g << i | s >>> 32 - i, g = s << i, s = 0;\n      }\n      n.__setDigit(e - 1, a);\n      for (let _ = e - 2; 0 <= _; _--) 0 < u ? (u -= 30, a = g >>> 2, g = g << 30 | s >>> 2, s <<= 30) : a = 0, n.__setDigit(_, a);\n      return n.__trim();\n    }\n    static __isWhitespace(i) {\n      return !!(13 >= i && 9 <= i) || (159 >= i ? 32 == i : 131071 >= i ? 160 == i || 5760 == i : 196607 >= i ? (i &= 131071, 10 >= i || 40 == i || 41 == i || 47 == i || 95 == i || 4096 == i) : 65279 == i);\n    }\n    static __fromString(i, _ = 0) {\n      let t = 0;\n      const e = i.length;\n      let n = 0;\n      if (n === e) return o.__zero();\n      let g = i.charCodeAt(n);\n      for (; o.__isWhitespace(g);) {\n        if (++n === e) return o.__zero();\n        g = i.charCodeAt(n);\n      }\n      if (43 === g) {\n        if (++n === e) return null;\n        g = i.charCodeAt(n), t = 1;\n      } else if (45 === g) {\n        if (++n === e) return null;\n        g = i.charCodeAt(n), t = -1;\n      }\n      if (0 === _) {\n        if (_ = 10, 48 === g) {\n          if (++n === e) return o.__zero();\n          if (g = i.charCodeAt(n), 88 === g || 120 === g) {\n            if (_ = 16, ++n === e) return null;\n            g = i.charCodeAt(n);\n          } else if (79 === g || 111 === g) {\n            if (_ = 8, ++n === e) return null;\n            g = i.charCodeAt(n);\n          } else if (66 === g || 98 === g) {\n            if (_ = 2, ++n === e) return null;\n            g = i.charCodeAt(n);\n          }\n        }\n      } else if (16 === _ && 48 === g) {\n        if (++n === e) return o.__zero();\n        if (g = i.charCodeAt(n), 88 === g || 120 === g) {\n          if (++n === e) return null;\n          g = i.charCodeAt(n);\n        }\n      }\n      if (0 != t && 10 !== _) return null;\n      for (; 48 === g;) {\n        if (++n === e) return o.__zero();\n        g = i.charCodeAt(n);\n      }\n      const s = e - n;\n      let l = o.__kMaxBitsPerChar[_],\n        r = o.__kBitsPerCharTableMultiplier - 1;\n      if (s > 1073741824 / l) return null;\n      const a = l * s + r >>> o.__kBitsPerCharTableShift,\n        u = new o(0 | (a + 29) / 30, !1),\n        h = 10 > _ ? _ : 10,\n        b = 10 < _ ? _ - 10 : 0;\n      if (0 == (_ & _ - 1)) {\n        l >>= o.__kBitsPerCharTableShift;\n        const _ = [],\n          t = [];\n        let s = !1;\n        do {\n          let o = 0,\n            r = 0;\n          for (;;) {\n            let _;\n            if (g - 48 >>> 0 < h) _ = g - 48;else if ((32 | g) - 97 >>> 0 < b) _ = (32 | g) - 87;else {\n              s = !0;\n              break;\n            }\n            if (r += l, o = o << l | _, ++n === e) {\n              s = !0;\n              break;\n            }\n            if (g = i.charCodeAt(n), 30 < r + l) break;\n          }\n          _.push(o), t.push(r);\n        } while (!s);\n        o.__fillFromParts(u, _, t);\n      } else {\n        u.__initializeDigits();\n        let t = !1,\n          s = 0;\n        do {\n          let a = 0,\n            D = 1;\n          for (;;) {\n            let o;\n            if (g - 48 >>> 0 < h) o = g - 48;else if ((32 | g) - 97 >>> 0 < b) o = (32 | g) - 87;else {\n              t = !0;\n              break;\n            }\n            const l = D * _;\n            if (1073741823 < l) break;\n            if (D = l, a = a * _ + o, s++, ++n === e) {\n              t = !0;\n              break;\n            }\n            g = i.charCodeAt(n);\n          }\n          r = 30 * o.__kBitsPerCharTableMultiplier - 1;\n          const c = 0 | (l * s + r >>> o.__kBitsPerCharTableShift) / 30;\n          u.__inplaceMultiplyAdd(D, a, c);\n        } while (!t);\n      }\n      if (n !== e) {\n        if (!o.__isWhitespace(g)) return null;\n        for (n++; n < e; n++) if (g = i.charCodeAt(n), !o.__isWhitespace(g)) return null;\n      }\n      return u.sign = -1 == t, u.__trim();\n    }\n    static __fillFromParts(_, t, e) {\n      let n = 0,\n        g = 0,\n        o = 0;\n      for (let s = t.length - 1; 0 <= s; s--) {\n        const i = t[s],\n          l = e[s];\n        g |= i << o, o += l, 30 === o ? (_.__setDigit(n++, g), o = 0, g = 0) : 30 < o && (_.__setDigit(n++, 1073741823 & g), o -= 30, g = i >>> l - o);\n      }\n      if (0 !== g) {\n        if (n >= _.length) throw new Error(\"implementation bug\");\n        _.__setDigit(n++, g);\n      }\n      for (; n < _.length; n++) _.__setDigit(n, 0);\n    }\n    static __toStringBasePowerOfTwo(_, i) {\n      const t = _.length;\n      let e = i - 1;\n      e = (85 & e >>> 1) + (85 & e), e = (51 & e >>> 2) + (51 & e), e = (15 & e >>> 4) + (15 & e);\n      const n = e,\n        g = i - 1,\n        s = _.__digit(t - 1),\n        l = o.__clz30(s);\n      let r = 0 | (30 * t - l + n - 1) / n;\n      if (_.sign && r++, 268435456 < r) throw new Error(\"string too long\");\n      const a = Array(r);\n      let u = r - 1,\n        d = 0,\n        h = 0;\n      for (let e = 0; e < t - 1; e++) {\n        const i = _.__digit(e),\n          t = (d | i << h) & g;\n        a[u--] = o.__kConversionChars[t];\n        const s = n - h;\n        for (d = i >>> s, h = 30 - s; h >= n;) a[u--] = o.__kConversionChars[d & g], d >>>= n, h -= n;\n      }\n      const m = (d | s << h) & g;\n      for (a[u--] = o.__kConversionChars[m], d = s >>> n - h; 0 !== d;) a[u--] = o.__kConversionChars[d & g], d >>>= n;\n      if (_.sign && (a[u--] = \"-\"), -1 != u) throw new Error(\"implementation bug\");\n      return a.join(\"\");\n    }\n    static __toStringGeneric(_, i, t) {\n      const e = _.length;\n      if (0 === e) return \"\";\n      if (1 === e) {\n        let e = _.__unsignedDigit(0).toString(i);\n        return !1 === t && _.sign && (e = \"-\" + e), e;\n      }\n      const n = 30 * e - o.__clz30(_.__digit(e - 1)),\n        g = o.__kMaxBitsPerChar[i],\n        s = g - 1;\n      let l = n * o.__kBitsPerCharTableMultiplier;\n      l += s - 1, l = 0 | l / s;\n      const r = l + 1 >> 1,\n        a = o.exponentiate(o.__oneDigit(i, !1), o.__oneDigit(r, !1));\n      let u, d;\n      const h = a.__unsignedDigit(0);\n      if (1 === a.length && 32767 >= h) {\n        u = new o(_.length, !1), u.__initializeDigits();\n        let t = 0;\n        for (let e = 2 * _.length - 1; 0 <= e; e--) {\n          const i = t << 15 | _.__halfDigit(e);\n          u.__setHalfDigit(e, 0 | i / h), t = 0 | i % h;\n        }\n        d = t.toString(i);\n      } else {\n        const t = o.__absoluteDivLarge(_, a, !0, !0);\n        u = t.quotient;\n        const e = t.remainder.__trim();\n        d = o.__toStringGeneric(e, i, !0);\n      }\n      u.__trim();\n      let m = o.__toStringGeneric(u, i, !0);\n      for (; d.length < r;) d = \"0\" + d;\n      return !1 === t && _.sign && (m = \"-\" + m), m + d;\n    }\n    static __unequalSign(i) {\n      return i ? -1 : 1;\n    }\n    static __absoluteGreater(i) {\n      return i ? -1 : 1;\n    }\n    static __absoluteLess(i) {\n      return i ? 1 : -1;\n    }\n    static __compareToBigInt(i, _) {\n      const t = i.sign;\n      if (t !== _.sign) return o.__unequalSign(t);\n      const e = o.__absoluteCompare(i, _);\n      return 0 < e ? o.__absoluteGreater(t) : 0 > e ? o.__absoluteLess(t) : 0;\n    }\n    static __compareToNumber(i, _) {\n      if (o.__isOneDigitInt(_)) {\n        const e = i.sign,\n          n = 0 > _;\n        if (e !== n) return o.__unequalSign(e);\n        if (0 === i.length) {\n          if (n) throw new Error(\"implementation bug\");\n          return 0 === _ ? 0 : -1;\n        }\n        if (1 < i.length) return o.__absoluteGreater(e);\n        const g = t(_),\n          s = i.__unsignedDigit(0);\n        return s > g ? o.__absoluteGreater(e) : s < g ? o.__absoluteLess(e) : 0;\n      }\n      return o.__compareToDouble(i, _);\n    }\n    static __compareToDouble(i, _) {\n      if (_ !== _) return _;\n      if (_ === 1 / 0) return -1;\n      if (_ === -Infinity) return 1;\n      const t = i.sign;\n      if (t !== 0 > _) return o.__unequalSign(t);\n      if (0 === _) throw new Error(\"implementation bug: should be handled elsewhere\");\n      if (0 === i.length) return -1;\n      o.__kBitConversionDouble[0] = _;\n      const e = 2047 & o.__kBitConversionInts[1] >>> 20;\n      if (2047 == e) throw new Error(\"implementation bug: handled elsewhere\");\n      const n = e - 1023;\n      if (0 > n) return o.__absoluteGreater(t);\n      const g = i.length;\n      let s = i.__digit(g - 1);\n      const l = o.__clz30(s),\n        r = 30 * g - l,\n        a = n + 1;\n      if (r < a) return o.__absoluteLess(t);\n      if (r > a) return o.__absoluteGreater(t);\n      let u = 1048576 | 1048575 & o.__kBitConversionInts[1],\n        d = o.__kBitConversionInts[0];\n      const h = 20,\n        m = 29 - l;\n      if (m !== (0 | (r - 1) % 30)) throw new Error(\"implementation bug\");\n      let b,\n        D = 0;\n      if (20 > m) {\n        const i = h - m;\n        D = i + 32, b = u >>> i, u = u << 32 - i | d >>> i, d <<= 32 - i;\n      } else if (20 === m) D = 32, b = u, u = d, d = 0;else {\n        const i = m - h;\n        D = 32 - i, b = u << i | d >>> 32 - i, u = d << i, d = 0;\n      }\n      if (s >>>= 0, b >>>= 0, s > b) return o.__absoluteGreater(t);\n      if (s < b) return o.__absoluteLess(t);\n      for (let e = g - 2; 0 <= e; e--) {\n        0 < D ? (D -= 30, b = u >>> 2, u = u << 30 | d >>> 2, d <<= 30) : b = 0;\n        const _ = i.__unsignedDigit(e);\n        if (_ > b) return o.__absoluteGreater(t);\n        if (_ < b) return o.__absoluteLess(t);\n      }\n      if (0 !== u || 0 !== d) {\n        if (0 === D) throw new Error(\"implementation bug\");\n        return o.__absoluteLess(t);\n      }\n      return 0;\n    }\n    static __equalToNumber(i, _) {\n      return o.__isOneDigitInt(_) ? 0 === _ ? 0 === i.length : 1 === i.length && i.sign === 0 > _ && i.__unsignedDigit(0) === t(_) : 0 === o.__compareToDouble(i, _);\n    }\n    static __comparisonResultToBool(i, _) {\n      return 0 === _ ? 0 > i : 1 === _ ? 0 >= i : 2 === _ ? 0 < i : 3 === _ ? 0 <= i : void 0;\n    }\n    static __compare(i, _, t) {\n      if (i = o.__toPrimitive(i), _ = o.__toPrimitive(_), \"string\" == typeof i && \"string\" == typeof _) switch (t) {\n        case 0:\n          return i < _;\n        case 1:\n          return i <= _;\n        case 2:\n          return i > _;\n        case 3:\n          return i >= _;\n      }\n      if (o.__isBigInt(i) && \"string\" == typeof _) return _ = o.__fromString(_), null !== _ && o.__comparisonResultToBool(o.__compareToBigInt(i, _), t);\n      if (\"string\" == typeof i && o.__isBigInt(_)) return i = o.__fromString(i), null !== i && o.__comparisonResultToBool(o.__compareToBigInt(i, _), t);\n      if (i = o.__toNumeric(i), _ = o.__toNumeric(_), o.__isBigInt(i)) {\n        if (o.__isBigInt(_)) return o.__comparisonResultToBool(o.__compareToBigInt(i, _), t);\n        if (\"number\" != typeof _) throw new Error(\"implementation bug\");\n        return o.__comparisonResultToBool(o.__compareToNumber(i, _), t);\n      }\n      if (\"number\" != typeof i) throw new Error(\"implementation bug\");\n      if (o.__isBigInt(_)) return o.__comparisonResultToBool(o.__compareToNumber(_, i), 2 ^ t);\n      if (\"number\" != typeof _) throw new Error(\"implementation bug\");\n      return 0 === t ? i < _ : 1 === t ? i <= _ : 2 === t ? i > _ : 3 === t ? i >= _ : void 0;\n    }\n    __clzmsd() {\n      return o.__clz30(this.__digit(this.length - 1));\n    }\n    static __absoluteAdd(_, t, e) {\n      if (_.length < t.length) return o.__absoluteAdd(t, _, e);\n      if (0 === _.length) return _;\n      if (0 === t.length) return _.sign === e ? _ : o.unaryMinus(_);\n      let n = _.length;\n      (0 === _.__clzmsd() || t.length === _.length && 0 === t.__clzmsd()) && n++;\n      const g = new o(n, e);\n      let s = 0,\n        l = 0;\n      for (; l < t.length; l++) {\n        const i = _.__digit(l) + t.__digit(l) + s;\n        s = i >>> 30, g.__setDigit(l, 1073741823 & i);\n      }\n      for (; l < _.length; l++) {\n        const i = _.__digit(l) + s;\n        s = i >>> 30, g.__setDigit(l, 1073741823 & i);\n      }\n      return l < g.length && g.__setDigit(l, s), g.__trim();\n    }\n    static __absoluteSub(_, t, e) {\n      if (0 === _.length) return _;\n      if (0 === t.length) return _.sign === e ? _ : o.unaryMinus(_);\n      const n = new o(_.length, e);\n      let g = 0,\n        s = 0;\n      for (; s < t.length; s++) {\n        const i = _.__digit(s) - t.__digit(s) - g;\n        g = 1 & i >>> 30, n.__setDigit(s, 1073741823 & i);\n      }\n      for (; s < _.length; s++) {\n        const i = _.__digit(s) - g;\n        g = 1 & i >>> 30, n.__setDigit(s, 1073741823 & i);\n      }\n      return n.__trim();\n    }\n    static __absoluteAddOne(_, i, t = null) {\n      const e = _.length;\n      null === t ? t = new o(e, i) : t.sign = i;\n      let n = 1;\n      for (let g = 0; g < e; g++) {\n        const i = _.__digit(g) + n;\n        n = i >>> 30, t.__setDigit(g, 1073741823 & i);\n      }\n      return 0 != n && t.__setDigitGrow(e, 1), t;\n    }\n    static __absoluteSubOne(_, t) {\n      const e = _.length;\n      t = t || e;\n      const n = new o(t, !1);\n      let g = 1;\n      for (let o = 0; o < e; o++) {\n        const i = _.__digit(o) - g;\n        g = 1 & i >>> 30, n.__setDigit(o, 1073741823 & i);\n      }\n      if (0 != g) throw new Error(\"implementation bug\");\n      for (let g = e; g < t; g++) n.__setDigit(g, 0);\n      return n;\n    }\n    static __absoluteAnd(_, t, e = null) {\n      let n = _.length,\n        g = t.length,\n        s = g;\n      if (n < g) {\n        s = n;\n        const i = _,\n          e = n;\n        _ = t, n = g, t = i, g = e;\n      }\n      let l = s;\n      null === e ? e = new o(l, !1) : l = e.length;\n      let r = 0;\n      for (; r < s; r++) e.__setDigit(r, _.__digit(r) & t.__digit(r));\n      for (; r < l; r++) e.__setDigit(r, 0);\n      return e;\n    }\n    static __absoluteAndNot(_, t, e = null) {\n      const n = _.length,\n        g = t.length;\n      let s = g;\n      n < g && (s = n);\n      let l = n;\n      null === e ? e = new o(l, !1) : l = e.length;\n      let r = 0;\n      for (; r < s; r++) e.__setDigit(r, _.__digit(r) & ~t.__digit(r));\n      for (; r < n; r++) e.__setDigit(r, _.__digit(r));\n      for (; r < l; r++) e.__setDigit(r, 0);\n      return e;\n    }\n    static __absoluteOr(_, t, e = null) {\n      let n = _.length,\n        g = t.length,\n        s = g;\n      if (n < g) {\n        s = n;\n        const i = _,\n          e = n;\n        _ = t, n = g, t = i, g = e;\n      }\n      let l = n;\n      null === e ? e = new o(l, !1) : l = e.length;\n      let r = 0;\n      for (; r < s; r++) e.__setDigit(r, _.__digit(r) | t.__digit(r));\n      for (; r < n; r++) e.__setDigit(r, _.__digit(r));\n      for (; r < l; r++) e.__setDigit(r, 0);\n      return e;\n    }\n    static __absoluteXor(_, t, e = null) {\n      let n = _.length,\n        g = t.length,\n        s = g;\n      if (n < g) {\n        s = n;\n        const i = _,\n          e = n;\n        _ = t, n = g, t = i, g = e;\n      }\n      let l = n;\n      null === e ? e = new o(l, !1) : l = e.length;\n      let r = 0;\n      for (; r < s; r++) e.__setDigit(r, _.__digit(r) ^ t.__digit(r));\n      for (; r < n; r++) e.__setDigit(r, _.__digit(r));\n      for (; r < l; r++) e.__setDigit(r, 0);\n      return e;\n    }\n    static __absoluteCompare(_, t) {\n      const e = _.length - t.length;\n      if (0 != e) return e;\n      let n = _.length - 1;\n      for (; 0 <= n && _.__digit(n) === t.__digit(n);) n--;\n      return 0 > n ? 0 : _.__unsignedDigit(n) > t.__unsignedDigit(n) ? 1 : -1;\n    }\n    static __multiplyAccumulate(_, t, e, n) {\n      if (0 === t) return;\n      const g = 32767 & t,\n        s = t >>> 15;\n      let l = 0,\n        r = 0;\n      for (let a, u = 0; u < _.length; u++, n++) {\n        a = e.__digit(n);\n        const i = _.__digit(u),\n          t = 32767 & i,\n          d = i >>> 15,\n          h = o.__imul(t, g),\n          m = o.__imul(t, s),\n          b = o.__imul(d, g),\n          D = o.__imul(d, s);\n        a += r + h + l, l = a >>> 30, a &= 1073741823, a += ((32767 & m) << 15) + ((32767 & b) << 15), l += a >>> 30, r = D + (m >>> 15) + (b >>> 15), e.__setDigit(n, 1073741823 & a);\n      }\n      for (; 0 != l || 0 !== r; n++) {\n        let i = e.__digit(n);\n        i += l + r, r = 0, l = i >>> 30, e.__setDigit(n, 1073741823 & i);\n      }\n    }\n    static __internalMultiplyAdd(_, t, e, g, s) {\n      let l = e,\n        a = 0;\n      for (let n = 0; n < g; n++) {\n        const i = _.__digit(n),\n          e = o.__imul(32767 & i, t),\n          g = o.__imul(i >>> 15, t),\n          u = e + ((32767 & g) << 15) + a + l;\n        l = u >>> 30, a = g >>> 15, s.__setDigit(n, 1073741823 & u);\n      }\n      if (s.length > g) for (s.__setDigit(g++, l + a); g < s.length;) s.__setDigit(g++, 0);else if (0 !== l + a) throw new Error(\"implementation bug\");\n    }\n    __inplaceMultiplyAdd(i, _, t) {\n      t > this.length && (t = this.length);\n      const e = 32767 & i,\n        n = i >>> 15;\n      let g = 0,\n        s = _;\n      for (let l = 0; l < t; l++) {\n        const i = this.__digit(l),\n          _ = 32767 & i,\n          t = i >>> 15,\n          r = o.__imul(_, e),\n          a = o.__imul(_, n),\n          u = o.__imul(t, e),\n          d = o.__imul(t, n);\n        let h = s + r + g;\n        g = h >>> 30, h &= 1073741823, h += ((32767 & a) << 15) + ((32767 & u) << 15), g += h >>> 30, s = d + (a >>> 15) + (u >>> 15), this.__setDigit(l, 1073741823 & h);\n      }\n      if (0 != g || 0 !== s) throw new Error(\"implementation bug\");\n    }\n    static __absoluteDivSmall(_, t, e = null) {\n      null === e && (e = new o(_.length, !1));\n      let n = 0;\n      for (let g, o = 2 * _.length - 1; 0 <= o; o -= 2) {\n        g = (n << 15 | _.__halfDigit(o)) >>> 0;\n        const i = 0 | g / t;\n        n = 0 | g % t, g = (n << 15 | _.__halfDigit(o - 1)) >>> 0;\n        const s = 0 | g / t;\n        n = 0 | g % t, e.__setDigit(o >>> 1, i << 15 | s);\n      }\n      return e;\n    }\n    static __absoluteModSmall(_, t) {\n      let e = 0;\n      for (let n = 2 * _.length - 1; 0 <= n; n--) {\n        const i = (e << 15 | _.__halfDigit(n)) >>> 0;\n        e = 0 | i % t;\n      }\n      return e;\n    }\n    static __absoluteDivLarge(i, _, t, e) {\n      const g = _.__halfDigitLength(),\n        n = _.length,\n        s = i.__halfDigitLength() - g;\n      let l = null;\n      t && (l = new o(s + 2 >>> 1, !1), l.__initializeDigits());\n      const r = new o(g + 2 >>> 1, !1);\n      r.__initializeDigits();\n      const a = o.__clz15(_.__halfDigit(g - 1));\n      0 < a && (_ = o.__specialLeftShift(_, a, 0));\n      const d = o.__specialLeftShift(i, a, 1),\n        u = _.__halfDigit(g - 1);\n      let h = 0;\n      for (let a, m = s; 0 <= m; m--) {\n        a = 32767;\n        const i = d.__halfDigit(m + g);\n        if (i !== u) {\n          const t = (i << 15 | d.__halfDigit(m + g - 1)) >>> 0;\n          a = 0 | t / u;\n          let e = 0 | t % u;\n          const n = _.__halfDigit(g - 2),\n            s = d.__halfDigit(m + g - 2);\n          for (; o.__imul(a, n) >>> 0 > (e << 16 | s) >>> 0 && (a--, e += u, !(32767 < e)););\n        }\n        o.__internalMultiplyAdd(_, a, 0, n, r);\n        let e = d.__inplaceSub(r, m, g + 1);\n        0 !== e && (e = d.__inplaceAdd(_, m, g), d.__setHalfDigit(m + g, 32767 & d.__halfDigit(m + g) + e), a--), t && (1 & m ? h = a << 15 : l.__setDigit(m >>> 1, h | a));\n      }\n      if (e) return d.__inplaceRightShift(a), t ? {\n        quotient: l,\n        remainder: d\n      } : d;\n      if (t) return l;\n      throw new Error(\"unreachable\");\n    }\n    static __clz15(i) {\n      return o.__clz30(i) - 15;\n    }\n    __inplaceAdd(_, t, e) {\n      let n = 0;\n      for (let g = 0; g < e; g++) {\n        const i = this.__halfDigit(t + g) + _.__halfDigit(g) + n;\n        n = i >>> 15, this.__setHalfDigit(t + g, 32767 & i);\n      }\n      return n;\n    }\n    __inplaceSub(_, t, e) {\n      let n = 0;\n      if (1 & t) {\n        t >>= 1;\n        let g = this.__digit(t),\n          o = 32767 & g,\n          s = 0;\n        for (; s < e - 1 >>> 1; s++) {\n          const i = _.__digit(s),\n            e = (g >>> 15) - (32767 & i) - n;\n          n = 1 & e >>> 15, this.__setDigit(t + s, (32767 & e) << 15 | 32767 & o), g = this.__digit(t + s + 1), o = (32767 & g) - (i >>> 15) - n, n = 1 & o >>> 15;\n        }\n        const i = _.__digit(s),\n          l = (g >>> 15) - (32767 & i) - n;\n        n = 1 & l >>> 15, this.__setDigit(t + s, (32767 & l) << 15 | 32767 & o);\n        if (t + s + 1 >= this.length) throw new RangeError(\"out of bounds\");\n        0 == (1 & e) && (g = this.__digit(t + s + 1), o = (32767 & g) - (i >>> 15) - n, n = 1 & o >>> 15, this.__setDigit(t + _.length, 1073709056 & g | 32767 & o));\n      } else {\n        t >>= 1;\n        let g = 0;\n        for (; g < _.length - 1; g++) {\n          const i = this.__digit(t + g),\n            e = _.__digit(g),\n            o = (32767 & i) - (32767 & e) - n;\n          n = 1 & o >>> 15;\n          const s = (i >>> 15) - (e >>> 15) - n;\n          n = 1 & s >>> 15, this.__setDigit(t + g, (32767 & s) << 15 | 32767 & o);\n        }\n        const i = this.__digit(t + g),\n          o = _.__digit(g),\n          s = (32767 & i) - (32767 & o) - n;\n        n = 1 & s >>> 15;\n        let l = 0;\n        0 == (1 & e) && (l = (i >>> 15) - (o >>> 15) - n, n = 1 & l >>> 15), this.__setDigit(t + g, (32767 & l) << 15 | 32767 & s);\n      }\n      return n;\n    }\n    __inplaceRightShift(_) {\n      if (0 === _) return;\n      let t = this.__digit(0) >>> _;\n      const e = this.length - 1;\n      for (let n = 0; n < e; n++) {\n        const i = this.__digit(n + 1);\n        this.__setDigit(n, 1073741823 & i << 30 - _ | t), t = i >>> _;\n      }\n      this.__setDigit(e, t);\n    }\n    static __specialLeftShift(_, t, e) {\n      const g = _.length,\n        n = new o(g + e, !1);\n      if (0 === t) {\n        for (let t = 0; t < g; t++) n.__setDigit(t, _.__digit(t));\n        return 0 < e && n.__setDigit(g, 0), n;\n      }\n      let s = 0;\n      for (let o = 0; o < g; o++) {\n        const i = _.__digit(o);\n        n.__setDigit(o, 1073741823 & i << t | s), s = i >>> 30 - t;\n      }\n      return 0 < e && n.__setDigit(g, s), n;\n    }\n    static __leftShiftByAbsolute(_, i) {\n      const t = o.__toShiftAmount(i);\n      if (0 > t) throw new RangeError(\"BigInt too big\");\n      const e = 0 | t / 30,\n        n = t % 30,\n        g = _.length,\n        s = 0 !== n && 0 != _.__digit(g - 1) >>> 30 - n,\n        l = g + e + (s ? 1 : 0),\n        r = new o(l, _.sign);\n      if (0 === n) {\n        let t = 0;\n        for (; t < e; t++) r.__setDigit(t, 0);\n        for (; t < l; t++) r.__setDigit(t, _.__digit(t - e));\n      } else {\n        let t = 0;\n        for (let _ = 0; _ < e; _++) r.__setDigit(_, 0);\n        for (let o = 0; o < g; o++) {\n          const i = _.__digit(o);\n          r.__setDigit(o + e, 1073741823 & i << n | t), t = i >>> 30 - n;\n        }\n        if (s) r.__setDigit(g + e, t);else if (0 !== t) throw new Error(\"implementation bug\");\n      }\n      return r.__trim();\n    }\n    static __rightShiftByAbsolute(_, i) {\n      const t = _.length,\n        e = _.sign,\n        n = o.__toShiftAmount(i);\n      if (0 > n) return o.__rightShiftByMaximum(e);\n      const g = 0 | n / 30,\n        s = n % 30;\n      let l = t - g;\n      if (0 >= l) return o.__rightShiftByMaximum(e);\n      let r = !1;\n      if (e) {\n        if (0 != (_.__digit(g) & (1 << s) - 1)) r = !0;else for (let t = 0; t < g; t++) if (0 !== _.__digit(t)) {\n          r = !0;\n          break;\n        }\n      }\n      if (r && 0 === s) {\n        const i = _.__digit(t - 1);\n        0 == ~i && l++;\n      }\n      let a = new o(l, e);\n      if (0 === s) {\n        a.__setDigit(l - 1, 0);\n        for (let e = g; e < t; e++) a.__setDigit(e - g, _.__digit(e));\n      } else {\n        let e = _.__digit(g) >>> s;\n        const n = t - g - 1;\n        for (let t = 0; t < n; t++) {\n          const i = _.__digit(t + g + 1);\n          a.__setDigit(t, 1073741823 & i << 30 - s | e), e = i >>> s;\n        }\n        a.__setDigit(n, e);\n      }\n      return r && (a = o.__absoluteAddOne(a, !0, a)), a.__trim();\n    }\n    static __rightShiftByMaximum(i) {\n      return i ? o.__oneDigit(1, !0) : o.__zero();\n    }\n    static __toShiftAmount(i) {\n      if (1 < i.length) return -1;\n      const _ = i.__unsignedDigit(0);\n      return _ > o.__kMaxLengthBits ? -1 : _;\n    }\n    static __toPrimitive(i, _ = \"default\") {\n      if (\"object\" != typeof i) return i;\n      if (i.constructor === o) return i;\n      if (\"undefined\" != typeof Symbol && \"symbol\" == typeof Symbol.toPrimitive) {\n        const t = i[Symbol.toPrimitive];\n        if (t) {\n          const i = t(_);\n          if (\"object\" != typeof i) return i;\n          throw new TypeError(\"Cannot convert object to primitive value\");\n        }\n      }\n      const t = i.valueOf;\n      if (t) {\n        const _ = t.call(i);\n        if (\"object\" != typeof _) return _;\n      }\n      const e = i.toString;\n      if (e) {\n        const _ = e.call(i);\n        if (\"object\" != typeof _) return _;\n      }\n      throw new TypeError(\"Cannot convert object to primitive value\");\n    }\n    static __toNumeric(i) {\n      return o.__isBigInt(i) ? i : +i;\n    }\n    static __isBigInt(i) {\n      return \"object\" == typeof i && null !== i && i.constructor === o;\n    }\n    static __truncateToNBits(i, _) {\n      const t = 0 | (i + 29) / 30,\n        e = new o(t, _.sign),\n        n = t - 1;\n      for (let t = 0; t < n; t++) e.__setDigit(t, _.__digit(t));\n      let g = _.__digit(n);\n      if (0 != i % 30) {\n        const _ = 32 - i % 30;\n        g = g << _ >>> _;\n      }\n      return e.__setDigit(n, g), e.__trim();\n    }\n    static __truncateAndSubFromPowerOfTwo(_, t, e) {\n      var n = Math.min;\n      const g = 0 | (_ + 29) / 30,\n        s = new o(g, e);\n      let l = 0;\n      const r = g - 1;\n      let a = 0;\n      for (const i = n(r, t.length); l < i; l++) {\n        const i = 0 - t.__digit(l) - a;\n        a = 1 & i >>> 30, s.__setDigit(l, 1073741823 & i);\n      }\n      for (; l < r; l++) s.__setDigit(l, 0 | 1073741823 & -a);\n      let u = r < t.length ? t.__digit(r) : 0;\n      const d = _ % 30;\n      let h;\n      if (0 == d) h = 0 - u - a, h &= 1073741823;else {\n        const i = 32 - d;\n        u = u << i >>> i;\n        const _ = 1 << 32 - i;\n        h = _ - u - a, h &= _ - 1;\n      }\n      return s.__setDigit(r, h), s.__trim();\n    }\n    __digit(_) {\n      return this[_];\n    }\n    __unsignedDigit(_) {\n      return this[_] >>> 0;\n    }\n    __setDigit(_, i) {\n      this[_] = 0 | i;\n    }\n    __setDigitGrow(_, i) {\n      this[_] = 0 | i;\n    }\n    __halfDigitLength() {\n      const i = this.length;\n      return 32767 >= this.__unsignedDigit(i - 1) ? 2 * i - 1 : 2 * i;\n    }\n    __halfDigit(_) {\n      return 32767 & this[_ >>> 1] >>> 15 * (1 & _);\n    }\n    __setHalfDigit(_, i) {\n      const t = _ >>> 1,\n        e = this.__digit(t),\n        n = 1 & _ ? 32767 & e | i << 15 : 1073709056 & e | 32767 & i;\n      this.__setDigit(t, n);\n    }\n    static __digitPow(i, _) {\n      let t = 1;\n      for (; 0 < _;) 1 & _ && (t *= i), _ >>>= 1, i *= i;\n      return t;\n    }\n    static __isOneDigitInt(i) {\n      return (1073741823 & i) === i;\n    }\n  }\n  return o.__kMaxLength = 33554432, o.__kMaxLengthBits = o.__kMaxLength << 5, o.__kMaxBitsPerChar = [0, 0, 32, 51, 64, 75, 83, 90, 96, 102, 107, 111, 115, 119, 122, 126, 128, 131, 134, 136, 139, 141, 143, 145, 147, 149, 151, 153, 154, 156, 158, 159, 160, 162, 163, 165, 166], o.__kBitsPerCharTableShift = 5, o.__kBitsPerCharTableMultiplier = 1 << o.__kBitsPerCharTableShift, o.__kConversionChars = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"], o.__kBitConversionBuffer = new ArrayBuffer(8), o.__kBitConversionDouble = new Float64Array(o.__kBitConversionBuffer), o.__kBitConversionInts = new Int32Array(o.__kBitConversionBuffer), o.__clz30 = _ ? function (i) {\n    return _(i) - 2;\n  } : function (i) {\n    var _ = Math.LN2,\n      t = Math.log;\n    return 0 === i ? 30 : 0 | 29 - (0 | t(i >>> 0) / _);\n  }, o.__imul = i || function (i, _) {\n    return 0 | i * _;\n  }, o;\n});\n//# sourceMappingURL=jsbi-umd.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}