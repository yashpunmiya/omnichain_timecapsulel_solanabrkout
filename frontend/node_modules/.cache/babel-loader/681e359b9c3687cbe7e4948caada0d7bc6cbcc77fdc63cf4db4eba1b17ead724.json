{"ast":null,"code":"import { AbiDecodingDataSizeTooSmallError, AbiDecodingZeroDataError, InvalidAbiDecodingTypeError } from '../../errors/abi.js';\nimport { checksumAddress } from '../address/getAddress.js';\nimport { createCursor } from '../cursor.js';\nimport { size } from '../data/size.js';\nimport { sliceBytes } from '../data/slice.js';\nimport { trim } from '../data/trim.js';\nimport { bytesToBigInt, bytesToBool, bytesToNumber, bytesToString } from '../encoding/fromBytes.js';\nimport { hexToBytes } from '../encoding/toBytes.js';\nimport { bytesToHex } from '../encoding/toHex.js';\nimport { getArrayComponents } from './encodeAbiParameters.js';\nexport function decodeAbiParameters(params, data) {\n  const bytes = typeof data === 'string' ? hexToBytes(data) : data;\n  const cursor = createCursor(bytes);\n  if (size(bytes) === 0 && params.length > 0) throw new AbiDecodingZeroDataError();\n  if (size(data) && size(data) < 32) throw new AbiDecodingDataSizeTooSmallError({\n    data: typeof data === 'string' ? data : bytesToHex(data),\n    params: params,\n    size: size(data)\n  });\n  let consumed = 0;\n  const values = [];\n  for (let i = 0; i < params.length; ++i) {\n    const param = params[i];\n    cursor.setPosition(consumed);\n    const [data, consumed_] = decodeParameter(cursor, param, {\n      staticPosition: 0\n    });\n    consumed += consumed_;\n    values.push(data);\n  }\n  return values;\n}\nfunction decodeParameter(cursor, param, {\n  staticPosition\n}) {\n  const arrayComponents = getArrayComponents(param.type);\n  if (arrayComponents) {\n    const [length, type] = arrayComponents;\n    return decodeArray(cursor, {\n      ...param,\n      type\n    }, {\n      length,\n      staticPosition\n    });\n  }\n  if (param.type === 'tuple') return decodeTuple(cursor, param, {\n    staticPosition\n  });\n  if (param.type === 'address') return decodeAddress(cursor);\n  if (param.type === 'bool') return decodeBool(cursor);\n  if (param.type.startsWith('bytes')) return decodeBytes(cursor, param, {\n    staticPosition\n  });\n  if (param.type.startsWith('uint') || param.type.startsWith('int')) return decodeNumber(cursor, param);\n  if (param.type === 'string') return decodeString(cursor, {\n    staticPosition\n  });\n  throw new InvalidAbiDecodingTypeError(param.type, {\n    docsPath: '/docs/contract/decodeAbiParameters'\n  });\n}\n////////////////////////////////////////////////////////////////////\n// Type Decoders\nconst sizeOfLength = 32;\nconst sizeOfOffset = 32;\nfunction decodeAddress(cursor) {\n  const value = cursor.readBytes(32);\n  return [checksumAddress(bytesToHex(sliceBytes(value, -20))), 32];\n}\nfunction decodeArray(cursor, param, {\n  length,\n  staticPosition\n}) {\n  // If the length of the array is not known in advance (dynamic array),\n  // this means we will need to wonder off to the pointer and decode.\n  if (!length) {\n    // Dealing with a dynamic type, so get the offset of the array data.\n    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset));\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset;\n    const startOfData = start + sizeOfLength;\n    // Get the length of the array from the offset.\n    cursor.setPosition(start);\n    const length = bytesToNumber(cursor.readBytes(sizeOfLength));\n    // Check if the array has any dynamic children.\n    const dynamicChild = hasDynamicChild(param);\n    let consumed = 0;\n    const value = [];\n    for (let i = 0; i < length; ++i) {\n      // If any of the children is dynamic, then all elements will be offset pointer, thus size of one slot (32 bytes).\n      // Otherwise, elements will be the size of their encoding (consumed bytes).\n      cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed));\n      const [data, consumed_] = decodeParameter(cursor, param, {\n        staticPosition: startOfData\n      });\n      consumed += consumed_;\n      value.push(data);\n    }\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32);\n    return [value, 32];\n  }\n  // If the length of the array is known in advance,\n  // and the length of an element deeply nested in the array is not known,\n  // we need to decode the offset of the array data.\n  if (hasDynamicChild(param)) {\n    // Dealing with dynamic types, so get the offset of the array data.\n    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset));\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset;\n    const value = [];\n    for (let i = 0; i < length; ++i) {\n      // Move cursor along to the next slot (next offset pointer).\n      cursor.setPosition(start + i * 32);\n      const [data] = decodeParameter(cursor, param, {\n        staticPosition: start\n      });\n      value.push(data);\n    }\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32);\n    return [value, 32];\n  }\n  // If the length of the array is known in advance and the array is deeply static,\n  // then we can just decode each element in sequence.\n  let consumed = 0;\n  const value = [];\n  for (let i = 0; i < length; ++i) {\n    const [data, consumed_] = decodeParameter(cursor, param, {\n      staticPosition: staticPosition + consumed\n    });\n    consumed += consumed_;\n    value.push(data);\n  }\n  return [value, consumed];\n}\nfunction decodeBool(cursor) {\n  return [bytesToBool(cursor.readBytes(32), {\n    size: 32\n  }), 32];\n}\nfunction decodeBytes(cursor, param, {\n  staticPosition\n}) {\n  const [_, size] = param.type.split('bytes');\n  if (!size) {\n    // Dealing with dynamic types, so get the offset of the bytes data.\n    const offset = bytesToNumber(cursor.readBytes(32));\n    // Set position of the cursor to start of bytes data.\n    cursor.setPosition(staticPosition + offset);\n    const length = bytesToNumber(cursor.readBytes(32));\n    // If there is no length, we have zero data.\n    if (length === 0) {\n      // As we have gone wondering, restore to the original position + next slot.\n      cursor.setPosition(staticPosition + 32);\n      return ['0x', 32];\n    }\n    const data = cursor.readBytes(length);\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32);\n    return [bytesToHex(data), 32];\n  }\n  const value = bytesToHex(cursor.readBytes(Number.parseInt(size), 32));\n  return [value, 32];\n}\nfunction decodeNumber(cursor, param) {\n  const signed = param.type.startsWith('int');\n  const size = Number.parseInt(param.type.split('int')[1] || '256');\n  const value = cursor.readBytes(32);\n  return [size > 48 ? bytesToBigInt(value, {\n    signed\n  }) : bytesToNumber(value, {\n    signed\n  }), 32];\n}\nfunction decodeTuple(cursor, param, {\n  staticPosition\n}) {\n  // Tuples can have unnamed components (i.e. they are arrays), so we must\n  // determine whether the tuple is named or unnamed. In the case of a named\n  // tuple, the value will be an object where each property is the name of the\n  // component. In the case of an unnamed tuple, the value will be an array.\n  const hasUnnamedChild = param.components.length === 0 || param.components.some(({\n    name\n  }) => !name);\n  // Initialize the value to an object or an array, depending on whether the\n  // tuple is named or unnamed.\n  const value = hasUnnamedChild ? [] : {};\n  let consumed = 0;\n  // If the tuple has a dynamic child, we must first decode the offset to the\n  // tuple data.\n  if (hasDynamicChild(param)) {\n    // Dealing with dynamic types, so get the offset of the tuple data.\n    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset));\n    // Start is the static position of referencing slot + offset.\n    const start = staticPosition + offset;\n    for (let i = 0; i < param.components.length; ++i) {\n      const component = param.components[i];\n      cursor.setPosition(start + consumed);\n      const [data, consumed_] = decodeParameter(cursor, component, {\n        staticPosition: start\n      });\n      consumed += consumed_;\n      value[hasUnnamedChild ? i : component?.name] = data;\n    }\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32);\n    return [value, 32];\n  }\n  // If the tuple has static children, we can just decode each component\n  // in sequence.\n  for (let i = 0; i < param.components.length; ++i) {\n    const component = param.components[i];\n    const [data, consumed_] = decodeParameter(cursor, component, {\n      staticPosition\n    });\n    value[hasUnnamedChild ? i : component?.name] = data;\n    consumed += consumed_;\n  }\n  return [value, consumed];\n}\nfunction decodeString(cursor, {\n  staticPosition\n}) {\n  // Get offset to start of string data.\n  const offset = bytesToNumber(cursor.readBytes(32));\n  // Start is the static position of current slot + offset.\n  const start = staticPosition + offset;\n  cursor.setPosition(start);\n  const length = bytesToNumber(cursor.readBytes(32));\n  // If there is no length, we have zero data (empty string).\n  if (length === 0) {\n    cursor.setPosition(staticPosition + 32);\n    return ['', 32];\n  }\n  const data = cursor.readBytes(length, 32);\n  const value = bytesToString(trim(data));\n  // As we have gone wondering, restore to the original position + next slot.\n  cursor.setPosition(staticPosition + 32);\n  return [value, 32];\n}\nfunction hasDynamicChild(param) {\n  const {\n    type\n  } = param;\n  if (type === 'string') return true;\n  if (type === 'bytes') return true;\n  if (type.endsWith('[]')) return true;\n  if (type === 'tuple') return param.components?.some(hasDynamicChild);\n  const arrayComponents = getArrayComponents(param.type);\n  if (arrayComponents && hasDynamicChild({\n    ...param,\n    type: arrayComponents[1]\n  })) return true;\n  return false;\n}","map":{"version":3,"names":["AbiDecodingDataSizeTooSmallError","AbiDecodingZeroDataError","InvalidAbiDecodingTypeError","checksumAddress","createCursor","size","sliceBytes","trim","bytesToBigInt","bytesToBool","bytesToNumber","bytesToString","hexToBytes","bytesToHex","getArrayComponents","decodeAbiParameters","params","data","bytes","cursor","length","consumed","values","i","param","setPosition","consumed_","decodeParameter","staticPosition","push","arrayComponents","type","decodeArray","decodeTuple","decodeAddress","decodeBool","startsWith","decodeBytes","decodeNumber","decodeString","docsPath","sizeOfLength","sizeOfOffset","value","readBytes","offset","start","startOfData","dynamicChild","hasDynamicChild","_","split","Number","parseInt","signed","hasUnnamedChild","components","some","name","component","endsWith"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\viem\\utils\\abi\\decodeAbiParameters.ts"],"sourcesContent":["import type { AbiParameter, AbiParametersToPrimitiveTypes } from 'abitype'\n\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\nimport {\n  AbiDecodingDataSizeTooSmallError,\n  AbiDecodingZeroDataError,\n  InvalidAbiDecodingTypeError,\n  type InvalidAbiDecodingTypeErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport {\n  type ChecksumAddressErrorType,\n  checksumAddress,\n} from '../address/getAddress.js'\nimport {\n  type CreateCursorErrorType,\n  type Cursor,\n  createCursor,\n} from '../cursor.js'\nimport { type SizeErrorType, size } from '../data/size.js'\nimport { type SliceBytesErrorType, sliceBytes } from '../data/slice.js'\nimport { type TrimErrorType, trim } from '../data/trim.js'\nimport {\n  type BytesToBigIntErrorType,\n  type BytesToBoolErrorType,\n  type BytesToNumberErrorType,\n  type BytesToStringErrorType,\n  bytesToBigInt,\n  bytesToBool,\n  bytesToNumber,\n  bytesToString,\n} from '../encoding/fromBytes.js'\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\nimport { getArrayComponents } from './encodeAbiParameters.js'\n\nexport type DecodeAbiParametersReturnType<\n  params extends readonly AbiParameter[] = readonly AbiParameter[],\n> = AbiParametersToPrimitiveTypes<\n  params extends readonly AbiParameter[] ? params : AbiParameter[]\n>\n\nexport type DecodeAbiParametersErrorType =\n  | HexToBytesErrorType\n  | BytesToHexErrorType\n  | DecodeParameterErrorType\n  | SizeErrorType\n  | CreateCursorErrorType\n  | ErrorType\n\nexport function decodeAbiParameters<\n  const params extends readonly AbiParameter[],\n>(\n  params: params,\n  data: ByteArray | Hex,\n): DecodeAbiParametersReturnType<params> {\n  const bytes = typeof data === 'string' ? hexToBytes(data) : data\n  const cursor = createCursor(bytes)\n\n  if (size(bytes) === 0 && params.length > 0)\n    throw new AbiDecodingZeroDataError()\n  if (size(data) && size(data) < 32)\n    throw new AbiDecodingDataSizeTooSmallError({\n      data: typeof data === 'string' ? data : bytesToHex(data),\n      params: params as readonly AbiParameter[],\n      size: size(data),\n    })\n\n  let consumed = 0\n  const values = []\n  for (let i = 0; i < params.length; ++i) {\n    const param = params[i]\n    cursor.setPosition(consumed)\n    const [data, consumed_] = decodeParameter(cursor, param, {\n      staticPosition: 0,\n    })\n    consumed += consumed_\n    values.push(data)\n  }\n  return values as DecodeAbiParametersReturnType<params>\n}\n\ntype DecodeParameterErrorType =\n  | DecodeArrayErrorType\n  | DecodeTupleErrorType\n  | DecodeAddressErrorType\n  | DecodeBoolErrorType\n  | DecodeBytesErrorType\n  | DecodeNumberErrorType\n  | DecodeStringErrorType\n  | InvalidAbiDecodingTypeErrorType\n\nfunction decodeParameter(\n  cursor: Cursor,\n  param: AbiParameter,\n  { staticPosition }: { staticPosition: number },\n) {\n  const arrayComponents = getArrayComponents(param.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return decodeArray(cursor, { ...param, type }, { length, staticPosition })\n  }\n  if (param.type === 'tuple')\n    return decodeTuple(cursor, param as TupleAbiParameter, { staticPosition })\n\n  if (param.type === 'address') return decodeAddress(cursor)\n  if (param.type === 'bool') return decodeBool(cursor)\n  if (param.type.startsWith('bytes'))\n    return decodeBytes(cursor, param, { staticPosition })\n  if (param.type.startsWith('uint') || param.type.startsWith('int'))\n    return decodeNumber(cursor, param)\n  if (param.type === 'string') return decodeString(cursor, { staticPosition })\n  throw new InvalidAbiDecodingTypeError(param.type, {\n    docsPath: '/docs/contract/decodeAbiParameters',\n  })\n}\n\n////////////////////////////////////////////////////////////////////\n// Type Decoders\n\nconst sizeOfLength = 32\nconst sizeOfOffset = 32\n\ntype DecodeAddressErrorType =\n  | ChecksumAddressErrorType\n  | BytesToHexErrorType\n  | SliceBytesErrorType\n  | ErrorType\n\nfunction decodeAddress(cursor: Cursor) {\n  const value = cursor.readBytes(32)\n  return [checksumAddress(bytesToHex(sliceBytes(value, -20))), 32]\n}\n\ntype DecodeArrayErrorType = BytesToNumberErrorType | ErrorType\n\nfunction decodeArray(\n  cursor: Cursor,\n  param: AbiParameter,\n  { length, staticPosition }: { length: number | null; staticPosition: number },\n) {\n  // If the length of the array is not known in advance (dynamic array),\n  // this means we will need to wonder off to the pointer and decode.\n  if (!length) {\n    // Dealing with a dynamic type, so get the offset of the array data.\n    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset\n    const startOfData = start + sizeOfLength\n\n    // Get the length of the array from the offset.\n    cursor.setPosition(start)\n    const length = bytesToNumber(cursor.readBytes(sizeOfLength))\n\n    // Check if the array has any dynamic children.\n    const dynamicChild = hasDynamicChild(param)\n\n    let consumed = 0\n    const value: unknown[] = []\n    for (let i = 0; i < length; ++i) {\n      // If any of the children is dynamic, then all elements will be offset pointer, thus size of one slot (32 bytes).\n      // Otherwise, elements will be the size of their encoding (consumed bytes).\n      cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed))\n      const [data, consumed_] = decodeParameter(cursor, param, {\n        staticPosition: startOfData,\n      })\n      consumed += consumed_\n      value.push(data)\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the length of the array is known in advance,\n  // and the length of an element deeply nested in the array is not known,\n  // we need to decode the offset of the array data.\n  if (hasDynamicChild(param)) {\n    // Dealing with dynamic types, so get the offset of the array data.\n    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset\n\n    const value: unknown[] = []\n    for (let i = 0; i < length; ++i) {\n      // Move cursor along to the next slot (next offset pointer).\n      cursor.setPosition(start + i * 32)\n      const [data] = decodeParameter(cursor, param, {\n        staticPosition: start,\n      })\n      value.push(data)\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the length of the array is known in advance and the array is deeply static,\n  // then we can just decode each element in sequence.\n  let consumed = 0\n  const value: unknown[] = []\n  for (let i = 0; i < length; ++i) {\n    const [data, consumed_] = decodeParameter(cursor, param, {\n      staticPosition: staticPosition + consumed,\n    })\n    consumed += consumed_\n    value.push(data)\n  }\n  return [value, consumed]\n}\n\ntype DecodeBoolErrorType = BytesToBoolErrorType | ErrorType\n\nfunction decodeBool(cursor: Cursor) {\n  return [bytesToBool(cursor.readBytes(32), { size: 32 }), 32]\n}\n\ntype DecodeBytesErrorType =\n  | BytesToNumberErrorType\n  | BytesToHexErrorType\n  | ErrorType\n\nfunction decodeBytes(\n  cursor: Cursor,\n  param: AbiParameter,\n  { staticPosition }: { staticPosition: number },\n) {\n  const [_, size] = param.type.split('bytes')\n  if (!size) {\n    // Dealing with dynamic types, so get the offset of the bytes data.\n    const offset = bytesToNumber(cursor.readBytes(32))\n\n    // Set position of the cursor to start of bytes data.\n    cursor.setPosition(staticPosition + offset)\n\n    const length = bytesToNumber(cursor.readBytes(32))\n\n    // If there is no length, we have zero data.\n    if (length === 0) {\n      // As we have gone wondering, restore to the original position + next slot.\n      cursor.setPosition(staticPosition + 32)\n      return ['0x', 32]\n    }\n\n    const data = cursor.readBytes(length)\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [bytesToHex(data), 32]\n  }\n\n  const value = bytesToHex(cursor.readBytes(Number.parseInt(size), 32))\n  return [value, 32]\n}\n\ntype DecodeNumberErrorType =\n  | BytesToNumberErrorType\n  | BytesToBigIntErrorType\n  | ErrorType\n\nfunction decodeNumber(cursor: Cursor, param: AbiParameter) {\n  const signed = param.type.startsWith('int')\n  const size = Number.parseInt(param.type.split('int')[1] || '256')\n  const value = cursor.readBytes(32)\n  return [\n    size > 48\n      ? bytesToBigInt(value, { signed })\n      : bytesToNumber(value, { signed }),\n    32,\n  ]\n}\n\ntype TupleAbiParameter = AbiParameter & { components: readonly AbiParameter[] }\n\ntype DecodeTupleErrorType = BytesToNumberErrorType | ErrorType\n\nfunction decodeTuple(\n  cursor: Cursor,\n  param: TupleAbiParameter,\n  { staticPosition }: { staticPosition: number },\n) {\n  // Tuples can have unnamed components (i.e. they are arrays), so we must\n  // determine whether the tuple is named or unnamed. In the case of a named\n  // tuple, the value will be an object where each property is the name of the\n  // component. In the case of an unnamed tuple, the value will be an array.\n  const hasUnnamedChild =\n    param.components.length === 0 || param.components.some(({ name }) => !name)\n\n  // Initialize the value to an object or an array, depending on whether the\n  // tuple is named or unnamed.\n  const value: any = hasUnnamedChild ? [] : {}\n  let consumed = 0\n\n  // If the tuple has a dynamic child, we must first decode the offset to the\n  // tuple data.\n  if (hasDynamicChild(param)) {\n    // Dealing with dynamic types, so get the offset of the tuple data.\n    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of referencing slot + offset.\n    const start = staticPosition + offset\n\n    for (let i = 0; i < param.components.length; ++i) {\n      const component = param.components[i]\n      cursor.setPosition(start + consumed)\n      const [data, consumed_] = decodeParameter(cursor, component, {\n        staticPosition: start,\n      })\n      consumed += consumed_\n      value[hasUnnamedChild ? i : component?.name!] = data\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the tuple has static children, we can just decode each component\n  // in sequence.\n  for (let i = 0; i < param.components.length; ++i) {\n    const component = param.components[i]\n    const [data, consumed_] = decodeParameter(cursor, component, {\n      staticPosition,\n    })\n    value[hasUnnamedChild ? i : component?.name!] = data\n    consumed += consumed_\n  }\n  return [value, consumed]\n}\n\ntype DecodeStringErrorType =\n  | BytesToNumberErrorType\n  | BytesToStringErrorType\n  | TrimErrorType\n  | ErrorType\n\nfunction decodeString(\n  cursor: Cursor,\n  { staticPosition }: { staticPosition: number },\n) {\n  // Get offset to start of string data.\n  const offset = bytesToNumber(cursor.readBytes(32))\n\n  // Start is the static position of current slot + offset.\n  const start = staticPosition + offset\n  cursor.setPosition(start)\n\n  const length = bytesToNumber(cursor.readBytes(32))\n\n  // If there is no length, we have zero data (empty string).\n  if (length === 0) {\n    cursor.setPosition(staticPosition + 32)\n    return ['', 32]\n  }\n\n  const data = cursor.readBytes(length, 32)\n  const value = bytesToString(trim(data))\n\n  // As we have gone wondering, restore to the original position + next slot.\n  cursor.setPosition(staticPosition + 32)\n\n  return [value, 32]\n}\n\nfunction hasDynamicChild(param: AbiParameter) {\n  const { type } = param\n  if (type === 'string') return true\n  if (type === 'bytes') return true\n  if (type.endsWith('[]')) return true\n\n  if (type === 'tuple') return (param as any).components?.some(hasDynamicChild)\n\n  const arrayComponents = getArrayComponents(param.type)\n  if (\n    arrayComponents &&\n    hasDynamicChild({ ...param, type: arrayComponents[1] } as AbiParameter)\n  )\n    return true\n\n  return false\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}