{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ValueErrorIterator = exports.ValueErrorsUnknownTypeError = exports.ValueErrorType = void 0;\nexports.Errors = Errors;\nconst index_1 = require(\"../system/index\");\nconst index_2 = require(\"../type/keyof/index\");\nconst index_3 = require(\"../type/registry/index\");\nconst extends_undefined_1 = require(\"../type/extends/extends-undefined\");\nconst function_1 = require(\"./function\");\nconst index_4 = require(\"../type/error/index\");\nconst index_5 = require(\"../value/deref/index\");\nconst index_6 = require(\"../value/hash/index\");\nconst index_7 = require(\"../value/check/index\");\nconst index_8 = require(\"../type/symbols/index\");\nconst index_9 = require(\"../type/never/index\");\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\n// prettier-ignore\nconst index_10 = require(\"../value/guard/index\");\n// ------------------------------------------------------------------\n// ValueErrorType\n// ------------------------------------------------------------------\nvar ValueErrorType;\n(function (ValueErrorType) {\n  ValueErrorType[ValueErrorType[\"ArrayContains\"] = 0] = \"ArrayContains\";\n  ValueErrorType[ValueErrorType[\"ArrayMaxContains\"] = 1] = \"ArrayMaxContains\";\n  ValueErrorType[ValueErrorType[\"ArrayMaxItems\"] = 2] = \"ArrayMaxItems\";\n  ValueErrorType[ValueErrorType[\"ArrayMinContains\"] = 3] = \"ArrayMinContains\";\n  ValueErrorType[ValueErrorType[\"ArrayMinItems\"] = 4] = \"ArrayMinItems\";\n  ValueErrorType[ValueErrorType[\"ArrayUniqueItems\"] = 5] = \"ArrayUniqueItems\";\n  ValueErrorType[ValueErrorType[\"Array\"] = 6] = \"Array\";\n  ValueErrorType[ValueErrorType[\"AsyncIterator\"] = 7] = \"AsyncIterator\";\n  ValueErrorType[ValueErrorType[\"BigIntExclusiveMaximum\"] = 8] = \"BigIntExclusiveMaximum\";\n  ValueErrorType[ValueErrorType[\"BigIntExclusiveMinimum\"] = 9] = \"BigIntExclusiveMinimum\";\n  ValueErrorType[ValueErrorType[\"BigIntMaximum\"] = 10] = \"BigIntMaximum\";\n  ValueErrorType[ValueErrorType[\"BigIntMinimum\"] = 11] = \"BigIntMinimum\";\n  ValueErrorType[ValueErrorType[\"BigIntMultipleOf\"] = 12] = \"BigIntMultipleOf\";\n  ValueErrorType[ValueErrorType[\"BigInt\"] = 13] = \"BigInt\";\n  ValueErrorType[ValueErrorType[\"Boolean\"] = 14] = \"Boolean\";\n  ValueErrorType[ValueErrorType[\"DateExclusiveMaximumTimestamp\"] = 15] = \"DateExclusiveMaximumTimestamp\";\n  ValueErrorType[ValueErrorType[\"DateExclusiveMinimumTimestamp\"] = 16] = \"DateExclusiveMinimumTimestamp\";\n  ValueErrorType[ValueErrorType[\"DateMaximumTimestamp\"] = 17] = \"DateMaximumTimestamp\";\n  ValueErrorType[ValueErrorType[\"DateMinimumTimestamp\"] = 18] = \"DateMinimumTimestamp\";\n  ValueErrorType[ValueErrorType[\"DateMultipleOfTimestamp\"] = 19] = \"DateMultipleOfTimestamp\";\n  ValueErrorType[ValueErrorType[\"Date\"] = 20] = \"Date\";\n  ValueErrorType[ValueErrorType[\"Function\"] = 21] = \"Function\";\n  ValueErrorType[ValueErrorType[\"IntegerExclusiveMaximum\"] = 22] = \"IntegerExclusiveMaximum\";\n  ValueErrorType[ValueErrorType[\"IntegerExclusiveMinimum\"] = 23] = \"IntegerExclusiveMinimum\";\n  ValueErrorType[ValueErrorType[\"IntegerMaximum\"] = 24] = \"IntegerMaximum\";\n  ValueErrorType[ValueErrorType[\"IntegerMinimum\"] = 25] = \"IntegerMinimum\";\n  ValueErrorType[ValueErrorType[\"IntegerMultipleOf\"] = 26] = \"IntegerMultipleOf\";\n  ValueErrorType[ValueErrorType[\"Integer\"] = 27] = \"Integer\";\n  ValueErrorType[ValueErrorType[\"IntersectUnevaluatedProperties\"] = 28] = \"IntersectUnevaluatedProperties\";\n  ValueErrorType[ValueErrorType[\"Intersect\"] = 29] = \"Intersect\";\n  ValueErrorType[ValueErrorType[\"Iterator\"] = 30] = \"Iterator\";\n  ValueErrorType[ValueErrorType[\"Kind\"] = 31] = \"Kind\";\n  ValueErrorType[ValueErrorType[\"Literal\"] = 32] = \"Literal\";\n  ValueErrorType[ValueErrorType[\"Never\"] = 33] = \"Never\";\n  ValueErrorType[ValueErrorType[\"Not\"] = 34] = \"Not\";\n  ValueErrorType[ValueErrorType[\"Null\"] = 35] = \"Null\";\n  ValueErrorType[ValueErrorType[\"NumberExclusiveMaximum\"] = 36] = \"NumberExclusiveMaximum\";\n  ValueErrorType[ValueErrorType[\"NumberExclusiveMinimum\"] = 37] = \"NumberExclusiveMinimum\";\n  ValueErrorType[ValueErrorType[\"NumberMaximum\"] = 38] = \"NumberMaximum\";\n  ValueErrorType[ValueErrorType[\"NumberMinimum\"] = 39] = \"NumberMinimum\";\n  ValueErrorType[ValueErrorType[\"NumberMultipleOf\"] = 40] = \"NumberMultipleOf\";\n  ValueErrorType[ValueErrorType[\"Number\"] = 41] = \"Number\";\n  ValueErrorType[ValueErrorType[\"ObjectAdditionalProperties\"] = 42] = \"ObjectAdditionalProperties\";\n  ValueErrorType[ValueErrorType[\"ObjectMaxProperties\"] = 43] = \"ObjectMaxProperties\";\n  ValueErrorType[ValueErrorType[\"ObjectMinProperties\"] = 44] = \"ObjectMinProperties\";\n  ValueErrorType[ValueErrorType[\"ObjectRequiredProperty\"] = 45] = \"ObjectRequiredProperty\";\n  ValueErrorType[ValueErrorType[\"Object\"] = 46] = \"Object\";\n  ValueErrorType[ValueErrorType[\"Promise\"] = 47] = \"Promise\";\n  ValueErrorType[ValueErrorType[\"RegExp\"] = 48] = \"RegExp\";\n  ValueErrorType[ValueErrorType[\"StringFormatUnknown\"] = 49] = \"StringFormatUnknown\";\n  ValueErrorType[ValueErrorType[\"StringFormat\"] = 50] = \"StringFormat\";\n  ValueErrorType[ValueErrorType[\"StringMaxLength\"] = 51] = \"StringMaxLength\";\n  ValueErrorType[ValueErrorType[\"StringMinLength\"] = 52] = \"StringMinLength\";\n  ValueErrorType[ValueErrorType[\"StringPattern\"] = 53] = \"StringPattern\";\n  ValueErrorType[ValueErrorType[\"String\"] = 54] = \"String\";\n  ValueErrorType[ValueErrorType[\"Symbol\"] = 55] = \"Symbol\";\n  ValueErrorType[ValueErrorType[\"TupleLength\"] = 56] = \"TupleLength\";\n  ValueErrorType[ValueErrorType[\"Tuple\"] = 57] = \"Tuple\";\n  ValueErrorType[ValueErrorType[\"Uint8ArrayMaxByteLength\"] = 58] = \"Uint8ArrayMaxByteLength\";\n  ValueErrorType[ValueErrorType[\"Uint8ArrayMinByteLength\"] = 59] = \"Uint8ArrayMinByteLength\";\n  ValueErrorType[ValueErrorType[\"Uint8Array\"] = 60] = \"Uint8Array\";\n  ValueErrorType[ValueErrorType[\"Undefined\"] = 61] = \"Undefined\";\n  ValueErrorType[ValueErrorType[\"Union\"] = 62] = \"Union\";\n  ValueErrorType[ValueErrorType[\"Void\"] = 63] = \"Void\";\n})(ValueErrorType || (exports.ValueErrorType = ValueErrorType = {}));\n// ------------------------------------------------------------------\n// ValueErrors\n// ------------------------------------------------------------------\nclass ValueErrorsUnknownTypeError extends index_4.TypeBoxError {\n  constructor(schema) {\n    super('Unknown type');\n    this.schema = schema;\n  }\n}\nexports.ValueErrorsUnknownTypeError = ValueErrorsUnknownTypeError;\n// ------------------------------------------------------------------\n// EscapeKey\n// ------------------------------------------------------------------\nfunction EscapeKey(key) {\n  return key.replace(/~/g, '~0').replace(/\\//g, '~1'); // RFC6901 Path\n}\n// ------------------------------------------------------------------\n// Guards\n// ------------------------------------------------------------------\nfunction IsDefined(value) {\n  return value !== undefined;\n}\n// ------------------------------------------------------------------\n// ValueErrorIterator\n// ------------------------------------------------------------------\nclass ValueErrorIterator {\n  constructor(iterator) {\n    this.iterator = iterator;\n  }\n  [Symbol.iterator]() {\n    return this.iterator;\n  }\n  /** Returns the first value error or undefined if no errors */\n  First() {\n    const next = this.iterator.next();\n    return next.done ? undefined : next.value;\n  }\n}\nexports.ValueErrorIterator = ValueErrorIterator;\n// --------------------------------------------------------------------------\n// Create\n// --------------------------------------------------------------------------\nfunction Create(errorType, schema, path, value, errors = []) {\n  return {\n    type: errorType,\n    schema,\n    path,\n    value,\n    message: (0, function_1.GetErrorFunction)()({\n      errorType,\n      path,\n      schema,\n      value,\n      errors\n    }),\n    errors\n  };\n}\n// --------------------------------------------------------------------------\n// Types\n// --------------------------------------------------------------------------\nfunction* FromAny(schema, references, path, value) {}\nfunction* FromArray(schema, references, path, value) {\n  if (!(0, index_10.IsArray)(value)) {\n    return yield Create(ValueErrorType.Array, schema, path, value);\n  }\n  if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {\n    yield Create(ValueErrorType.ArrayMinItems, schema, path, value);\n  }\n  if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {\n    yield Create(ValueErrorType.ArrayMaxItems, schema, path, value);\n  }\n  for (let i = 0; i < value.length; i++) {\n    yield* Visit(schema.items, references, `${path}/${i}`, value[i]);\n  }\n  // prettier-ignore\n  if (schema.uniqueItems === true && !function () {\n    const set = new Set();\n    for (const element of value) {\n      const hashed = (0, index_6.Hash)(element);\n      if (set.has(hashed)) {\n        return false;\n      } else {\n        set.add(hashed);\n      }\n    }\n    return true;\n  }()) {\n    yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value);\n  }\n  // contains\n  if (!(IsDefined(schema.contains) || IsDefined(schema.minContains) || IsDefined(schema.maxContains))) {\n    return;\n  }\n  const containsSchema = IsDefined(schema.contains) ? schema.contains : (0, index_9.Never)();\n  const containsCount = value.reduce((acc, value, index) => Visit(containsSchema, references, `${path}${index}`, value).next().done === true ? acc + 1 : acc, 0);\n  if (containsCount === 0) {\n    yield Create(ValueErrorType.ArrayContains, schema, path, value);\n  }\n  if ((0, index_10.IsNumber)(schema.minContains) && containsCount < schema.minContains) {\n    yield Create(ValueErrorType.ArrayMinContains, schema, path, value);\n  }\n  if ((0, index_10.IsNumber)(schema.maxContains) && containsCount > schema.maxContains) {\n    yield Create(ValueErrorType.ArrayMaxContains, schema, path, value);\n  }\n}\nfunction* FromAsyncIterator(schema, references, path, value) {\n  if (!(0, index_10.IsAsyncIterator)(value)) yield Create(ValueErrorType.AsyncIterator, schema, path, value);\n}\nfunction* FromBigInt(schema, references, path, value) {\n  if (!(0, index_10.IsBigInt)(value)) return yield Create(ValueErrorType.BigInt, schema, path, value);\n  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n    yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value);\n  }\n  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n    yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value);\n  }\n  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n    yield Create(ValueErrorType.BigIntMaximum, schema, path, value);\n  }\n  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n    yield Create(ValueErrorType.BigIntMinimum, schema, path, value);\n  }\n  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {\n    yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value);\n  }\n}\nfunction* FromBoolean(schema, references, path, value) {\n  if (!(0, index_10.IsBoolean)(value)) yield Create(ValueErrorType.Boolean, schema, path, value);\n}\nfunction* FromConstructor(schema, references, path, value) {\n  yield* Visit(schema.returns, references, path, value.prototype);\n}\nfunction* FromDate(schema, references, path, value) {\n  if (!(0, index_10.IsDate)(value)) return yield Create(ValueErrorType.Date, schema, path, value);\n  if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {\n    yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value);\n  }\n  if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {\n    yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value);\n  }\n  if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {\n    yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value);\n  }\n  if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {\n    yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value);\n  }\n  if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {\n    yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value);\n  }\n}\nfunction* FromFunction(schema, references, path, value) {\n  if (!(0, index_10.IsFunction)(value)) yield Create(ValueErrorType.Function, schema, path, value);\n}\nfunction* FromInteger(schema, references, path, value) {\n  if (!(0, index_10.IsInteger)(value)) return yield Create(ValueErrorType.Integer, schema, path, value);\n  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n    yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value);\n  }\n  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n    yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value);\n  }\n  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n    yield Create(ValueErrorType.IntegerMaximum, schema, path, value);\n  }\n  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n    yield Create(ValueErrorType.IntegerMinimum, schema, path, value);\n  }\n  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n    yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value);\n  }\n}\nfunction* FromIntersect(schema, references, path, value) {\n  let hasError = false;\n  for (const inner of schema.allOf) {\n    for (const error of Visit(inner, references, path, value)) {\n      hasError = true;\n      yield error;\n    }\n  }\n  if (hasError) {\n    return yield Create(ValueErrorType.Intersect, schema, path, value);\n  }\n  if (schema.unevaluatedProperties === false) {\n    const keyCheck = new RegExp((0, index_2.KeyOfPattern)(schema));\n    for (const valueKey of Object.getOwnPropertyNames(value)) {\n      if (!keyCheck.test(valueKey)) {\n        yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value);\n      }\n    }\n  }\n  if (typeof schema.unevaluatedProperties === 'object') {\n    const keyCheck = new RegExp((0, index_2.KeyOfPattern)(schema));\n    for (const valueKey of Object.getOwnPropertyNames(value)) {\n      if (!keyCheck.test(valueKey)) {\n        const next = Visit(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();\n        if (!next.done) yield next.value; // yield interior\n      }\n    }\n  }\n}\nfunction* FromIterator(schema, references, path, value) {\n  if (!(0, index_10.IsIterator)(value)) yield Create(ValueErrorType.Iterator, schema, path, value);\n}\nfunction* FromLiteral(schema, references, path, value) {\n  if (!(value === schema.const)) yield Create(ValueErrorType.Literal, schema, path, value);\n}\nfunction* FromNever(schema, references, path, value) {\n  yield Create(ValueErrorType.Never, schema, path, value);\n}\nfunction* FromNot(schema, references, path, value) {\n  if (Visit(schema.not, references, path, value).next().done === true) yield Create(ValueErrorType.Not, schema, path, value);\n}\nfunction* FromNull(schema, references, path, value) {\n  if (!(0, index_10.IsNull)(value)) yield Create(ValueErrorType.Null, schema, path, value);\n}\nfunction* FromNumber(schema, references, path, value) {\n  if (!index_1.TypeSystemPolicy.IsNumberLike(value)) return yield Create(ValueErrorType.Number, schema, path, value);\n  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n    yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value);\n  }\n  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n    yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value);\n  }\n  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n    yield Create(ValueErrorType.NumberMaximum, schema, path, value);\n  }\n  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n    yield Create(ValueErrorType.NumberMinimum, schema, path, value);\n  }\n  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n    yield Create(ValueErrorType.NumberMultipleOf, schema, path, value);\n  }\n}\nfunction* FromObject(schema, references, path, value) {\n  if (!index_1.TypeSystemPolicy.IsObjectLike(value)) return yield Create(ValueErrorType.Object, schema, path, value);\n  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);\n  }\n  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);\n  }\n  const requiredKeys = Array.isArray(schema.required) ? schema.required : [];\n  const knownKeys = Object.getOwnPropertyNames(schema.properties);\n  const unknownKeys = Object.getOwnPropertyNames(value);\n  for (const requiredKey of requiredKeys) {\n    if (unknownKeys.includes(requiredKey)) continue;\n    yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);\n  }\n  if (schema.additionalProperties === false) {\n    for (const valueKey of unknownKeys) {\n      if (!knownKeys.includes(valueKey)) {\n        yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);\n      }\n    }\n  }\n  if (typeof schema.additionalProperties === 'object') {\n    for (const valueKey of unknownKeys) {\n      if (knownKeys.includes(valueKey)) continue;\n      yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);\n    }\n  }\n  for (const knownKey of knownKeys) {\n    const property = schema.properties[knownKey];\n    if (schema.required && schema.required.includes(knownKey)) {\n      yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);\n      if ((0, extends_undefined_1.ExtendsUndefinedCheck)(schema) && !(knownKey in value)) {\n        yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);\n      }\n    } else {\n      if (index_1.TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {\n        yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);\n      }\n    }\n  }\n}\nfunction* FromPromise(schema, references, path, value) {\n  if (!(0, index_10.IsPromise)(value)) yield Create(ValueErrorType.Promise, schema, path, value);\n}\nfunction* FromRecord(schema, references, path, value) {\n  if (!index_1.TypeSystemPolicy.IsRecordLike(value)) return yield Create(ValueErrorType.Object, schema, path, value);\n  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);\n  }\n  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);\n  }\n  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];\n  const regex = new RegExp(patternKey);\n  for (const [propertyKey, propertyValue] of Object.entries(value)) {\n    if (regex.test(propertyKey)) yield* Visit(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n  }\n  if (typeof schema.additionalProperties === 'object') {\n    for (const [propertyKey, propertyValue] of Object.entries(value)) {\n      if (!regex.test(propertyKey)) yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n    }\n  }\n  if (schema.additionalProperties === false) {\n    for (const [propertyKey, propertyValue] of Object.entries(value)) {\n      if (regex.test(propertyKey)) continue;\n      return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n    }\n  }\n}\nfunction* FromRef(schema, references, path, value) {\n  yield* Visit((0, index_5.Deref)(schema, references), references, path, value);\n}\nfunction* FromRegExp(schema, references, path, value) {\n  if (!(0, index_10.IsString)(value)) return yield Create(ValueErrorType.String, schema, path, value);\n  if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {\n    yield Create(ValueErrorType.StringMinLength, schema, path, value);\n  }\n  if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {\n    yield Create(ValueErrorType.StringMaxLength, schema, path, value);\n  }\n  const regex = new RegExp(schema.source, schema.flags);\n  if (!regex.test(value)) {\n    return yield Create(ValueErrorType.RegExp, schema, path, value);\n  }\n}\nfunction* FromString(schema, references, path, value) {\n  if (!(0, index_10.IsString)(value)) return yield Create(ValueErrorType.String, schema, path, value);\n  if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {\n    yield Create(ValueErrorType.StringMinLength, schema, path, value);\n  }\n  if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {\n    yield Create(ValueErrorType.StringMaxLength, schema, path, value);\n  }\n  if ((0, index_10.IsString)(schema.pattern)) {\n    const regex = new RegExp(schema.pattern);\n    if (!regex.test(value)) {\n      yield Create(ValueErrorType.StringPattern, schema, path, value);\n    }\n  }\n  if ((0, index_10.IsString)(schema.format)) {\n    if (!index_3.FormatRegistry.Has(schema.format)) {\n      yield Create(ValueErrorType.StringFormatUnknown, schema, path, value);\n    } else {\n      const format = index_3.FormatRegistry.Get(schema.format);\n      if (!format(value)) {\n        yield Create(ValueErrorType.StringFormat, schema, path, value);\n      }\n    }\n  }\n}\nfunction* FromSymbol(schema, references, path, value) {\n  if (!(0, index_10.IsSymbol)(value)) yield Create(ValueErrorType.Symbol, schema, path, value);\n}\nfunction* FromTemplateLiteral(schema, references, path, value) {\n  if (!(0, index_10.IsString)(value)) return yield Create(ValueErrorType.String, schema, path, value);\n  const regex = new RegExp(schema.pattern);\n  if (!regex.test(value)) {\n    yield Create(ValueErrorType.StringPattern, schema, path, value);\n  }\n}\nfunction* FromThis(schema, references, path, value) {\n  yield* Visit((0, index_5.Deref)(schema, references), references, path, value);\n}\nfunction* FromTuple(schema, references, path, value) {\n  if (!(0, index_10.IsArray)(value)) return yield Create(ValueErrorType.Tuple, schema, path, value);\n  if (schema.items === undefined && !(value.length === 0)) {\n    return yield Create(ValueErrorType.TupleLength, schema, path, value);\n  }\n  if (!(value.length === schema.maxItems)) {\n    return yield Create(ValueErrorType.TupleLength, schema, path, value);\n  }\n  if (!schema.items) {\n    return;\n  }\n  for (let i = 0; i < schema.items.length; i++) {\n    yield* Visit(schema.items[i], references, `${path}/${i}`, value[i]);\n  }\n}\nfunction* FromUndefined(schema, references, path, value) {\n  if (!(0, index_10.IsUndefined)(value)) yield Create(ValueErrorType.Undefined, schema, path, value);\n}\nfunction* FromUnion(schema, references, path, value) {\n  if ((0, index_7.Check)(schema, references, value)) return;\n  const errors = schema.anyOf.map(variant => new ValueErrorIterator(Visit(variant, references, path, value)));\n  yield Create(ValueErrorType.Union, schema, path, value, errors);\n}\nfunction* FromUint8Array(schema, references, path, value) {\n  if (!(0, index_10.IsUint8Array)(value)) return yield Create(ValueErrorType.Uint8Array, schema, path, value);\n  if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {\n    yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value);\n  }\n  if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {\n    yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value);\n  }\n}\nfunction* FromUnknown(schema, references, path, value) {}\nfunction* FromVoid(schema, references, path, value) {\n  if (!index_1.TypeSystemPolicy.IsVoidLike(value)) yield Create(ValueErrorType.Void, schema, path, value);\n}\nfunction* FromKind(schema, references, path, value) {\n  const check = index_3.TypeRegistry.Get(schema[index_8.Kind]);\n  if (!check(schema, value)) yield Create(ValueErrorType.Kind, schema, path, value);\n}\nfunction* Visit(schema, references, path, value) {\n  const references_ = IsDefined(schema.$id) ? [...references, schema] : references;\n  const schema_ = schema;\n  switch (schema_[index_8.Kind]) {\n    case 'Any':\n      return yield* FromAny(schema_, references_, path, value);\n    case 'Array':\n      return yield* FromArray(schema_, references_, path, value);\n    case 'AsyncIterator':\n      return yield* FromAsyncIterator(schema_, references_, path, value);\n    case 'BigInt':\n      return yield* FromBigInt(schema_, references_, path, value);\n    case 'Boolean':\n      return yield* FromBoolean(schema_, references_, path, value);\n    case 'Constructor':\n      return yield* FromConstructor(schema_, references_, path, value);\n    case 'Date':\n      return yield* FromDate(schema_, references_, path, value);\n    case 'Function':\n      return yield* FromFunction(schema_, references_, path, value);\n    case 'Integer':\n      return yield* FromInteger(schema_, references_, path, value);\n    case 'Intersect':\n      return yield* FromIntersect(schema_, references_, path, value);\n    case 'Iterator':\n      return yield* FromIterator(schema_, references_, path, value);\n    case 'Literal':\n      return yield* FromLiteral(schema_, references_, path, value);\n    case 'Never':\n      return yield* FromNever(schema_, references_, path, value);\n    case 'Not':\n      return yield* FromNot(schema_, references_, path, value);\n    case 'Null':\n      return yield* FromNull(schema_, references_, path, value);\n    case 'Number':\n      return yield* FromNumber(schema_, references_, path, value);\n    case 'Object':\n      return yield* FromObject(schema_, references_, path, value);\n    case 'Promise':\n      return yield* FromPromise(schema_, references_, path, value);\n    case 'Record':\n      return yield* FromRecord(schema_, references_, path, value);\n    case 'Ref':\n      return yield* FromRef(schema_, references_, path, value);\n    case 'RegExp':\n      return yield* FromRegExp(schema_, references_, path, value);\n    case 'String':\n      return yield* FromString(schema_, references_, path, value);\n    case 'Symbol':\n      return yield* FromSymbol(schema_, references_, path, value);\n    case 'TemplateLiteral':\n      return yield* FromTemplateLiteral(schema_, references_, path, value);\n    case 'This':\n      return yield* FromThis(schema_, references_, path, value);\n    case 'Tuple':\n      return yield* FromTuple(schema_, references_, path, value);\n    case 'Undefined':\n      return yield* FromUndefined(schema_, references_, path, value);\n    case 'Union':\n      return yield* FromUnion(schema_, references_, path, value);\n    case 'Uint8Array':\n      return yield* FromUint8Array(schema_, references_, path, value);\n    case 'Unknown':\n      return yield* FromUnknown(schema_, references_, path, value);\n    case 'Void':\n      return yield* FromVoid(schema_, references_, path, value);\n    default:\n      if (!index_3.TypeRegistry.Has(schema_[index_8.Kind])) throw new ValueErrorsUnknownTypeError(schema);\n      return yield* FromKind(schema_, references_, path, value);\n  }\n}\n/** Returns an iterator for each error in this value. */\nfunction Errors(...args) {\n  const iterator = args.length === 3 ? Visit(args[0], args[1], '', args[2]) : Visit(args[0], [], '', args[1]);\n  return new ValueErrorIterator(iterator);\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}