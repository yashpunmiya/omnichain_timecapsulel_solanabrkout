{"ast":null,"code":"import { execTyped } from '../regex.js';\n// https://regexr.com/7f7rv\nconst tupleRegex = /^tuple(?<array>(\\[(\\d*)\\])*)$/;\n/**\n * Formats {@link AbiParameter} to human-readable ABI parameter.\n *\n * @param abiParameter - ABI parameter\n * @returns Human-readable ABI parameter\n *\n * @example\n * const result = formatAbiParameter({ type: 'address', name: 'from' })\n * //    ^? const result: 'address from'\n */\nexport function formatAbiParameter(abiParameter) {\n  let type = abiParameter.type;\n  if (tupleRegex.test(abiParameter.type) && 'components' in abiParameter) {\n    type = '(';\n    const length = abiParameter.components.length;\n    for (let i = 0; i < length; i++) {\n      const component = abiParameter.components[i];\n      type += formatAbiParameter(component);\n      if (i < length - 1) type += ', ';\n    }\n    const result = execTyped(tupleRegex, abiParameter.type);\n    type += `)${result?.array ?? ''}`;\n    return formatAbiParameter({\n      ...abiParameter,\n      type\n    });\n  }\n  // Add `indexed` to type if in `abiParameter`\n  if ('indexed' in abiParameter && abiParameter.indexed) type = `${type} indexed`;\n  // Return human-readable ABI parameter\n  if (abiParameter.name) return `${type} ${abiParameter.name}`;\n  return type;\n}","map":{"version":3,"names":["execTyped","tupleRegex","formatAbiParameter","abiParameter","type","test","length","components","i","component","result","array","indexed","name"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\abitype\\src\\human-readable\\formatAbiParameter.ts"],"sourcesContent":["import type { AbiEventParameter, AbiParameter } from '../abi.js'\nimport { execTyped } from '../regex.js'\nimport type { IsNarrowable, Join } from '../types.js'\nimport type { AssertName } from './types/signatures.js'\n\n/**\n * Formats {@link AbiParameter} to human-readable ABI parameter.\n *\n * @param abiParameter - ABI parameter\n * @returns Human-readable ABI parameter\n *\n * @example\n * type Result = FormatAbiParameter<{ type: 'address'; name: 'from'; }>\n * //   ^? type Result = 'address from'\n */\nexport type FormatAbiParameter<\n  abiParameter extends AbiParameter | AbiEventParameter,\n> = abiParameter extends {\n  name?: infer name extends string\n  type: `tuple${infer array}`\n  components: infer components extends readonly AbiParameter[]\n  indexed?: infer indexed extends boolean\n}\n  ? FormatAbiParameter<\n      {\n        type: `(${Join<\n          {\n            [key in keyof components]: FormatAbiParameter<\n              {\n                type: components[key]['type']\n              } & (IsNarrowable<components[key]['name'], string> extends true\n                ? { name: components[key]['name'] }\n                : unknown) &\n                (components[key] extends { components: readonly AbiParameter[] }\n                  ? { components: components[key]['components'] }\n                  : unknown)\n            >\n          },\n          ', '\n        >})${array}`\n      } & (IsNarrowable<name, string> extends true ? { name: name } : unknown) &\n        (IsNarrowable<indexed, boolean> extends true\n          ? { indexed: indexed }\n          : unknown)\n    >\n  : `${abiParameter['type']}${abiParameter extends { indexed: true }\n      ? ' indexed'\n      : ''}${abiParameter['name'] extends infer name extends string\n      ? name extends ''\n        ? ''\n        : ` ${AssertName<name>}`\n      : ''}`\n\n// https://regexr.com/7f7rv\nconst tupleRegex = /^tuple(?<array>(\\[(\\d*)\\])*)$/\n\n/**\n * Formats {@link AbiParameter} to human-readable ABI parameter.\n *\n * @param abiParameter - ABI parameter\n * @returns Human-readable ABI parameter\n *\n * @example\n * const result = formatAbiParameter({ type: 'address', name: 'from' })\n * //    ^? const result: 'address from'\n */\nexport function formatAbiParameter<\n  const abiParameter extends AbiParameter | AbiEventParameter,\n>(abiParameter: abiParameter): FormatAbiParameter<abiParameter> {\n  type Result = FormatAbiParameter<abiParameter>\n\n  let type = abiParameter.type\n  if (tupleRegex.test(abiParameter.type) && 'components' in abiParameter) {\n    type = '('\n    const length = abiParameter.components.length as number\n    for (let i = 0; i < length; i++) {\n      const component = abiParameter.components[i]!\n      type += formatAbiParameter(component)\n      if (i < length - 1) type += ', '\n    }\n    const result = execTyped<{ array?: string }>(tupleRegex, abiParameter.type)\n    type += `)${result?.array ?? ''}`\n    return formatAbiParameter({\n      ...abiParameter,\n      type,\n    }) as Result\n  }\n  // Add `indexed` to type if in `abiParameter`\n  if ('indexed' in abiParameter && abiParameter.indexed)\n    type = `${type} indexed`\n  // Return human-readable ABI parameter\n  if (abiParameter.name) return `${type} ${abiParameter.name}` as Result\n  return type as Result\n}\n"],"mappings":"AACA,SAASA,SAAS,QAAQ,aAAa;AAoDvC;AACA,MAAMC,UAAU,GAAG,+BAA+B;AAElD;;;;;;;;;;AAUA,OAAM,SAAUC,kBAAkBA,CAEhCC,YAA0B;EAG1B,IAAIC,IAAI,GAAGD,YAAY,CAACC,IAAI;EAC5B,IAAIH,UAAU,CAACI,IAAI,CAACF,YAAY,CAACC,IAAI,CAAC,IAAI,YAAY,IAAID,YAAY,EAAE;IACtEC,IAAI,GAAG,GAAG;IACV,MAAME,MAAM,GAAGH,YAAY,CAACI,UAAU,CAACD,MAAgB;IACvD,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,MAAM,EAAEE,CAAC,EAAE,EAAE;MAC/B,MAAMC,SAAS,GAAGN,YAAY,CAACI,UAAU,CAACC,CAAC,CAAE;MAC7CJ,IAAI,IAAIF,kBAAkB,CAACO,SAAS,CAAC;MACrC,IAAID,CAAC,GAAGF,MAAM,GAAG,CAAC,EAAEF,IAAI,IAAI,IAAI;IAClC;IACA,MAAMM,MAAM,GAAGV,SAAS,CAAqBC,UAAU,EAAEE,YAAY,CAACC,IAAI,CAAC;IAC3EA,IAAI,IAAI,IAAIM,MAAM,EAAEC,KAAK,IAAI,EAAE,EAAE;IACjC,OAAOT,kBAAkB,CAAC;MACxB,GAAGC,YAAY;MACfC;KACD,CAAW;EACd;EACA;EACA,IAAI,SAAS,IAAID,YAAY,IAAIA,YAAY,CAACS,OAAO,EACnDR,IAAI,GAAG,GAAGA,IAAI,UAAU;EAC1B;EACA,IAAID,YAAY,CAACU,IAAI,EAAE,OAAO,GAAGT,IAAI,IAAID,YAAY,CAACU,IAAI,EAAY;EACtE,OAAOT,IAAc;AACvB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}