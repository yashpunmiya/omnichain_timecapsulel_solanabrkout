{"ast":null,"code":"import { BaseMessageSignerWalletAdapter, isIosAndRedirectable, isVersionedTransaction, scopePollingDetectionStrategy, WalletAccountError, WalletConnectionError, WalletDisconnectedError, WalletDisconnectionError, WalletError, WalletNotConnectedError, WalletNotReadyError, WalletPublicKeyError, WalletReadyState, WalletSendTransactionError, WalletSignMessageError, WalletSignTransactionError } from '@solana/wallet-adapter-base';\nimport { PublicKey } from '@solana/web3.js';\nexport const PhantomWalletName = 'Phantom';\nexport class PhantomWalletAdapter extends BaseMessageSignerWalletAdapter {\n  constructor(config = {}) {\n    super();\n    this.name = PhantomWalletName;\n    this.url = 'https://phantom.app';\n    this.icon = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiB2aWV3Qm94PSIwIDAgMTA4IDEwOCIgZmlsbD0ibm9uZSI+CjxyZWN0IHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiByeD0iMjYiIGZpbGw9IiNBQjlGRjIiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00Ni41MjY3IDY5LjkyMjlDNDIuMDA1NCA3Ni44NTA5IDM0LjQyOTIgODUuNjE4MiAyNC4zNDggODUuNjE4MkMxOS41ODI0IDg1LjYxODIgMTUgODMuNjU2MyAxNSA3NS4xMzQyQzE1IDUzLjQzMDUgNDQuNjMyNiAxOS44MzI3IDcyLjEyNjggMTkuODMyN0M4Ny43NjggMTkuODMyNyA5NCAzMC42ODQ2IDk0IDQzLjAwNzlDOTQgNTguODI1OCA4My43MzU1IDc2LjkxMjIgNzMuNTMyMSA3Ni45MTIyQzcwLjI5MzkgNzYuOTEyMiA2OC43MDUzIDc1LjEzNDIgNjguNzA1MyA3Mi4zMTRDNjguNzA1MyA3MS41NzgzIDY4LjgyNzUgNzAuNzgxMiA2OS4wNzE5IDY5LjkyMjlDNjUuNTg5MyA3NS44Njk5IDU4Ljg2ODUgODEuMzg3OCA1Mi41NzU0IDgxLjM4NzhDNDcuOTkzIDgxLjM4NzggNDUuNjcxMyA3OC41MDYzIDQ1LjY3MTMgNzQuNDU5OEM0NS42NzEzIDcyLjk4ODQgNDUuOTc2OCA3MS40NTU2IDQ2LjUyNjcgNjkuOTIyOVpNODMuNjc2MSA0Mi41Nzk0QzgzLjY3NjEgNDYuMTcwNCA4MS41NTc1IDQ3Ljk2NTggNzkuMTg3NSA0Ny45NjU4Qzc2Ljc4MTYgNDcuOTY1OCA3NC42OTg5IDQ2LjE3MDQgNzQuNjk4OSA0Mi41Nzk0Qzc0LjY5ODkgMzguOTg4NSA3Ni43ODE2IDM3LjE5MzEgNzkuMTg3NSAzNy4xOTMxQzgxLjU1NzUgMzcuMTkzMSA4My42NzYxIDM4Ljk4ODUgODMuNjc2MSA0Mi41Nzk0Wk03MC4yMTAzIDQyLjU3OTVDNzAuMjEwMyA0Ni4xNzA0IDY4LjA5MTYgNDcuOTY1OCA2NS43MjE2IDQ3Ljk2NThDNjMuMzE1NyA0Ny45NjU4IDYxLjIzMyA0Ni4xNzA0IDYxLjIzMyA0Mi41Nzk1QzYxLjIzMyAzOC45ODg1IDYzLjMxNTcgMzcuMTkzMSA2NS43MjE2IDM3LjE5MzFDNjguMDkxNiAzNy4xOTMxIDcwLjIxMDMgMzguOTg4NSA3MC4yMTAzIDQyLjU3OTVaIiBmaWxsPSIjRkZGREY4Ii8+Cjwvc3ZnPg==';\n    this.supportedTransactionVersions = new Set(['legacy', 0]);\n    this._readyState = typeof window === 'undefined' || typeof document === 'undefined' ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;\n    this._disconnected = () => {\n      const wallet = this._wallet;\n      if (wallet) {\n        wallet.off('disconnect', this._disconnected);\n        wallet.off('accountChanged', this._accountChanged);\n        this._wallet = null;\n        this._publicKey = null;\n        this.emit('error', new WalletDisconnectedError());\n        this.emit('disconnect');\n      }\n    };\n    this._accountChanged = newPublicKey => {\n      const publicKey = this._publicKey;\n      if (!publicKey) return;\n      try {\n        newPublicKey = new PublicKey(newPublicKey.toBytes());\n      } catch (error) {\n        this.emit('error', new WalletPublicKeyError(error?.message, error));\n        return;\n      }\n      if (publicKey.equals(newPublicKey)) return;\n      this._publicKey = newPublicKey;\n      this.emit('connect', newPublicKey);\n    };\n    this._connecting = false;\n    this._wallet = null;\n    this._publicKey = null;\n    if (this._readyState !== WalletReadyState.Unsupported) {\n      if (isIosAndRedirectable()) {\n        // when in iOS (not webview), set Phantom as loadable instead of checking for install\n        this._readyState = WalletReadyState.Loadable;\n        this.emit('readyStateChange', this._readyState);\n      } else {\n        scopePollingDetectionStrategy(() => {\n          if (window.phantom?.solana?.isPhantom || window.solana?.isPhantom) {\n            this._readyState = WalletReadyState.Installed;\n            this.emit('readyStateChange', this._readyState);\n            return true;\n          }\n          return false;\n        });\n      }\n    }\n  }\n  get publicKey() {\n    return this._publicKey;\n  }\n  get connecting() {\n    return this._connecting;\n  }\n  get readyState() {\n    return this._readyState;\n  }\n  async autoConnect() {\n    // Skip autoconnect in the Loadable state\n    // We can't redirect to a universal link without user input\n    if (this.readyState === WalletReadyState.Installed) {\n      await this.connect();\n    }\n  }\n  async connect() {\n    try {\n      if (this.connected || this.connecting) return;\n      if (this.readyState === WalletReadyState.Loadable) {\n        // redirect to the Phantom /browse universal link\n        // this will open the current URL in the Phantom in-wallet browser\n        const url = encodeURIComponent(window.location.href);\n        const ref = encodeURIComponent(window.location.origin);\n        window.location.href = `https://phantom.app/ul/browse/${url}?ref=${ref}`;\n        return;\n      }\n      if (this.readyState !== WalletReadyState.Installed) throw new WalletNotReadyError();\n      this._connecting = true;\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const wallet = window.phantom?.solana || window.solana;\n      if (!wallet.isConnected) {\n        try {\n          await wallet.connect();\n        } catch (error) {\n          throw new WalletConnectionError(error?.message, error);\n        }\n      }\n      if (!wallet.publicKey) throw new WalletAccountError();\n      let publicKey;\n      try {\n        publicKey = new PublicKey(wallet.publicKey.toBytes());\n      } catch (error) {\n        throw new WalletPublicKeyError(error?.message, error);\n      }\n      wallet.on('disconnect', this._disconnected);\n      wallet.on('accountChanged', this._accountChanged);\n      this._wallet = wallet;\n      this._publicKey = publicKey;\n      this.emit('connect', publicKey);\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    } finally {\n      this._connecting = false;\n    }\n  }\n  async disconnect() {\n    const wallet = this._wallet;\n    if (wallet) {\n      wallet.off('disconnect', this._disconnected);\n      wallet.off('accountChanged', this._accountChanged);\n      this._wallet = null;\n      this._publicKey = null;\n      try {\n        await wallet.disconnect();\n      } catch (error) {\n        this.emit('error', new WalletDisconnectionError(error?.message, error));\n      }\n    }\n    this.emit('disconnect');\n  }\n  async sendTransaction(transaction, connection, options = {}) {\n    try {\n      const wallet = this._wallet;\n      if (!wallet) throw new WalletNotConnectedError();\n      try {\n        const {\n          signers,\n          ...sendOptions\n        } = options;\n        if (isVersionedTransaction(transaction)) {\n          signers?.length && transaction.sign(signers);\n        } else {\n          transaction = await this.prepareTransaction(transaction, connection, sendOptions);\n          signers?.length && transaction.partialSign(...signers);\n        }\n        sendOptions.preflightCommitment = sendOptions.preflightCommitment || connection.commitment;\n        const {\n          signature\n        } = await wallet.signAndSendTransaction(transaction, sendOptions);\n        return signature;\n      } catch (error) {\n        if (error instanceof WalletError) throw error;\n        throw new WalletSendTransactionError(error?.message, error);\n      }\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n  async signTransaction(transaction) {\n    try {\n      const wallet = this._wallet;\n      if (!wallet) throw new WalletNotConnectedError();\n      try {\n        return (await wallet.signTransaction(transaction)) || transaction;\n      } catch (error) {\n        throw new WalletSignTransactionError(error?.message, error);\n      }\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n  async signAllTransactions(transactions) {\n    try {\n      const wallet = this._wallet;\n      if (!wallet) throw new WalletNotConnectedError();\n      try {\n        return (await wallet.signAllTransactions(transactions)) || transactions;\n      } catch (error) {\n        throw new WalletSignTransactionError(error?.message, error);\n      }\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n  async signMessage(message) {\n    try {\n      const wallet = this._wallet;\n      if (!wallet) throw new WalletNotConnectedError();\n      try {\n        const {\n          signature\n        } = await wallet.signMessage(message);\n        return signature;\n      } catch (error) {\n        throw new WalletSignMessageError(error?.message, error);\n      }\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n}\n//# sourceMappingURL=adapter.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}