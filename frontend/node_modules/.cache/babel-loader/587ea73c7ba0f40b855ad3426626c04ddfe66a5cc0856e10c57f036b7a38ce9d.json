{"ast":null,"code":"import bt from \"@walletconnect/sign-client\";\nimport { isValidObject as It, isCaipNamespace as Y, parseNamespaceKey as q, mergeArrays as M, parseChainId as Q, getSdkError as Z, isValidArray as T } from \"@walletconnect/utils\";\nimport { pino as $t, getDefaultLoggerOptions as Ot } from \"@walletconnect/logger\";\nimport m, { HttpConnection as At } from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider as l } from \"@walletconnect/jsonrpc-provider\";\nimport { formatJsonRpcRequest as Ht, formatJsonRpcResult as Et } from \"@walletconnect/jsonrpc-utils\";\nimport Ct from \"events\";\nconst tt = \"error\",\n  Nt = \"wss://relay.walletconnect.org\",\n  St = \"wc\",\n  Dt = \"universal_provider\",\n  _ = `${St}@2:${Dt}:`,\n  et = \"https://rpc.walletconnect.org/v1/\",\n  w = \"generic\",\n  qt = `${et}bundler`,\n  d = {\n    DEFAULT_CHAIN_CHANGED: \"default_chain_changed\"\n  };\nfunction jt() {}\nfunction B(s) {\n  return s == null || typeof s != \"object\" && typeof s != \"function\";\n}\nfunction G(s) {\n  return ArrayBuffer.isView(s) && !(s instanceof DataView);\n}\nfunction Rt(s) {\n  if (B(s)) return s;\n  if (Array.isArray(s) || G(s) || s instanceof ArrayBuffer || typeof SharedArrayBuffer < \"u\" && s instanceof SharedArrayBuffer) return s.slice(0);\n  const t = Object.getPrototypeOf(s),\n    e = t.constructor;\n  if (s instanceof Date || s instanceof Map || s instanceof Set) return new e(s);\n  if (s instanceof RegExp) {\n    const i = new e(s);\n    return i.lastIndex = s.lastIndex, i;\n  }\n  if (s instanceof DataView) return new e(s.buffer.slice(0));\n  if (s instanceof Error) {\n    const i = new e(s.message);\n    return i.stack = s.stack, i.name = s.name, i.cause = s.cause, i;\n  }\n  if (typeof File < \"u\" && s instanceof File) return new e([s], s.name, {\n    type: s.type,\n    lastModified: s.lastModified\n  });\n  if (typeof s == \"object\") {\n    const i = Object.create(t);\n    return Object.assign(i, s);\n  }\n  return s;\n}\nfunction st(s) {\n  return typeof s == \"object\" && s !== null;\n}\nfunction it(s) {\n  return Object.getOwnPropertySymbols(s).filter(t => Object.prototype.propertyIsEnumerable.call(s, t));\n}\nfunction rt(s) {\n  return s == null ? s === void 0 ? \"[object Undefined]\" : \"[object Null]\" : Object.prototype.toString.call(s);\n}\nconst _t = \"[object RegExp]\",\n  nt = \"[object String]\",\n  at = \"[object Number]\",\n  ct = \"[object Boolean]\",\n  ot = \"[object Arguments]\",\n  Ut = \"[object Symbol]\",\n  Ft = \"[object Date]\",\n  Lt = \"[object Map]\",\n  xt = \"[object Set]\",\n  Mt = \"[object Array]\",\n  Bt = \"[object ArrayBuffer]\",\n  Gt = \"[object Object]\",\n  Jt = \"[object DataView]\",\n  zt = \"[object Uint8Array]\",\n  kt = \"[object Uint8ClampedArray]\",\n  Wt = \"[object Uint16Array]\",\n  Kt = \"[object Uint32Array]\",\n  Vt = \"[object Int8Array]\",\n  Xt = \"[object Int16Array]\",\n  Yt = \"[object Int32Array]\",\n  Qt = \"[object Float32Array]\",\n  Zt = \"[object Float64Array]\";\nfunction Tt(s, t) {\n  return y(s, void 0, s, new Map(), t);\n}\nfunction y(s, t, e, i = new Map(), r = void 0) {\n  const a = r?.(s, t, e, i);\n  if (a != null) return a;\n  if (B(s)) return s;\n  if (i.has(s)) return i.get(s);\n  if (Array.isArray(s)) {\n    const n = new Array(s.length);\n    i.set(s, n);\n    for (let c = 0; c < s.length; c++) n[c] = y(s[c], c, e, i, r);\n    return Object.hasOwn(s, \"index\") && (n.index = s.index), Object.hasOwn(s, \"input\") && (n.input = s.input), n;\n  }\n  if (s instanceof Date) return new Date(s.getTime());\n  if (s instanceof RegExp) {\n    const n = new RegExp(s.source, s.flags);\n    return n.lastIndex = s.lastIndex, n;\n  }\n  if (s instanceof Map) {\n    const n = new Map();\n    i.set(s, n);\n    for (const [c, h] of s) n.set(c, y(h, c, e, i, r));\n    return n;\n  }\n  if (s instanceof Set) {\n    const n = new Set();\n    i.set(s, n);\n    for (const c of s) n.add(y(c, void 0, e, i, r));\n    return n;\n  }\n  if (typeof Buffer < \"u\" && Buffer.isBuffer(s)) return s.subarray();\n  if (G(s)) {\n    const n = new (Object.getPrototypeOf(s).constructor)(s.length);\n    i.set(s, n);\n    for (let c = 0; c < s.length; c++) n[c] = y(s[c], c, e, i, r);\n    return n;\n  }\n  if (s instanceof ArrayBuffer || typeof SharedArrayBuffer < \"u\" && s instanceof SharedArrayBuffer) return s.slice(0);\n  if (s instanceof DataView) {\n    const n = new DataView(s.buffer.slice(0), s.byteOffset, s.byteLength);\n    return i.set(s, n), g(n, s, e, i, r), n;\n  }\n  if (typeof File < \"u\" && s instanceof File) {\n    const n = new File([s], s.name, {\n      type: s.type\n    });\n    return i.set(s, n), g(n, s, e, i, r), n;\n  }\n  if (s instanceof Blob) {\n    const n = new Blob([s], {\n      type: s.type\n    });\n    return i.set(s, n), g(n, s, e, i, r), n;\n  }\n  if (s instanceof Error) {\n    const n = new s.constructor();\n    return i.set(s, n), n.message = s.message, n.name = s.name, n.stack = s.stack, n.cause = s.cause, g(n, s, e, i, r), n;\n  }\n  if (typeof s == \"object\" && te(s)) {\n    const n = Object.create(Object.getPrototypeOf(s));\n    return i.set(s, n), g(n, s, e, i, r), n;\n  }\n  return s;\n}\nfunction g(s, t, e = s, i, r) {\n  const a = [...Object.keys(t), ...it(t)];\n  for (let n = 0; n < a.length; n++) {\n    const c = a[n],\n      h = Object.getOwnPropertyDescriptor(s, c);\n    (h == null || h.writable) && (s[c] = y(t[c], c, e, i, r));\n  }\n}\nfunction te(s) {\n  switch (rt(s)) {\n    case ot:\n    case Mt:\n    case Bt:\n    case Jt:\n    case ct:\n    case Ft:\n    case Qt:\n    case Zt:\n    case Vt:\n    case Xt:\n    case Yt:\n    case Lt:\n    case at:\n    case Gt:\n    case _t:\n    case xt:\n    case nt:\n    case Ut:\n    case zt:\n    case kt:\n    case Wt:\n    case Kt:\n      return !0;\n    default:\n      return !1;\n  }\n}\nfunction ee(s, t) {\n  return Tt(s, (e, i, r, a) => {\n    const n = t?.(e, i, r, a);\n    if (n != null) return n;\n    if (typeof s == \"object\") switch (Object.prototype.toString.call(s)) {\n      case at:\n      case nt:\n      case ct:\n        {\n          const c = new s.constructor(s?.valueOf());\n          return g(c, s), c;\n        }\n      case ot:\n        {\n          const c = {};\n          return g(c, s), c.length = s.length, c[Symbol.iterator] = s[Symbol.iterator], c;\n        }\n      default:\n        return;\n    }\n  });\n}\nfunction ht(s) {\n  return ee(s);\n}\nfunction pt(s) {\n  return s !== null && typeof s == \"object\" && rt(s) === \"[object Arguments]\";\n}\nfunction se(s) {\n  return G(s);\n}\nfunction ie(s) {\n  if (typeof s != \"object\" || s == null) return !1;\n  if (Object.getPrototypeOf(s) === null) return !0;\n  if (Object.prototype.toString.call(s) !== \"[object Object]\") {\n    const e = s[Symbol.toStringTag];\n    return e == null || !Object.getOwnPropertyDescriptor(s, Symbol.toStringTag)?.writable ? !1 : s.toString() === `[object ${e}]`;\n  }\n  let t = s;\n  for (; Object.getPrototypeOf(t) !== null;) t = Object.getPrototypeOf(t);\n  return Object.getPrototypeOf(s) === t;\n}\nfunction re(s, ...t) {\n  const e = t.slice(0, -1),\n    i = t[t.length - 1];\n  let r = s;\n  for (let a = 0; a < e.length; a++) {\n    const n = e[a];\n    r = U(r, n, i, new Map());\n  }\n  return r;\n}\nfunction U(s, t, e, i) {\n  if (B(s) && (s = Object(s)), t == null || typeof t != \"object\") return s;\n  if (i.has(t)) return Rt(i.get(t));\n  if (i.set(t, s), Array.isArray(t)) {\n    t = t.slice();\n    for (let a = 0; a < t.length; a++) t[a] = t[a] ?? void 0;\n  }\n  const r = [...Object.keys(t), ...it(t)];\n  for (let a = 0; a < r.length; a++) {\n    const n = r[a];\n    let c = t[n],\n      h = s[n];\n    if (pt(c) && (c = {\n      ...c\n    }), pt(h) && (h = {\n      ...h\n    }), typeof Buffer < \"u\" && Buffer.isBuffer(c) && (c = ht(c)), Array.isArray(c)) if (typeof h == \"object\" && h != null) {\n      const j = [],\n        R = Reflect.ownKeys(h);\n      for (let f = 0; f < R.length; f++) {\n        const X = R[f];\n        j[X] = h[X];\n      }\n      h = j;\n    } else h = [];\n    const v = e(h, c, n, s, t, i);\n    v != null ? s[n] = v : Array.isArray(c) || st(h) && st(c) ? s[n] = U(h, c, e, i) : h == null && ie(c) ? s[n] = U({}, c, e, i) : h == null && se(c) ? s[n] = ht(c) : (h === void 0 || c !== void 0) && (s[n] = c);\n  }\n  return s;\n}\nfunction ne(s, ...t) {\n  return re(s, ...t, jt);\n}\nvar ae = Object.defineProperty,\n  ce = Object.defineProperties,\n  oe = Object.getOwnPropertyDescriptors,\n  dt = Object.getOwnPropertySymbols,\n  he = Object.prototype.hasOwnProperty,\n  pe = Object.prototype.propertyIsEnumerable,\n  ut = (s, t, e) => t in s ? ae(s, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : s[t] = e,\n  F = (s, t) => {\n    for (var e in t || (t = {})) he.call(t, e) && ut(s, e, t[e]);\n    if (dt) for (var e of dt(t)) pe.call(t, e) && ut(s, e, t[e]);\n    return s;\n  },\n  de = (s, t) => ce(s, oe(t));\nfunction p(s, t, e) {\n  var i;\n  const r = Q(s);\n  return ((i = t.rpcMap) == null ? void 0 : i[r.reference]) || `${et}?chainId=${r.namespace}:${r.reference}&projectId=${e}`;\n}\nfunction P(s) {\n  return s.includes(\":\") ? s.split(\":\")[1] : s;\n}\nfunction lt(s) {\n  return s.map(t => `${t.split(\":\")[0]}:${t.split(\":\")[1]}`);\n}\nfunction ue(s, t) {\n  const e = Object.keys(t.namespaces).filter(r => r.includes(s));\n  if (!e.length) return [];\n  const i = [];\n  return e.forEach(r => {\n    const a = t.namespaces[r].accounts;\n    i.push(...a);\n  }), i;\n}\nfunction J(s = {}, t = {}) {\n  const e = ft(s),\n    i = ft(t);\n  return ne(e, i);\n}\nfunction ft(s) {\n  var t, e, i, r;\n  const a = {};\n  if (!It(s)) return a;\n  for (const [n, c] of Object.entries(s)) {\n    const h = Y(n) ? [n] : c.chains,\n      v = c.methods || [],\n      j = c.events || [],\n      R = c.rpcMap || {},\n      f = q(n);\n    a[f] = de(F(F({}, a[f]), c), {\n      chains: M(h, (t = a[f]) == null ? void 0 : t.chains),\n      methods: M(v, (e = a[f]) == null ? void 0 : e.methods),\n      events: M(j, (i = a[f]) == null ? void 0 : i.events),\n      rpcMap: F(F({}, R), (r = a[f]) == null ? void 0 : r.rpcMap)\n    });\n  }\n  return a;\n}\nfunction le(s) {\n  return s.includes(\":\") ? s.split(\":\")[2] : s;\n}\nfunction mt(s) {\n  const t = {};\n  for (const [e, i] of Object.entries(s)) {\n    const r = i.methods || [],\n      a = i.events || [],\n      n = i.accounts || [],\n      c = Y(e) ? [e] : i.chains ? i.chains : lt(i.accounts);\n    t[e] = {\n      chains: c,\n      methods: r,\n      events: a,\n      accounts: n\n    };\n  }\n  return t;\n}\nfunction z(s) {\n  return typeof s == \"number\" ? s : s.includes(\"0x\") ? parseInt(s, 16) : (s = s.includes(\":\") ? s.split(\":\")[1] : s, isNaN(Number(s)) ? s : Number(s));\n}\nconst vt = {},\n  o = s => vt[s],\n  k = (s, t) => {\n    vt[s] = t;\n  };\nvar fe = Object.defineProperty,\n  me = (s, t, e) => t in s ? fe(s, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : s[t] = e,\n  b = (s, t, e) => me(s, typeof t != \"symbol\" ? t + \"\" : t, e);\nclass ve {\n  constructor(t) {\n    b(this, \"name\", \"polkadot\"), b(this, \"client\"), b(this, \"httpProviders\"), b(this, \"events\"), b(this, \"namespace\"), b(this, \"chainId\"), this.namespace = t.namespace, this.events = o(\"events\"), this.client = o(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(t) {\n    this.namespace = Object.assign(this.namespace, t);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const t = this.namespace.chains[0];\n    if (!t) throw new Error(\"ChainId not found\");\n    return t.split(\":\")[1];\n  }\n  request(t) {\n    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);\n  }\n  setDefaultChain(t, e) {\n    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(d.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);\n  }\n  getAccounts() {\n    const t = this.namespace.accounts;\n    return t ? t.filter(e => e.split(\":\")[1] === this.chainId.toString()).map(e => e.split(\":\")[2]) || [] : [];\n  }\n  createHttpProviders() {\n    const t = {};\n    return this.namespace.chains.forEach(e => {\n      var i;\n      const r = P(e);\n      t[r] = this.createHttpProvider(r, (i = this.namespace.rpcMap) == null ? void 0 : i[e]);\n    }), t;\n  }\n  getHttpProvider() {\n    const t = `${this.name}:${this.chainId}`,\n      e = this.httpProviders[t];\n    if (typeof e > \"u\") throw new Error(`JSON-RPC provider for ${t} not found`);\n    return e;\n  }\n  setHttpProvider(t, e) {\n    const i = this.createHttpProvider(t, e);\n    i && (this.httpProviders[t] = i);\n  }\n  createHttpProvider(t, e) {\n    const i = e || p(t, this.namespace, this.client.core.projectId);\n    if (!i) throw new Error(`No RPC url provided for chainId: ${t}`);\n    return new l(new m(i, o(\"disableProviderPing\")));\n  }\n}\nvar ge = Object.defineProperty,\n  Pe = Object.defineProperties,\n  we = Object.getOwnPropertyDescriptors,\n  gt = Object.getOwnPropertySymbols,\n  ye = Object.prototype.hasOwnProperty,\n  be = Object.prototype.propertyIsEnumerable,\n  W = (s, t, e) => t in s ? ge(s, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : s[t] = e,\n  Pt = (s, t) => {\n    for (var e in t || (t = {})) ye.call(t, e) && W(s, e, t[e]);\n    if (gt) for (var e of gt(t)) be.call(t, e) && W(s, e, t[e]);\n    return s;\n  },\n  wt = (s, t) => Pe(s, we(t)),\n  I = (s, t, e) => W(s, typeof t != \"symbol\" ? t + \"\" : t, e);\nclass Ie {\n  constructor(t) {\n    I(this, \"name\", \"eip155\"), I(this, \"client\"), I(this, \"chainId\"), I(this, \"namespace\"), I(this, \"httpProviders\"), I(this, \"events\"), this.namespace = t.namespace, this.events = o(\"events\"), this.client = o(\"client\"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain());\n  }\n  async request(t) {\n    switch (t.request.method) {\n      case \"eth_requestAccounts\":\n        return this.getAccounts();\n      case \"eth_accounts\":\n        return this.getAccounts();\n      case \"wallet_switchEthereumChain\":\n        return await this.handleSwitchChain(t);\n      case \"eth_chainId\":\n        return parseInt(this.getDefaultChain());\n      case \"wallet_getCapabilities\":\n        return await this.getCapabilities(t);\n      case \"wallet_getCallsStatus\":\n        return await this.getCallStatus(t);\n    }\n    return this.namespace.methods.includes(t.request.method) ? await this.client.request(t) : this.getHttpProvider().request(t.request);\n  }\n  updateNamespace(t) {\n    this.namespace = Object.assign(this.namespace, t);\n  }\n  setDefaultChain(t, e) {\n    this.httpProviders[t] || this.setHttpProvider(parseInt(t), e), this.chainId = parseInt(t), this.events.emit(d.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId.toString();\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const t = this.namespace.chains[0];\n    if (!t) throw new Error(\"ChainId not found\");\n    return t.split(\":\")[1];\n  }\n  createHttpProvider(t, e) {\n    const i = e || p(`${this.name}:${t}`, this.namespace, this.client.core.projectId);\n    if (!i) throw new Error(`No RPC url provided for chainId: ${t}`);\n    return new l(new At(i, o(\"disableProviderPing\")));\n  }\n  setHttpProvider(t, e) {\n    const i = this.createHttpProvider(t, e);\n    i && (this.httpProviders[t] = i);\n  }\n  createHttpProviders() {\n    const t = {};\n    return this.namespace.chains.forEach(e => {\n      var i;\n      const r = parseInt(P(e));\n      t[r] = this.createHttpProvider(r, (i = this.namespace.rpcMap) == null ? void 0 : i[e]);\n    }), t;\n  }\n  getAccounts() {\n    const t = this.namespace.accounts;\n    return t ? [...new Set(t.filter(e => e.split(\":\")[1] === this.chainId.toString()).map(e => e.split(\":\")[2]))] : [];\n  }\n  getHttpProvider() {\n    const t = this.chainId,\n      e = this.httpProviders[t];\n    if (typeof e > \"u\") throw new Error(`JSON-RPC provider for ${t} not found`);\n    return e;\n  }\n  async handleSwitchChain(t) {\n    var e, i;\n    let r = t.request.params ? (e = t.request.params[0]) == null ? void 0 : e.chainId : \"0x0\";\n    r = r.startsWith(\"0x\") ? r : `0x${r}`;\n    const a = parseInt(r, 16);\n    if (this.isChainApproved(a)) this.setDefaultChain(`${a}`);else if (this.namespace.methods.includes(\"wallet_switchEthereumChain\")) await this.client.request({\n      topic: t.topic,\n      request: {\n        method: t.request.method,\n        params: [{\n          chainId: r\n        }]\n      },\n      chainId: (i = this.namespace.chains) == null ? void 0 : i[0]\n    }), this.setDefaultChain(`${a}`);else throw new Error(`Failed to switch to chain 'eip155:${a}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);\n    return null;\n  }\n  isChainApproved(t) {\n    return this.namespace.chains.includes(`${this.name}:${t}`);\n  }\n  async getCapabilities(t) {\n    var e, i, r;\n    const a = (i = (e = t.request) == null ? void 0 : e.params) == null ? void 0 : i[0];\n    if (!a) throw new Error(\"Missing address parameter in `wallet_getCapabilities` request\");\n    const n = this.client.session.get(t.topic),\n      c = ((r = n?.sessionProperties) == null ? void 0 : r.capabilities) || {};\n    if (c != null && c[a]) return c?.[a];\n    const h = await this.client.request(t);\n    try {\n      await this.client.session.update(t.topic, {\n        sessionProperties: wt(Pt({}, n.sessionProperties || {}), {\n          capabilities: wt(Pt({}, c || {}), {\n            [a]: h\n          })\n        })\n      });\n    } catch (v) {\n      console.warn(\"Failed to update session with capabilities\", v);\n    }\n    return h;\n  }\n  async getCallStatus(t) {\n    var e, i;\n    const r = this.client.session.get(t.topic),\n      a = (e = r.sessionProperties) == null ? void 0 : e.bundler_name;\n    if (a) {\n      const c = this.getBundlerUrl(t.chainId, a);\n      try {\n        return await this.getUserOperationReceipt(c, t);\n      } catch (h) {\n        console.warn(\"Failed to fetch call status from bundler\", h, c);\n      }\n    }\n    const n = (i = r.sessionProperties) == null ? void 0 : i.bundler_url;\n    if (n) try {\n      return await this.getUserOperationReceipt(n, t);\n    } catch (c) {\n      console.warn(\"Failed to fetch call status from custom bundler\", c, n);\n    }\n    if (this.namespace.methods.includes(t.request.method)) return await this.client.request(t);\n    throw new Error(\"Fetching call status not approved by the wallet.\");\n  }\n  async getUserOperationReceipt(t, e) {\n    var i;\n    const r = new URL(t),\n      a = await fetch(r, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(Ht(\"eth_getUserOperationReceipt\", [(i = e.request.params) == null ? void 0 : i[0]]))\n      });\n    if (!a.ok) throw new Error(`Failed to fetch user operation receipt - ${a.status}`);\n    return await a.json();\n  }\n  getBundlerUrl(t, e) {\n    return `${qt}?projectId=${this.client.core.projectId}&chainId=${t}&bundler=${e}`;\n  }\n}\nvar $e = Object.defineProperty,\n  Oe = (s, t, e) => t in s ? $e(s, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : s[t] = e,\n  $ = (s, t, e) => Oe(s, typeof t != \"symbol\" ? t + \"\" : t, e);\nclass Ae {\n  constructor(t) {\n    $(this, \"name\", \"solana\"), $(this, \"client\"), $(this, \"httpProviders\"), $(this, \"events\"), $(this, \"namespace\"), $(this, \"chainId\"), this.namespace = t.namespace, this.events = o(\"events\"), this.client = o(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(t) {\n    this.namespace = Object.assign(this.namespace, t);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  request(t) {\n    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);\n  }\n  setDefaultChain(t, e) {\n    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(d.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const t = this.namespace.chains[0];\n    if (!t) throw new Error(\"ChainId not found\");\n    return t.split(\":\")[1];\n  }\n  getAccounts() {\n    const t = this.namespace.accounts;\n    return t ? [...new Set(t.filter(e => e.split(\":\")[1] === this.chainId.toString()).map(e => e.split(\":\")[2]))] : [];\n  }\n  createHttpProviders() {\n    const t = {};\n    return this.namespace.chains.forEach(e => {\n      var i;\n      const r = P(e);\n      t[r] = this.createHttpProvider(r, (i = this.namespace.rpcMap) == null ? void 0 : i[e]);\n    }), t;\n  }\n  getHttpProvider() {\n    const t = `${this.name}:${this.chainId}`,\n      e = this.httpProviders[t];\n    if (typeof e > \"u\") throw new Error(`JSON-RPC provider for ${t} not found`);\n    return e;\n  }\n  setHttpProvider(t, e) {\n    const i = this.createHttpProvider(t, e);\n    i && (this.httpProviders[t] = i);\n  }\n  createHttpProvider(t, e) {\n    const i = e || p(t, this.namespace, this.client.core.projectId);\n    if (!i) throw new Error(`No RPC url provided for chainId: ${t}`);\n    return new l(new m(i, o(\"disableProviderPing\")));\n  }\n}\nvar He = Object.defineProperty,\n  Ee = (s, t, e) => t in s ? He(s, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : s[t] = e,\n  O = (s, t, e) => Ee(s, typeof t != \"symbol\" ? t + \"\" : t, e);\nclass Ce {\n  constructor(t) {\n    O(this, \"name\", \"cosmos\"), O(this, \"client\"), O(this, \"httpProviders\"), O(this, \"events\"), O(this, \"namespace\"), O(this, \"chainId\"), this.namespace = t.namespace, this.events = o(\"events\"), this.client = o(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(t) {\n    this.namespace = Object.assign(this.namespace, t);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const t = this.namespace.chains[0];\n    if (!t) throw new Error(\"ChainId not found\");\n    return t.split(\":\")[1];\n  }\n  request(t) {\n    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);\n  }\n  setDefaultChain(t, e) {\n    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(d.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n  getAccounts() {\n    const t = this.namespace.accounts;\n    return t ? [...new Set(t.filter(e => e.split(\":\")[1] === this.chainId.toString()).map(e => e.split(\":\")[2]))] : [];\n  }\n  createHttpProviders() {\n    const t = {};\n    return this.namespace.chains.forEach(e => {\n      var i;\n      const r = P(e);\n      t[r] = this.createHttpProvider(r, (i = this.namespace.rpcMap) == null ? void 0 : i[e]);\n    }), t;\n  }\n  getHttpProvider() {\n    const t = `${this.name}:${this.chainId}`,\n      e = this.httpProviders[t];\n    if (typeof e > \"u\") throw new Error(`JSON-RPC provider for ${t} not found`);\n    return e;\n  }\n  setHttpProvider(t, e) {\n    const i = this.createHttpProvider(t, e);\n    i && (this.httpProviders[t] = i);\n  }\n  createHttpProvider(t, e) {\n    const i = e || p(t, this.namespace, this.client.core.projectId);\n    if (!i) throw new Error(`No RPC url provided for chainId: ${t}`);\n    return new l(new m(i, o(\"disableProviderPing\")));\n  }\n}\nvar Ne = Object.defineProperty,\n  Se = (s, t, e) => t in s ? Ne(s, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : s[t] = e,\n  A = (s, t, e) => Se(s, typeof t != \"symbol\" ? t + \"\" : t, e);\nclass De {\n  constructor(t) {\n    A(this, \"name\", \"algorand\"), A(this, \"client\"), A(this, \"httpProviders\"), A(this, \"events\"), A(this, \"namespace\"), A(this, \"chainId\"), this.namespace = t.namespace, this.events = o(\"events\"), this.client = o(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(t) {\n    this.namespace = Object.assign(this.namespace, t);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  request(t) {\n    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);\n  }\n  setDefaultChain(t, e) {\n    if (!this.httpProviders[t]) {\n      const i = e || p(`${this.name}:${t}`, this.namespace, this.client.core.projectId);\n      if (!i) throw new Error(`No RPC url provided for chainId: ${t}`);\n      this.setHttpProvider(t, i);\n    }\n    this.chainId = t, this.events.emit(d.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const t = this.namespace.chains[0];\n    if (!t) throw new Error(\"ChainId not found\");\n    return t.split(\":\")[1];\n  }\n  getAccounts() {\n    const t = this.namespace.accounts;\n    return t ? [...new Set(t.filter(e => e.split(\":\")[1] === this.chainId.toString()).map(e => e.split(\":\")[2]))] : [];\n  }\n  createHttpProviders() {\n    const t = {};\n    return this.namespace.chains.forEach(e => {\n      var i;\n      t[e] = this.createHttpProvider(e, (i = this.namespace.rpcMap) == null ? void 0 : i[e]);\n    }), t;\n  }\n  getHttpProvider() {\n    const t = `${this.name}:${this.chainId}`,\n      e = this.httpProviders[t];\n    if (typeof e > \"u\") throw new Error(`JSON-RPC provider for ${t} not found`);\n    return e;\n  }\n  setHttpProvider(t, e) {\n    const i = this.createHttpProvider(t, e);\n    i && (this.httpProviders[t] = i);\n  }\n  createHttpProvider(t, e) {\n    const i = e || p(t, this.namespace, this.client.core.projectId);\n    return typeof i > \"u\" ? void 0 : new l(new m(i, o(\"disableProviderPing\")));\n  }\n}\nvar qe = Object.defineProperty,\n  je = (s, t, e) => t in s ? qe(s, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : s[t] = e,\n  H = (s, t, e) => je(s, typeof t != \"symbol\" ? t + \"\" : t, e);\nclass Re {\n  constructor(t) {\n    H(this, \"name\", \"cip34\"), H(this, \"client\"), H(this, \"httpProviders\"), H(this, \"events\"), H(this, \"namespace\"), H(this, \"chainId\"), this.namespace = t.namespace, this.events = o(\"events\"), this.client = o(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(t) {\n    this.namespace = Object.assign(this.namespace, t);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const t = this.namespace.chains[0];\n    if (!t) throw new Error(\"ChainId not found\");\n    return t.split(\":\")[1];\n  }\n  request(t) {\n    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);\n  }\n  setDefaultChain(t, e) {\n    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(d.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n  getAccounts() {\n    const t = this.namespace.accounts;\n    return t ? [...new Set(t.filter(e => e.split(\":\")[1] === this.chainId.toString()).map(e => e.split(\":\")[2]))] : [];\n  }\n  createHttpProviders() {\n    const t = {};\n    return this.namespace.chains.forEach(e => {\n      const i = this.getCardanoRPCUrl(e),\n        r = P(e);\n      t[r] = this.createHttpProvider(r, i);\n    }), t;\n  }\n  getHttpProvider() {\n    const t = `${this.name}:${this.chainId}`,\n      e = this.httpProviders[t];\n    if (typeof e > \"u\") throw new Error(`JSON-RPC provider for ${t} not found`);\n    return e;\n  }\n  getCardanoRPCUrl(t) {\n    const e = this.namespace.rpcMap;\n    if (e) return e[t];\n  }\n  setHttpProvider(t, e) {\n    const i = this.createHttpProvider(t, e);\n    i && (this.httpProviders[t] = i);\n  }\n  createHttpProvider(t, e) {\n    const i = e || this.getCardanoRPCUrl(t);\n    if (!i) throw new Error(`No RPC url provided for chainId: ${t}`);\n    return new l(new m(i, o(\"disableProviderPing\")));\n  }\n}\nvar _e = Object.defineProperty,\n  Ue = (s, t, e) => t in s ? _e(s, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : s[t] = e,\n  E = (s, t, e) => Ue(s, typeof t != \"symbol\" ? t + \"\" : t, e);\nclass Fe {\n  constructor(t) {\n    E(this, \"name\", \"elrond\"), E(this, \"client\"), E(this, \"httpProviders\"), E(this, \"events\"), E(this, \"namespace\"), E(this, \"chainId\"), this.namespace = t.namespace, this.events = o(\"events\"), this.client = o(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(t) {\n    this.namespace = Object.assign(this.namespace, t);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  request(t) {\n    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);\n  }\n  setDefaultChain(t, e) {\n    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(d.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const t = this.namespace.chains[0];\n    if (!t) throw new Error(\"ChainId not found\");\n    return t.split(\":\")[1];\n  }\n  getAccounts() {\n    const t = this.namespace.accounts;\n    return t ? [...new Set(t.filter(e => e.split(\":\")[1] === this.chainId.toString()).map(e => e.split(\":\")[2]))] : [];\n  }\n  createHttpProviders() {\n    const t = {};\n    return this.namespace.chains.forEach(e => {\n      var i;\n      const r = P(e);\n      t[r] = this.createHttpProvider(r, (i = this.namespace.rpcMap) == null ? void 0 : i[e]);\n    }), t;\n  }\n  getHttpProvider() {\n    const t = `${this.name}:${this.chainId}`,\n      e = this.httpProviders[t];\n    if (typeof e > \"u\") throw new Error(`JSON-RPC provider for ${t} not found`);\n    return e;\n  }\n  setHttpProvider(t, e) {\n    const i = this.createHttpProvider(t, e);\n    i && (this.httpProviders[t] = i);\n  }\n  createHttpProvider(t, e) {\n    const i = e || p(t, this.namespace, this.client.core.projectId);\n    if (!i) throw new Error(`No RPC url provided for chainId: ${t}`);\n    return new l(new m(i, o(\"disableProviderPing\")));\n  }\n}\nvar Le = Object.defineProperty,\n  xe = (s, t, e) => t in s ? Le(s, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : s[t] = e,\n  C = (s, t, e) => xe(s, typeof t != \"symbol\" ? t + \"\" : t, e);\nclass Me {\n  constructor(t) {\n    C(this, \"name\", \"multiversx\"), C(this, \"client\"), C(this, \"httpProviders\"), C(this, \"events\"), C(this, \"namespace\"), C(this, \"chainId\"), this.namespace = t.namespace, this.events = o(\"events\"), this.client = o(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(t) {\n    this.namespace = Object.assign(this.namespace, t);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  request(t) {\n    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);\n  }\n  setDefaultChain(t, e) {\n    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(d.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const t = this.namespace.chains[0];\n    if (!t) throw new Error(\"ChainId not found\");\n    return t.split(\":\")[1];\n  }\n  getAccounts() {\n    const t = this.namespace.accounts;\n    return t ? [...new Set(t.filter(e => e.split(\":\")[1] === this.chainId.toString()).map(e => e.split(\":\")[2]))] : [];\n  }\n  createHttpProviders() {\n    const t = {};\n    return this.namespace.chains.forEach(e => {\n      var i;\n      const r = P(e);\n      t[r] = this.createHttpProvider(r, (i = this.namespace.rpcMap) == null ? void 0 : i[e]);\n    }), t;\n  }\n  getHttpProvider() {\n    const t = `${this.name}:${this.chainId}`,\n      e = this.httpProviders[t];\n    if (typeof e > \"u\") throw new Error(`JSON-RPC provider for ${t} not found`);\n    return e;\n  }\n  setHttpProvider(t, e) {\n    const i = this.createHttpProvider(t, e);\n    i && (this.httpProviders[t] = i);\n  }\n  createHttpProvider(t, e) {\n    const i = e || p(t, this.namespace, this.client.core.projectId);\n    if (!i) throw new Error(`No RPC url provided for chainId: ${t}`);\n    return new l(new m(i, o(\"disableProviderPing\")));\n  }\n}\nvar Be = Object.defineProperty,\n  Ge = (s, t, e) => t in s ? Be(s, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : s[t] = e,\n  N = (s, t, e) => Ge(s, typeof t != \"symbol\" ? t + \"\" : t, e);\nclass Je {\n  constructor(t) {\n    N(this, \"name\", \"near\"), N(this, \"client\"), N(this, \"httpProviders\"), N(this, \"events\"), N(this, \"namespace\"), N(this, \"chainId\"), this.namespace = t.namespace, this.events = o(\"events\"), this.client = o(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(t) {\n    this.namespace = Object.assign(this.namespace, t);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const t = this.namespace.chains[0];\n    if (!t) throw new Error(\"ChainId not found\");\n    return t.split(\":\")[1];\n  }\n  request(t) {\n    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);\n  }\n  setDefaultChain(t, e) {\n    if (this.chainId = t, !this.httpProviders[t]) {\n      const i = e || p(`${this.name}:${t}`, this.namespace);\n      if (!i) throw new Error(`No RPC url provided for chainId: ${t}`);\n      this.setHttpProvider(t, i);\n    }\n    this.events.emit(d.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n  getAccounts() {\n    const t = this.namespace.accounts;\n    return t ? t.filter(e => e.split(\":\")[1] === this.chainId.toString()).map(e => e.split(\":\")[2]) || [] : [];\n  }\n  createHttpProviders() {\n    const t = {};\n    return this.namespace.chains.forEach(e => {\n      var i;\n      t[e] = this.createHttpProvider(e, (i = this.namespace.rpcMap) == null ? void 0 : i[e]);\n    }), t;\n  }\n  getHttpProvider() {\n    const t = `${this.name}:${this.chainId}`,\n      e = this.httpProviders[t];\n    if (typeof e > \"u\") throw new Error(`JSON-RPC provider for ${t} not found`);\n    return e;\n  }\n  setHttpProvider(t, e) {\n    const i = this.createHttpProvider(t, e);\n    i && (this.httpProviders[t] = i);\n  }\n  createHttpProvider(t, e) {\n    const i = e || p(t, this.namespace);\n    return typeof i > \"u\" ? void 0 : new l(new m(i, o(\"disableProviderPing\")));\n  }\n}\nvar ze = Object.defineProperty,\n  ke = (s, t, e) => t in s ? ze(s, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : s[t] = e,\n  S = (s, t, e) => ke(s, typeof t != \"symbol\" ? t + \"\" : t, e);\nclass We {\n  constructor(t) {\n    S(this, \"name\", \"tezos\"), S(this, \"client\"), S(this, \"httpProviders\"), S(this, \"events\"), S(this, \"namespace\"), S(this, \"chainId\"), this.namespace = t.namespace, this.events = o(\"events\"), this.client = o(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(t) {\n    this.namespace = Object.assign(this.namespace, t);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const t = this.namespace.chains[0];\n    if (!t) throw new Error(\"ChainId not found\");\n    return t.split(\":\")[1];\n  }\n  request(t) {\n    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);\n  }\n  setDefaultChain(t, e) {\n    if (this.chainId = t, !this.httpProviders[t]) {\n      const i = e || p(`${this.name}:${t}`, this.namespace);\n      if (!i) throw new Error(`No RPC url provided for chainId: ${t}`);\n      this.setHttpProvider(t, i);\n    }\n    this.events.emit(d.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n  getAccounts() {\n    const t = this.namespace.accounts;\n    return t ? t.filter(e => e.split(\":\")[1] === this.chainId.toString()).map(e => e.split(\":\")[2]) || [] : [];\n  }\n  createHttpProviders() {\n    const t = {};\n    return this.namespace.chains.forEach(e => {\n      t[e] = this.createHttpProvider(e);\n    }), t;\n  }\n  getHttpProvider() {\n    const t = `${this.name}:${this.chainId}`,\n      e = this.httpProviders[t];\n    if (typeof e > \"u\") throw new Error(`JSON-RPC provider for ${t} not found`);\n    return e;\n  }\n  setHttpProvider(t, e) {\n    const i = this.createHttpProvider(t, e);\n    i && (this.httpProviders[t] = i);\n  }\n  createHttpProvider(t, e) {\n    const i = e || p(t, this.namespace);\n    return typeof i > \"u\" ? void 0 : new l(new m(i));\n  }\n}\nvar Ke = Object.defineProperty,\n  Ve = (s, t, e) => t in s ? Ke(s, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : s[t] = e,\n  D = (s, t, e) => Ve(s, typeof t != \"symbol\" ? t + \"\" : t, e);\nclass Xe {\n  constructor(t) {\n    D(this, \"name\", w), D(this, \"client\"), D(this, \"httpProviders\"), D(this, \"events\"), D(this, \"namespace\"), D(this, \"chainId\"), this.namespace = t.namespace, this.events = o(\"events\"), this.client = o(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(t) {\n    this.namespace.chains = [...new Set((this.namespace.chains || []).concat(t.chains || []))], this.namespace.accounts = [...new Set((this.namespace.accounts || []).concat(t.accounts || []))], this.namespace.methods = [...new Set((this.namespace.methods || []).concat(t.methods || []))], this.namespace.events = [...new Set((this.namespace.events || []).concat(t.events || []))], this.httpProviders = this.createHttpProviders();\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  request(t) {\n    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider(t.chainId).request(t.request);\n  }\n  setDefaultChain(t, e) {\n    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(d.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const t = this.namespace.chains[0];\n    if (!t) throw new Error(\"ChainId not found\");\n    return t.split(\":\")[1];\n  }\n  getAccounts() {\n    const t = this.namespace.accounts;\n    return t ? [...new Set(t.filter(e => e.split(\":\")[1] === this.chainId.toString()).map(e => e.split(\":\")[2]))] : [];\n  }\n  createHttpProviders() {\n    var t, e;\n    const i = {};\n    return (e = (t = this.namespace) == null ? void 0 : t.accounts) == null || e.forEach(r => {\n      const a = Q(r);\n      i[`${a.namespace}:${a.reference}`] = this.createHttpProvider(r);\n    }), i;\n  }\n  getHttpProvider(t) {\n    const e = this.httpProviders[t];\n    if (typeof e > \"u\") throw new Error(`JSON-RPC provider for ${t} not found`);\n    return e;\n  }\n  setHttpProvider(t, e) {\n    const i = this.createHttpProvider(t, e);\n    i && (this.httpProviders[t] = i);\n  }\n  createHttpProvider(t, e) {\n    const i = e || p(t, this.namespace, this.client.core.projectId);\n    if (!i) throw new Error(`No RPC url provided for chainId: ${t}`);\n    return new l(new m(i, o(\"disableProviderPing\")));\n  }\n}\nvar Ye = Object.defineProperty,\n  Qe = Object.defineProperties,\n  Ze = Object.getOwnPropertyDescriptors,\n  yt = Object.getOwnPropertySymbols,\n  Te = Object.prototype.hasOwnProperty,\n  ts = Object.prototype.propertyIsEnumerable,\n  K = (s, t, e) => t in s ? Ye(s, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : s[t] = e,\n  L = (s, t) => {\n    for (var e in t || (t = {})) Te.call(t, e) && K(s, e, t[e]);\n    if (yt) for (var e of yt(t)) ts.call(t, e) && K(s, e, t[e]);\n    return s;\n  },\n  V = (s, t) => Qe(s, Ze(t)),\n  u = (s, t, e) => K(s, typeof t != \"symbol\" ? t + \"\" : t, e);\nclass x {\n  constructor(t) {\n    u(this, \"client\"), u(this, \"namespaces\"), u(this, \"optionalNamespaces\"), u(this, \"sessionProperties\"), u(this, \"scopedProperties\"), u(this, \"events\", new Ct()), u(this, \"rpcProviders\", {}), u(this, \"session\"), u(this, \"providerOpts\"), u(this, \"logger\"), u(this, \"uri\"), u(this, \"disableProviderPing\", !1), this.providerOpts = t, this.logger = typeof t?.logger < \"u\" && typeof t?.logger != \"string\" ? t.logger : $t(Ot({\n      level: t?.logger || tt\n    })), this.disableProviderPing = t?.disableProviderPing || !1;\n  }\n  static async init(t) {\n    const e = new x(t);\n    return await e.initialize(), e;\n  }\n  async request(t, e, i) {\n    const [r, a] = this.validateChain(e);\n    if (!this.session) throw new Error(\"Please call connect() before request()\");\n    return await this.getProvider(r).request({\n      request: L({}, t),\n      chainId: `${r}:${a}`,\n      topic: this.session.topic,\n      expiry: i\n    });\n  }\n  sendAsync(t, e, i, r) {\n    const a = new Date().getTime();\n    this.request(t, i, r).then(n => e(null, Et(a, n))).catch(n => e(n, void 0));\n  }\n  async enable() {\n    if (!this.client) throw new Error(\"Sign Client not initialized\");\n    return this.session || (await this.connect({\n      namespaces: this.namespaces,\n      optionalNamespaces: this.optionalNamespaces,\n      sessionProperties: this.sessionProperties,\n      scopedProperties: this.scopedProperties\n    })), await this.requestAccounts();\n  }\n  async disconnect() {\n    var t;\n    if (!this.session) throw new Error(\"Please call connect() before enable()\");\n    await this.client.disconnect({\n      topic: (t = this.session) == null ? void 0 : t.topic,\n      reason: Z(\"USER_DISCONNECTED\")\n    }), await this.cleanup();\n  }\n  async connect(t) {\n    if (!this.client) throw new Error(\"Sign Client not initialized\");\n    if (this.setNamespaces(t), await this.cleanupPendingPairings(), !t.skipPairing) return await this.pair(t.pairingTopic);\n  }\n  async authenticate(t, e) {\n    if (!this.client) throw new Error(\"Sign Client not initialized\");\n    this.setNamespaces(t), await this.cleanupPendingPairings();\n    const {\n      uri: i,\n      response: r\n    } = await this.client.authenticate(t, e);\n    i && (this.uri = i, this.events.emit(\"display_uri\", i));\n    const a = await r();\n    if (this.session = a.session, this.session) {\n      const n = mt(this.session.namespaces);\n      this.namespaces = J(this.namespaces, n), await this.persist(\"namespaces\", this.namespaces), this.onConnect();\n    }\n    return a;\n  }\n  on(t, e) {\n    this.events.on(t, e);\n  }\n  once(t, e) {\n    this.events.once(t, e);\n  }\n  removeListener(t, e) {\n    this.events.removeListener(t, e);\n  }\n  off(t, e) {\n    this.events.off(t, e);\n  }\n  get isWalletConnect() {\n    return !0;\n  }\n  async pair(t) {\n    const {\n      uri: e,\n      approval: i\n    } = await this.client.connect({\n      pairingTopic: t,\n      requiredNamespaces: this.namespaces,\n      optionalNamespaces: this.optionalNamespaces,\n      sessionProperties: this.sessionProperties,\n      scopedProperties: this.scopedProperties\n    });\n    e && (this.uri = e, this.events.emit(\"display_uri\", e));\n    const r = await i();\n    this.session = r;\n    const a = mt(r.namespaces);\n    return this.namespaces = J(this.namespaces, a), await this.persist(\"namespaces\", this.namespaces), await this.persist(\"optionalNamespaces\", this.optionalNamespaces), this.onConnect(), this.session;\n  }\n  setDefaultChain(t, e) {\n    try {\n      if (!this.session) return;\n      const [i, r] = this.validateChain(t),\n        a = this.getProvider(i);\n      a.name === w ? a.setDefaultChain(`${i}:${r}`, e) : a.setDefaultChain(r, e);\n    } catch (i) {\n      if (!/Please call connect/.test(i.message)) throw i;\n    }\n  }\n  async cleanupPendingPairings(t = {}) {\n    this.logger.info(\"Cleaning up inactive pairings...\");\n    const e = this.client.pairing.getAll();\n    if (T(e)) {\n      for (const i of e) t.deletePairings ? this.client.core.expirer.set(i.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(i.topic);\n      this.logger.info(`Inactive pairings cleared: ${e.length}`);\n    }\n  }\n  abortPairingAttempt() {\n    this.logger.warn(\"abortPairingAttempt is deprecated. This is now a no-op.\");\n  }\n  async checkStorage() {\n    this.namespaces = (await this.getFromStore(\"namespaces\")) || {}, this.optionalNamespaces = (await this.getFromStore(\"optionalNamespaces\")) || {}, this.session && this.createProviders();\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();\n  }\n  async createClient() {\n    var t, e;\n    if (this.client = this.providerOpts.client || (await bt.init({\n      core: this.providerOpts.core,\n      logger: this.providerOpts.logger || tt,\n      relayUrl: this.providerOpts.relayUrl || Nt,\n      projectId: this.providerOpts.projectId,\n      metadata: this.providerOpts.metadata,\n      storageOptions: this.providerOpts.storageOptions,\n      storage: this.providerOpts.storage,\n      name: this.providerOpts.name,\n      customStoragePrefix: this.providerOpts.customStoragePrefix,\n      telemetryEnabled: this.providerOpts.telemetryEnabled\n    })), this.providerOpts.session) try {\n      this.session = this.client.session.get(this.providerOpts.session.topic);\n    } catch (i) {\n      throw this.logger.error(\"Failed to get session\", i), new Error(`The provided session: ${(e = (t = this.providerOpts) == null ? void 0 : t.session) == null ? void 0 : e.topic} doesn't exist in the Sign client`);\n    } else {\n      const i = this.client.session.getAll();\n      this.session = i[0];\n    }\n    this.logger.trace(\"SignClient Initialized\");\n  }\n  createProviders() {\n    if (!this.client) throw new Error(\"Sign Client not initialized\");\n    if (!this.session) throw new Error(\"Session not initialized. Please call connect() before enable()\");\n    const t = [...new Set(Object.keys(this.session.namespaces).map(e => q(e)))];\n    k(\"client\", this.client), k(\"events\", this.events), k(\"disableProviderPing\", this.disableProviderPing), t.forEach(e => {\n      if (!this.session) return;\n      const i = ue(e, this.session),\n        r = lt(i),\n        a = J(this.namespaces, this.optionalNamespaces),\n        n = V(L({}, a[e]), {\n          accounts: i,\n          chains: r\n        });\n      switch (e) {\n        case \"eip155\":\n          this.rpcProviders[e] = new Ie({\n            namespace: n\n          });\n          break;\n        case \"algorand\":\n          this.rpcProviders[e] = new De({\n            namespace: n\n          });\n          break;\n        case \"solana\":\n          this.rpcProviders[e] = new Ae({\n            namespace: n\n          });\n          break;\n        case \"cosmos\":\n          this.rpcProviders[e] = new Ce({\n            namespace: n\n          });\n          break;\n        case \"polkadot\":\n          this.rpcProviders[e] = new ve({\n            namespace: n\n          });\n          break;\n        case \"cip34\":\n          this.rpcProviders[e] = new Re({\n            namespace: n\n          });\n          break;\n        case \"elrond\":\n          this.rpcProviders[e] = new Fe({\n            namespace: n\n          });\n          break;\n        case \"multiversx\":\n          this.rpcProviders[e] = new Me({\n            namespace: n\n          });\n          break;\n        case \"near\":\n          this.rpcProviders[e] = new Je({\n            namespace: n\n          });\n          break;\n        case \"tezos\":\n          this.rpcProviders[e] = new We({\n            namespace: n\n          });\n          break;\n        default:\n          this.rpcProviders[w] ? this.rpcProviders[w].updateNamespace(n) : this.rpcProviders[w] = new Xe({\n            namespace: n\n          });\n      }\n    });\n  }\n  registerEventListeners() {\n    if (typeof this.client > \"u\") throw new Error(\"Sign Client is not initialized\");\n    this.client.on(\"session_ping\", t => {\n      var e;\n      const {\n        topic: i\n      } = t;\n      i === ((e = this.session) == null ? void 0 : e.topic) && this.events.emit(\"session_ping\", t);\n    }), this.client.on(\"session_event\", t => {\n      var e;\n      const {\n        params: i,\n        topic: r\n      } = t;\n      if (r !== ((e = this.session) == null ? void 0 : e.topic)) return;\n      const {\n        event: a\n      } = i;\n      if (a.name === \"accountsChanged\") {\n        const n = a.data;\n        n && T(n) && this.events.emit(\"accountsChanged\", n.map(le));\n      } else if (a.name === \"chainChanged\") {\n        const n = i.chainId,\n          c = i.event.data,\n          h = q(n),\n          v = z(n) !== z(c) ? `${h}:${z(c)}` : n;\n        this.onChainChanged(v);\n      } else this.events.emit(a.name, a.data);\n      this.events.emit(\"session_event\", t);\n    }), this.client.on(\"session_update\", ({\n      topic: t,\n      params: e\n    }) => {\n      var i, r;\n      if (t !== ((i = this.session) == null ? void 0 : i.topic)) return;\n      const {\n          namespaces: a\n        } = e,\n        n = (r = this.client) == null ? void 0 : r.session.get(t);\n      this.session = V(L({}, n), {\n        namespaces: a\n      }), this.onSessionUpdate(), this.events.emit(\"session_update\", {\n        topic: t,\n        params: e\n      });\n    }), this.client.on(\"session_delete\", async t => {\n      var e;\n      t.topic === ((e = this.session) == null ? void 0 : e.topic) && (await this.cleanup(), this.events.emit(\"session_delete\", t), this.events.emit(\"disconnect\", V(L({}, Z(\"USER_DISCONNECTED\")), {\n        data: t.topic\n      })));\n    }), this.on(d.DEFAULT_CHAIN_CHANGED, t => {\n      this.onChainChanged(t, !0);\n    });\n  }\n  getProvider(t) {\n    return this.rpcProviders[t] || this.rpcProviders[w];\n  }\n  onSessionUpdate() {\n    Object.keys(this.rpcProviders).forEach(t => {\n      var e;\n      this.getProvider(t).updateNamespace((e = this.session) == null ? void 0 : e.namespaces[t]);\n    });\n  }\n  setNamespaces(t) {\n    const {\n      namespaces: e,\n      optionalNamespaces: i,\n      sessionProperties: r,\n      scopedProperties: a\n    } = t;\n    e && Object.keys(e).length && (this.namespaces = e), i && Object.keys(i).length && (this.optionalNamespaces = i), this.sessionProperties = r, this.scopedProperties = a;\n  }\n  validateChain(t) {\n    const [e, i] = t?.split(\":\") || [\"\", \"\"];\n    if (!this.namespaces || !Object.keys(this.namespaces).length) return [e, i];\n    if (e && !Object.keys(this.namespaces || {}).map(n => q(n)).includes(e)) throw new Error(`Namespace '${e}' is not configured. Please call connect() first with namespace config.`);\n    if (e && i) return [e, i];\n    const r = q(Object.keys(this.namespaces)[0]),\n      a = this.rpcProviders[r].getDefaultChain();\n    return [r, a];\n  }\n  async requestAccounts() {\n    const [t] = this.validateChain();\n    return await this.getProvider(t).requestAccounts();\n  }\n  async onChainChanged(t, e = !1) {\n    if (!this.namespaces) return;\n    const [i, r] = this.validateChain(t);\n    r && (e || this.getProvider(i).setDefaultChain(r), this.namespaces[i] ? this.namespaces[i].defaultChain = r : this.namespaces[`${i}:${r}`] ? this.namespaces[`${i}:${r}`].defaultChain = r : this.namespaces[`${i}:${r}`] = {\n      defaultChain: r\n    }, this.events.emit(\"chainChanged\", r), await this.persist(\"namespaces\", this.namespaces));\n  }\n  onConnect() {\n    this.createProviders(), this.events.emit(\"connect\", {\n      session: this.session\n    });\n  }\n  async cleanup() {\n    this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, await this.deleteFromStore(\"namespaces\"), await this.deleteFromStore(\"optionalNamespaces\"), await this.deleteFromStore(\"sessionProperties\"), this.session = void 0, await this.cleanupPendingPairings({\n      deletePairings: !0\n    }), await this.cleanupStorage();\n  }\n  async persist(t, e) {\n    var i;\n    const r = ((i = this.session) == null ? void 0 : i.topic) || \"\";\n    await this.client.core.storage.setItem(`${_}/${t}${r}`, e);\n  }\n  async getFromStore(t) {\n    var e;\n    const i = ((e = this.session) == null ? void 0 : e.topic) || \"\";\n    return await this.client.core.storage.getItem(`${_}/${t}${i}`);\n  }\n  async deleteFromStore(t) {\n    var e;\n    const i = ((e = this.session) == null ? void 0 : e.topic) || \"\";\n    await this.client.core.storage.removeItem(`${_}/${t}${i}`);\n  }\n  async cleanupStorage() {\n    var t;\n    try {\n      if (((t = this.client) == null ? void 0 : t.session.length) > 0) return;\n      const e = await this.client.core.storage.getKeys();\n      for (const i of e) i.startsWith(_) && (await this.client.core.storage.removeItem(i));\n    } catch (e) {\n      this.logger.warn(\"Failed to cleanup storage\", e);\n    }\n  }\n}\nconst es = x;\nexport { es as UniversalProvider, x as default };\n//# sourceMappingURL=index.es.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}