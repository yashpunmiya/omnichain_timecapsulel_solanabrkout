{"ast":null,"code":"/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { nLength, validateField } from './modular.js';\nimport { bitLen, validateObject } from './utils.js';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction constTimeNegate(condition, item) {\n  const neg = item.negate();\n  return condition ? neg : item;\n}\nfunction validateW(W, bits) {\n  if (!Number.isSafeInteger(W) || W <= 0 || W > bits) throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\nfunction calcWOpts(W, bits) {\n  validateW(W, bits);\n  const windows = Math.ceil(bits / W) + 1; // +1, because\n  const windowSize = 2 ** (W - 1); // -1 because we skip zero\n  return {\n    windows,\n    windowSize\n  };\n}\nfunction validateMSMPoints(points, c) {\n  if (!Array.isArray(points)) throw new Error('array expected');\n  points.forEach((p, i) => {\n    if (!(p instanceof c)) throw new Error('invalid point at index ' + i);\n  });\n}\nfunction validateMSMScalars(scalars, field) {\n  if (!Array.isArray(scalars)) throw new Error('array of scalars expected');\n  scalars.forEach((s, i) => {\n    if (!field.isValid(s)) throw new Error('invalid scalar at index ' + i);\n  });\n}\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap(); // This allows use make points immutable (nothing changes inside)\nfunction getW(P) {\n  return pointWindowSizes.get(P) || 1;\n}\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / ùëä) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */\nexport function wNAF(c, bits) {\n  return {\n    constTimeNegate,\n    hasPrecomputes(elm) {\n      return getW(elm) !== 1;\n    },\n    // non-const time multiplication ladder\n    unsafeLadder(elm, n, p = c.ZERO) {\n      let d = elm;\n      while (n > _0n) {\n        if (n & _1n) p = p.add(d);\n        d = d.double();\n        n >>= _1n;\n      }\n      return p;\n    },\n    /**\n     * Creates a wNAF precomputation window. Used for caching.\n     * Default window size is set by `utils.precompute()` and is equal to 8.\n     * Number of precomputed points depends on the curve size:\n     * 2^(ùëä‚àí1) * (Math.ceil(ùëõ / ùëä) + 1), where:\n     * - ùëä is the window size\n     * - ùëõ is the bitlength of the curve order.\n     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n     * @param elm Point instance\n     * @param W window size\n     * @returns precomputed point tables flattened to a single array\n     */\n    precomputeWindow(elm, W) {\n      const {\n        windows,\n        windowSize\n      } = calcWOpts(W, bits);\n      const points = [];\n      let p = elm;\n      let base = p;\n      for (let window = 0; window < windows; window++) {\n        base = p;\n        points.push(base);\n        // =1, because we skip zero\n        for (let i = 1; i < windowSize; i++) {\n          base = base.add(p);\n          points.push(base);\n        }\n        p = base.double();\n      }\n      return points;\n    },\n    /**\n     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param W window size\n     * @param precomputes precomputed tables\n     * @param n scalar (we don't check here, but should be less than curve order)\n     * @returns real and fake (for const-time) points\n     */\n    wNAF(W, precomputes, n) {\n      // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n      // But need to carefully remove other checks before wNAF. ORDER == bits here\n      const {\n        windows,\n        windowSize\n      } = calcWOpts(W, bits);\n      let p = c.ZERO;\n      let f = c.BASE;\n      const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n      const maxNumber = 2 ** W;\n      const shiftBy = BigInt(W);\n      for (let window = 0; window < windows; window++) {\n        const offset = window * windowSize;\n        // Extract W bits.\n        let wbits = Number(n & mask);\n        // Shift number by W bits.\n        n >>= shiftBy;\n        // If the bits are bigger than max size, we'll split those.\n        // +224 => 256 - 32\n        if (wbits > windowSize) {\n          wbits -= maxNumber;\n          n += _1n;\n        }\n        // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n        // there is negate now: it is possible that negated element from low value\n        // would be the same as high element, which will create carry into next window.\n        // It's not obvious how this can fail, but still worth investigating later.\n        // Check if we're onto Zero point.\n        // Add random point inside current window to f.\n        const offset1 = offset;\n        const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n        const cond1 = window % 2 !== 0;\n        const cond2 = wbits < 0;\n        if (wbits === 0) {\n          // The most important part for const-time getPublicKey\n          f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n        } else {\n          p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n        }\n      }\n      // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n      // Even if the variable is still unused, there are some checks which will\n      // throw an exception, so compiler needs to prove they won't happen, which is hard.\n      // At this point there is a way to F be infinity-point even if p is not,\n      // which makes it less const-time: around 1 bigint multiply.\n      return {\n        p,\n        f\n      };\n    },\n    /**\n     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param W window size\n     * @param precomputes precomputed tables\n     * @param n scalar (we don't check here, but should be less than curve order)\n     * @param acc accumulator point to add result of multiplication\n     * @returns point\n     */\n    wNAFUnsafe(W, precomputes, n, acc = c.ZERO) {\n      const {\n        windows,\n        windowSize\n      } = calcWOpts(W, bits);\n      const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n      const maxNumber = 2 ** W;\n      const shiftBy = BigInt(W);\n      for (let window = 0; window < windows; window++) {\n        const offset = window * windowSize;\n        if (n === _0n) break; // No need to go over empty scalar\n        // Extract W bits.\n        let wbits = Number(n & mask);\n        // Shift number by W bits.\n        n >>= shiftBy;\n        // If the bits are bigger than max size, we'll split those.\n        // +224 => 256 - 32\n        if (wbits > windowSize) {\n          wbits -= maxNumber;\n          n += _1n;\n        }\n        if (wbits === 0) continue;\n        let curr = precomputes[offset + Math.abs(wbits) - 1]; // -1 because we skip zero\n        if (wbits < 0) curr = curr.negate();\n        // NOTE: by re-using acc, we can save a lot of additions in case of MSM\n        acc = acc.add(curr);\n      }\n      return acc;\n    },\n    getPrecomputes(W, P, transform) {\n      // Calculate precomputes on a first run, reuse them after\n      let comp = pointPrecomputes.get(P);\n      if (!comp) {\n        comp = this.precomputeWindow(P, W);\n        if (W !== 1) pointPrecomputes.set(P, transform(comp));\n      }\n      return comp;\n    },\n    wNAFCached(P, n, transform) {\n      const W = getW(P);\n      return this.wNAF(W, this.getPrecomputes(W, P, transform), n);\n    },\n    wNAFCachedUnsafe(P, n, transform, prev) {\n      const W = getW(P);\n      if (W === 1) return this.unsafeLadder(P, n, prev); // For W=1 ladder is ~x2 faster\n      return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);\n    },\n    // We calculate precomputes for elliptic curve point multiplication\n    // using windowed method. This specifies window size and\n    // stores precomputed values. Usually only base point would be precomputed.\n    setWindowSize(P, W) {\n      validateW(W, bits);\n      pointWindowSizes.set(P, W);\n      pointPrecomputes.delete(P);\n    }\n  };\n}\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster with precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka private keys / bigints)\n */\nexport function pippenger(c, fieldN, points, scalars) {\n  // If we split scalars by some window (let's say 8 bits), every chunk will only\n  // take 256 buckets even if there are 4096 scalars, also re-uses double.\n  // TODO:\n  // - https://eprint.iacr.org/2024/750.pdf\n  // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n  // 0 is accepted in scalars\n  validateMSMPoints(points, c);\n  validateMSMScalars(scalars, fieldN);\n  if (points.length !== scalars.length) throw new Error('arrays of points and scalars must have equal length');\n  const zero = c.ZERO;\n  const wbits = bitLen(BigInt(points.length));\n  const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1; // in bits\n  const MASK = (1 << windowSize) - 1;\n  const buckets = new Array(MASK + 1).fill(zero); // +1 for zero array\n  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n  let sum = zero;\n  for (let i = lastBits; i >= 0; i -= windowSize) {\n    buckets.fill(zero);\n    for (let j = 0; j < scalars.length; j++) {\n      const scalar = scalars[j];\n      const wbits = Number(scalar >> BigInt(i) & BigInt(MASK));\n      buckets[wbits] = buckets[wbits].add(points[j]);\n    }\n    let resI = zero; // not using this will do small speed-up, but will lose ct\n    // Skip first bucket, because it is zero\n    for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n      sumI = sumI.add(buckets[j]);\n      resI = resI.add(sumI);\n    }\n    sum = sum.add(resI);\n    if (i !== 0) for (let j = 0; j < windowSize; j++) sum = sum.double();\n  }\n  return sum;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */\nexport function precomputeMSMUnsafe(c, fieldN, points, windowSize) {\n  /**\n   * Performance Analysis of Window-based Precomputation\n   *\n   * Base Case (256-bit scalar, 8-bit window):\n   * - Standard precomputation requires:\n   *   - 31 additions per scalar √ó 256 scalars = 7,936 ops\n   *   - Plus 255 summary additions = 8,191 total ops\n   *   Note: Summary additions can be optimized via accumulator\n   *\n   * Chunked Precomputation Analysis:\n   * - Using 32 chunks requires:\n   *   - 255 additions per chunk\n   *   - 256 doublings\n   *   - Total: (255 √ó 32) + 256 = 8,416 ops\n   *\n   * Memory Usage Comparison:\n   * Window Size | Standard Points | Chunked Points\n   * ------------|-----------------|---------------\n   *     4-bit   |     520         |      15\n   *     8-bit   |    4,224        |     255\n   *    10-bit   |   13,824        |   1,023\n   *    16-bit   |  557,056        |  65,535\n   *\n   * Key Advantages:\n   * 1. Enables larger window sizes due to reduced memory overhead\n   * 2. More efficient for smaller scalar counts:\n   *    - 16 chunks: (16 √ó 255) + 256 = 4,336 ops\n   *    - ~2x faster than standard 8,191 ops\n   *\n   * Limitations:\n   * - Not suitable for plain precomputes (requires 256 constant doublings)\n   * - Performance degrades with larger scalar counts:\n   *   - Optimal for ~256 scalars\n   *   - Less efficient for 4096+ scalars (Pippenger preferred)\n   */\n  validateW(windowSize, fieldN.BITS);\n  validateMSMPoints(points, c);\n  const zero = c.ZERO;\n  const tableSize = 2 ** windowSize - 1; // table size (without zero)\n  const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n  const MASK = BigInt((1 << windowSize) - 1);\n  const tables = points.map(p => {\n    const res = [];\n    for (let i = 0, acc = p; i < tableSize; i++) {\n      res.push(acc);\n      acc = acc.add(p);\n    }\n    return res;\n  });\n  return scalars => {\n    validateMSMScalars(scalars, fieldN);\n    if (scalars.length > points.length) throw new Error('array of scalars must be smaller than array of points');\n    let res = zero;\n    for (let i = 0; i < chunks; i++) {\n      // No need to double if accumulator is still zero.\n      if (res !== zero) for (let j = 0; j < windowSize; j++) res = res.double();\n      const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n      for (let j = 0; j < scalars.length; j++) {\n        const n = scalars[j];\n        const curr = Number(n >> shiftBy & MASK);\n        if (!curr) continue; // skip zero scalars chunks\n        res = res.add(tables[j][curr - 1]);\n      }\n    }\n    return res;\n  };\n}\nexport function validateBasic(curve) {\n  validateField(curve.Fp);\n  validateObject(curve, {\n    n: 'bigint',\n    h: 'bigint',\n    Gx: 'field',\n    Gy: 'field'\n  }, {\n    nBitLength: 'isSafeInteger',\n    nByteLength: 'isSafeInteger'\n  });\n  // Set defaults\n  return Object.freeze({\n    ...nLength(curve.n, curve.nBitLength),\n    ...curve,\n    ...{\n      p: curve.Fp.ORDER\n    }\n  });\n}","map":{"version":3,"names":["nLength","validateField","bitLen","validateObject","_0n","BigInt","_1n","constTimeNegate","condition","item","neg","negate","validateW","W","bits","Number","isSafeInteger","Error","calcWOpts","windows","Math","ceil","windowSize","validateMSMPoints","points","c","Array","isArray","forEach","p","i","validateMSMScalars","scalars","field","s","isValid","pointPrecomputes","WeakMap","pointWindowSizes","getW","P","get","wNAF","hasPrecomputes","elm","unsafeLadder","n","ZERO","d","add","double","precomputeWindow","base","window","push","precomputes","f","BASE","mask","maxNumber","shiftBy","offset","wbits","offset1","offset2","abs","cond1","cond2","wNAFUnsafe","acc","curr","getPrecomputes","transform","comp","set","wNAFCached","wNAFCachedUnsafe","prev","setWindowSize","delete","pippenger","fieldN","length","zero","MASK","buckets","fill","lastBits","floor","BITS","sum","j","scalar","resI","sumI","precomputeMSMUnsafe","tableSize","chunks","tables","map","res","validateBasic","curve","Fp","h","Gx","Gy","nBitLength","nByteLength","Object","freeze","ORDER"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@reown\\appkit\\node_modules\\@noble\\curves\\src\\abstract\\curve.ts"],"sourcesContent":["/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { type IField, nLength, validateField } from './modular.js';\nimport { bitLen, validateObject } from './utils.js';\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n\nexport type AffinePoint<T> = {\n  x: T;\n  y: T;\n} & { z?: never; t?: never };\n\nexport interface Group<T extends Group<T>> {\n  double(): T;\n  negate(): T;\n  add(other: T): T;\n  subtract(other: T): T;\n  equals(other: T): boolean;\n  multiply(scalar: bigint): T;\n}\n\nexport type GroupConstructor<T> = {\n  BASE: T;\n  ZERO: T;\n};\nexport type Mapper<T> = (i: T[]) => T[];\n\nfunction constTimeNegate<T extends Group<T>>(condition: boolean, item: T): T {\n  const neg = item.negate();\n  return condition ? neg : item;\n}\n\nfunction validateW(W: number, bits: number) {\n  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n    throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\n\nfunction calcWOpts(W: number, bits: number) {\n  validateW(W, bits);\n  const windows = Math.ceil(bits / W) + 1; // +1, because\n  const windowSize = 2 ** (W - 1); // -1 because we skip zero\n  return { windows, windowSize };\n}\n\nfunction validateMSMPoints(points: any[], c: any) {\n  if (!Array.isArray(points)) throw new Error('array expected');\n  points.forEach((p, i) => {\n    if (!(p instanceof c)) throw new Error('invalid point at index ' + i);\n  });\n}\nfunction validateMSMScalars(scalars: any[], field: any) {\n  if (!Array.isArray(scalars)) throw new Error('array of scalars expected');\n  scalars.forEach((s, i) => {\n    if (!field.isValid(s)) throw new Error('invalid scalar at index ' + i);\n  });\n}\n\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes\nconst pointPrecomputes = new WeakMap<any, any[]>();\nconst pointWindowSizes = new WeakMap<any, number>(); // This allows use make points immutable (nothing changes inside)\n\nfunction getW(P: any): number {\n  return pointWindowSizes.get(P) || 1;\n}\n\nexport type IWNAF<T extends Group<T>> = {\n  constTimeNegate: <T extends Group<T>>(condition: boolean, item: T) => T;\n  hasPrecomputes(elm: T): boolean;\n  unsafeLadder(elm: T, n: bigint, p?: T): T;\n  precomputeWindow(elm: T, W: number): Group<T>[];\n  wNAF(W: number, precomputes: T[], n: bigint): { p: T; f: T };\n  wNAFUnsafe(W: number, precomputes: T[], n: bigint, acc?: T): T;\n  getPrecomputes(W: number, P: T, transform: Mapper<T>): T[];\n  wNAFCached(P: T, n: bigint, transform: Mapper<T>): { p: T; f: T };\n  wNAFCachedUnsafe(P: T, n: bigint, transform: Mapper<T>, prev?: T): T;\n  setWindowSize(P: T, W: number): void;\n};\n\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / ùëä) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */\nexport function wNAF<T extends Group<T>>(c: GroupConstructor<T>, bits: number): IWNAF<T> {\n  return {\n    constTimeNegate,\n\n    hasPrecomputes(elm: T) {\n      return getW(elm) !== 1;\n    },\n\n    // non-const time multiplication ladder\n    unsafeLadder(elm: T, n: bigint, p = c.ZERO) {\n      let d: T = elm;\n      while (n > _0n) {\n        if (n & _1n) p = p.add(d);\n        d = d.double();\n        n >>= _1n;\n      }\n      return p;\n    },\n\n    /**\n     * Creates a wNAF precomputation window. Used for caching.\n     * Default window size is set by `utils.precompute()` and is equal to 8.\n     * Number of precomputed points depends on the curve size:\n     * 2^(ùëä‚àí1) * (Math.ceil(ùëõ / ùëä) + 1), where:\n     * - ùëä is the window size\n     * - ùëõ is the bitlength of the curve order.\n     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n     * @param elm Point instance\n     * @param W window size\n     * @returns precomputed point tables flattened to a single array\n     */\n    precomputeWindow(elm: T, W: number): Group<T>[] {\n      const { windows, windowSize } = calcWOpts(W, bits);\n      const points: T[] = [];\n      let p: T = elm;\n      let base = p;\n      for (let window = 0; window < windows; window++) {\n        base = p;\n        points.push(base);\n        // =1, because we skip zero\n        for (let i = 1; i < windowSize; i++) {\n          base = base.add(p);\n          points.push(base);\n        }\n        p = base.double();\n      }\n      return points;\n    },\n\n    /**\n     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param W window size\n     * @param precomputes precomputed tables\n     * @param n scalar (we don't check here, but should be less than curve order)\n     * @returns real and fake (for const-time) points\n     */\n    wNAF(W: number, precomputes: T[], n: bigint): { p: T; f: T } {\n      // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n      // But need to carefully remove other checks before wNAF. ORDER == bits here\n      const { windows, windowSize } = calcWOpts(W, bits);\n\n      let p = c.ZERO;\n      let f = c.BASE;\n\n      const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n      const maxNumber = 2 ** W;\n      const shiftBy = BigInt(W);\n\n      for (let window = 0; window < windows; window++) {\n        const offset = window * windowSize;\n        // Extract W bits.\n        let wbits = Number(n & mask);\n\n        // Shift number by W bits.\n        n >>= shiftBy;\n\n        // If the bits are bigger than max size, we'll split those.\n        // +224 => 256 - 32\n        if (wbits > windowSize) {\n          wbits -= maxNumber;\n          n += _1n;\n        }\n\n        // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n        // there is negate now: it is possible that negated element from low value\n        // would be the same as high element, which will create carry into next window.\n        // It's not obvious how this can fail, but still worth investigating later.\n\n        // Check if we're onto Zero point.\n        // Add random point inside current window to f.\n        const offset1 = offset;\n        const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n        const cond1 = window % 2 !== 0;\n        const cond2 = wbits < 0;\n        if (wbits === 0) {\n          // The most important part for const-time getPublicKey\n          f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n        } else {\n          p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n        }\n      }\n      // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n      // Even if the variable is still unused, there are some checks which will\n      // throw an exception, so compiler needs to prove they won't happen, which is hard.\n      // At this point there is a way to F be infinity-point even if p is not,\n      // which makes it less const-time: around 1 bigint multiply.\n      return { p, f };\n    },\n\n    /**\n     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param W window size\n     * @param precomputes precomputed tables\n     * @param n scalar (we don't check here, but should be less than curve order)\n     * @param acc accumulator point to add result of multiplication\n     * @returns point\n     */\n    wNAFUnsafe(W: number, precomputes: T[], n: bigint, acc: T = c.ZERO): T {\n      const { windows, windowSize } = calcWOpts(W, bits);\n      const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n      const maxNumber = 2 ** W;\n      const shiftBy = BigInt(W);\n      for (let window = 0; window < windows; window++) {\n        const offset = window * windowSize;\n        if (n === _0n) break; // No need to go over empty scalar\n        // Extract W bits.\n        let wbits = Number(n & mask);\n        // Shift number by W bits.\n        n >>= shiftBy;\n        // If the bits are bigger than max size, we'll split those.\n        // +224 => 256 - 32\n        if (wbits > windowSize) {\n          wbits -= maxNumber;\n          n += _1n;\n        }\n        if (wbits === 0) continue;\n        let curr = precomputes[offset + Math.abs(wbits) - 1]; // -1 because we skip zero\n        if (wbits < 0) curr = curr.negate();\n        // NOTE: by re-using acc, we can save a lot of additions in case of MSM\n        acc = acc.add(curr);\n      }\n      return acc;\n    },\n\n    getPrecomputes(W: number, P: T, transform: Mapper<T>): T[] {\n      // Calculate precomputes on a first run, reuse them after\n      let comp = pointPrecomputes.get(P);\n      if (!comp) {\n        comp = this.precomputeWindow(P, W) as T[];\n        if (W !== 1) pointPrecomputes.set(P, transform(comp));\n      }\n      return comp;\n    },\n\n    wNAFCached(P: T, n: bigint, transform: Mapper<T>): { p: T; f: T } {\n      const W = getW(P);\n      return this.wNAF(W, this.getPrecomputes(W, P, transform), n);\n    },\n\n    wNAFCachedUnsafe(P: T, n: bigint, transform: Mapper<T>, prev?: T): T {\n      const W = getW(P);\n      if (W === 1) return this.unsafeLadder(P, n, prev); // For W=1 ladder is ~x2 faster\n      return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);\n    },\n\n    // We calculate precomputes for elliptic curve point multiplication\n    // using windowed method. This specifies window size and\n    // stores precomputed values. Usually only base point would be precomputed.\n\n    setWindowSize(P: T, W: number) {\n      validateW(W, bits);\n      pointWindowSizes.set(P, W);\n      pointPrecomputes.delete(P);\n    },\n  };\n}\n\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster with precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka private keys / bigints)\n */\nexport function pippenger<T extends Group<T>>(\n  c: GroupConstructor<T>,\n  fieldN: IField<bigint>,\n  points: T[],\n  scalars: bigint[]\n): T {\n  // If we split scalars by some window (let's say 8 bits), every chunk will only\n  // take 256 buckets even if there are 4096 scalars, also re-uses double.\n  // TODO:\n  // - https://eprint.iacr.org/2024/750.pdf\n  // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n  // 0 is accepted in scalars\n  validateMSMPoints(points, c);\n  validateMSMScalars(scalars, fieldN);\n  if (points.length !== scalars.length)\n    throw new Error('arrays of points and scalars must have equal length');\n  const zero = c.ZERO;\n  const wbits = bitLen(BigInt(points.length));\n  const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1; // in bits\n  const MASK = (1 << windowSize) - 1;\n  const buckets = new Array(MASK + 1).fill(zero); // +1 for zero array\n  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n  let sum = zero;\n  for (let i = lastBits; i >= 0; i -= windowSize) {\n    buckets.fill(zero);\n    for (let j = 0; j < scalars.length; j++) {\n      const scalar = scalars[j];\n      const wbits = Number((scalar >> BigInt(i)) & BigInt(MASK));\n      buckets[wbits] = buckets[wbits].add(points[j]);\n    }\n    let resI = zero; // not using this will do small speed-up, but will lose ct\n    // Skip first bucket, because it is zero\n    for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n      sumI = sumI.add(buckets[j]);\n      resI = resI.add(sumI);\n    }\n    sum = sum.add(resI);\n    if (i !== 0) for (let j = 0; j < windowSize; j++) sum = sum.double();\n  }\n  return sum as T;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */\nexport function precomputeMSMUnsafe<T extends Group<T>>(\n  c: GroupConstructor<T>,\n  fieldN: IField<bigint>,\n  points: T[],\n  windowSize: number\n): (scalars: bigint[]) => T {\n  /**\n   * Performance Analysis of Window-based Precomputation\n   *\n   * Base Case (256-bit scalar, 8-bit window):\n   * - Standard precomputation requires:\n   *   - 31 additions per scalar √ó 256 scalars = 7,936 ops\n   *   - Plus 255 summary additions = 8,191 total ops\n   *   Note: Summary additions can be optimized via accumulator\n   *\n   * Chunked Precomputation Analysis:\n   * - Using 32 chunks requires:\n   *   - 255 additions per chunk\n   *   - 256 doublings\n   *   - Total: (255 √ó 32) + 256 = 8,416 ops\n   *\n   * Memory Usage Comparison:\n   * Window Size | Standard Points | Chunked Points\n   * ------------|-----------------|---------------\n   *     4-bit   |     520         |      15\n   *     8-bit   |    4,224        |     255\n   *    10-bit   |   13,824        |   1,023\n   *    16-bit   |  557,056        |  65,535\n   *\n   * Key Advantages:\n   * 1. Enables larger window sizes due to reduced memory overhead\n   * 2. More efficient for smaller scalar counts:\n   *    - 16 chunks: (16 √ó 255) + 256 = 4,336 ops\n   *    - ~2x faster than standard 8,191 ops\n   *\n   * Limitations:\n   * - Not suitable for plain precomputes (requires 256 constant doublings)\n   * - Performance degrades with larger scalar counts:\n   *   - Optimal for ~256 scalars\n   *   - Less efficient for 4096+ scalars (Pippenger preferred)\n   */\n  validateW(windowSize, fieldN.BITS);\n  validateMSMPoints(points, c);\n  const zero = c.ZERO;\n  const tableSize = 2 ** windowSize - 1; // table size (without zero)\n  const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n  const MASK = BigInt((1 << windowSize) - 1);\n  const tables = points.map((p: T) => {\n    const res = [];\n    for (let i = 0, acc = p; i < tableSize; i++) {\n      res.push(acc);\n      acc = acc.add(p);\n    }\n    return res;\n  });\n  return (scalars: bigint[]): T => {\n    validateMSMScalars(scalars, fieldN);\n    if (scalars.length > points.length)\n      throw new Error('array of scalars must be smaller than array of points');\n    let res = zero;\n    for (let i = 0; i < chunks; i++) {\n      // No need to double if accumulator is still zero.\n      if (res !== zero) for (let j = 0; j < windowSize; j++) res = res.double();\n      const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n      for (let j = 0; j < scalars.length; j++) {\n        const n = scalars[j];\n        const curr = Number((n >> shiftBy) & MASK);\n        if (!curr) continue; // skip zero scalars chunks\n        res = res.add(tables[j][curr - 1]);\n      }\n    }\n    return res;\n  };\n}\n\n/**\n * Generic BasicCurve interface: works even for polynomial fields (BLS): P, n, h would be ok.\n * Though generator can be different (Fp2 / Fp6 for BLS).\n */\nexport type BasicCurve<T> = {\n  Fp: IField<T>; // Field over which we'll do calculations (Fp)\n  n: bigint; // Curve order, total count of valid points in the field\n  nBitLength?: number; // bit length of curve order\n  nByteLength?: number; // byte length of curve order\n  h: bigint; // cofactor. we can assign default=1, but users will just ignore it w/o validation\n  hEff?: bigint; // Number to multiply to clear cofactor\n  Gx: T; // base point X coordinate\n  Gy: T; // base point Y coordinate\n  allowInfinityPoint?: boolean; // bls12-381 requires it. ZERO point is valid, but invalid pubkey\n};\n\nexport function validateBasic<FP, T>(\n  curve: BasicCurve<FP> & T\n): Readonly<\n  {\n    readonly nBitLength: number;\n    readonly nByteLength: number;\n  } & BasicCurve<FP> &\n    T & {\n      p: bigint;\n    }\n> {\n  validateField(curve.Fp);\n  validateObject(\n    curve,\n    {\n      n: 'bigint',\n      h: 'bigint',\n      Gx: 'field',\n      Gy: 'field',\n    },\n    {\n      nBitLength: 'isSafeInteger',\n      nByteLength: 'isSafeInteger',\n    }\n  );\n  // Set defaults\n  return Object.freeze({\n    ...nLength(curve.n, curve.nBitLength),\n    ...curve,\n    ...{ p: curve.Fp.ORDER },\n  } as const);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}