{"ast":null,"code":"import { AbiDecodingDataSizeTooSmallError, AbiEventSignatureEmptyTopicsError, AbiEventSignatureNotFoundError, DecodeLogDataMismatch, DecodeLogTopicsMismatch } from '../../errors/abi.js';\nimport { size } from '../data/size.js';\nimport { toEventSelector } from '../hash/toEventSelector.js';\nimport { PositionOutOfBoundsError } from '../../errors/cursor.js';\nimport { decodeAbiParameters } from './decodeAbiParameters.js';\nimport { formatAbiItem } from './formatAbiItem.js';\nconst docsPath = '/docs/contract/decodeEventLog';\nexport function decodeEventLog(parameters) {\n  const {\n    abi,\n    data,\n    strict: strict_,\n    topics\n  } = parameters;\n  const strict = strict_ ?? true;\n  const [signature, ...argTopics] = topics;\n  if (!signature) throw new AbiEventSignatureEmptyTopicsError({\n    docsPath\n  });\n  const abiItem = (() => {\n    if (abi.length === 1) return abi[0];\n    return abi.find(x => x.type === 'event' && signature === toEventSelector(formatAbiItem(x)));\n  })();\n  if (!(abiItem && 'name' in abiItem) || abiItem.type !== 'event') throw new AbiEventSignatureNotFoundError(signature, {\n    docsPath\n  });\n  const {\n    name,\n    inputs\n  } = abiItem;\n  const isUnnamed = inputs?.some(x => !('name' in x && x.name));\n  let args = isUnnamed ? [] : {};\n  // Decode topics (indexed args).\n  const indexedInputs = inputs.filter(x => 'indexed' in x && x.indexed);\n  for (let i = 0; i < indexedInputs.length; i++) {\n    const param = indexedInputs[i];\n    const topic = argTopics[i];\n    if (!topic) throw new DecodeLogTopicsMismatch({\n      abiItem,\n      param: param\n    });\n    args[isUnnamed ? i : param.name || i] = decodeTopic({\n      param,\n      value: topic\n    });\n  }\n  // Decode data (non-indexed args).\n  const nonIndexedInputs = inputs.filter(x => !('indexed' in x && x.indexed));\n  if (nonIndexedInputs.length > 0) {\n    if (data && data !== '0x') {\n      try {\n        const decodedData = decodeAbiParameters(nonIndexedInputs, data);\n        if (decodedData) {\n          if (isUnnamed) args = [...args, ...decodedData];else {\n            for (let i = 0; i < nonIndexedInputs.length; i++) {\n              args[nonIndexedInputs[i].name] = decodedData[i];\n            }\n          }\n        }\n      } catch (err) {\n        if (strict) {\n          if (err instanceof AbiDecodingDataSizeTooSmallError || err instanceof PositionOutOfBoundsError) throw new DecodeLogDataMismatch({\n            abiItem,\n            data: data,\n            params: nonIndexedInputs,\n            size: size(data)\n          });\n          throw err;\n        }\n      }\n    } else if (strict) {\n      throw new DecodeLogDataMismatch({\n        abiItem,\n        data: '0x',\n        params: nonIndexedInputs,\n        size: 0\n      });\n    }\n  }\n  return {\n    eventName: name,\n    args: Object.values(args).length > 0 ? args : undefined\n  };\n}\nfunction decodeTopic({\n  param,\n  value\n}) {\n  if (param.type === 'string' || param.type === 'bytes' || param.type === 'tuple' || param.type.match(/^(.*)\\[(\\d+)?\\]$/)) return value;\n  const decodedArg = decodeAbiParameters([param], value) || [];\n  return decodedArg[0];\n}\n//# sourceMappingURL=decodeEventLog.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}