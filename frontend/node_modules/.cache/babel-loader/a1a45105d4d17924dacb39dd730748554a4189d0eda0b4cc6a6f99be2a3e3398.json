{"ast":null,"code":"import { equalBytes } from '@noble/curves/abstract/utils';\nimport * as Bytes from './Bytes.js';\nimport * as Errors from './Errors.js';\nimport * as Json from './Json.js';\nimport * as internal_bytes from './internal/bytes.js';\nimport * as internal from './internal/hex.js';\nconst encoder = /*#__PURE__*/new TextEncoder();\nconst hexes = /*#__PURE__*/Array.from({\n  length: 256\n}, (_v, i) => i.toString(16).padStart(2, '0'));\n/**\n * Asserts if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('abc')\n * // @error: InvalidHexValueTypeError:\n * // @error: Value `\"abc\"` of type `string` is an invalid hex type.\n * // @error: Hex types must be represented as `\"0x\\${string}\"`.\n * ```\n *\n * @param value - The value to assert.\n * @param options - Options.\n */\nexport function assert(value, options = {}) {\n  const {\n    strict = false\n  } = options;\n  if (!value) throw new InvalidHexTypeError(value);\n  if (typeof value !== 'string') throw new InvalidHexTypeError(value);\n  if (strict) {\n    if (!/^0x[0-9a-fA-F]*$/.test(value)) throw new InvalidHexValueError(value);\n  }\n  if (!value.startsWith('0x')) throw new InvalidHexValueError(value);\n}\n/**\n * Concatenates two or more {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.concat('0x123', '0x456')\n * // @log: '0x123456'\n * ```\n *\n * @param values - The {@link ox#Hex.Hex} values to concatenate.\n * @returns The concatenated {@link ox#Hex.Hex} value.\n */\nexport function concat(...values) {\n  return `0x${values.reduce((acc, x) => acc + x.replace('0x', ''), '')}`;\n}\n/**\n * Instantiates a {@link ox#Hex.Hex} value from a hex string or {@link ox#Bytes.Bytes} value.\n *\n * :::tip\n *\n * To instantiate from a **Boolean**, **String**, or **Number**, use one of the following:\n *\n * - `Hex.fromBoolean`\n *\n * - `Hex.fromString`\n *\n * - `Hex.fromNumber`\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.from('0x48656c6c6f20576f726c6421')\n * // @log: '0x48656c6c6f20576f726c6421'\n *\n * Hex.from(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function from(value) {\n  if (value instanceof Uint8Array) return fromBytes(value);\n  if (Array.isArray(value)) return fromBytes(new Uint8Array(value));\n  return value;\n}\n/**\n * Encodes a boolean into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromBoolean(true)\n * // @log: '0x1'\n *\n * Hex.fromBoolean(false)\n * // @log: '0x0'\n *\n * Hex.fromBoolean(true, { size: 32 })\n * // @log: '0x0000000000000000000000000000000000000000000000000000000000000001'\n * ```\n *\n * @param value - The boolean value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromBoolean(value, options = {}) {\n  const hex = `0x${Number(value)}`;\n  if (typeof options.size === 'number') {\n    internal.assertSize(hex, options.size);\n    return padLeft(hex, options.size);\n  }\n  return hex;\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.fromBytes(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromBytes(value, options = {}) {\n  let string = '';\n  for (let i = 0; i < value.length; i++) string += hexes[value[i]];\n  const hex = `0x${string}`;\n  if (typeof options.size === 'number') {\n    internal.assertSize(hex, options.size);\n    return padRight(hex, options.size);\n  }\n  return hex;\n}\n/**\n * Encodes a number or bigint into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420)\n * // @log: '0x1a4'\n *\n * Hex.fromNumber(420, { size: 32 })\n * // @log: '0x00000000000000000000000000000000000000000000000000000000000001a4'\n * ```\n *\n * @param value - The number or bigint value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromNumber(value, options = {}) {\n  const {\n    signed,\n    size\n  } = options;\n  const value_ = BigInt(value);\n  let maxValue;\n  if (size) {\n    if (signed) maxValue = (1n << BigInt(size) * 8n - 1n) - 1n;else maxValue = 2n ** (BigInt(size) * 8n) - 1n;\n  } else if (typeof value === 'number') {\n    maxValue = BigInt(Number.MAX_SAFE_INTEGER);\n  }\n  const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;\n  if (maxValue && value_ > maxValue || value_ < minValue) {\n    const suffix = typeof value === 'bigint' ? 'n' : '';\n    throw new IntegerOutOfRangeError({\n      max: maxValue ? `${maxValue}${suffix}` : undefined,\n      min: `${minValue}${suffix}`,\n      signed,\n      size,\n      value: `${value}${suffix}`\n    });\n  }\n  const stringValue = (signed && value_ < 0 ? (1n << BigInt(size * 8)) + BigInt(value_) : value_).toString(16);\n  const hex = `0x${stringValue}`;\n  if (size) return padLeft(hex, size);\n  return hex;\n}\n/**\n * Encodes a string into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n * Hex.fromString('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * Hex.fromString('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n * ```\n *\n * @param value - The string value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromString(value, options = {}) {\n  return fromBytes(encoder.encode(value), options);\n}\n/**\n * Checks if two {@link ox#Hex.Hex} values are equal.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.isEqual('0xdeadbeef', '0xdeadbeef')\n * // @log: true\n *\n * Hex.isEqual('0xda', '0xba')\n * // @log: false\n * ```\n *\n * @param hexA - The first {@link ox#Hex.Hex} value.\n * @param hexB - The second {@link ox#Hex.Hex} value.\n * @returns `true` if the two {@link ox#Hex.Hex} values are equal, `false` otherwise.\n */\nexport function isEqual(hexA, hexB) {\n  return equalBytes(Bytes.fromHex(hexA), Bytes.fromHex(hexB));\n}\n/**\n * Pads a {@link ox#Hex.Hex} value to the left with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1234', 4)\n * // @log: '0x00001234'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */\nexport function padLeft(value, size) {\n  return internal.pad(value, {\n    dir: 'left',\n    size\n  });\n}\n/**\n * Pads a {@link ox#Hex.Hex} value to the right with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts\n * import { Hex } from 'ox'\n *\n * Hex.padRight('0x1234', 4)\n * // @log: '0x12340000'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */\nexport function padRight(value, size) {\n  return internal.pad(value, {\n    dir: 'right',\n    size\n  });\n}\n/**\n * Generates a random {@link ox#Hex.Hex} value of the specified length.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const hex = Hex.random(32)\n * // @log: '0x...'\n * ```\n *\n * @returns Random {@link ox#Hex.Hex} value.\n */\nexport function random(length) {\n  return fromBytes(Bytes.random(length));\n}\n/**\n * Returns a section of a {@link ox#Bytes.Bytes} value given a start/end bytes offset.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 1, 4)\n * // @log: '0x234567'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to slice.\n * @param start - The start offset (in bytes).\n * @param end - The end offset (in bytes).\n * @param options - Options.\n * @returns The sliced {@link ox#Hex.Hex} value.\n */\nexport function slice(value, start, end, options = {}) {\n  const {\n    strict\n  } = options;\n  internal.assertStartOffset(value, start);\n  const value_ = `0x${value.replace('0x', '').slice((start ?? 0) * 2, (end ?? value.length) * 2)}`;\n  if (strict) internal.assertEndOffset(value_, start, end);\n  return value_;\n}\n/**\n * Retrieves the size of a {@link ox#Hex.Hex} value (in bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.size('0xdeadbeef')\n * // @log: 4\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to get the size of.\n * @returns The size of the {@link ox#Hex.Hex} value (in bytes).\n */\nexport function size(value) {\n  return Math.ceil((value.length - 2) / 2);\n}\n/**\n * Trims leading zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimLeft('0x00000000deadbeef')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */\nexport function trimLeft(value) {\n  return internal.trim(value, {\n    dir: 'left'\n  });\n}\n/**\n * Trims trailing zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimRight('0xdeadbeef00000000')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */\nexport function trimRight(value) {\n  return internal.trim(value, {\n    dir: 'right'\n  });\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a BigInt.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBigInt('0x1a4')\n * // @log: 420n\n *\n * Hex.toBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420n\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded BigInt.\n */\nexport function toBigInt(hex, options = {}) {\n  const {\n    signed\n  } = options;\n  if (options.size) internal.assertSize(hex, options.size);\n  const value = BigInt(hex);\n  if (!signed) return value;\n  const size = (hex.length - 2) / 2;\n  const max_unsigned = (1n << BigInt(size) * 8n) - 1n;\n  const max_signed = max_unsigned >> 1n;\n  if (value <= max_signed) return value;\n  return value - max_unsigned - 1n;\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0x01')\n * // @log: true\n *\n * Hex.toBoolean('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })\n * // @log: true\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded boolean.\n */\nexport function toBoolean(hex, options = {}) {\n  if (options.size) internal.assertSize(hex, options.size);\n  const hex_ = trimLeft(hex);\n  if (hex_ === '0x') return false;\n  if (hex_ === '0x1') return true;\n  throw new InvalidHexBooleanError(hex);\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const data = Hex.toBytes('0x48656c6c6f20776f726c6421')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded {@link ox#Bytes.Bytes}.\n */\nexport function toBytes(hex, options = {}) {\n  return Bytes.fromHex(hex, options);\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a number.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toNumber('0x1a4')\n * // @log: 420\n *\n * Hex.toNumber('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded number.\n */\nexport function toNumber(hex, options = {}) {\n  const {\n    signed,\n    size\n  } = options;\n  if (!signed && !size) return Number(hex);\n  return Number(toBigInt(hex, options));\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a string.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toString('0x48656c6c6f20576f726c6421')\n * // @log: 'Hello world!'\n *\n * Hex.toString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *  size: 32,\n * })\n * // @log: 'Hello world'\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded string.\n */\nexport function toString(hex, options = {}) {\n  const {\n    size\n  } = options;\n  let bytes = Bytes.fromHex(hex);\n  if (size) {\n    internal_bytes.assertSize(bytes, size);\n    bytes = Bytes.trimRight(bytes);\n  }\n  return new TextDecoder().decode(bytes);\n}\n/**\n * Checks if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.validate('0xdeadbeef')\n * // @log: true\n *\n * Hex.validate(Bytes.from([1, 2, 3]))\n * // @log: false\n * ```\n *\n * @param value - The value to check.\n * @param options - Options.\n * @returns `true` if the value is a {@link ox#Hex.Hex}, `false` otherwise.\n */\nexport function validate(value, options = {}) {\n  const {\n    strict = false\n  } = options;\n  try {\n    assert(value, {\n      strict\n    });\n    return true;\n  } catch {\n    return false;\n  }\n}\n/**\n * Thrown when the provided integer is out of range, and cannot be represented as a hex value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420182738912731283712937129)\n * // @error: Hex.IntegerOutOfRangeError: Number \\`4.2018273891273126e+26\\` is not in safe unsigned integer range (`0` to `9007199254740991`)\n * ```\n */\nexport class IntegerOutOfRangeError extends Errors.BaseError {\n  constructor({\n    max,\n    min,\n    signed,\n    size,\n    value\n  }) {\n    super(`Number \\`${value}\\` is not in safe${size ? ` ${size * 8}-bit` : ''}${signed ? ' signed' : ' unsigned'} integer range ${max ? `(\\`${min}\\` to \\`${max}\\`)` : `(above \\`${min}\\`)`}`);\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Hex.IntegerOutOfRangeError'\n    });\n  }\n}\n/**\n * Thrown when the provided hex value cannot be represented as a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0xa')\n * // @error: Hex.InvalidHexBooleanError: Hex value `\"0xa\"` is not a valid boolean.\n * // @error: The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).\n * ```\n */\nexport class InvalidHexBooleanError extends Errors.BaseError {\n  constructor(hex) {\n    super(`Hex value \\`\"${hex}\"\\` is not a valid boolean.`, {\n      metaMessages: ['The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).']\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Hex.InvalidHexBooleanError'\n    });\n  }\n}\n/**\n * Thrown when the provided value is not a valid hex type.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert(1)\n * // @error: Hex.InvalidHexTypeError: Value `1` of type `number` is an invalid hex type.\n * ```\n */\nexport class InvalidHexTypeError extends Errors.BaseError {\n  constructor(value) {\n    super(`Value \\`${typeof value === 'object' ? Json.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid hex type.`, {\n      metaMessages: ['Hex types must be represented as `\"0x${string}\"`.']\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Hex.InvalidHexTypeError'\n    });\n  }\n}\n/**\n * Thrown when the provided hex value is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('0x0123456789abcdefg')\n * // @error: Hex.InvalidHexValueError: Value `0x0123456789abcdefg` is an invalid hex value.\n * // @error: Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).\n * ```\n */\nexport class InvalidHexValueError extends Errors.BaseError {\n  constructor(value) {\n    super(`Value \\`${value}\\` is an invalid hex value.`, {\n      metaMessages: ['Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).']\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Hex.InvalidHexValueError'\n    });\n  }\n}\n/**\n * Thrown when the provided hex value is an odd length.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.fromHex('0xabcde')\n * // @error: Hex.InvalidLengthError: Hex value `\"0xabcde\"` is an odd length (5 nibbles).\n * ```\n */\nexport class InvalidLengthError extends Errors.BaseError {\n  constructor(value) {\n    super(`Hex value \\`\"${value}\"\\` is an odd length (${value.length - 2} nibbles).`, {\n      metaMessages: ['It must be an even length.']\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Hex.InvalidLengthError'\n    });\n  }\n}\n/**\n * Thrown when the size of the value exceeds the expected max size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromString('Hello World!', { size: 8 })\n * // @error: Hex.SizeOverflowError: Size cannot exceed `8` bytes. Given size: `12` bytes.\n * ```\n */\nexport class SizeOverflowError extends Errors.BaseError {\n  constructor({\n    givenSize,\n    maxSize\n  }) {\n    super(`Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`);\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Hex.SizeOverflowError'\n    });\n  }\n}\n/**\n * Thrown when the slice offset exceeds the bounds of the value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 6)\n * // @error: Hex.SliceOffsetOutOfBoundsError: Slice starting at offset `6` is out-of-bounds (size: `5`).\n * ```\n */\nexport class SliceOffsetOutOfBoundsError extends Errors.BaseError {\n  constructor({\n    offset,\n    position,\n    size\n  }) {\n    super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`);\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Hex.SliceOffsetOutOfBoundsError'\n    });\n  }\n}\n/**\n * Thrown when the size of the value exceeds the pad size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1a4e12a45a21323123aaa87a897a897a898a6567a578a867a98778a667a85a875a87a6a787a65a675a6a9', 32)\n * // @error: Hex.SizeExceedsPaddingSizeError: Hex size (`43`) exceeds padding size (`32`).\n * ```\n */\nexport class SizeExceedsPaddingSizeError extends Errors.BaseError {\n  constructor({\n    size,\n    targetSize,\n    type\n  }) {\n    super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`);\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Hex.SizeExceedsPaddingSizeError'\n    });\n  }\n}","map":{"version":3,"names":["equalBytes","Bytes","Errors","Json","internal_bytes","internal","encoder","TextEncoder","hexes","Array","from","length","_v","i","toString","padStart","assert","value","options","strict","InvalidHexTypeError","test","InvalidHexValueError","startsWith","concat","values","reduce","acc","x","replace","Uint8Array","fromBytes","isArray","fromBoolean","hex","Number","size","assertSize","padLeft","string","padRight","fromNumber","signed","value_","BigInt","maxValue","MAX_SAFE_INTEGER","minValue","suffix","IntegerOutOfRangeError","max","undefined","min","stringValue","fromString","encode","isEqual","hexA","hexB","fromHex","pad","dir","random","slice","start","end","assertStartOffset","assertEndOffset","Math","ceil","trimLeft","trim","trimRight","toBigInt","max_unsigned","max_signed","toBoolean","hex_","InvalidHexBooleanError","toBytes","toNumber","bytes","TextDecoder","decode","validate","BaseError","constructor","Object","defineProperty","metaMessages","stringify","InvalidLengthError","SizeOverflowError","givenSize","maxSize","SliceOffsetOutOfBoundsError","offset","position","SizeExceedsPaddingSizeError","targetSize","type","charAt","toUpperCase","toLowerCase"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@reown\\appkit\\node_modules\\ox\\core\\Hex.ts"],"sourcesContent":["import { equalBytes } from '@noble/curves/abstract/utils'\nimport * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as Json from './Json.js'\nimport * as internal_bytes from './internal/bytes.js'\nimport * as internal from './internal/hex.js'\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\n\nconst hexes = /*#__PURE__*/ Array.from({ length: 256 }, (_v, i) =>\n  i.toString(16).padStart(2, '0'),\n)\n\n/** Root type for a Hex string. */\nexport type Hex = `0x${string}`\n\n/**\n * Asserts if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('abc')\n * // @error: InvalidHexValueTypeError:\n * // @error: Value `\"abc\"` of type `string` is an invalid hex type.\n * // @error: Hex types must be represented as `\"0x\\${string}\"`.\n * ```\n *\n * @param value - The value to assert.\n * @param options - Options.\n */\nexport function assert(\n  value: unknown,\n  options: assert.Options = {},\n): asserts value is Hex {\n  const { strict = false } = options\n  if (!value) throw new InvalidHexTypeError(value)\n  if (typeof value !== 'string') throw new InvalidHexTypeError(value)\n  if (strict) {\n    if (!/^0x[0-9a-fA-F]*$/.test(value)) throw new InvalidHexValueError(value)\n  }\n  if (!value.startsWith('0x')) throw new InvalidHexValueError(value)\n}\n\nexport declare namespace assert {\n  type Options = {\n    /** Checks if the {@link ox#Hex.Hex} value contains invalid hexadecimal characters. @default false */\n    strict?: boolean | undefined\n  }\n\n  type ErrorType =\n    | InvalidHexTypeError\n    | InvalidHexValueError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Concatenates two or more {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.concat('0x123', '0x456')\n * // @log: '0x123456'\n * ```\n *\n * @param values - The {@link ox#Hex.Hex} values to concatenate.\n * @returns The concatenated {@link ox#Hex.Hex} value.\n */\nexport function concat(...values: readonly Hex[]): Hex {\n  return `0x${(values as Hex[]).reduce((acc, x) => acc + x.replace('0x', ''), '')}`\n}\n\nexport declare namespace concat {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Instantiates a {@link ox#Hex.Hex} value from a hex string or {@link ox#Bytes.Bytes} value.\n *\n * :::tip\n *\n * To instantiate from a **Boolean**, **String**, or **Number**, use one of the following:\n *\n * - `Hex.fromBoolean`\n *\n * - `Hex.fromString`\n *\n * - `Hex.fromNumber`\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.from('0x48656c6c6f20576f726c6421')\n * // @log: '0x48656c6c6f20576f726c6421'\n *\n * Hex.from(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function from(value: Hex | Bytes.Bytes | readonly number[]): Hex {\n  if (value instanceof Uint8Array) return fromBytes(value)\n  if (Array.isArray(value)) return fromBytes(new Uint8Array(value))\n  return value as never\n}\n\nexport declare namespace from {\n  type Options = {\n    /** The size (in bytes) of the output hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType = fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a boolean into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromBoolean(true)\n * // @log: '0x1'\n *\n * Hex.fromBoolean(false)\n * // @log: '0x0'\n *\n * Hex.fromBoolean(true, { size: 32 })\n * // @log: '0x0000000000000000000000000000000000000000000000000000000000000001'\n * ```\n *\n * @param value - The boolean value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromBoolean(\n  value: boolean,\n  options: fromBoolean.Options = {},\n): Hex {\n  const hex: Hex = `0x${Number(value)}`\n  if (typeof options.size === 'number') {\n    internal.assertSize(hex, options.size)\n    return padLeft(hex, options.size)\n  }\n  return hex\n}\n\nexport declare namespace fromBoolean {\n  type Options = {\n    /** The size (in bytes) of the output hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | internal.assertSize.ErrorType\n    | padLeft.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.fromBytes(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromBytes(\n  value: Bytes.Bytes,\n  options: fromBytes.Options = {},\n): Hex {\n  let string = ''\n  for (let i = 0; i < value.length; i++) string += hexes[value[i]!]\n  const hex = `0x${string}` as const\n\n  if (typeof options.size === 'number') {\n    internal.assertSize(hex, options.size)\n    return padRight(hex, options.size)\n  }\n  return hex\n}\n\nexport declare namespace fromBytes {\n  type Options = {\n    /** The size (in bytes) of the output hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | internal.assertSize.ErrorType\n    | padRight.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a number or bigint into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420)\n * // @log: '0x1a4'\n *\n * Hex.fromNumber(420, { size: 32 })\n * // @log: '0x00000000000000000000000000000000000000000000000000000000000001a4'\n * ```\n *\n * @param value - The number or bigint value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromNumber(\n  value: number | bigint,\n  options: fromNumber.Options = {},\n): Hex {\n  const { signed, size } = options\n\n  const value_ = BigInt(value)\n\n  let maxValue: bigint | number | undefined\n  if (size) {\n    if (signed) maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n\n    else maxValue = 2n ** (BigInt(size) * 8n) - 1n\n  } else if (typeof value === 'number') {\n    maxValue = BigInt(Number.MAX_SAFE_INTEGER)\n  }\n\n  const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0\n\n  if ((maxValue && value_ > maxValue) || value_ < minValue) {\n    const suffix = typeof value === 'bigint' ? 'n' : ''\n    throw new IntegerOutOfRangeError({\n      max: maxValue ? `${maxValue}${suffix}` : undefined,\n      min: `${minValue}${suffix}`,\n      signed,\n      size,\n      value: `${value}${suffix}`,\n    })\n  }\n\n  const stringValue = (\n    signed && value_ < 0 ? (1n << BigInt(size * 8)) + BigInt(value_) : value_\n  ).toString(16)\n\n  const hex = `0x${stringValue}` as Hex\n  if (size) return padLeft(hex, size) as Hex\n  return hex\n}\n\nexport declare namespace fromNumber {\n  type Options =\n    | {\n        /** Whether or not the number of a signed representation. */\n        signed?: boolean | undefined\n        /** The size (in bytes) of the output hex value. */\n        size: number\n      }\n    | {\n        signed?: undefined\n        /** The size (in bytes) of the output hex value. */\n        size?: number | undefined\n      }\n\n  type ErrorType =\n    | IntegerOutOfRangeError\n    | padLeft.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a string into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n * Hex.fromString('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * Hex.fromString('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n * ```\n *\n * @param value - The string value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromString(\n  value: string,\n  options: fromString.Options = {},\n): Hex {\n  return fromBytes(encoder.encode(value), options)\n}\n\nexport declare namespace fromString {\n  type Options = {\n    /** The size (in bytes) of the output hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType = fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Checks if two {@link ox#Hex.Hex} values are equal.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.isEqual('0xdeadbeef', '0xdeadbeef')\n * // @log: true\n *\n * Hex.isEqual('0xda', '0xba')\n * // @log: false\n * ```\n *\n * @param hexA - The first {@link ox#Hex.Hex} value.\n * @param hexB - The second {@link ox#Hex.Hex} value.\n * @returns `true` if the two {@link ox#Hex.Hex} values are equal, `false` otherwise.\n */\nexport function isEqual(hexA: Hex, hexB: Hex) {\n  return equalBytes(Bytes.fromHex(hexA), Bytes.fromHex(hexB))\n}\n\nexport declare namespace isEqual {\n  type ErrorType = Bytes.fromHex.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Pads a {@link ox#Hex.Hex} value to the left with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1234', 4)\n * // @log: '0x00001234'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */\nexport function padLeft(\n  value: Hex,\n  size?: number | undefined,\n): padLeft.ReturnType {\n  return internal.pad(value, { dir: 'left', size })\n}\n\nexport declare namespace padLeft {\n  type ReturnType = Hex\n  type ErrorType = internal.pad.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Pads a {@link ox#Hex.Hex} value to the right with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts\n * import { Hex } from 'ox'\n *\n * Hex.padRight('0x1234', 4)\n * // @log: '0x12340000'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */\nexport function padRight(\n  value: Hex,\n  size?: number | undefined,\n): padRight.ReturnType {\n  return internal.pad(value, { dir: 'right', size })\n}\n\nexport declare namespace padRight {\n  type ReturnType = Hex\n  type ErrorType = internal.pad.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Generates a random {@link ox#Hex.Hex} value of the specified length.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const hex = Hex.random(32)\n * // @log: '0x...'\n * ```\n *\n * @returns Random {@link ox#Hex.Hex} value.\n */\nexport function random(length: number): Hex {\n  return fromBytes(Bytes.random(length))\n}\n\nexport declare namespace random {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Returns a section of a {@link ox#Bytes.Bytes} value given a start/end bytes offset.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 1, 4)\n * // @log: '0x234567'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to slice.\n * @param start - The start offset (in bytes).\n * @param end - The end offset (in bytes).\n * @param options - Options.\n * @returns The sliced {@link ox#Hex.Hex} value.\n */\nexport function slice(\n  value: Hex,\n  start?: number | undefined,\n  end?: number | undefined,\n  options: slice.Options = {},\n): Hex {\n  const { strict } = options\n  internal.assertStartOffset(value, start)\n  const value_ = `0x${value\n    .replace('0x', '')\n    .slice((start ?? 0) * 2, (end ?? value.length) * 2)}` as const\n  if (strict) internal.assertEndOffset(value_, start, end)\n  return value_\n}\n\nexport declare namespace slice {\n  type Options = {\n    /** Asserts that the sliced value is the same size as the given start/end offsets. */\n    strict?: boolean | undefined\n  }\n\n  type ErrorType =\n    | internal.assertStartOffset.ErrorType\n    | internal.assertEndOffset.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Retrieves the size of a {@link ox#Hex.Hex} value (in bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.size('0xdeadbeef')\n * // @log: 4\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to get the size of.\n * @returns The size of the {@link ox#Hex.Hex} value (in bytes).\n */\nexport function size(value: Hex): number {\n  return Math.ceil((value.length - 2) / 2)\n}\n\nexport declare namespace size {\n  export type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Trims leading zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimLeft('0x00000000deadbeef')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */\nexport function trimLeft(value: Hex): trimLeft.ReturnType {\n  return internal.trim(value, { dir: 'left' })\n}\n\nexport declare namespace trimLeft {\n  type ReturnType = Hex\n\n  type ErrorType = internal.trim.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Trims trailing zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimRight('0xdeadbeef00000000')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */\nexport function trimRight(value: Hex): trimRight.ReturnType {\n  return internal.trim(value, { dir: 'right' })\n}\n\nexport declare namespace trimRight {\n  type ReturnType = Hex\n\n  type ErrorType = internal.trim.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Hex.Hex} value into a BigInt.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBigInt('0x1a4')\n * // @log: 420n\n *\n * Hex.toBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420n\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded BigInt.\n */\nexport function toBigInt(hex: Hex, options: toBigInt.Options = {}): bigint {\n  const { signed } = options\n\n  if (options.size) internal.assertSize(hex, options.size)\n\n  const value = BigInt(hex)\n  if (!signed) return value\n\n  const size = (hex.length - 2) / 2\n\n  const max_unsigned = (1n << (BigInt(size) * 8n)) - 1n\n  const max_signed = max_unsigned >> 1n\n\n  if (value <= max_signed) return value\n  return value - max_unsigned - 1n\n}\n\nexport declare namespace toBigInt {\n  type Options = {\n    /** Whether or not the number of a signed representation. */\n    signed?: boolean | undefined\n    /** Size (in bytes) of the hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType = internal.assertSize.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Hex.Hex} value into a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0x01')\n * // @log: true\n *\n * Hex.toBoolean('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })\n * // @log: true\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded boolean.\n */\nexport function toBoolean(hex: Hex, options: toBoolean.Options = {}): boolean {\n  if (options.size) internal.assertSize(hex, options.size)\n  const hex_ = trimLeft(hex)\n  if (hex_ === '0x') return false\n  if (hex_ === '0x1') return true\n  throw new InvalidHexBooleanError(hex)\n}\n\nexport declare namespace toBoolean {\n  type Options = {\n    /** Size (in bytes) of the hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | internal.assertSize.ErrorType\n    | trimLeft.ErrorType\n    | InvalidHexBooleanError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Hex.Hex} value into a {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const data = Hex.toBytes('0x48656c6c6f20776f726c6421')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded {@link ox#Bytes.Bytes}.\n */\nexport function toBytes(hex: Hex, options: toBytes.Options = {}): Bytes.Bytes {\n  return Bytes.fromHex(hex, options)\n}\n\nexport declare namespace toBytes {\n  type Options = {\n    /** Size (in bytes) of the hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType = Bytes.fromHex.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Hex.Hex} value into a number.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toNumber('0x1a4')\n * // @log: 420\n *\n * Hex.toNumber('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded number.\n */\nexport function toNumber(hex: Hex, options: toNumber.Options = {}): number {\n  const { signed, size } = options\n  if (!signed && !size) return Number(hex)\n  return Number(toBigInt(hex, options))\n}\n\nexport declare namespace toNumber {\n  type Options = toBigInt.Options\n\n  type ErrorType = toBigInt.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Hex.Hex} value into a string.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toString('0x48656c6c6f20576f726c6421')\n * // @log: 'Hello world!'\n *\n * Hex.toString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *  size: 32,\n * })\n * // @log: 'Hello world'\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded string.\n */\nexport function toString(hex: Hex, options: toString.Options = {}): string {\n  const { size } = options\n\n  let bytes = Bytes.fromHex(hex)\n  if (size) {\n    internal_bytes.assertSize(bytes, size)\n    bytes = Bytes.trimRight(bytes)\n  }\n  return new TextDecoder().decode(bytes)\n}\n\nexport declare namespace toString {\n  type Options = {\n    /** Size (in bytes) of the hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | internal_bytes.assertSize.ErrorType\n    | Bytes.fromHex.ErrorType\n    | Bytes.trimRight.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Checks if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.validate('0xdeadbeef')\n * // @log: true\n *\n * Hex.validate(Bytes.from([1, 2, 3]))\n * // @log: false\n * ```\n *\n * @param value - The value to check.\n * @param options - Options.\n * @returns `true` if the value is a {@link ox#Hex.Hex}, `false` otherwise.\n */\nexport function validate(\n  value: unknown,\n  options: validate.Options = {},\n): value is Hex {\n  const { strict = false } = options\n  try {\n    assert(value, { strict })\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type Options = {\n    /** Checks if the {@link ox#Hex.Hex} value contains invalid hexadecimal characters. @default false */\n    strict?: boolean | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Thrown when the provided integer is out of range, and cannot be represented as a hex value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420182738912731283712937129)\n * // @error: Hex.IntegerOutOfRangeError: Number \\`4.2018273891273126e+26\\` is not in safe unsigned integer range (`0` to `9007199254740991`)\n * ```\n */\nexport class IntegerOutOfRangeError extends Errors.BaseError {\n  override readonly name = 'Hex.IntegerOutOfRangeError'\n\n  constructor({\n    max,\n    min,\n    signed,\n    size,\n    value,\n  }: {\n    max?: string | undefined\n    min: string\n    signed?: boolean | undefined\n    size?: number | undefined\n    value: string\n  }) {\n    super(\n      `Number \\`${value}\\` is not in safe${\n        size ? ` ${size * 8}-bit` : ''\n      }${signed ? ' signed' : ' unsigned'} integer range ${max ? `(\\`${min}\\` to \\`${max}\\`)` : `(above \\`${min}\\`)`}`,\n    )\n  }\n}\n\n/**\n * Thrown when the provided hex value cannot be represented as a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0xa')\n * // @error: Hex.InvalidHexBooleanError: Hex value `\"0xa\"` is not a valid boolean.\n * // @error: The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).\n * ```\n */\nexport class InvalidHexBooleanError extends Errors.BaseError {\n  override readonly name = 'Hex.InvalidHexBooleanError'\n\n  constructor(hex: Hex) {\n    super(`Hex value \\`\"${hex}\"\\` is not a valid boolean.`, {\n      metaMessages: [\n        'The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).',\n      ],\n    })\n  }\n}\n\n/**\n * Thrown when the provided value is not a valid hex type.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert(1)\n * // @error: Hex.InvalidHexTypeError: Value `1` of type `number` is an invalid hex type.\n * ```\n */\nexport class InvalidHexTypeError extends Errors.BaseError {\n  override readonly name = 'Hex.InvalidHexTypeError'\n\n  constructor(value: unknown) {\n    super(\n      `Value \\`${typeof value === 'object' ? Json.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid hex type.`,\n      {\n        metaMessages: ['Hex types must be represented as `\"0x${string}\"`.'],\n      },\n    )\n  }\n}\n\n/**\n * Thrown when the provided hex value is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('0x0123456789abcdefg')\n * // @error: Hex.InvalidHexValueError: Value `0x0123456789abcdefg` is an invalid hex value.\n * // @error: Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).\n * ```\n */\nexport class InvalidHexValueError extends Errors.BaseError {\n  override readonly name = 'Hex.InvalidHexValueError'\n\n  constructor(value: unknown) {\n    super(`Value \\`${value}\\` is an invalid hex value.`, {\n      metaMessages: [\n        'Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).',\n      ],\n    })\n  }\n}\n\n/**\n * Thrown when the provided hex value is an odd length.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.fromHex('0xabcde')\n * // @error: Hex.InvalidLengthError: Hex value `\"0xabcde\"` is an odd length (5 nibbles).\n * ```\n */\nexport class InvalidLengthError extends Errors.BaseError {\n  override readonly name = 'Hex.InvalidLengthError'\n\n  constructor(value: Hex) {\n    super(\n      `Hex value \\`\"${value}\"\\` is an odd length (${value.length - 2} nibbles).`,\n      {\n        metaMessages: ['It must be an even length.'],\n      },\n    )\n  }\n}\n\n/**\n * Thrown when the size of the value exceeds the expected max size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromString('Hello World!', { size: 8 })\n * // @error: Hex.SizeOverflowError: Size cannot exceed `8` bytes. Given size: `12` bytes.\n * ```\n */\nexport class SizeOverflowError extends Errors.BaseError {\n  override readonly name = 'Hex.SizeOverflowError'\n\n  constructor({ givenSize, maxSize }: { givenSize: number; maxSize: number }) {\n    super(\n      `Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`,\n    )\n  }\n}\n\n/**\n * Thrown when the slice offset exceeds the bounds of the value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 6)\n * // @error: Hex.SliceOffsetOutOfBoundsError: Slice starting at offset `6` is out-of-bounds (size: `5`).\n * ```\n */\nexport class SliceOffsetOutOfBoundsError extends Errors.BaseError {\n  override readonly name = 'Hex.SliceOffsetOutOfBoundsError'\n\n  constructor({\n    offset,\n    position,\n    size,\n  }: { offset: number; position: 'start' | 'end'; size: number }) {\n    super(\n      `Slice ${\n        position === 'start' ? 'starting' : 'ending'\n      } at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`,\n    )\n  }\n}\n\n/**\n * Thrown when the size of the value exceeds the pad size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1a4e12a45a21323123aaa87a897a897a898a6567a578a867a98778a667a85a875a87a6a787a65a675a6a9', 32)\n * // @error: Hex.SizeExceedsPaddingSizeError: Hex size (`43`) exceeds padding size (`32`).\n * ```\n */\nexport class SizeExceedsPaddingSizeError extends Errors.BaseError {\n  override readonly name = 'Hex.SizeExceedsPaddingSizeError'\n\n  constructor({\n    size,\n    targetSize,\n    type,\n  }: {\n    size: number\n    targetSize: number\n    type: 'Hex' | 'Bytes'\n  }) {\n    super(\n      `${type.charAt(0).toUpperCase()}${type\n        .slice(1)\n        .toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`,\n    )\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}