{"ast":null,"code":"import { textResolverAbi, universalResolverResolveAbi } from '../../constants/abis.js';\nimport { decodeFunctionResult } from '../../utils/abi/decodeFunctionResult.js';\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js';\nimport { getChainContractAddress } from '../../utils/chain/getChainContractAddress.js';\nimport { toHex } from '../../utils/encoding/toHex.js';\nimport { isNullUniversalResolverError } from '../../utils/ens/errors.js';\nimport { localBatchGatewayUrl } from '../../utils/ens/localBatchGatewayRequest.js';\nimport { namehash } from '../../utils/ens/namehash.js';\nimport { packetToBytes } from '../../utils/ens/packetToBytes.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { readContract } from '../public/readContract.js';\n/**\n * Gets a text record for specified ENS name.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsResolver\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens\n *\n * Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsTextParameters}\n * @returns Address for ENS resolver. {@link GetEnsTextReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsText, normalize } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const twitterRecord = await getEnsText(client, {\n *   name: normalize('wevm.eth'),\n *   key: 'com.twitter',\n * })\n * // 'wevm_dev'\n */\nexport async function getEnsText(client, parameters) {\n  const {\n    blockNumber,\n    blockTag,\n    key,\n    name,\n    gatewayUrls,\n    strict\n  } = parameters;\n  const {\n    chain\n  } = client;\n  const universalResolverAddress = (() => {\n    if (parameters.universalResolverAddress) return parameters.universalResolverAddress;\n    if (!chain) throw new Error('client chain not configured. universalResolverAddress is required.');\n    return getChainContractAddress({\n      blockNumber,\n      chain,\n      contract: 'ensUniversalResolver'\n    });\n  })();\n  const tlds = chain?.ensTlds;\n  if (tlds && !tlds.some(tld => name.endsWith(tld))) return null;\n  try {\n    const readContractParameters = {\n      address: universalResolverAddress,\n      abi: universalResolverResolveAbi,\n      functionName: 'resolve',\n      args: [toHex(packetToBytes(name)), encodeFunctionData({\n        abi: textResolverAbi,\n        functionName: 'text',\n        args: [namehash(name), key]\n      }), gatewayUrls ?? [localBatchGatewayUrl]],\n      blockNumber,\n      blockTag\n    };\n    const readContractAction = getAction(client, readContract, 'readContract');\n    const res = await readContractAction(readContractParameters);\n    if (res[0] === '0x') return null;\n    const record = decodeFunctionResult({\n      abi: textResolverAbi,\n      functionName: 'text',\n      data: res[0]\n    });\n    return record === '' ? null : record;\n  } catch (err) {\n    if (strict) throw err;\n    if (isNullUniversalResolverError(err, 'resolve')) return null;\n    throw err;\n  }\n}","map":{"version":3,"names":["textResolverAbi","universalResolverResolveAbi","decodeFunctionResult","encodeFunctionData","getChainContractAddress","toHex","isNullUniversalResolverError","localBatchGatewayUrl","namehash","packetToBytes","getAction","readContract","getEnsText","client","parameters","blockNumber","blockTag","key","name","gatewayUrls","strict","chain","universalResolverAddress","Error","contract","tlds","ensTlds","some","tld","endsWith","readContractParameters","address","abi","functionName","args","readContractAction","res","record","data","err"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\viem\\actions\\ens\\getEnsText.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  textResolverAbi,\n  universalResolverResolveAbi,\n} from '../../constants/abis.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Prettify } from '../../types/utils.js'\nimport {\n  type DecodeFunctionResultErrorType,\n  decodeFunctionResult,\n} from '../../utils/abi/decodeFunctionResult.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport {\n  type GetChainContractAddressErrorType,\n  getChainContractAddress,\n} from '../../utils/chain/getChainContractAddress.js'\nimport { type ToHexErrorType, toHex } from '../../utils/encoding/toHex.js'\nimport { isNullUniversalResolverError } from '../../utils/ens/errors.js'\nimport { localBatchGatewayUrl } from '../../utils/ens/localBatchGatewayRequest.js'\nimport { type NamehashErrorType, namehash } from '../../utils/ens/namehash.js'\nimport {\n  type PacketToBytesErrorType,\n  packetToBytes,\n} from '../../utils/ens/packetToBytes.js'\nimport { getAction } from '../../utils/getAction.js'\nimport {\n  type ReadContractErrorType,\n  type ReadContractParameters,\n  readContract,\n} from '../public/readContract.js'\n\nexport type GetEnsTextParameters = Prettify<\n  Pick<ReadContractParameters, 'blockNumber' | 'blockTag'> & {\n    /** ENS name to get Text for. */\n    name: string\n    /** Universal Resolver gateway URLs to use for resolving CCIP-read requests. */\n    gatewayUrls?: string[] | undefined\n    /** Text record to retrieve. */\n    key: string\n    /** Whether or not to throw errors propagated from the ENS Universal Resolver Contract. */\n    strict?: boolean | undefined\n    /** Address of ENS Universal Resolver Contract. */\n    universalResolverAddress?: Address | undefined\n  }\n>\n\nexport type GetEnsTextReturnType = string | null\n\nexport type GetEnsTextErrorType =\n  | GetChainContractAddressErrorType\n  | ReadContractErrorType\n  | ToHexErrorType\n  | PacketToBytesErrorType\n  | EncodeFunctionDataErrorType\n  | NamehashErrorType\n  | DecodeFunctionResultErrorType\n\n/**\n * Gets a text record for specified ENS name.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsResolver\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens\n *\n * Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsTextParameters}\n * @returns Address for ENS resolver. {@link GetEnsTextReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsText, normalize } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const twitterRecord = await getEnsText(client, {\n *   name: normalize('wevm.eth'),\n *   key: 'com.twitter',\n * })\n * // 'wevm_dev'\n */\nexport async function getEnsText<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: GetEnsTextParameters,\n): Promise<GetEnsTextReturnType> {\n  const { blockNumber, blockTag, key, name, gatewayUrls, strict } = parameters\n  const { chain } = client\n\n  const universalResolverAddress = (() => {\n    if (parameters.universalResolverAddress)\n      return parameters.universalResolverAddress\n    if (!chain)\n      throw new Error(\n        'client chain not configured. universalResolverAddress is required.',\n      )\n    return getChainContractAddress({\n      blockNumber,\n      chain,\n      contract: 'ensUniversalResolver',\n    })\n  })()\n\n  const tlds = chain?.ensTlds\n  if (tlds && !tlds.some((tld) => name.endsWith(tld))) return null\n\n  try {\n    const readContractParameters = {\n      address: universalResolverAddress,\n      abi: universalResolverResolveAbi,\n      functionName: 'resolve',\n      args: [\n        toHex(packetToBytes(name)),\n        encodeFunctionData({\n          abi: textResolverAbi,\n          functionName: 'text',\n          args: [namehash(name), key],\n        }),\n        gatewayUrls ?? [localBatchGatewayUrl],\n      ],\n      blockNumber,\n      blockTag,\n    } as const\n\n    const readContractAction = getAction(client, readContract, 'readContract')\n\n    const res = await readContractAction(readContractParameters)\n\n    if (res[0] === '0x') return null\n\n    const record = decodeFunctionResult({\n      abi: textResolverAbi,\n      functionName: 'text',\n      data: res[0],\n    })\n\n    return record === '' ? null : record\n  } catch (err) {\n    if (strict) throw err\n    if (isNullUniversalResolverError(err, 'resolve')) return null\n    throw err\n  }\n}\n"],"mappings":"AAIA,SACEA,eAAe,EACfC,2BAA2B,QACtB,yBAAyB;AAGhC,SAEEC,oBAAoB,QACf,yCAAyC;AAChD,SAEEC,kBAAkB,QACb,uCAAuC;AAC9C,SAEEC,uBAAuB,QAClB,8CAA8C;AACrD,SAA8BC,KAAK,QAAQ,+BAA+B;AAC1E,SAASC,4BAA4B,QAAQ,2BAA2B;AACxE,SAASC,oBAAoB,QAAQ,6CAA6C;AAClF,SAAiCC,QAAQ,QAAQ,6BAA6B;AAC9E,SAEEC,aAAa,QACR,kCAAkC;AACzC,SAASC,SAAS,QAAQ,0BAA0B;AACpD,SAGEC,YAAY,QACP,2BAA2B;AA4BlC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA,OAAO,eAAeC,UAAUA,CAC9BC,MAAgC,EAChCC,UAAgC;EAEhC,MAAM;IAAEC,WAAW;IAAEC,QAAQ;IAAEC,GAAG;IAAEC,IAAI;IAAEC,WAAW;IAAEC;EAAM,CAAE,GAAGN,UAAU;EAC5E,MAAM;IAAEO;EAAK,CAAE,GAAGR,MAAM;EAExB,MAAMS,wBAAwB,GAAG,CAAC,MAAK;IACrC,IAAIR,UAAU,CAACQ,wBAAwB,EACrC,OAAOR,UAAU,CAACQ,wBAAwB;IAC5C,IAAI,CAACD,KAAK,EACR,MAAM,IAAIE,KAAK,CACb,oEAAoE,CACrE;IACH,OAAOnB,uBAAuB,CAAC;MAC7BW,WAAW;MACXM,KAAK;MACLG,QAAQ,EAAE;KACX,CAAC;EACJ,CAAC,EAAC,CAAE;EAEJ,MAAMC,IAAI,GAAGJ,KAAK,EAAEK,OAAO;EAC3B,IAAID,IAAI,IAAI,CAACA,IAAI,CAACE,IAAI,CAAEC,GAAG,IAAKV,IAAI,CAACW,QAAQ,CAACD,GAAG,CAAC,CAAC,EAAE,OAAO,IAAI;EAEhE,IAAI;IACF,MAAME,sBAAsB,GAAG;MAC7BC,OAAO,EAAET,wBAAwB;MACjCU,GAAG,EAAE/B,2BAA2B;MAChCgC,YAAY,EAAE,SAAS;MACvBC,IAAI,EAAE,CACJ7B,KAAK,CAACI,aAAa,CAACS,IAAI,CAAC,CAAC,EAC1Bf,kBAAkB,CAAC;QACjB6B,GAAG,EAAEhC,eAAe;QACpBiC,YAAY,EAAE,MAAM;QACpBC,IAAI,EAAE,CAAC1B,QAAQ,CAACU,IAAI,CAAC,EAAED,GAAG;OAC3B,CAAC,EACFE,WAAW,IAAI,CAACZ,oBAAoB,CAAC,CACtC;MACDQ,WAAW;MACXC;KACQ;IAEV,MAAMmB,kBAAkB,GAAGzB,SAAS,CAACG,MAAM,EAAEF,YAAY,EAAE,cAAc,CAAC;IAE1E,MAAMyB,GAAG,GAAG,MAAMD,kBAAkB,CAACL,sBAAsB,CAAC;IAE5D,IAAIM,GAAG,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE,OAAO,IAAI;IAEhC,MAAMC,MAAM,GAAGnC,oBAAoB,CAAC;MAClC8B,GAAG,EAAEhC,eAAe;MACpBiC,YAAY,EAAE,MAAM;MACpBK,IAAI,EAAEF,GAAG,CAAC,CAAC;KACZ,CAAC;IAEF,OAAOC,MAAM,KAAK,EAAE,GAAG,IAAI,GAAGA,MAAM;EACtC,CAAC,CAAC,OAAOE,GAAG,EAAE;IACZ,IAAInB,MAAM,EAAE,MAAMmB,GAAG;IACrB,IAAIjC,4BAA4B,CAACiC,GAAG,EAAE,SAAS,CAAC,EAAE,OAAO,IAAI;IAC7D,MAAMA,GAAG;EACX;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}