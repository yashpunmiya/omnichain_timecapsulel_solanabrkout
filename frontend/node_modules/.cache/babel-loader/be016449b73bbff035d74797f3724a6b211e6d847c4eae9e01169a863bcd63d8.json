{"ast":null,"code":"import { getChainContractAddress } from '../../utils/chain/getChainContractAddress.js';\nimport { toHex } from '../../utils/encoding/toHex.js';\nimport { packetToBytes } from '../../utils/ens/packetToBytes.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { readContract } from '../public/readContract.js';\n/**\n * Gets resolver for ENS name.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsResolver\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens\n *\n * Calls `findResolver(bytes)` on ENS Universal Resolver Contract to retrieve the resolver of an ENS name.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsResolverParameters}\n * @returns Address for ENS resolver. {@link GetEnsResolverReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsResolver, normalize } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const resolverAddress = await getEnsResolver(client, {\n *   name: normalize('wevm.eth'),\n * })\n * // '0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41'\n */\nexport async function getEnsResolver(client, parameters) {\n  const {\n    blockNumber,\n    blockTag,\n    name\n  } = parameters;\n  const {\n    chain\n  } = client;\n  const universalResolverAddress = (() => {\n    if (parameters.universalResolverAddress) return parameters.universalResolverAddress;\n    if (!chain) throw new Error('client chain not configured. universalResolverAddress is required.');\n    return getChainContractAddress({\n      blockNumber,\n      chain,\n      contract: 'ensUniversalResolver'\n    });\n  })();\n  const tlds = chain?.ensTlds;\n  if (tlds && !tlds.some(tld => name.endsWith(tld))) throw new Error(`${name} is not a valid ENS TLD (${tlds?.join(', ')}) for chain \"${chain.name}\" (id: ${chain.id}).`);\n  const [resolverAddress] = await getAction(client, readContract, 'readContract')({\n    address: universalResolverAddress,\n    abi: [{\n      inputs: [{\n        type: 'bytes'\n      }],\n      name: 'findResolver',\n      outputs: [{\n        type: 'address'\n      }, {\n        type: 'bytes32'\n      }],\n      stateMutability: 'view',\n      type: 'function'\n    }],\n    functionName: 'findResolver',\n    args: [toHex(packetToBytes(name))],\n    blockNumber,\n    blockTag\n  });\n  return resolverAddress;\n}","map":{"version":3,"names":["getChainContractAddress","toHex","packetToBytes","getAction","readContract","getEnsResolver","client","parameters","blockNumber","blockTag","name","chain","universalResolverAddress","Error","contract","tlds","ensTlds","some","tld","endsWith","join","id","resolverAddress","address","abi","inputs","type","outputs","stateMutability","functionName","args"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\viem\\actions\\ens\\getEnsResolver.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Prettify } from '../../types/utils.js'\nimport {\n  type GetChainContractAddressErrorType,\n  getChainContractAddress,\n} from '../../utils/chain/getChainContractAddress.js'\nimport { type ToHexErrorType, toHex } from '../../utils/encoding/toHex.js'\nimport {\n  type PacketToBytesErrorType,\n  packetToBytes,\n} from '../../utils/ens/packetToBytes.js'\nimport { getAction } from '../../utils/getAction.js'\nimport {\n  type ReadContractParameters,\n  readContract,\n} from '../public/readContract.js'\n\nexport type GetEnsResolverParameters = Prettify<\n  Pick<ReadContractParameters, 'blockNumber' | 'blockTag'> & {\n    /** Name to get the address for. */\n    name: string\n    /** Address of ENS Universal Resolver Contract. */\n    universalResolverAddress?: Address | undefined\n  }\n>\n\nexport type GetEnsResolverReturnType = Address\n\nexport type GetEnsResolverErrorType =\n  | GetChainContractAddressErrorType\n  | ToHexErrorType\n  | PacketToBytesErrorType\n  | ErrorType\n\n/**\n * Gets resolver for ENS name.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsResolver\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens\n *\n * Calls `findResolver(bytes)` on ENS Universal Resolver Contract to retrieve the resolver of an ENS name.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsResolverParameters}\n * @returns Address for ENS resolver. {@link GetEnsResolverReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsResolver, normalize } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const resolverAddress = await getEnsResolver(client, {\n *   name: normalize('wevm.eth'),\n * })\n * // '0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41'\n */\nexport async function getEnsResolver<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: GetEnsResolverParameters,\n): Promise<GetEnsResolverReturnType> {\n  const { blockNumber, blockTag, name } = parameters\n  const { chain } = client\n\n  const universalResolverAddress = (() => {\n    if (parameters.universalResolverAddress)\n      return parameters.universalResolverAddress\n    if (!chain)\n      throw new Error(\n        'client chain not configured. universalResolverAddress is required.',\n      )\n    return getChainContractAddress({\n      blockNumber,\n      chain,\n      contract: 'ensUniversalResolver',\n    })\n  })()\n\n  const tlds = chain?.ensTlds\n  if (tlds && !tlds.some((tld) => name.endsWith(tld)))\n    throw new Error(\n      `${name} is not a valid ENS TLD (${tlds?.join(', ')}) for chain \"${chain.name}\" (id: ${chain.id}).`,\n    )\n\n  const [resolverAddress] = await getAction(\n    client,\n    readContract,\n    'readContract',\n  )({\n    address: universalResolverAddress,\n    abi: [\n      {\n        inputs: [{ type: 'bytes' }],\n        name: 'findResolver',\n        outputs: [{ type: 'address' }, { type: 'bytes32' }],\n        stateMutability: 'view',\n        type: 'function',\n      },\n    ],\n    functionName: 'findResolver',\n    args: [toHex(packetToBytes(name))],\n    blockNumber,\n    blockTag,\n  })\n  return resolverAddress\n}\n"],"mappings":"AAOA,SAEEA,uBAAuB,QAClB,8CAA8C;AACrD,SAA8BC,KAAK,QAAQ,+BAA+B;AAC1E,SAEEC,aAAa,QACR,kCAAkC;AACzC,SAASC,SAAS,QAAQ,0BAA0B;AACpD,SAEEC,YAAY,QACP,2BAA2B;AAmBlC;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA,OAAO,eAAeC,cAAcA,CAClCC,MAAgC,EAChCC,UAAoC;EAEpC,MAAM;IAAEC,WAAW;IAAEC,QAAQ;IAAEC;EAAI,CAAE,GAAGH,UAAU;EAClD,MAAM;IAAEI;EAAK,CAAE,GAAGL,MAAM;EAExB,MAAMM,wBAAwB,GAAG,CAAC,MAAK;IACrC,IAAIL,UAAU,CAACK,wBAAwB,EACrC,OAAOL,UAAU,CAACK,wBAAwB;IAC5C,IAAI,CAACD,KAAK,EACR,MAAM,IAAIE,KAAK,CACb,oEAAoE,CACrE;IACH,OAAOb,uBAAuB,CAAC;MAC7BQ,WAAW;MACXG,KAAK;MACLG,QAAQ,EAAE;KACX,CAAC;EACJ,CAAC,EAAC,CAAE;EAEJ,MAAMC,IAAI,GAAGJ,KAAK,EAAEK,OAAO;EAC3B,IAAID,IAAI,IAAI,CAACA,IAAI,CAACE,IAAI,CAAEC,GAAG,IAAKR,IAAI,CAACS,QAAQ,CAACD,GAAG,CAAC,CAAC,EACjD,MAAM,IAAIL,KAAK,CACb,GAAGH,IAAI,4BAA4BK,IAAI,EAAEK,IAAI,CAAC,IAAI,CAAC,gBAAgBT,KAAK,CAACD,IAAI,UAAUC,KAAK,CAACU,EAAE,IAAI,CACpG;EAEH,MAAM,CAACC,eAAe,CAAC,GAAG,MAAMnB,SAAS,CACvCG,MAAM,EACNF,YAAY,EACZ,cAAc,CACf,CAAC;IACAmB,OAAO,EAAEX,wBAAwB;IACjCY,GAAG,EAAE,CACH;MACEC,MAAM,EAAE,CAAC;QAAEC,IAAI,EAAE;MAAO,CAAE,CAAC;MAC3BhB,IAAI,EAAE,cAAc;MACpBiB,OAAO,EAAE,CAAC;QAAED,IAAI,EAAE;MAAS,CAAE,EAAE;QAAEA,IAAI,EAAE;MAAS,CAAE,CAAC;MACnDE,eAAe,EAAE,MAAM;MACvBF,IAAI,EAAE;KACP,CACF;IACDG,YAAY,EAAE,cAAc;IAC5BC,IAAI,EAAE,CAAC7B,KAAK,CAACC,aAAa,CAACQ,IAAI,CAAC,CAAC,CAAC;IAClCF,WAAW;IACXC;GACD,CAAC;EACF,OAAOa,eAAe;AACxB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}