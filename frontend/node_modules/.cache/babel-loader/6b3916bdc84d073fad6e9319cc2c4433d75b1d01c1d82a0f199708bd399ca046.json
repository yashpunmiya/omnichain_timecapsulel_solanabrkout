{"ast":null,"code":"import { universalSignatureValidatorAbi } from '../../constants/abis.js';\nimport { universalSignatureValidatorByteCode } from '../../constants/contracts.js';\nimport { CallExecutionError } from '../../errors/contract.js';\nimport { encodeDeployData } from '../../utils/abi/encodeDeployData.js';\nimport { getAddress } from '../../utils/address/getAddress.js';\nimport { isAddressEqual } from '../../utils/address/isAddressEqual.js';\nimport { isHex } from '../../utils/data/isHex.js';\nimport { bytesToHex } from '../../utils/encoding/toHex.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { encodeFunctionData, hexToBool } from '../../utils/index.js';\nimport { isErc6492Signature } from '../../utils/signature/isErc6492Signature.js';\nimport { recoverAddress } from '../../utils/signature/recoverAddress.js';\nimport { serializeErc6492Signature } from '../../utils/signature/serializeErc6492Signature.js';\nimport { serializeSignature } from '../../utils/signature/serializeSignature.js';\nimport { call } from './call.js';\n/**\n * Verifies a message hash onchain using ERC-6492.\n *\n * @param client - Client to use.\n * @param parameters - {@link VerifyHashParameters}\n * @returns Whether or not the signature is valid. {@link VerifyHashReturnType}\n */\nexport async function verifyHash(client, parameters) {\n  const {\n    address,\n    factory,\n    factoryData,\n    hash,\n    signature,\n    universalSignatureVerifierAddress = client.chain?.contracts?.universalSignatureVerifier?.address,\n    ...rest\n  } = parameters;\n  const signatureHex = (() => {\n    if (isHex(signature)) return signature;\n    if (typeof signature === 'object' && 'r' in signature && 's' in signature) return serializeSignature(signature);\n    return bytesToHex(signature);\n  })();\n  const wrappedSignature = await (async () => {\n    // If no `factory` or `factoryData` is provided, it is assumed that the\n    // address is not a Smart Account, or the Smart Account is already deployed.\n    if (!factory && !factoryData) return signatureHex;\n    // If the signature is already wrapped, return the signature.\n    if (isErc6492Signature(signatureHex)) return signatureHex;\n    // If the Smart Account is not deployed, wrap the signature with a 6492 wrapper\n    // to perform counterfactual validation.\n    return serializeErc6492Signature({\n      address: factory,\n      data: factoryData,\n      signature: signatureHex\n    });\n  })();\n  try {\n    const args = universalSignatureVerifierAddress ? {\n      to: universalSignatureVerifierAddress,\n      data: encodeFunctionData({\n        abi: universalSignatureValidatorAbi,\n        functionName: 'isValidSig',\n        args: [address, hash, wrappedSignature]\n      }),\n      ...rest\n    } : {\n      data: encodeDeployData({\n        abi: universalSignatureValidatorAbi,\n        args: [address, hash, wrappedSignature],\n        bytecode: universalSignatureValidatorByteCode\n      }),\n      ...rest\n    };\n    const {\n      data\n    } = await getAction(client, call, 'call')(args);\n    return hexToBool(data ?? '0x0');\n  } catch (error) {\n    // Fallback attempt to verify the signature via ECDSA recovery.\n    try {\n      const verified = isAddressEqual(getAddress(address), await recoverAddress({\n        hash,\n        signature\n      }));\n      if (verified) return true;\n    } catch {}\n    if (error instanceof CallExecutionError) {\n      // if the execution fails, the signature was not valid and an internal method inside of the validator reverted\n      // this can happen for many reasons, for example if signer can not be recovered from the signature\n      // or if the signature has no valid format\n      return false;\n    }\n    throw error;\n  }\n}\n//# sourceMappingURL=verifyHash.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}