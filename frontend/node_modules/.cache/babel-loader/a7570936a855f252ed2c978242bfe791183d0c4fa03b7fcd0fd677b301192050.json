{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbstractMessageChannel = void 0;\nconst utils_1 = require(\"@trezor/utils\");\nclass AbstractMessageChannel extends utils_1.TypedEmitter {\n  messagePromises = {};\n  messagesQueue = [];\n  messageID = 0;\n  isConnected = false;\n  handshakeMaxRetries = 5;\n  handshakeRetryInterval = 2000;\n  handshakeFinished;\n  lazyHandshake;\n  legacyMode;\n  logger;\n  sendFn;\n  channel;\n  constructor({\n    sendFn,\n    channel,\n    logger,\n    lazyHandshake = false,\n    legacyMode = false\n  }) {\n    super();\n    this.channel = channel;\n    this.sendFn = sendFn;\n    this.lazyHandshake = lazyHandshake;\n    this.legacyMode = legacyMode;\n    this.logger = logger;\n  }\n  init() {\n    if (!this.handshakeFinished) {\n      this.handshakeFinished = (0, utils_1.createDeferred)();\n      if (this.legacyMode) {\n        setTimeout(() => {\n          this.handshakeFinished?.resolve();\n        }, 500);\n      }\n      if (!this.lazyHandshake) {\n        this.handshakeWithPeer();\n      }\n    }\n    return this.handshakeFinished.promise;\n  }\n  handshakeWithPeer() {\n    this.logger?.log(this.channel.here, 'handshake');\n    return (0, utils_1.scheduleAction)(async () => {\n      this.postMessage({\n        type: 'channel-handshake-request',\n        data: {\n          success: true,\n          payload: undefined\n        }\n      }, {\n        usePromise: false,\n        useQueue: false\n      });\n      await this.handshakeFinished?.promise;\n    }, {\n      attempts: this.handshakeMaxRetries,\n      timeout: this.handshakeRetryInterval\n    }).then(() => {\n      this.logger?.log(this.channel.here, 'handshake confirmed');\n      this.messagesQueue.forEach(message => {\n        message.channel = this.channel;\n        this.sendFn(message);\n      });\n      this.messagesQueue = [];\n    }).catch(() => {\n      this.handshakeFinished?.reject(new Error('handshake failed'));\n      this.handshakeFinished = undefined;\n    });\n  }\n  onMessage(_message) {\n    let message = _message;\n    if (this.legacyMode && message.type === undefined && 'data' in message && typeof message.data === 'object' && message.data !== null && 'type' in message.data && typeof message.data.type === 'string') {\n      message = message.data;\n    }\n    const {\n      channel,\n      id,\n      type,\n      ...data\n    } = message;\n    if (!this.legacyMode) {\n      if (!channel?.peer || channel.peer !== this.channel.here) {\n        return;\n      }\n      if (!channel?.here || this.channel.peer !== channel.here) {\n        return;\n      }\n    }\n    if (type === 'channel-handshake-request') {\n      this.postMessage({\n        type: 'channel-handshake-confirm',\n        data: {\n          success: true,\n          payload: undefined\n        }\n      }, {\n        usePromise: false,\n        useQueue: false\n      });\n      if (this.lazyHandshake) {\n        this.handshakeWithPeer();\n      }\n      return;\n    }\n    if (type === 'channel-handshake-confirm') {\n      this.handshakeFinished?.resolve(undefined);\n      return;\n    }\n    if (this.messagePromises[id]) {\n      this.messagePromises[id].resolve({\n        id,\n        ...data\n      });\n      delete this.messagePromises[id];\n    }\n    const messagePromisesLength = Object.keys(this.messagePromises).length;\n    if (messagePromisesLength > 5) {\n      this.logger?.warn(`too many message promises (${messagePromisesLength}). this feels unexpected!`);\n    }\n    this.emit('message', message);\n  }\n  postMessage(message, {\n    usePromise = true,\n    useQueue = true\n  } = {}) {\n    message.channel = this.channel;\n    if (!usePromise) {\n      try {\n        this.sendFn(message);\n      } catch {\n        if (useQueue) {\n          this.messagesQueue.push(message);\n        }\n      }\n      return;\n    }\n    this.messageID++;\n    message.id = this.messageID;\n    this.messagePromises[message.id] = (0, utils_1.createDeferred)();\n    try {\n      this.sendFn(message);\n    } catch {\n      if (useQueue) {\n        this.messagesQueue.push(message);\n      }\n    }\n    return this.messagePromises[message.id].promise;\n  }\n  resolveMessagePromises(resolvePayload) {\n    Object.keys(this.messagePromises).forEach(id => this.messagePromises[id].resolve({\n      id,\n      payload: resolvePayload\n    }));\n  }\n  clear() {\n    this.handshakeFinished = undefined;\n  }\n}\nexports.AbstractMessageChannel = AbstractMessageChannel;\n//# sourceMappingURL=abstract.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}