{"ast":null,"code":"import h, { levels as s } from \"pino\";\nimport { default as U } from \"pino\";\nimport { safeJsonStringify as u } from \"@walletconnect/safe-json\";\nconst c = {\n    level: \"info\"\n  },\n  n = \"custom_context\",\n  l = 1e3 * 1024;\nclass O {\n  constructor(e) {\n    this.nodeValue = e, this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length, this.next = null;\n  }\n  get value() {\n    return this.nodeValue;\n  }\n  get size() {\n    return this.sizeInBytes;\n  }\n}\nclass d {\n  constructor(e) {\n    this.head = null, this.tail = null, this.lengthInNodes = 0, this.maxSizeInBytes = e, this.sizeInBytes = 0;\n  }\n  append(e) {\n    const t = new O(e);\n    if (t.size > this.maxSizeInBytes) throw new Error(`[LinkedList] Value too big to insert into list: ${e} with size ${t.size}`);\n    for (; this.size + t.size > this.maxSizeInBytes;) this.shift();\n    this.head ? (this.tail && (this.tail.next = t), this.tail = t) : (this.head = t, this.tail = t), this.lengthInNodes++, this.sizeInBytes += t.size;\n  }\n  shift() {\n    if (!this.head) return;\n    const e = this.head;\n    this.head = this.head.next, this.head || (this.tail = null), this.lengthInNodes--, this.sizeInBytes -= e.size;\n  }\n  toArray() {\n    const e = [];\n    let t = this.head;\n    for (; t !== null;) e.push(t.value), t = t.next;\n    return e;\n  }\n  get length() {\n    return this.lengthInNodes;\n  }\n  get size() {\n    return this.sizeInBytes;\n  }\n  toOrderedArray() {\n    return Array.from(this);\n  }\n  [Symbol.iterator]() {\n    let e = this.head;\n    return {\n      next: () => {\n        if (!e) return {\n          done: !0,\n          value: null\n        };\n        const t = e.value;\n        return e = e.next, {\n          done: !1,\n          value: t\n        };\n      }\n    };\n  }\n}\nclass L {\n  constructor(e, t = l) {\n    this.level = e ?? \"error\", this.levelValue = s.values[this.level], this.MAX_LOG_SIZE_IN_BYTES = t, this.logs = new d(this.MAX_LOG_SIZE_IN_BYTES);\n  }\n  forwardToConsole(e, t) {\n    t === s.values.error ? console.error(e) : t === s.values.warn ? console.warn(e) : t === s.values.debug ? console.debug(e) : t === s.values.trace ? console.trace(e) : console.log(e);\n  }\n  appendToLogs(e) {\n    this.logs.append(u({\n      timestamp: new Date().toISOString(),\n      log: e\n    }));\n    const t = typeof e == \"string\" ? JSON.parse(e).level : e.level;\n    t >= this.levelValue && this.forwardToConsole(e, t);\n  }\n  getLogs() {\n    return this.logs;\n  }\n  clearLogs() {\n    this.logs = new d(this.MAX_LOG_SIZE_IN_BYTES);\n  }\n  getLogArray() {\n    return Array.from(this.logs);\n  }\n  logsToBlob(e) {\n    const t = this.getLogArray();\n    return t.push(u({\n      extraMetadata: e\n    })), new Blob(t, {\n      type: \"application/json\"\n    });\n  }\n}\nclass m {\n  constructor(e, t = l) {\n    this.baseChunkLogger = new L(e, t);\n  }\n  write(e) {\n    this.baseChunkLogger.appendToLogs(e);\n  }\n  getLogs() {\n    return this.baseChunkLogger.getLogs();\n  }\n  clearLogs() {\n    this.baseChunkLogger.clearLogs();\n  }\n  getLogArray() {\n    return this.baseChunkLogger.getLogArray();\n  }\n  logsToBlob(e) {\n    return this.baseChunkLogger.logsToBlob(e);\n  }\n  downloadLogsBlobInBrowser(e) {\n    const t = URL.createObjectURL(this.logsToBlob(e)),\n      o = document.createElement(\"a\");\n    o.href = t, o.download = `walletconnect-logs-${new Date().toISOString()}.txt`, document.body.appendChild(o), o.click(), document.body.removeChild(o), URL.revokeObjectURL(t);\n  }\n}\nclass B {\n  constructor(e, t = l) {\n    this.baseChunkLogger = new L(e, t);\n  }\n  write(e) {\n    this.baseChunkLogger.appendToLogs(e);\n  }\n  getLogs() {\n    return this.baseChunkLogger.getLogs();\n  }\n  clearLogs() {\n    this.baseChunkLogger.clearLogs();\n  }\n  getLogArray() {\n    return this.baseChunkLogger.getLogArray();\n  }\n  logsToBlob(e) {\n    return this.baseChunkLogger.logsToBlob(e);\n  }\n}\nvar x = Object.defineProperty,\n  S = Object.defineProperties,\n  _ = Object.getOwnPropertyDescriptors,\n  p = Object.getOwnPropertySymbols,\n  T = Object.prototype.hasOwnProperty,\n  z = Object.prototype.propertyIsEnumerable,\n  f = (r, e, t) => e in r ? x(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  i = (r, e) => {\n    for (var t in e || (e = {})) T.call(e, t) && f(r, t, e[t]);\n    if (p) for (var t of p(e)) z.call(e, t) && f(r, t, e[t]);\n    return r;\n  },\n  g = (r, e) => S(r, _(e));\nfunction k(r) {\n  return g(i({}, r), {\n    level: r?.level || c.level\n  });\n}\nfunction v(r, e = n) {\n  return r[e] || \"\";\n}\nfunction b(r, e, t = n) {\n  return r[t] = e, r;\n}\nfunction y(r, e = n) {\n  let t = \"\";\n  return typeof r.bindings > \"u\" ? t = v(r, e) : t = r.bindings().context || \"\", t;\n}\nfunction w(r, e, t = n) {\n  const o = y(r, t);\n  return o.trim() ? `${o}/${e}` : e;\n}\nfunction E(r, e, t = n) {\n  const o = w(r, e, t),\n    a = r.child({\n      context: o\n    });\n  return b(a, o, t);\n}\nfunction C(r) {\n  var e, t;\n  const o = new m((e = r.opts) == null ? void 0 : e.level, r.maxSizeInBytes);\n  return {\n    logger: h(g(i({}, r.opts), {\n      level: \"trace\",\n      browser: g(i({}, (t = r.opts) == null ? void 0 : t.browser), {\n        write: a => o.write(a)\n      })\n    })),\n    chunkLoggerController: o\n  };\n}\nfunction I(r) {\n  var e;\n  const t = new B((e = r.opts) == null ? void 0 : e.level, r.maxSizeInBytes);\n  return {\n    logger: h(g(i({}, r.opts), {\n      level: \"trace\"\n    }), t),\n    chunkLoggerController: t\n  };\n}\nfunction A(r) {\n  return typeof r.loggerOverride < \"u\" && typeof r.loggerOverride != \"string\" ? {\n    logger: r.loggerOverride,\n    chunkLoggerController: null\n  } : typeof window < \"u\" ? C(r) : I(r);\n}\nexport { l as MAX_LOG_SIZE_IN_BYTES_DEFAULT, n as PINO_CUSTOM_CONTEXT_KEY, c as PINO_LOGGER_DEFAULTS, w as formatChildLoggerContext, E as generateChildLogger, C as generateClientLogger, A as generatePlatformLogger, I as generateServerLogger, v as getBrowserLoggerContext, k as getDefaultLoggerOptions, y as getLoggerContext, U as pino, b as setBrowserLoggerContext };\n//# sourceMappingURL=index.es.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}