{"ast":null,"code":"import { StatusCodes, TransportStatusError } from '@ledgerhq/hw-transport';\nimport { isVersionedTransaction } from '@solana/wallet-adapter-base';\nimport { PublicKey } from '@solana/web3.js';\nimport './polyfills/index.js';\nexport function getDerivationPath(account, change) {\n  const length = account !== undefined ? change === undefined ? 3 : 4 : 2;\n  const derivationPath = Buffer.alloc(1 + length * 4);\n  let offset = derivationPath.writeUInt8(length, 0);\n  offset = derivationPath.writeUInt32BE(harden(44), offset); // Using BIP44\n  offset = derivationPath.writeUInt32BE(harden(501), offset); // Solana's BIP44 path\n  if (account !== undefined) {\n    offset = derivationPath.writeUInt32BE(harden(account), offset);\n    if (change !== undefined) {\n      derivationPath.writeUInt32BE(harden(change), offset);\n    }\n  }\n  return derivationPath;\n}\nconst BIP32_HARDENED_BIT = 1 << 31 >>> 0;\nfunction harden(n) {\n  return (n | BIP32_HARDENED_BIT) >>> 0;\n}\nconst INS_GET_PUBKEY = 0x05;\nconst INS_SIGN_MESSAGE = 0x06;\nconst P1_NON_CONFIRM = 0x00;\nconst P1_CONFIRM = 0x01;\nconst P2_EXTEND = 0x01;\nconst P2_MORE = 0x02;\nconst MAX_PAYLOAD = 255;\nconst LEDGER_CLA = 0xe0;\n/** @internal */\nexport async function getPublicKey(transport, derivationPath) {\n  const bytes = await send(transport, INS_GET_PUBKEY, P1_NON_CONFIRM, derivationPath);\n  return new PublicKey(bytes);\n}\n/** @internal */\nexport async function signTransaction(transport, transaction, derivationPath) {\n  const paths = Buffer.alloc(1);\n  paths.writeUInt8(1, 0);\n  const message = isVersionedTransaction(transaction) ? transaction.message.serialize() : transaction.serializeMessage();\n  const data = Buffer.concat([paths, derivationPath, message]);\n  return await send(transport, INS_SIGN_MESSAGE, P1_CONFIRM, data);\n}\nasync function send(transport, instruction, p1, data) {\n  let p2 = 0;\n  let offset = 0;\n  if (data.length > MAX_PAYLOAD) {\n    while (data.length - offset > MAX_PAYLOAD) {\n      const buffer = data.slice(offset, offset + MAX_PAYLOAD);\n      const response = await transport.send(LEDGER_CLA, instruction, p1, p2 | P2_MORE, buffer);\n      // @ts-ignore -- TransportStatusError is a constructor Function, not a Class\n      if (response.length !== 2) throw new TransportStatusError(StatusCodes.INCORRECT_DATA);\n      p2 |= P2_EXTEND;\n      offset += MAX_PAYLOAD;\n    }\n  }\n  const buffer = data.slice(offset);\n  const response = await transport.send(LEDGER_CLA, instruction, p1, p2, buffer);\n  return response.slice(0, response.length - 2);\n}\n//# sourceMappingURL=util.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}