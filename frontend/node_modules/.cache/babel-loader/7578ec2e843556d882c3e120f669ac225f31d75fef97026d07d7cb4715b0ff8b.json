{"ast":null,"code":"import { execTyped, isTupleRegex } from '../../regex.js';\nimport { UnknownTypeError } from '../errors/abiItem.js';\nimport { InvalidAbiTypeParameterError } from '../errors/abiParameter.js';\nimport { InvalidSignatureError, InvalidStructSignatureError } from '../errors/signature.js';\nimport { CircularReferenceError } from '../errors/struct.js';\nimport { execStructSignature, isStructSignature } from './signatures.js';\nimport { isSolidityType, parseAbiParameter } from './utils.js';\nexport function parseStructs(signatures) {\n  // Create \"shallow\" version of each struct (and filter out non-structs or invalid structs)\n  const shallowStructs = {};\n  const signaturesLength = signatures.length;\n  for (let i = 0; i < signaturesLength; i++) {\n    const signature = signatures[i];\n    if (!isStructSignature(signature)) continue;\n    const match = execStructSignature(signature);\n    if (!match) throw new InvalidSignatureError({\n      signature,\n      type: 'struct'\n    });\n    const properties = match.properties.split(';');\n    const components = [];\n    const propertiesLength = properties.length;\n    for (let k = 0; k < propertiesLength; k++) {\n      const property = properties[k];\n      const trimmed = property.trim();\n      if (!trimmed) continue;\n      const abiParameter = parseAbiParameter(trimmed, {\n        type: 'struct'\n      });\n      components.push(abiParameter);\n    }\n    if (!components.length) throw new InvalidStructSignatureError({\n      signature\n    });\n    shallowStructs[match.name] = components;\n  }\n  // Resolve nested structs inside each parameter\n  const resolvedStructs = {};\n  const entries = Object.entries(shallowStructs);\n  const entriesLength = entries.length;\n  for (let i = 0; i < entriesLength; i++) {\n    const [name, parameters] = entries[i];\n    resolvedStructs[name] = resolveStructs(parameters, shallowStructs);\n  }\n  return resolvedStructs;\n}\nconst typeWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?$/;\nfunction resolveStructs(abiParameters, structs, ancestors = new Set()) {\n  const components = [];\n  const length = abiParameters.length;\n  for (let i = 0; i < length; i++) {\n    const abiParameter = abiParameters[i];\n    const isTuple = isTupleRegex.test(abiParameter.type);\n    if (isTuple) components.push(abiParameter);else {\n      const match = execTyped(typeWithoutTupleRegex, abiParameter.type);\n      if (!match?.type) throw new InvalidAbiTypeParameterError({\n        abiParameter\n      });\n      const {\n        array,\n        type\n      } = match;\n      if (type in structs) {\n        if (ancestors.has(type)) throw new CircularReferenceError({\n          type\n        });\n        components.push({\n          ...abiParameter,\n          type: `tuple${array ?? ''}`,\n          components: resolveStructs(structs[type] ?? [], structs, new Set([...ancestors, type]))\n        });\n      } else {\n        if (isSolidityType(type)) components.push(abiParameter);else throw new UnknownTypeError({\n          type\n        });\n      }\n    }\n  }\n  return components;\n}\n//# sourceMappingURL=structs.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}