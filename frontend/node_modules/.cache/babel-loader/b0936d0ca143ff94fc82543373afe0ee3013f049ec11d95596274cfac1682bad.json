{"ast":null,"code":"import { ConstantsUtil as CommonConstants } from '@reown/appkit-common';\nimport { ConstantsUtil } from './ConstantsUtil.js';\nimport { StorageUtil } from './StorageUtil.js';\nexport const CoreHelperUtil = {\n  isMobile() {\n    if (this.isClient()) {\n      return Boolean(window?.matchMedia('(pointer:coarse)')?.matches || /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent));\n    }\n    return false;\n  },\n  checkCaipNetwork(network, networkName = '') {\n    return network?.caipNetworkId.toLocaleLowerCase().includes(networkName.toLowerCase());\n  },\n  isAndroid() {\n    if (!this.isMobile()) {\n      return false;\n    }\n    const ua = window?.navigator.userAgent.toLowerCase();\n    return CoreHelperUtil.isMobile() && ua.includes('android');\n  },\n  isIos() {\n    if (!this.isMobile()) {\n      return false;\n    }\n    const ua = window?.navigator.userAgent.toLowerCase();\n    return ua.includes('iphone') || ua.includes('ipad');\n  },\n  isSafari() {\n    if (!this.isClient()) {\n      return false;\n    }\n    const ua = window?.navigator.userAgent.toLowerCase();\n    return ua.includes('safari');\n  },\n  isClient() {\n    return typeof window !== 'undefined';\n  },\n  isPairingExpired(expiry) {\n    return expiry ? expiry - Date.now() <= ConstantsUtil.TEN_SEC_MS : true;\n  },\n  isAllowedRetry(lastRetry, differenceMs = ConstantsUtil.ONE_SEC_MS) {\n    return Date.now() - lastRetry >= differenceMs;\n  },\n  copyToClopboard(text) {\n    navigator.clipboard.writeText(text);\n  },\n  isIframe() {\n    try {\n      return window?.self !== window?.top;\n    } catch (e) {\n      return false;\n    }\n  },\n  getPairingExpiry() {\n    return Date.now() + ConstantsUtil.FOUR_MINUTES_MS;\n  },\n  getNetworkId(caipAddress) {\n    return caipAddress?.split(':')[1];\n  },\n  getPlainAddress(caipAddress) {\n    return caipAddress?.split(':')[2];\n  },\n  async wait(milliseconds) {\n    return new Promise(resolve => {\n      setTimeout(resolve, milliseconds);\n    });\n  },\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  debounce(func, timeout = 500) {\n    let timer = undefined;\n    return (...args) => {\n      function next() {\n        func(...args);\n      }\n      if (timer) {\n        clearTimeout(timer);\n      }\n      timer = setTimeout(next, timeout);\n    };\n  },\n  isHttpUrl(url) {\n    return url.startsWith('http://') || url.startsWith('https://');\n  },\n  formatNativeUrl(appUrl, wcUri) {\n    if (CoreHelperUtil.isHttpUrl(appUrl)) {\n      return this.formatUniversalUrl(appUrl, wcUri);\n    }\n    let safeAppUrl = appUrl;\n    if (!safeAppUrl.includes('://')) {\n      safeAppUrl = appUrl.replaceAll('/', '').replaceAll(':', '');\n      safeAppUrl = `${safeAppUrl}://`;\n    }\n    if (!safeAppUrl.endsWith('/')) {\n      safeAppUrl = `${safeAppUrl}/`;\n    }\n    // Android deeplinks in tg context require the uri to be encoded twice\n    if (this.isTelegram() && this.isAndroid()) {\n      // eslint-disable-next-line no-param-reassign\n      wcUri = encodeURIComponent(wcUri);\n    }\n    const encodedWcUrl = encodeURIComponent(wcUri);\n    return {\n      redirect: `${safeAppUrl}wc?uri=${encodedWcUrl}`,\n      href: safeAppUrl\n    };\n  },\n  formatUniversalUrl(appUrl, wcUri) {\n    if (!CoreHelperUtil.isHttpUrl(appUrl)) {\n      return this.formatNativeUrl(appUrl, wcUri);\n    }\n    let safeAppUrl = appUrl;\n    if (!safeAppUrl.endsWith('/')) {\n      safeAppUrl = `${safeAppUrl}/`;\n    }\n    const encodedWcUrl = encodeURIComponent(wcUri);\n    return {\n      redirect: `${safeAppUrl}wc?uri=${encodedWcUrl}`,\n      href: safeAppUrl\n    };\n  },\n  getOpenTargetForPlatform(target) {\n    if (target === 'popupWindow') {\n      return target;\n    }\n    // Only '_blank' deeplinks work in Telegram context\n    if (this.isTelegram()) {\n      // But for social login, we need to load the page in the same context\n      if (StorageUtil.getTelegramSocialProvider()) {\n        return '_top';\n      }\n      return '_blank';\n    }\n    return target;\n  },\n  openHref(href, target, features) {\n    window?.open(href, this.getOpenTargetForPlatform(target), features || 'noreferrer noopener');\n  },\n  returnOpenHref(href, target, features) {\n    return window?.open(href, this.getOpenTargetForPlatform(target), features || 'noreferrer noopener');\n  },\n  isTelegram() {\n    return typeof window !== 'undefined' && (\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Boolean(window.TelegramWebviewProxy) ||\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Boolean(window.Telegram) ||\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Boolean(window.TelegramWebviewProxyProto));\n  },\n  async preloadImage(src) {\n    const imagePromise = new Promise((resolve, reject) => {\n      const image = new Image();\n      image.onload = resolve;\n      image.onerror = reject;\n      image.crossOrigin = 'anonymous';\n      image.src = src;\n    });\n    return Promise.race([imagePromise, CoreHelperUtil.wait(2000)]);\n  },\n  formatBalance(balance, symbol) {\n    let formattedBalance = '0.000';\n    if (typeof balance === 'string') {\n      const number = Number(balance);\n      if (number) {\n        const formattedValue = Math.floor(number * 1000) / 1000;\n        if (formattedValue) {\n          formattedBalance = formattedValue.toString();\n        }\n      }\n    }\n    return `${formattedBalance}${symbol ? ` ${symbol}` : ''}`;\n  },\n  formatBalance2(balance, symbol) {\n    let formattedBalance = undefined;\n    if (balance === '0') {\n      formattedBalance = '0';\n    } else if (typeof balance === 'string') {\n      const number = Number(balance);\n      if (number) {\n        formattedBalance = number.toString().match(/^-?\\d+(?:\\.\\d{0,3})?/u)?.[0];\n      }\n    }\n    return {\n      value: formattedBalance ?? '0',\n      rest: formattedBalance === '0' ? '000' : '',\n      symbol\n    };\n  },\n  getApiUrl() {\n    return CommonConstants.W3M_API_URL;\n  },\n  getBlockchainApiUrl() {\n    return CommonConstants.BLOCKCHAIN_API_RPC_URL;\n  },\n  getAnalyticsUrl() {\n    return CommonConstants.PULSE_API_URL;\n  },\n  getUUID() {\n    if (crypto?.randomUUID) {\n      return crypto.randomUUID();\n    }\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/gu, c => {\n      const r = Math.random() * 16 | 0;\n      const v = c === 'x' ? r : r & 0x3 | 0x8;\n      return v.toString(16);\n    });\n  },\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  parseError(error) {\n    if (typeof error === 'string') {\n      return error;\n    } else if (typeof error?.issues?.[0]?.message === 'string') {\n      return error.issues[0].message;\n    } else if (error instanceof Error) {\n      return error.message;\n    }\n    return 'Unknown error';\n  },\n  sortRequestedNetworks(approvedIds, requestedNetworks = []) {\n    const approvedIndexMap = {};\n    if (requestedNetworks && approvedIds) {\n      approvedIds.forEach((id, index) => {\n        approvedIndexMap[id] = index;\n      });\n      requestedNetworks.sort((a, b) => {\n        const indexA = approvedIndexMap[a.id];\n        const indexB = approvedIndexMap[b.id];\n        if (indexA !== undefined && indexB !== undefined) {\n          return indexA - indexB;\n        } else if (indexA !== undefined) {\n          return -1;\n        } else if (indexB !== undefined) {\n          return 1;\n        }\n        return 0;\n      });\n    }\n    return requestedNetworks;\n  },\n  calculateBalance(array) {\n    let sum = 0;\n    for (const item of array) {\n      sum += item.value ?? 0;\n    }\n    return sum;\n  },\n  formatTokenBalance(number) {\n    const roundedNumber = number.toFixed(2);\n    const [dollars, pennies] = roundedNumber.split('.');\n    return {\n      dollars,\n      pennies\n    };\n  },\n  isAddress(address, chain = 'eip155') {\n    switch (chain) {\n      case 'eip155':\n        if (!/^(?:0x)?[0-9a-f]{40}$/iu.test(address)) {\n          return false;\n        } else if (/^(?:0x)?[0-9a-f]{40}$/iu.test(address) || /^(?:0x)?[0-9A-F]{40}$/iu.test(address)) {\n          return true;\n        }\n        return false;\n      case 'solana':\n        return /[1-9A-HJ-NP-Za-km-z]{32,44}$/iu.test(address);\n      default:\n        return false;\n    }\n  },\n  uniqueBy(arr, key) {\n    const set = new Set();\n    return arr.filter(item => {\n      const keyValue = item[key];\n      if (set.has(keyValue)) {\n        return false;\n      }\n      set.add(keyValue);\n      return true;\n    });\n  },\n  generateSdkVersion(adapters, platform, version) {\n    const hasNoAdapters = adapters.length === 0;\n    const adapterNames = hasNoAdapters ? ConstantsUtil.ADAPTER_TYPES.UNIVERSAL : adapters.map(adapter => adapter.adapterType).join(',');\n    return `${platform}-${adapterNames}-${version}`;\n  },\n  // eslint-disable-next-line max-params\n  createAccount(namespace, address, type, publicKey, path) {\n    return {\n      namespace,\n      address,\n      type,\n      publicKey,\n      path\n    };\n  },\n  isCaipAddress(address) {\n    if (typeof address !== 'string') {\n      return false;\n    }\n    const sections = address.split(':');\n    const namespace = sections[0];\n    return sections.filter(Boolean).length === 3 && namespace in CommonConstants.CHAIN_NAME_MAP;\n  },\n  isMac() {\n    const ua = window?.navigator.userAgent.toLowerCase();\n    return ua.includes('macintosh') && !ua.includes('safari');\n  },\n  formatTelegramSocialLoginUrl(url) {\n    const valueToInject = `--${encodeURIComponent(window?.location.href)}`;\n    const paramToInject = 'state=';\n    const parsedUrl = new URL(url);\n    if (parsedUrl.host === 'auth.magic.link') {\n      const providerParam = 'provider_authorization_url=';\n      const providerUrl = url.substring(url.indexOf(providerParam) + providerParam.length);\n      const resultUrl = this.injectIntoUrl(decodeURIComponent(providerUrl), paramToInject, valueToInject);\n      return url.replace(providerUrl, encodeURIComponent(resultUrl));\n    }\n    return this.injectIntoUrl(url, paramToInject, valueToInject);\n  },\n  injectIntoUrl(url, key, appendString) {\n    // Find the position of \"key\" e.g. \"state=\" in the URL\n    const keyIndex = url.indexOf(key);\n    if (keyIndex === -1) {\n      throw new Error(`${key} parameter not found in the URL: ${url}`);\n    }\n    // Find the position of the next \"&\" after \"key\"\n    const keyEndIndex = url.indexOf('&', keyIndex);\n    const keyLength = key.length;\n    // If there is no \"&\" after key, it means \"key\" is the last parameter\n    // eslint-disable-next-line no-negated-condition\n    const keyParamEnd = keyEndIndex !== -1 ? keyEndIndex : url.length;\n    // Extract the part of the URL before the key value\n    const beforeKeyValue = url.substring(0, keyIndex + keyLength);\n    // Extract the current key value\n    const currentKeyValue = url.substring(keyIndex + keyLength, keyParamEnd);\n    // Extract the part of the URL after the key value\n    const afterKeyValue = url.substring(keyEndIndex);\n    // Append the new string to the key value\n    const newKeyValue = currentKeyValue + appendString;\n    // Reconstruct the URL with the appended key value\n    const newUrl = beforeKeyValue + newKeyValue + afterKeyValue;\n    return newUrl;\n  }\n};\n//# sourceMappingURL=CoreHelperUtil.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}