{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n/*\n * IMPORTANT: For compatibility with tsickle and the Closure JS compiler, all\n * property decorators (but not class decorators) in this file that have\n * an @ExportDecoratedItems annotation must be defined as a regular function,\n * not an arrow function.\n */\nimport { defaultConverter, notEqual } from '../reactive-element.js';\nconst DEV_MODE = true;\nlet issueWarning;\nif (DEV_MODE) {\n  // Ensure warnings are issued only 1x, even if multiple versions of Lit\n  // are loaded.\n  globalThis.litIssuedWarnings ??= new Set();\n  /**\n   * Issue a warning if we haven't already, based either on `code` or `warning`.\n   * Warnings are disabled automatically only by `warning`; disabling via `code`\n   * can be done by users.\n   */\n  issueWarning = (code, warning) => {\n    warning += ` See https://lit.dev/msg/${code} for more information.`;\n    if (!globalThis.litIssuedWarnings.has(warning) && !globalThis.litIssuedWarnings.has(code)) {\n      console.warn(warning);\n      globalThis.litIssuedWarnings.add(warning);\n    }\n  };\n}\nconst legacyProperty = (options, proto, name) => {\n  const hasOwnProperty = proto.hasOwnProperty(name);\n  proto.constructor.createProperty(name, options);\n  // For accessors (which have a descriptor on the prototype) we need to\n  // return a descriptor, otherwise TypeScript overwrites the descriptor we\n  // define in createProperty() with the original descriptor. We don't do this\n  // for fields, which don't have a descriptor, because this could overwrite\n  // descriptor defined by other decorators.\n  return hasOwnProperty ? Object.getOwnPropertyDescriptor(proto, name) : undefined;\n};\n// This is duplicated from a similar variable in reactive-element.ts, but\n// actually makes sense to have this default defined with the decorator, so\n// that different decorators could have different defaults.\nconst defaultPropertyDeclaration = {\n  attribute: true,\n  type: String,\n  converter: defaultConverter,\n  reflect: false,\n  hasChanged: notEqual\n};\n/**\n * Wraps a class accessor or setter so that `requestUpdate()` is called with the\n * property name and old value when the accessor is set.\n */\nexport const standardProperty = (options = defaultPropertyDeclaration, target, context) => {\n  const {\n    kind,\n    metadata\n  } = context;\n  if (DEV_MODE && metadata == null) {\n    issueWarning('missing-class-metadata', `The class ${target} is missing decorator metadata. This ` + `could mean that you're using a compiler that supports decorators ` + `but doesn't support decorator metadata, such as TypeScript 5.1. ` + `Please update your compiler.`);\n  }\n  // Store the property options\n  let properties = globalThis.litPropertyMetadata.get(metadata);\n  if (properties === undefined) {\n    globalThis.litPropertyMetadata.set(metadata, properties = new Map());\n  }\n  if (kind === 'setter') {\n    options = Object.create(options);\n    options.wrapped = true;\n  }\n  properties.set(context.name, options);\n  if (kind === 'accessor') {\n    // Standard decorators cannot dynamically modify the class, so we can't\n    // replace a field with accessors. The user must use the new `accessor`\n    // keyword instead.\n    const {\n      name\n    } = context;\n    return {\n      set(v) {\n        const oldValue = target.get.call(this);\n        target.set.call(this, v);\n        this.requestUpdate(name, oldValue, options);\n      },\n      init(v) {\n        if (v !== undefined) {\n          this._$changeProperty(name, undefined, options, v);\n        }\n        return v;\n      }\n    };\n  } else if (kind === 'setter') {\n    const {\n      name\n    } = context;\n    return function (value) {\n      const oldValue = this[name];\n      target.call(this, value);\n      this.requestUpdate(name, oldValue, options);\n    };\n  }\n  throw new Error(`Unsupported decorator location: ${kind}`);\n};\n/**\n * A class field or accessor decorator which creates a reactive property that\n * reflects a corresponding attribute value. When a decorated property is set\n * the element will update and render. A {@linkcode PropertyDeclaration} may\n * optionally be supplied to configure property features.\n *\n * This decorator should only be used for public fields. As public fields,\n * properties should be considered as primarily settable by element users,\n * either via attribute or the property itself.\n *\n * Generally, properties that are changed by the element should be private or\n * protected fields and should use the {@linkcode state} decorator.\n *\n * However, sometimes element code does need to set a public property. This\n * should typically only be done in response to user interaction, and an event\n * should be fired informing the user; for example, a checkbox sets its\n * `checked` property when clicked and fires a `changed` event. Mutating public\n * properties should typically not be done for non-primitive (object or array)\n * properties. In other cases when an element needs to manage state, a private\n * property decorated via the {@linkcode state} decorator should be used. When\n * needed, state properties can be initialized via public properties to\n * facilitate complex interactions.\n *\n * ```ts\n * class MyElement {\n *   @property({ type: Boolean })\n *   clicked = false;\n * }\n * ```\n * @category Decorator\n * @ExportDecoratedItems\n */\nexport function property(options) {\n  return (protoOrTarget, nameOrContext\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ) => {\n    return typeof nameOrContext === 'object' ? standardProperty(options, protoOrTarget, nameOrContext) : legacyProperty(options, protoOrTarget, nameOrContext);\n  };\n}","map":{"version":3,"names":["defaultConverter","notEqual","DEV_MODE","issueWarning","globalThis","litIssuedWarnings","Set","code","warning","has","console","warn","add","legacyProperty","options","proto","name","hasOwnProperty","constructor","createProperty","Object","getOwnPropertyDescriptor","undefined","defaultPropertyDeclaration","attribute","type","String","converter","reflect","hasChanged","standardProperty","target","context","kind","metadata","properties","litPropertyMetadata","get","set","Map","create","wrapped","v","oldValue","call","requestUpdate","init","_$changeProperty","value","Error","property","protoOrTarget","nameOrContext"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@lit\\reactive-element\\src\\decorators\\property.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/*\n * IMPORTANT: For compatibility with tsickle and the Closure JS compiler, all\n * property decorators (but not class decorators) in this file that have\n * an @ExportDecoratedItems annotation must be defined as a regular function,\n * not an arrow function.\n */\n\nimport {\n  type PropertyDeclaration,\n  type ReactiveElement,\n  defaultConverter,\n  notEqual,\n} from '../reactive-element.js';\nimport type {Interface} from './base.js';\n\nconst DEV_MODE = true;\n\nlet issueWarning: (code: string, warning: string) => void;\n\nif (DEV_MODE) {\n  // Ensure warnings are issued only 1x, even if multiple versions of Lit\n  // are loaded.\n  globalThis.litIssuedWarnings ??= new Set();\n\n  /**\n   * Issue a warning if we haven't already, based either on `code` or `warning`.\n   * Warnings are disabled automatically only by `warning`; disabling via `code`\n   * can be done by users.\n   */\n  issueWarning = (code: string, warning: string) => {\n    warning += ` See https://lit.dev/msg/${code} for more information.`;\n    if (\n      !globalThis.litIssuedWarnings!.has(warning) &&\n      !globalThis.litIssuedWarnings!.has(code)\n    ) {\n      console.warn(warning);\n      globalThis.litIssuedWarnings!.add(warning);\n    }\n  };\n}\n\n// Overloads for property decorator so that TypeScript can infer the correct\n// return type when a decorator is used as an accessor decorator or a setter\n// decorator.\nexport type PropertyDecorator = {\n  // accessor decorator signature\n  <C extends Interface<ReactiveElement>, V>(\n    target: ClassAccessorDecoratorTarget<C, V>,\n    context: ClassAccessorDecoratorContext<C, V>\n  ): ClassAccessorDecoratorResult<C, V>;\n\n  // setter decorator signature\n  <C extends Interface<ReactiveElement>, V>(\n    target: (value: V) => void,\n    context: ClassSetterDecoratorContext<C, V>\n  ): (this: C, value: V) => void;\n\n  // legacy decorator signature\n  (\n    protoOrDescriptor: Object,\n    name: PropertyKey,\n    descriptor?: PropertyDescriptor\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): any;\n};\n\nconst legacyProperty = (\n  options: PropertyDeclaration | undefined,\n  proto: Object,\n  name: PropertyKey\n) => {\n  const hasOwnProperty = proto.hasOwnProperty(name);\n  (proto.constructor as typeof ReactiveElement).createProperty(name, options);\n  // For accessors (which have a descriptor on the prototype) we need to\n  // return a descriptor, otherwise TypeScript overwrites the descriptor we\n  // define in createProperty() with the original descriptor. We don't do this\n  // for fields, which don't have a descriptor, because this could overwrite\n  // descriptor defined by other decorators.\n  return hasOwnProperty\n    ? Object.getOwnPropertyDescriptor(proto, name)\n    : undefined;\n};\n\n// This is duplicated from a similar variable in reactive-element.ts, but\n// actually makes sense to have this default defined with the decorator, so\n// that different decorators could have different defaults.\nconst defaultPropertyDeclaration: PropertyDeclaration = {\n  attribute: true,\n  type: String,\n  converter: defaultConverter,\n  reflect: false,\n  hasChanged: notEqual,\n};\n\n// Temporary type, until google3 is on TypeScript 5.2\ntype StandardPropertyContext<C, V> = (\n  | ClassAccessorDecoratorContext<C, V>\n  | ClassSetterDecoratorContext<C, V>\n) & {metadata: object};\n\n/**\n * Wraps a class accessor or setter so that `requestUpdate()` is called with the\n * property name and old value when the accessor is set.\n */\nexport const standardProperty = <C extends Interface<ReactiveElement>, V>(\n  options: PropertyDeclaration = defaultPropertyDeclaration,\n  target: ClassAccessorDecoratorTarget<C, V> | ((value: V) => void),\n  context: StandardPropertyContext<C, V>\n): ClassAccessorDecoratorResult<C, V> | ((this: C, value: V) => void) => {\n  const {kind, metadata} = context;\n\n  if (DEV_MODE && metadata == null) {\n    issueWarning(\n      'missing-class-metadata',\n      `The class ${target} is missing decorator metadata. This ` +\n        `could mean that you're using a compiler that supports decorators ` +\n        `but doesn't support decorator metadata, such as TypeScript 5.1. ` +\n        `Please update your compiler.`\n    );\n  }\n\n  // Store the property options\n  let properties = globalThis.litPropertyMetadata.get(metadata);\n  if (properties === undefined) {\n    globalThis.litPropertyMetadata.set(metadata, (properties = new Map()));\n  }\n  if (kind === 'setter') {\n    options = Object.create(options);\n    options.wrapped = true;\n  }\n  properties.set(context.name, options);\n\n  if (kind === 'accessor') {\n    // Standard decorators cannot dynamically modify the class, so we can't\n    // replace a field with accessors. The user must use the new `accessor`\n    // keyword instead.\n    const {name} = context;\n    return {\n      set(this: ReactiveElement, v: V) {\n        const oldValue = (\n          target as ClassAccessorDecoratorTarget<C, V>\n        ).get.call(this as unknown as C);\n        (target as ClassAccessorDecoratorTarget<C, V>).set.call(\n          this as unknown as C,\n          v\n        );\n        this.requestUpdate(name, oldValue, options);\n      },\n      init(this: ReactiveElement, v: V): V {\n        if (v !== undefined) {\n          this._$changeProperty(name, undefined, options, v);\n        }\n        return v;\n      },\n    } as unknown as ClassAccessorDecoratorResult<C, V>;\n  } else if (kind === 'setter') {\n    const {name} = context;\n    return function (this: ReactiveElement, value: V) {\n      const oldValue = this[name as keyof ReactiveElement];\n      (target as (value: V) => void).call(this, value);\n      this.requestUpdate(name, oldValue, options);\n    } as unknown as (this: C, value: V) => void;\n  }\n  throw new Error(`Unsupported decorator location: ${kind}`);\n};\n\n/**\n * A class field or accessor decorator which creates a reactive property that\n * reflects a corresponding attribute value. When a decorated property is set\n * the element will update and render. A {@linkcode PropertyDeclaration} may\n * optionally be supplied to configure property features.\n *\n * This decorator should only be used for public fields. As public fields,\n * properties should be considered as primarily settable by element users,\n * either via attribute or the property itself.\n *\n * Generally, properties that are changed by the element should be private or\n * protected fields and should use the {@linkcode state} decorator.\n *\n * However, sometimes element code does need to set a public property. This\n * should typically only be done in response to user interaction, and an event\n * should be fired informing the user; for example, a checkbox sets its\n * `checked` property when clicked and fires a `changed` event. Mutating public\n * properties should typically not be done for non-primitive (object or array)\n * properties. In other cases when an element needs to manage state, a private\n * property decorated via the {@linkcode state} decorator should be used. When\n * needed, state properties can be initialized via public properties to\n * facilitate complex interactions.\n *\n * ```ts\n * class MyElement {\n *   @property({ type: Boolean })\n *   clicked = false;\n * }\n * ```\n * @category Decorator\n * @ExportDecoratedItems\n */\nexport function property(options?: PropertyDeclaration): PropertyDecorator {\n  return <C extends Interface<ReactiveElement>, V>(\n    protoOrTarget:\n      | object\n      | ClassAccessorDecoratorTarget<C, V>\n      | ((value: V) => void),\n    nameOrContext:\n      | PropertyKey\n      | ClassAccessorDecoratorContext<C, V>\n      | ClassSetterDecoratorContext<C, V>\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): any => {\n    return (\n      typeof nameOrContext === 'object'\n        ? standardProperty<C, V>(\n            options,\n            protoOrTarget as\n              | ClassAccessorDecoratorTarget<C, V>\n              | ((value: V) => void),\n            nameOrContext as StandardPropertyContext<C, V>\n          )\n        : legacyProperty(\n            options,\n            protoOrTarget as Object,\n            nameOrContext as PropertyKey\n          )\n    ) as PropertyDecorator;\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}