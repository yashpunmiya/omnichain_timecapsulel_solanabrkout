{"ast":null,"code":"import { addressResolverAbi, universalResolverResolveAbi } from '../../constants/abis.js';\nimport { decodeFunctionResult } from '../../utils/abi/decodeFunctionResult.js';\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js';\nimport { getChainContractAddress } from '../../utils/chain/getChainContractAddress.js';\nimport { trim } from '../../utils/data/trim.js';\nimport { toHex } from '../../utils/encoding/toHex.js';\nimport { isNullUniversalResolverError } from '../../utils/ens/errors.js';\nimport { namehash } from '../../utils/ens/namehash.js';\nimport { packetToBytes } from '../../utils/ens/packetToBytes.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { readContract } from '../public/readContract.js';\n/**\n * Gets address for ENS name.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsAddress\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens\n *\n * Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsAddressParameters}\n * @returns Address for ENS name or `null` if not found. {@link GetEnsAddressReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsAddress, normalize } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const ensAddress = await getEnsAddress(client, {\n *   name: normalize('wevm.eth'),\n * })\n * // '0xd2135CfB216b74109775236E36d4b433F1DF507B'\n */\nexport async function getEnsAddress(client, {\n  blockNumber,\n  blockTag,\n  coinType,\n  name,\n  gatewayUrls,\n  strict,\n  universalResolverAddress: universalResolverAddress_\n}) {\n  let universalResolverAddress = universalResolverAddress_;\n  if (!universalResolverAddress) {\n    if (!client.chain) throw new Error('client chain not configured. universalResolverAddress is required.');\n    universalResolverAddress = getChainContractAddress({\n      blockNumber,\n      chain: client.chain,\n      contract: 'ensUniversalResolver'\n    });\n  }\n  try {\n    const functionData = encodeFunctionData({\n      abi: addressResolverAbi,\n      functionName: 'addr',\n      ...(coinType != null ? {\n        args: [namehash(name), BigInt(coinType)]\n      } : {\n        args: [namehash(name)]\n      })\n    });\n    const readContractParameters = {\n      address: universalResolverAddress,\n      abi: universalResolverResolveAbi,\n      functionName: 'resolve',\n      args: [toHex(packetToBytes(name)), functionData],\n      blockNumber,\n      blockTag\n    };\n    const readContractAction = getAction(client, readContract, 'readContract');\n    const res = gatewayUrls ? await readContractAction({\n      ...readContractParameters,\n      args: [...readContractParameters.args, gatewayUrls]\n    }) : await readContractAction(readContractParameters);\n    if (res[0] === '0x') return null;\n    const address = decodeFunctionResult({\n      abi: addressResolverAbi,\n      args: coinType != null ? [namehash(name), BigInt(coinType)] : undefined,\n      functionName: 'addr',\n      data: res[0]\n    });\n    if (address === '0x') return null;\n    if (trim(address) === '0x00') return null;\n    return address;\n  } catch (err) {\n    if (strict) throw err;\n    if (isNullUniversalResolverError(err, 'resolve')) return null;\n    throw err;\n  }\n}\n//# sourceMappingURL=getEnsAddress.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}