{"ast":null,"code":"import { proxy, snapshot } from 'valtio/vanilla';\nimport { subscribeKey as subKey } from 'valtio/vanilla/utils';\nimport { AccountController } from './AccountController.js';\nimport { ChainController } from './ChainController.js';\nimport { ConnectorController } from './ConnectorController.js';\nimport { ModalController } from './ModalController.js';\nimport { OptionsController } from './OptionsController.js';\n// -- State --------------------------------------------- //\nconst state = proxy({\n  view: 'Connect',\n  history: ['Connect'],\n  transactionStack: []\n});\n// -- Controller ---------------------------------------- //\nexport const RouterController = {\n  state,\n  subscribeKey(key, callback) {\n    return subKey(state, key, callback);\n  },\n  pushTransactionStack(action) {\n    state.transactionStack.push(action);\n  },\n  popTransactionStack(cancel) {\n    const action = state.transactionStack.pop();\n    if (!action) {\n      return;\n    }\n    if (cancel) {\n      // When the transaction is cancelled, we go back to the previous view\n      this.goBack();\n      action?.onCancel?.();\n    } else {\n      // When the transaction is successful, we do conditional navigation depending on the action properties\n      if (action.goBack) {\n        this.goBack();\n      } else if (action.replace) {\n        /*\n         *  If the history like [\"ConnectingSiwe\", \"ApproveTransaction\"], this means SIWE popup is opened after page rendered (not after user interaction)\n         *  we need to conditionally call replace.\n         *  There is a chance that there is only these two views in the history; when user approved, the modal should closed and history should be empty (both connectingsiwe and approveTX should be removed)\n         *  If there is another views before the ConnectingSiwe (if the CS is not the first view), we should back to the first view before CS.\n         */\n        const history = state.history;\n        const connectingSiweIndex = history.indexOf('ConnectingSiwe');\n        if (connectingSiweIndex > 0) {\n          // There are views before ConnectingSiwe\n          this.goBackToIndex(connectingSiweIndex - 1);\n        } else {\n          // ConnectingSiwe is the first view\n          ModalController.close();\n          state.history = [];\n        }\n      } else if (action.view) {\n        this.reset(action.view);\n      }\n      action?.onSuccess?.();\n    }\n  },\n  push(view, data) {\n    if (view !== state.view) {\n      state.view = view;\n      state.history.push(view);\n      state.data = data;\n    }\n  },\n  reset(view, data) {\n    state.view = view;\n    state.history = [view];\n    state.data = data;\n  },\n  replace(view, data) {\n    const lastView = state.history.at(-1);\n    const isSameView = lastView === view;\n    if (!isSameView) {\n      state.view = view;\n      state.history[state.history.length - 1] = view;\n      state.data = data;\n    }\n  },\n  goBack() {\n    const shouldReload = !ChainController.state.activeCaipAddress && this.state.view === 'ConnectingFarcaster';\n    if (state.history.length > 1 && !state.history.includes('UnsupportedChain')) {\n      state.history.pop();\n      const [last] = state.history.slice(-1);\n      if (last) {\n        state.view = last;\n      }\n    } else {\n      ModalController.close();\n    }\n    if (state.data?.wallet) {\n      state.data.wallet = undefined;\n    }\n    // Reloading the iframe contentwindow and doing the view animation in the modal causes a small freeze in the transition. Doing these separately fixes that.\n    setTimeout(() => {\n      if (shouldReload) {\n        AccountController.setFarcasterUrl(undefined, ChainController.state.activeChain);\n        const authConnector = ConnectorController.getAuthConnector();\n        authConnector?.provider?.reload();\n        const optionsState = snapshot(OptionsController.state);\n        authConnector?.provider?.syncDappData?.({\n          metadata: optionsState.metadata,\n          sdkVersion: optionsState.sdkVersion,\n          projectId: optionsState.projectId,\n          sdkType: optionsState.sdkType\n        });\n      }\n    }, 100);\n  },\n  goBackToIndex(historyIndex) {\n    if (state.history.length > 1) {\n      state.history = state.history.slice(0, historyIndex + 1);\n      const [last] = state.history.slice(-1);\n      if (last) {\n        state.view = last;\n      }\n    }\n  }\n};\n//# sourceMappingURL=RouterController.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}