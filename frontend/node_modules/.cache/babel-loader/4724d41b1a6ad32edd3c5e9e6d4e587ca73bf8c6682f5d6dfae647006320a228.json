{"ast":null,"code":"let id = 0;\nconst subscribers = [];\n/**\n * Logs something\n *\n * @param type a namespaced identifier of the log (it is not a level like \"debug\", \"error\" but more like \"apdu-in\", \"apdu-out\", etc...)\n * @param message a clear message of the log associated to the type\n */\nexport const log = (type, message, data) => {\n  const obj = {\n    type,\n    id: String(++id),\n    date: new Date()\n  };\n  if (message) obj.message = message;\n  if (data) obj.data = data;\n  dispatch(obj);\n};\n/**\n * A simple tracer function, only expanding the existing log function\n *\n * Its goal is to capture more context than a log function.\n * This is simple for now, but can be improved later.\n *\n * @param context Anything representing the context where the log occurred\n */\nexport const trace = ({\n  type,\n  message,\n  data,\n  context\n}) => {\n  const obj = {\n    type,\n    id: String(++id),\n    date: new Date()\n  };\n  if (message) obj.message = message;\n  if (data) obj.data = data;\n  if (context) obj.context = context;\n  dispatch(obj);\n};\n/**\n * A simple tracer class, that can be used to avoid repetition when using the `trace` function\n *\n * Its goal is to capture more context than a log function.\n * This is simple for now, but can be improved later.\n *\n * @param type A given type (not level) for the current local tracer (\"hw\", \"withDevice\", etc.)\n * @param context Anything representing the context where the log occurred\n */\nexport class LocalTracer {\n  constructor(type, context) {\n    this.type = type;\n    this.context = context;\n  }\n  trace(message, data) {\n    trace({\n      type: this.type,\n      message,\n      data,\n      context: this.context\n    });\n  }\n  getContext() {\n    return this.context;\n  }\n  setContext(context) {\n    this.context = context;\n  }\n  updateContext(contextToAdd) {\n    this.context = Object.assign(Object.assign({}, this.context), contextToAdd);\n  }\n  getType() {\n    return this.type;\n  }\n  setType(type) {\n    this.type = type;\n  }\n  /**\n   * Create a new instance of the LocalTracer with an updated `type`\n   *\n   * It does not mutate the calling instance, but returns a new LocalTracer,\n   * following a simple builder pattern.\n   */\n  withType(type) {\n    return new LocalTracer(type, this.context);\n  }\n  /**\n   * Create a new instance of the LocalTracer with a new `context`\n   *\n   * It does not mutate the calling instance, but returns a new LocalTracer,\n   * following a simple builder pattern.\n   *\n   * @param context A TraceContext, that can undefined to reset the context\n   */\n  withContext(context) {\n    return new LocalTracer(this.type, context);\n  }\n  /**\n   * Create a new instance of the LocalTracer with an updated `context`,\n   * on which an additional context is merged with the existing one.\n   *\n   * It does not mutate the calling instance, but returns a new LocalTracer,\n   * following a simple builder pattern.\n   */\n  withUpdatedContext(contextToAdd) {\n    return new LocalTracer(this.type, Object.assign(Object.assign({}, this.context), contextToAdd));\n  }\n}\n/**\n * Adds a subscribers to the emitted logs.\n *\n * @param cb that is called for each future log() with the Log object\n * @return a function that can be called to unsubscribe the listener\n */\nexport const listen = cb => {\n  subscribers.push(cb);\n  return () => {\n    const i = subscribers.indexOf(cb);\n    if (i !== -1) {\n      // equivalent of subscribers.splice(i, 1) // https://twitter.com/Rich_Harris/status/1125850391155965952\n      subscribers[i] = subscribers[subscribers.length - 1];\n      subscribers.pop();\n    }\n  };\n};\nfunction dispatch(log) {\n  for (let i = 0; i < subscribers.length; i++) {\n    try {\n      subscribers[i](log);\n    } catch (e) {\n      console.error(e);\n    }\n  }\n}\nif (typeof window !== \"undefined\") {\n  window.__ledgerLogsListen = listen;\n}\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}