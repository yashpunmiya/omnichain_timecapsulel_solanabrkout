{"ast":null,"code":"/**\n * this is a set which automatically forgets\n * a given entry when a new entry is set and the ttl\n * of the old one is over\n */\nexport class ObliviousSet {\n  ttl;\n  map = new Map();\n  /**\n   * Creating calls to setTimeout() is expensive,\n   * so we only do that if there is not timeout already open.\n   */\n  _to = false;\n  constructor(ttl) {\n    this.ttl = ttl;\n  }\n  has(value) {\n    return this.map.has(value);\n  }\n  add(value) {\n    this.map.set(value, now());\n    /**\n     * When a new value is added,\n     * start the cleanup at the next tick\n     * to not block the cpu for more important stuff\n     * that might happen.\n     */\n    if (!this._to) {\n      this._to = true;\n      setTimeout(() => {\n        this._to = false;\n        removeTooOldValues(this);\n      }, 0);\n    }\n  }\n  clear() {\n    this.map.clear();\n  }\n}\n/**\n * Removes all entries from the set\n * where the TTL has expired\n */\nexport function removeTooOldValues(obliviousSet) {\n  const olderThen = now() - obliviousSet.ttl;\n  const iterator = obliviousSet.map[Symbol.iterator]();\n  /**\n   * Because we can assume the new values are added at the bottom,\n   * we start from the top and stop as soon as we reach a non-too-old value.\n   */\n  while (true) {\n    const next = iterator.next().value;\n    if (!next) {\n      return; // no more elements\n    }\n    const value = next[0];\n    const time = next[1];\n    if (time < olderThen) {\n      obliviousSet.map.delete(value);\n    } else {\n      // We reached a value that is not old enough\n      return;\n    }\n  }\n}\nexport function now() {\n  return Date.now();\n}\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}