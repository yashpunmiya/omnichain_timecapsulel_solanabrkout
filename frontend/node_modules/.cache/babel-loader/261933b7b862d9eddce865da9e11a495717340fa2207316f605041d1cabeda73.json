{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\nvar bcUrRegistrySol = require('@keystonehq/bc-ur-registry-sol');\nvar sdk = require('@keystonehq/sdk');\nvar sdk__default = _interopDefault(sdk);\nvar bcUrRegistry = require('@keystonehq/bc-ur-registry');\nvar bs58 = _interopDefault(require('bs58'));\nvar uuid = require('uuid');\nvar web3_js = require('@solana/web3.js');\nclass DefaultInteractionProvider {\n  constructor() {\n    this.keystoneSDK = undefined;\n    this.readCryptoMultiAccounts = async () => {\n      const decodedResult = await this.keystoneSDK.read([sdk.SupportedResult.UR_CRYPTO_MULTI_ACCOUNTS], {\n        title: \"Sync Keystone\",\n        description: \"Please scan the QR code displayed on your Keystone\",\n        renderInitial: {\n          walletMode: \"Solflare\",\n          link: \"https://keyst.one/defi\"\n        },\n        URTypeErrorMessage: \"The scanned QR code is not the sync code from the Keystone hardware wallet. Please verify the code and try again\"\n      });\n      if (decodedResult.status === sdk.ReadStatus.success) {\n        const {\n          result\n        } = decodedResult;\n        return bcUrRegistry.CryptoMultiAccounts.fromCBOR(result.cbor);\n      } else {\n        throw new Error(\"Reading canceled\");\n      }\n    };\n    this.requestSignature = async (solSignRequest, requestTitle, requestDescription) => {\n      const status = await this.keystoneSDK.play(solSignRequest.toUR(), {\n        hasNext: true,\n        title: requestTitle,\n        description: requestDescription,\n        maxFragmentLength: 400\n      });\n      if (status === sdk.PlayStatus.canceled) throw new Error(\"#ktek_error[play-cancel]: play canceled\");\n      const result = await this.keystoneSDK.read([sdk.SupportedResult.UR_SOL_SIGNATURE], {\n        title: \"Scan Keystone\",\n        description: \"Please scan the QR code displayed on your Keystone\"\n      });\n      if (result.status === sdk.ReadStatus.canceled) {\n        throw new Error(\"#ktek_error[read-cancel]: read signature canceled\");\n      } else {\n        return bcUrRegistrySol.SolSignature.fromCBOR(result.result.cbor);\n      }\n    };\n    if (DefaultInteractionProvider.instance) {\n      return DefaultInteractionProvider.instance;\n    }\n    sdk__default.bootstrap();\n    this.keystoneSDK = sdk__default.getSdk();\n    DefaultInteractionProvider.instance = this;\n  }\n}\nconst keyringType = \"QR Hardware Wallet Device\";\nclass BaseKeyring {\n  constructor() {\n    this.getInteraction = () => {\n      throw new Error(\"KeystoneError#invalid_extends: method getInteraction not implemented, please extend BaseKeyring by overwriting this method.\");\n    };\n    this.type = keyringType;\n    this.requestSignature = async (_requestId, signRequest, requestTitle, requestDescription) => {\n      const solSignature = await this.getInteraction().requestSignature(signRequest, requestTitle, requestDescription);\n      const requestIdBuffer = solSignature.getRequestId();\n      const signature = solSignature.getSignature();\n      if (requestIdBuffer) {\n        const requestId = uuid.stringify(requestIdBuffer);\n        if (requestId !== _requestId) {\n          throw new Error(\"KeystoneError#invalid_data: read signature error: mismatched requestId\");\n        }\n      }\n      return signature;\n    };\n    this.getName = () => {\n      return this.name;\n    };\n    //common props\n    this.keys = [];\n    this.name = \"QR Hardware\";\n    this.initialized = false;\n    this.device = \"\";\n    this.xfp = \"\";\n  }\n  //initial read\n  async readKeyring() {\n    const result = await this.getInteraction().readCryptoMultiAccounts();\n    this.syncKeyring(result);\n  }\n  syncKeyring(data) {\n    var _data$getKeys$0$getOr;\n    const keys = data.getKeys();\n    this.device = data.getDevice();\n    this.xfp = (_data$getKeys$0$getOr = data.getKeys()[0].getOrigin().getSourceFingerprint()) === null || _data$getKeys$0$getOr === void 0 ? void 0 : _data$getKeys$0$getOr.toString(\"hex\");\n    this.name = data.getKeys()[0].getName();\n    this.keys = keys.map((each, index) => ({\n      hdPath: each.getOrigin().getPath(),\n      pubKey: bs58.encode(each.getKey()),\n      index\n    }));\n    this.initialized = true;\n  }\n  syncKeyringData({\n    xfp,\n    keys,\n    name = \"QR Hardware\",\n    device\n  }) {\n    this.xfp = xfp;\n    this.name = name;\n    this.keys = keys;\n    this.device = device;\n    this.initialized = true;\n  }\n  getAccounts() {\n    if (!this.initialized) {\n      return [];\n    }\n    return this.keys;\n  }\n  async signTransaction(pubKey, txHex) {\n    const signature = await this._getSignature(pubKey, Buffer.from(txHex), bcUrRegistrySol.SignType.Transaction);\n    return signature;\n  }\n  async signMessage(pubKey, messageHex) {\n    return await this._getSignature(pubKey, Buffer.from(messageHex), bcUrRegistrySol.SignType.Message);\n  }\n  async createSignature(pubKey, messageHex) {\n    try {\n      const messageInstance = web3_js.Message.from(messageHex);\n      const transaction = web3_js.Transaction.populate(messageInstance, []);\n      if (transaction) {\n        return this._getSignature(pubKey, Buffer.from(messageHex), bcUrRegistrySol.SignType.Transaction);\n      }\n    } catch (e) {\n      console.error(e);\n    }\n    return this.signMessage(pubKey, messageHex);\n  }\n  async _getSignature(pubKey, messageHex, signType) {\n    const requestId = uuid.v4();\n    const account = this.getAccounts().find(account => account.pubKey == pubKey);\n    const solSignRequest = bcUrRegistrySol.SolSignRequest.constructSOLRequest(messageHex, account.hdPath, this.xfp, signType, requestId);\n    return this.requestSignature(requestId, solSignRequest, \"Scan with your Keystone\", 'After your Keystone has signed this message, click on \"Scan Keystone\" to receive the signature');\n  }\n}\nBaseKeyring.type = keyringType;\nclass DefaultKeyring extends BaseKeyring {\n  constructor() {\n    super();\n    this.getInteraction = () => {\n      return new DefaultInteractionProvider();\n    };\n  }\n  static getEmptyKeyring() {\n    return new DefaultKeyring();\n  }\n}\nDefaultKeyring.type = BaseKeyring.type;\nexports.BaseKeyring = BaseKeyring;\nexports.DefaultKeyring = DefaultKeyring;","map":{"version":3,"names":["DefaultInteractionProvider","constructor","keystoneSDK","undefined","readCryptoMultiAccounts","decodedResult","read","sdk","SupportedResult","UR_CRYPTO_MULTI_ACCOUNTS","title","description","renderInitial","walletMode","link","URTypeErrorMessage","status","ReadStatus","success","result","bcUrRegistry","CryptoMultiAccounts","fromCBOR","cbor","Error","requestSignature","solSignRequest","requestTitle","requestDescription","play","toUR","hasNext","maxFragmentLength","PlayStatus","canceled","UR_SOL_SIGNATURE","bcUrRegistrySol","SolSignature","instance","sdk__default","bootstrap","getSdk","keyringType","BaseKeyring","getInteraction","type","_requestId","signRequest","solSignature","requestIdBuffer","getRequestId","signature","getSignature","requestId","uuid","stringify","getName","name","keys","initialized","device","xfp","readKeyring","syncKeyring","data","getKeys","getDevice","_data$getKeys$0$getOr","getOrigin","getSourceFingerprint","toString","map","each","index","hdPath","getPath","pubKey","bs58","encode","getKey","syncKeyringData","getAccounts","signTransaction","txHex","_getSignature","Buffer","from","SignType","Transaction","signMessage","messageHex","Message","createSignature","messageInstance","web3_js","transaction","populate","e","console","error","signType","v4","account","find","SolSignRequest","constructSOLRequest","DefaultKeyring","getEmptyKeyring"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@keystonehq\\sol-keyring\\src\\DefaultInteractionProvider.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@keystonehq\\sol-keyring\\src\\BaseKeyring.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@keystonehq\\sol-keyring\\src\\DefaultKeyring.ts"],"sourcesContent":["import { SolSignature, SolSignRequest } from \"@keystonehq/bc-ur-registry-sol\";\nimport { InteractionProvider } from \"./InteractionProvider\";\nimport sdk, { PlayStatus, ReadStatus, SupportedResult } from \"@keystonehq/sdk\";\nimport { CryptoMultiAccounts } from \"@keystonehq/bc-ur-registry\";\n\nexport class DefaultInteractionProvider implements InteractionProvider {\n  private static instance;\n  private keystoneSDK = undefined;\n\n  constructor() {\n    if (DefaultInteractionProvider.instance) {\n      return DefaultInteractionProvider.instance;\n    }\n    sdk.bootstrap();\n    this.keystoneSDK = sdk.getSdk();\n    DefaultInteractionProvider.instance = this;\n  }\n\n  public readCryptoMultiAccounts = async () => {\n    const decodedResult = await this.keystoneSDK.read(\n      [SupportedResult.UR_CRYPTO_MULTI_ACCOUNTS],\n      {\n        title: \"Sync Keystone\",\n        description: \"Please scan the QR code displayed on your Keystone\",\n        renderInitial: {\n          walletMode: \"Solflare\",\n          link: \"https://keyst.one/defi\",\n        },\n        URTypeErrorMessage:\n          \"The scanned QR code is not the sync code from the Keystone hardware wallet. Please verify the code and try again\",\n      }\n    );\n    if (decodedResult.status === ReadStatus.success) {\n      const { result } = decodedResult;\n      return CryptoMultiAccounts.fromCBOR(result.cbor);\n    } else {\n      throw new Error(\"Reading canceled\");\n    }\n  };\n\n  public requestSignature = async (\n    solSignRequest: SolSignRequest,\n    requestTitle?: string,\n    requestDescription?: string\n  ) => {\n    const status = await this.keystoneSDK.play(solSignRequest.toUR(), {\n      hasNext: true,\n      title: requestTitle,\n      description: requestDescription,\n      maxFragmentLength: 400,\n    });\n    if (status === PlayStatus.canceled)\n      throw new Error(\"#ktek_error[play-cancel]: play canceled\");\n    const result = await this.keystoneSDK.read(\n      [SupportedResult.UR_SOL_SIGNATURE],\n      {\n        title: \"Scan Keystone\",\n        description: \"Please scan the QR code displayed on your Keystone\",\n      }\n    );\n    if (result.status === ReadStatus.canceled) {\n      throw new Error(\"#ktek_error[read-cancel]: read signature canceled\");\n    } else {\n      return SolSignature.fromCBOR(result.result.cbor);\n    }\n  };\n}\n","import bs58 from \"bs58\";\nimport * as uuid from \"uuid\";\nimport { Message, Transaction } from \"@solana/web3.js\";\nimport { InteractionProvider } from \"./InteractionProvider\";\nimport { CryptoMultiAccounts } from \"@keystonehq/bc-ur-registry\";\nimport { SolSignRequest, SignType } from \"@keystonehq/bc-ur-registry-sol\";\n\nconst keyringType = \"QR Hardware Wallet Device\";\n\nexport interface HDKey {\n  hdPath: string;\n  pubKey: string;\n  index: number;\n}\n\ninterface KeyringInitData {\n  xfp: string;\n  keys: HDKey[];\n  name?: string;\n  device?: string;\n}\n\nexport class BaseKeyring {\n  getInteraction = (): InteractionProvider => {\n    throw new Error(\n      \"KeystoneError#invalid_extends: method getInteraction not implemented, please extend BaseKeyring by overwriting this method.\"\n    );\n  };\n  static type = keyringType;\n  protected xfp: string;\n  protected type = keyringType;\n  protected initialized: boolean;\n  protected keys: HDKey[];\n  protected name: string;\n  protected device: string;\n\n  constructor() {\n    //common props\n    this.keys = [];\n    this.name = \"QR Hardware\";\n    this.initialized = false;\n    this.device = \"\";\n    this.xfp = \"\";\n  }\n\n  protected requestSignature = async (\n    _requestId: string,\n    signRequest: SolSignRequest,\n    requestTitle?: string,\n    requestDescription?: string\n  ): Promise<Buffer> => {\n    const solSignature = await this.getInteraction().requestSignature(\n      signRequest,\n      requestTitle,\n      requestDescription\n    );\n    const requestIdBuffer = solSignature.getRequestId();\n    const signature = solSignature.getSignature();\n    if (requestIdBuffer) {\n      const requestId = uuid.stringify(requestIdBuffer);\n      if (requestId !== _requestId) {\n        throw new Error(\n          \"KeystoneError#invalid_data: read signature error: mismatched requestId\"\n        );\n      }\n    }\n    return signature;\n  };\n\n  //initial read\n  async readKeyring(): Promise<void> {\n    const result = await this.getInteraction().readCryptoMultiAccounts();\n    this.syncKeyring(result);\n  }\n\n  public syncKeyring(data: CryptoMultiAccounts): void {\n    const keys = data.getKeys();\n    this.device = data.getDevice();\n    this.xfp = data\n      .getKeys()[0]\n      .getOrigin()\n      .getSourceFingerprint()\n      ?.toString(\"hex\");\n    this.name = data.getKeys()[0].getName();\n    this.keys = keys.map((each, index) => ({\n      hdPath: each.getOrigin().getPath(),\n      pubKey: bs58.encode(each.getKey()),\n      index,\n    }));\n    this.initialized = true;\n  }\n\n  public syncKeyringData({\n    xfp,\n    keys,\n    name = \"QR Hardware\",\n    device,\n  }: KeyringInitData): void {\n    this.xfp = xfp;\n    this.name = name;\n    this.keys = keys;\n    this.device = device;\n    this.initialized = true;\n  }\n\n  public getName = (): string => {\n    return this.name;\n  };\n\n  getAccounts() {\n    if (!this.initialized) {\n      return [];\n    }\n    return this.keys;\n  }\n\n  async signTransaction(pubKey: string, txHex: Uint8Array): Promise<Uint8Array> {\n    const signature = await this._getSignature(\n      pubKey,\n      Buffer.from(txHex),\n      SignType.Transaction\n    );\n    return signature;\n  }\n\n  async signMessage(\n    pubKey: string,\n    messageHex: Uint8Array\n  ): Promise<Uint8Array> {\n    return await this._getSignature(\n      pubKey,\n      Buffer.from(messageHex),\n      SignType.Message\n    );\n  }\n\n  async createSignature(\n    pubKey: string,\n    messageHex: Uint8Array\n  ): Promise<Uint8Array> {\n    try {\n      const messageInstance = Message.from(messageHex);\n      const transaction = Transaction.populate(messageInstance, []);\n      if (transaction) {\n        return this._getSignature(\n          pubKey,\n          Buffer.from(messageHex),\n          SignType.Transaction\n        );\n      }\n    } catch (e) {\n      console.error(e);\n    }\n    return this.signMessage(pubKey, messageHex);\n  }\n\n  async _getSignature(\n    pubKey: string,\n    messageHex: Buffer,\n    signType\n  ): Promise<Buffer> {\n    const requestId = uuid.v4();\n    const account = this.getAccounts().find(\n      (account) => account.pubKey == pubKey\n    );\n    const solSignRequest = SolSignRequest.constructSOLRequest(\n      messageHex,\n      account.hdPath,\n      this.xfp,\n      signType,\n      requestId\n    );\n    return this.requestSignature(\n      requestId,\n      solSignRequest,\n      \"Scan with your Keystone\",\n      'After your Keystone has signed this message, click on \"Scan Keystone\" to receive the signature'\n    );\n  }\n}\n","import { DefaultInteractionProvider } from \"./DefaultInteractionProvider\";\nimport { BaseKeyring } from \"./BaseKeyring\";\n\nexport class DefaultKeyring extends BaseKeyring {\n  static type = BaseKeyring.type;\n\n  static getEmptyKeyring(): DefaultKeyring {\n    return new DefaultKeyring();\n  }\n\n  constructor() {\n    super();\n  }\n\n  getInteraction = () => {\n    return new DefaultInteractionProvider();\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}