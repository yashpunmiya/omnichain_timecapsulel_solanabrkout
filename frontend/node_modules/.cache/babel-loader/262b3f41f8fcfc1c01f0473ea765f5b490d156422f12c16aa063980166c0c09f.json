{"ast":null,"code":"import { getAction } from '../../utils/getAction.js';\nimport { observe } from '../../utils/observe.js';\nimport { poll } from '../../utils/poll.js';\nimport { stringify } from '../../utils/stringify.js';\nimport { getBlock } from './getBlock.js';\n/**\n * Watches and returns information for incoming blocks.\n *\n * - Docs: https://viem.sh/docs/actions/public/watchBlocks\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks_watching-blocks\n * - JSON-RPC Methods:\n *   - When `poll: true`, calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getBlockByNumber) on a polling interval.\n *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `\"newHeads\"` event.\n *\n * @param client - Client to use\n * @param parameters - {@link WatchBlocksParameters}\n * @returns A function that can be invoked to stop watching for new block numbers. {@link WatchBlocksReturnType}\n *\n * @example\n * import { createPublicClient, watchBlocks, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = watchBlocks(client, {\n *   onBlock: (block) => console.log(block),\n * })\n */\nexport function watchBlocks(client, {\n  blockTag = 'latest',\n  emitMissed = false,\n  emitOnBegin = false,\n  onBlock,\n  onError,\n  includeTransactions: includeTransactions_,\n  poll: poll_,\n  pollingInterval = client.pollingInterval\n}) {\n  const enablePolling = (() => {\n    if (typeof poll_ !== 'undefined') return poll_;\n    if (client.transport.type === 'webSocket') return false;\n    if (client.transport.type === 'fallback' && client.transport.transports[0].config.type === 'webSocket') return false;\n    return true;\n  })();\n  const includeTransactions = includeTransactions_ ?? false;\n  let prevBlock;\n  const pollBlocks = () => {\n    const observerId = stringify(['watchBlocks', client.uid, blockTag, emitMissed, emitOnBegin, includeTransactions, pollingInterval]);\n    return observe(observerId, {\n      onBlock,\n      onError\n    }, emit => poll(async () => {\n      try {\n        const block = await getAction(client, getBlock, 'getBlock')({\n          blockTag,\n          includeTransactions\n        });\n        if (block.number && prevBlock?.number) {\n          // If the current block number is the same as the previous,\n          // we can skip.\n          if (block.number === prevBlock.number) return;\n          // If we have missed out on some previous blocks, and the\n          // `emitMissed` flag is truthy, let's emit those blocks.\n          if (block.number - prevBlock.number > 1 && emitMissed) {\n            for (let i = prevBlock?.number + 1n; i < block.number; i++) {\n              const block = await getAction(client, getBlock, 'getBlock')({\n                blockNumber: i,\n                includeTransactions\n              });\n              emit.onBlock(block, prevBlock);\n              prevBlock = block;\n            }\n          }\n        }\n        if (\n        // If no previous block exists, emit.\n        !prevBlock?.number ||\n        // If the block tag is \"pending\" with no block number, emit.\n        blockTag === 'pending' && !block?.number ||\n        // If the next block number is greater than the previous block number, emit.\n        // We don't want to emit blocks in the past.\n        block.number && block.number > prevBlock.number) {\n          emit.onBlock(block, prevBlock);\n          prevBlock = block;\n        }\n      } catch (err) {\n        emit.onError?.(err);\n      }\n    }, {\n      emitOnBegin,\n      interval: pollingInterval\n    }));\n  };\n  const subscribeBlocks = () => {\n    let active = true;\n    let emitFetched = true;\n    let unsubscribe = () => active = false;\n    (async () => {\n      try {\n        if (emitOnBegin) {\n          getAction(client, getBlock, 'getBlock')({\n            blockTag,\n            includeTransactions\n          }).then(block => {\n            if (!active) return;\n            if (!emitFetched) return;\n            onBlock(block, undefined);\n            emitFetched = false;\n          });\n        }\n        const transport = (() => {\n          if (client.transport.type === 'fallback') {\n            const transport = client.transport.transports.find(transport => transport.config.type === 'webSocket');\n            if (!transport) return client.transport;\n            return transport.value;\n          }\n          return client.transport;\n        })();\n        const {\n          unsubscribe: unsubscribe_\n        } = await transport.subscribe({\n          params: ['newHeads'],\n          async onData(data) {\n            if (!active) return;\n            const block = await getAction(client, getBlock, 'getBlock')({\n              blockNumber: data.blockNumber,\n              includeTransactions\n            }).catch(() => {});\n            if (!active) return;\n            onBlock(block, prevBlock);\n            emitFetched = false;\n            prevBlock = block;\n          },\n          onError(error) {\n            onError?.(error);\n          }\n        });\n        unsubscribe = unsubscribe_;\n        if (!active) unsubscribe();\n      } catch (err) {\n        onError?.(err);\n      }\n    })();\n    return () => unsubscribe();\n  };\n  return enablePolling ? pollBlocks() : subscribeBlocks();\n}\n//# sourceMappingURL=watchBlocks.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}