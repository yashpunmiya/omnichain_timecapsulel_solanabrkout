{"ast":null,"code":"'use strict';\n\nconst {\n  pipeline\n} = require('./pipeline');\nconst Duplex = require('./duplex');\nconst {\n  destroyer\n} = require('./destroy');\nconst {\n  isNodeStream,\n  isReadable,\n  isWritable,\n  isWebStream,\n  isTransformStream,\n  isWritableStream,\n  isReadableStream\n} = require('./utils');\nconst {\n  AbortError,\n  codes: {\n    ERR_INVALID_ARG_VALUE,\n    ERR_MISSING_ARGS\n  }\n} = require('../../ours/errors');\nconst eos = require('./end-of-stream');\nmodule.exports = function compose(...streams) {\n  if (streams.length === 0) {\n    throw new ERR_MISSING_ARGS('streams');\n  }\n  if (streams.length === 1) {\n    return Duplex.from(streams[0]);\n  }\n  const orgStreams = [...streams];\n  if (typeof streams[0] === 'function') {\n    streams[0] = Duplex.from(streams[0]);\n  }\n  if (typeof streams[streams.length - 1] === 'function') {\n    const idx = streams.length - 1;\n    streams[idx] = Duplex.from(streams[idx]);\n  }\n  for (let n = 0; n < streams.length; ++n) {\n    if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {\n      // TODO(ronag): Add checks for non streams.\n      continue;\n    }\n    if (n < streams.length - 1 && !(isReadable(streams[n]) || isReadableStream(streams[n]) || isTransformStream(streams[n]))) {\n      throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], 'must be readable');\n    }\n    if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n]))) {\n      throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], 'must be writable');\n    }\n  }\n  let ondrain;\n  let onfinish;\n  let onreadable;\n  let onclose;\n  let d;\n  function onfinished(err) {\n    const cb = onclose;\n    onclose = null;\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      d.destroy(err);\n    } else if (!readable && !writable) {\n      d.destroy();\n    }\n  }\n  const head = streams[0];\n  const tail = pipeline(streams, onfinished);\n  const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head));\n  const readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail));\n\n  // TODO(ronag): Avoid double buffering.\n  // Implement Writable/Readable/Duplex traits.\n  // See, https://github.com/nodejs/node/pull/33515.\n  d = new Duplex({\n    // TODO (ronag): highWaterMark?\n    writableObjectMode: !!(head !== null && head !== undefined && head.writableObjectMode),\n    readableObjectMode: !!(tail !== null && tail !== undefined && tail.readableObjectMode),\n    writable,\n    readable\n  });\n  if (writable) {\n    if (isNodeStream(head)) {\n      d._write = function (chunk, encoding, callback) {\n        if (head.write(chunk, encoding)) {\n          callback();\n        } else {\n          ondrain = callback;\n        }\n      };\n      d._final = function (callback) {\n        head.end();\n        onfinish = callback;\n      };\n      head.on('drain', function () {\n        if (ondrain) {\n          const cb = ondrain;\n          ondrain = null;\n          cb();\n        }\n      });\n    } else if (isWebStream(head)) {\n      const writable = isTransformStream(head) ? head.writable : head;\n      const writer = writable.getWriter();\n      d._write = async function (chunk, encoding, callback) {\n        try {\n          await writer.ready;\n          writer.write(chunk).catch(() => {});\n          callback();\n        } catch (err) {\n          callback(err);\n        }\n      };\n      d._final = async function (callback) {\n        try {\n          await writer.ready;\n          writer.close().catch(() => {});\n          onfinish = callback;\n        } catch (err) {\n          callback(err);\n        }\n      };\n    }\n    const toRead = isTransformStream(tail) ? tail.readable : tail;\n    eos(toRead, () => {\n      if (onfinish) {\n        const cb = onfinish;\n        onfinish = null;\n        cb();\n      }\n    });\n  }\n  if (readable) {\n    if (isNodeStream(tail)) {\n      tail.on('readable', function () {\n        if (onreadable) {\n          const cb = onreadable;\n          onreadable = null;\n          cb();\n        }\n      });\n      tail.on('end', function () {\n        d.push(null);\n      });\n      d._read = function () {\n        while (true) {\n          const buf = tail.read();\n          if (buf === null) {\n            onreadable = d._read;\n            return;\n          }\n          if (!d.push(buf)) {\n            return;\n          }\n        }\n      };\n    } else if (isWebStream(tail)) {\n      const readable = isTransformStream(tail) ? tail.readable : tail;\n      const reader = readable.getReader();\n      d._read = async function () {\n        while (true) {\n          try {\n            const {\n              value,\n              done\n            } = await reader.read();\n            if (!d.push(value)) {\n              return;\n            }\n            if (done) {\n              d.push(null);\n              return;\n            }\n          } catch {\n            return;\n          }\n        }\n      };\n    }\n  }\n  d._destroy = function (err, callback) {\n    if (!err && onclose !== null) {\n      err = new AbortError();\n    }\n    onreadable = null;\n    ondrain = null;\n    onfinish = null;\n    if (onclose === null) {\n      callback(err);\n    } else {\n      onclose = callback;\n      if (isNodeStream(tail)) {\n        destroyer(tail, err);\n      }\n    }\n  };\n  return d;\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}