{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { PublicKey, Transaction, VersionedTransaction } from '@solana/web3.js';\nimport EventEmitter from 'eventemitter3';\nimport bs58 from 'bs58';\nimport { v4 as uuidv4 } from 'uuid';\nimport { isLegacyTransactionInstance, serializeTransaction } from './utils';\nimport { detectProvider } from './detectProvider';\nimport { StandardSolflareMetaMaskWalletAccount } from './standard/account';\nimport { isSolanaChain } from './standard/solana';\nexport * from './types';\nexport * from './standard/account';\nclass SolflareMetaMask extends EventEmitter {\n  constructor(config) {\n    super();\n    this._network = 'mainnet-beta';\n    this._iframeParams = {};\n    this._element = null;\n    this._iframe = null;\n    this._publicKey = null;\n    this._account = null;\n    this._isConnected = false;\n    this._connectHandler = null;\n    this._messageHandlers = {};\n    this._handleEvent = event => {\n      var _a, _b;\n      switch (event.type) {\n        case 'connect':\n          {\n            this._collapseIframe();\n            if ((_a = event.data) === null || _a === void 0 ? void 0 : _a.publicKey) {\n              this._publicKey = event.data.publicKey;\n              this._isConnected = true;\n              if (this._connectHandler) {\n                this._connectHandler.resolve();\n                this._connectHandler = null;\n              }\n              this._connected();\n            } else {\n              if (this._connectHandler) {\n                this._connectHandler.reject();\n                this._connectHandler = null;\n              }\n              this._disconnected();\n            }\n            return;\n          }\n        case 'disconnect':\n          {\n            if (this._connectHandler) {\n              this._connectHandler.reject();\n              this._connectHandler = null;\n            }\n            this._disconnected();\n            return;\n          }\n        case 'accountChanged':\n          {\n            if ((_b = event.data) === null || _b === void 0 ? void 0 : _b.publicKey) {\n              this._publicKey = event.data.publicKey;\n              this.emit('accountChanged', this.publicKey);\n              this._standardConnected();\n            } else {\n              this.emit('accountChanged', undefined);\n              this._standardDisconnected();\n            }\n            return;\n          }\n        default:\n          {\n            return;\n          }\n      }\n    };\n    this._handleResize = data => {\n      if (data.resizeMode === 'full') {\n        if (data.params.mode === 'fullscreen') {\n          this._expandIframe();\n        } else if (data.params.mode === 'hide') {\n          this._collapseIframe();\n        }\n      } else if (data.resizeMode === 'coordinates') {\n        this._resizeIframe(data.params);\n      }\n    };\n    this._handleMessage = event => {\n      var _a;\n      if (((_a = event.data) === null || _a === void 0 ? void 0 : _a.channel) !== 'solflareIframeToWalletAdapter') {\n        return;\n      }\n      const data = event.data.data || {};\n      if (data.type === 'event') {\n        this._handleEvent(data.event);\n      } else if (data.type === 'resize') {\n        this._handleResize(data);\n      } else if (data.type === 'response') {\n        if (this._messageHandlers[data.id]) {\n          const {\n            resolve,\n            reject\n          } = this._messageHandlers[data.id];\n          delete this._messageHandlers[data.id];\n          if (data.error) {\n            reject(data.error);\n          } else {\n            resolve(data.result);\n          }\n        }\n      }\n    };\n    this._removeElement = () => {\n      if (this._element) {\n        this._element.remove();\n        this._element = null;\n      }\n    };\n    this._removeDanglingElements = () => {\n      const elements = document.getElementsByClassName('solflare-metamask-wallet-adapter-iframe');\n      for (const element of elements) {\n        if (element.parentElement) {\n          element.remove();\n        }\n      }\n    };\n    this._injectElement = () => {\n      this._removeElement();\n      this._removeDanglingElements();\n      const params = Object.assign(Object.assign({}, this._iframeParams), {\n        mm: true,\n        v: 1,\n        cluster: this._network || 'mainnet-beta',\n        origin: window.location.origin || '',\n        title: document.title || ''\n      });\n      const queryString = Object.keys(params).map(key => `${key}=${encodeURIComponent(params[key])}`).join('&');\n      const iframeUrl = `${SolflareMetaMask.IFRAME_URL}?${queryString}`;\n      this._element = document.createElement('div');\n      this._element.className = 'solflare-metamask-wallet-adapter-iframe';\n      this._element.innerHTML = `\n      <iframe src='${iframeUrl}' style='position: fixed; top: 0; bottom: 0; left: 0; right: 0; width: 100%; height: 100%; border: none; border-radius: 0; z-index: 99999; color-scheme: auto;' allowtransparency='true'></iframe>\n    `;\n      document.body.appendChild(this._element);\n      this._iframe = this._element.querySelector('iframe');\n      window.addEventListener('message', this._handleMessage, false);\n    };\n    this._collapseIframe = () => {\n      if (this._iframe) {\n        this._iframe.style.top = '';\n        this._iframe.style.right = '';\n        this._iframe.style.height = '2px';\n        this._iframe.style.width = '2px';\n      }\n    };\n    this._expandIframe = () => {\n      if (this._iframe) {\n        this._iframe.style.top = '0px';\n        this._iframe.style.bottom = '0px';\n        this._iframe.style.left = '0px';\n        this._iframe.style.right = '0px';\n        this._iframe.style.width = '100%';\n        this._iframe.style.height = '100%';\n      }\n    };\n    this._resizeIframe = params => {\n      if (!this._iframe) {\n        return;\n      }\n      this._iframe.style.top = isFinite(params.top) ? `${params.top}px` : '';\n      this._iframe.style.bottom = isFinite(params.bottom) ? `${params.bottom}px` : '';\n      this._iframe.style.left = isFinite(params.left) ? `${params.left}px` : '';\n      this._iframe.style.right = isFinite(params.right) ? `${params.right}px` : '';\n      this._iframe.style.width = isFinite(params.width) ? `${params.width}px` : params.width;\n      this._iframe.style.height = isFinite(params.height) ? `${params.height}px` : params.height;\n    };\n    this._sendIframeMessage = data => {\n      if (!this.connected || !this.publicKey) {\n        throw new Error('Wallet not connected');\n      }\n      return new Promise((resolve, reject) => {\n        var _a, _b;\n        const messageId = uuidv4();\n        this._messageHandlers[messageId] = {\n          resolve,\n          reject\n        };\n        (_b = (_a = this._iframe) === null || _a === void 0 ? void 0 : _a.contentWindow) === null || _b === void 0 ? void 0 : _b.postMessage({\n          channel: 'solflareWalletAdapterToIframe',\n          data: Object.assign({\n            id: messageId\n          }, data)\n        }, '*');\n      });\n    };\n    this._connected = () => {\n      this._isConnected = true;\n      this.emit('connect', this.publicKey);\n      this._standardConnected();\n    };\n    this._disconnected = () => {\n      this._publicKey = null;\n      this._isConnected = false;\n      window.removeEventListener('message', this._handleMessage, false);\n      this._removeElement();\n      this.emit('disconnect');\n      this._standardDisconnected();\n    };\n    this._standardConnected = () => {\n      if (!this.publicKey) {\n        return;\n      }\n      const address = this.publicKey.toString();\n      if (!this._account || this._account.address !== address) {\n        this._account = new StandardSolflareMetaMaskWalletAccount({\n          address,\n          publicKey: this.publicKey.toBytes()\n        });\n        this.emit('standard_change', {\n          accounts: this.standardAccounts\n        });\n      }\n    };\n    this._standardDisconnected = () => {\n      if (this._account) {\n        this._account = null;\n        this.emit('standard_change', {\n          accounts: this.standardAccounts\n        });\n      }\n    };\n    if (config === null || config === void 0 ? void 0 : config.network) {\n      this._network = config === null || config === void 0 ? void 0 : config.network;\n    }\n    if (window.SolflareMetaMaskParams) {\n      this._iframeParams = Object.assign(Object.assign({}, this._iframeParams), window.SolflareMetaMaskParams);\n    }\n    if (config === null || config === void 0 ? void 0 : config.params) {\n      this._iframeParams = Object.assign(Object.assign({}, this._iframeParams), config === null || config === void 0 ? void 0 : config.params);\n    }\n  }\n  get publicKey() {\n    return this._publicKey ? new PublicKey(this._publicKey) : null;\n  }\n  get standardAccount() {\n    return this._account;\n  }\n  get standardAccounts() {\n    return this._account ? [this._account] : [];\n  }\n  get isConnected() {\n    return this._isConnected;\n  }\n  get connected() {\n    return this.isConnected;\n  }\n  get autoApprove() {\n    return false;\n  }\n  connect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.connected) {\n        return;\n      }\n      this._injectElement();\n      yield new Promise((resolve, reject) => {\n        this._connectHandler = {\n          resolve,\n          reject\n        };\n      });\n    });\n  }\n  disconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this._sendIframeMessage({\n        method: 'disconnect'\n      });\n      this._disconnected();\n    });\n  }\n  signTransaction(transaction) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.connected || !this.publicKey) {\n        throw new Error('Wallet not connected');\n      }\n      try {\n        const serializedTransaction = serializeTransaction(transaction);\n        const response = yield this._sendIframeMessage({\n          method: 'signTransactionV2',\n          params: {\n            transaction: bs58.encode(serializedTransaction)\n          }\n        });\n        const {\n          transaction: signedTransaction\n        } = response;\n        return isLegacyTransactionInstance(transaction) ? Transaction.from(bs58.decode(signedTransaction)) : VersionedTransaction.deserialize(bs58.decode(signedTransaction));\n      } catch (e) {\n        throw new Error(((_a = e === null || e === void 0 ? void 0 : e.toString) === null || _a === void 0 ? void 0 : _a.call(e)) || 'Failed to sign transaction');\n      }\n    });\n  }\n  signAllTransactions(transactions) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.connected || !this.publicKey) {\n        throw new Error('Wallet not connected');\n      }\n      try {\n        const serializedTransactions = transactions.map(transaction => serializeTransaction(transaction));\n        const {\n          transactions: signedTransactions\n        } = yield this._sendIframeMessage({\n          method: 'signAllTransactionsV2',\n          params: {\n            transactions: serializedTransactions.map(transaction => bs58.encode(transaction))\n          }\n        });\n        return signedTransactions.map((signedTransaction, index) => {\n          return isLegacyTransactionInstance(transactions[index]) ? Transaction.from(bs58.decode(signedTransaction)) : VersionedTransaction.deserialize(bs58.decode(signedTransaction));\n        });\n      } catch (e) {\n        throw new Error(((_a = e === null || e === void 0 ? void 0 : e.toString) === null || _a === void 0 ? void 0 : _a.call(e)) || 'Failed to sign transactions');\n      }\n    });\n  }\n  signAndSendTransaction(transaction, options) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.connected || !this.publicKey) {\n        throw new Error('Wallet not connected');\n      }\n      try {\n        const serializedTransaction = serializeTransaction(transaction);\n        const {\n          signature\n        } = yield this._sendIframeMessage({\n          method: 'signAndSendTransaction',\n          params: {\n            transaction: bs58.encode(serializedTransaction),\n            options\n          }\n        });\n        return signature;\n      } catch (e) {\n        throw new Error(((_a = e === null || e === void 0 ? void 0 : e.toString) === null || _a === void 0 ? void 0 : _a.call(e)) || 'Failed to sign and send transaction');\n      }\n    });\n  }\n  signMessage(data, display = 'utf8') {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.connected || !this.publicKey) {\n        throw new Error('Wallet not connected');\n      }\n      try {\n        const {\n          signature\n        } = yield this._sendIframeMessage({\n          method: 'signMessage',\n          params: {\n            data: bs58.encode(data),\n            display\n          }\n        });\n        return Uint8Array.from(bs58.decode(signature));\n      } catch (e) {\n        throw new Error(((_a = e === null || e === void 0 ? void 0 : e.toString) === null || _a === void 0 ? void 0 : _a.call(e)) || 'Failed to sign message');\n      }\n    });\n  }\n  sign(data, display = 'utf8') {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.signMessage(data, display);\n    });\n  }\n  static isSupported() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const provider = yield detectProvider();\n      return !!provider;\n    });\n  }\n  standardSignAndSendTransaction(...inputs) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.connected) throw new Error('not connected');\n      const outputs = [];\n      if (inputs.length === 1) {\n        const {\n          transaction,\n          account,\n          chain,\n          options\n        } = inputs[0];\n        const {\n          minContextSlot,\n          preflightCommitment,\n          skipPreflight,\n          maxRetries\n        } = options || {};\n        if (account !== this._account) throw new Error('invalid account');\n        if (!isSolanaChain(chain)) throw new Error('invalid chain');\n        const signature = yield this.signAndSendTransaction(VersionedTransaction.deserialize(transaction), {\n          preflightCommitment,\n          minContextSlot,\n          maxRetries,\n          skipPreflight\n        });\n        outputs.push({\n          signature: bs58.decode(signature)\n        });\n      } else if (inputs.length > 1) {\n        for (const input of inputs) {\n          outputs.push(...(yield this.standardSignAndSendTransaction(input)));\n        }\n      }\n      return outputs;\n    });\n  }\n  standardSignTransaction(...inputs) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.connected) throw new Error('not connected');\n      const outputs = [];\n      if (inputs.length === 1) {\n        const {\n          transaction,\n          account,\n          chain\n        } = inputs[0];\n        if (account !== this._account) throw new Error('invalid account');\n        if (chain && !isSolanaChain(chain)) throw new Error('invalid chain');\n        const signedTransaction = yield this.signTransaction(VersionedTransaction.deserialize(transaction));\n        outputs.push({\n          signedTransaction: signedTransaction.serialize()\n        });\n      } else if (inputs.length > 1) {\n        let chain;\n        for (const input of inputs) {\n          if (input.account !== this._account) throw new Error('invalid account');\n          if (input.chain) {\n            if (!isSolanaChain(input.chain)) throw new Error('invalid chain');\n            if (chain) {\n              if (input.chain !== chain) throw new Error('conflicting chain');\n            } else {\n              chain = input.chain;\n            }\n          }\n        }\n        const transactions = inputs.map(({\n          transaction\n        }) => VersionedTransaction.deserialize(transaction));\n        const signedTransactions = yield this.signAllTransactions(transactions);\n        outputs.push(...signedTransactions.map(signedTransaction => ({\n          signedTransaction: signedTransaction.serialize()\n        })));\n      }\n      return outputs;\n    });\n  }\n  standardSignMessage(...inputs) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.connected) throw new Error('not connected');\n      const outputs = [];\n      if (inputs.length === 1) {\n        const {\n          message,\n          account\n        } = inputs[0];\n        if (account !== this._account) throw new Error('invalid account');\n        const signature = yield this.signMessage(message);\n        outputs.push({\n          signedMessage: message,\n          signature\n        });\n      } else if (inputs.length > 1) {\n        for (const input of inputs) {\n          outputs.push(...(yield this.standardSignMessage(input)));\n        }\n      }\n      return outputs;\n    });\n  }\n}\nSolflareMetaMask.IFRAME_URL = 'https://widget.solflare.com/';\nexport default SolflareMetaMask;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}