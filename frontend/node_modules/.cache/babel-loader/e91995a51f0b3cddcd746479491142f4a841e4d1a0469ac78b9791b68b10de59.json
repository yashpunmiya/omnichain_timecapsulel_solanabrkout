{"ast":null,"code":"import UniversalProvider from '@walletconnect/universal-provider';\nimport { ConstantsUtil, NetworkUtil, ParseUtil } from '@reown/appkit-common';\nimport { AccountController, AlertController, AssetUtil, BlockchainApiController, ChainController, ConnectionController, ConnectorController, CoreHelperUtil, EnsController, EventsController, ModalController, OptionsController, PublicStateController, RouterController, SnackController, StorageUtil, ThemeController } from '@reown/appkit-controllers';\nimport { WalletUtil } from '@reown/appkit-scaffold-ui/utils';\nimport { setColorTheme, setThemeVariables } from '@reown/appkit-ui';\nimport { CaipNetworksUtil, ErrorUtil, HelpersUtil, LoggerUtil, ConstantsUtil as UtilConstantsUtil } from '@reown/appkit-utils';\nimport { ProviderUtil } from '@reown/appkit-utils';\nimport { UniversalAdapter } from '../universal-adapter/client.js';\nimport { WcHelpersUtil } from '../utils/index.js';\nexport class AppKitBaseClient {\n  constructor(options) {\n    this.hasSwitchedToPreferredAccountTypeOnConnect = false;\n    this.chainNamespaces = [];\n    this.reportedAlertErrors = {};\n    // -- Public Internal ---------------------------------------------------\n    this.getCaipNetwork = chainNamespace => {\n      if (chainNamespace) {\n        const namespaceCaipNetwork = ChainController.getNetworkData(chainNamespace)?.caipNetwork;\n        if (namespaceCaipNetwork) {\n          return namespaceCaipNetwork;\n        }\n        return ChainController.getRequestedCaipNetworks(chainNamespace).filter(c => c.chainNamespace === chainNamespace)?.[0];\n      }\n      return ChainController.state.activeCaipNetwork || this.defaultCaipNetwork;\n    };\n    this.getCaipNetworkId = () => {\n      const network = this.getCaipNetwork();\n      if (network) {\n        return network.id;\n      }\n      return undefined;\n    };\n    this.getCaipNetworks = namespace => ChainController.getRequestedCaipNetworks(namespace);\n    this.getActiveChainNamespace = () => ChainController.state.activeChain;\n    this.setRequestedCaipNetworks = (requestedCaipNetworks, chain) => {\n      ChainController.setRequestedCaipNetworks(requestedCaipNetworks, chain);\n    };\n    this.getApprovedCaipNetworkIds = () => ChainController.getAllApprovedCaipNetworkIds();\n    this.getCaipAddress = chainNamespace => {\n      if (ChainController.state.activeChain === chainNamespace || !chainNamespace) {\n        return ChainController.state.activeCaipAddress;\n      }\n      return ChainController.getAccountProp('caipAddress', chainNamespace);\n    };\n    this.setClientId = clientId => {\n      BlockchainApiController.setClientId(clientId);\n    };\n    this.getProvider = namespace => ProviderUtil.getProvider(namespace);\n    this.getProviderType = namespace => ProviderUtil.getProviderId(namespace);\n    this.getPreferredAccountType = () => AccountController.state.preferredAccountType;\n    this.setCaipAddress = (caipAddress, chain) => {\n      AccountController.setCaipAddress(caipAddress, chain);\n    };\n    this.setBalance = (balance, balanceSymbol, chain) => {\n      AccountController.setBalance(balance, balanceSymbol, chain);\n    };\n    this.setProfileName = (profileName, chain) => {\n      AccountController.setProfileName(profileName, chain);\n    };\n    this.setProfileImage = (profileImage, chain) => {\n      AccountController.setProfileImage(profileImage, chain);\n    };\n    this.setUser = (user, chain) => {\n      AccountController.setUser(user, chain);\n      if (OptionsController.state.enableEmbedded) {\n        ModalController.close();\n      }\n    };\n    this.resetAccount = chain => {\n      AccountController.resetAccount(chain);\n    };\n    this.setCaipNetwork = caipNetwork => {\n      ChainController.setActiveCaipNetwork(caipNetwork);\n    };\n    this.setCaipNetworkOfNamespace = (caipNetwork, chainNamespace) => {\n      ChainController.setChainNetworkData(chainNamespace, {\n        caipNetwork\n      });\n    };\n    this.setAllAccounts = (addresses, chain) => {\n      AccountController.setAllAccounts(addresses, chain);\n      OptionsController.setHasMultipleAddresses(addresses?.length > 1);\n    };\n    this.setStatus = (status, chain) => {\n      AccountController.setStatus(status, chain);\n      // If at least one namespace is connected, set the connection status\n      if (ConnectorController.isConnected()) {\n        StorageUtil.setConnectionStatus('connected');\n      } else {\n        StorageUtil.setConnectionStatus('disconnected');\n      }\n    };\n    this.getAddressByChainNamespace = chainNamespace => ChainController.getAccountProp('address', chainNamespace);\n    this.setConnectors = connectors => {\n      const allConnectors = [...ConnectorController.getConnectors(), ...connectors];\n      ConnectorController.setConnectors(allConnectors);\n    };\n    this.fetchIdentity = request => BlockchainApiController.fetchIdentity(request);\n    this.getReownName = address => EnsController.getNamesForAddress(address);\n    this.getConnectors = () => ConnectorController.getConnectors();\n    this.getConnectorImage = connector => AssetUtil.getConnectorImage(connector);\n    this.setConnectedWalletInfo = (connectedWalletInfo, chain) => {\n      const type = ProviderUtil.getProviderId(chain);\n      const walletInfo = connectedWalletInfo ? {\n        ...connectedWalletInfo,\n        type\n      } : undefined;\n      AccountController.setConnectedWalletInfo(walletInfo, chain);\n    };\n    this.getIsConnectedState = () => Boolean(ChainController.state.activeCaipAddress);\n    this.addAddressLabel = (address, label, chain) => {\n      AccountController.addAddressLabel(address, label, chain);\n    };\n    this.removeAddressLabel = (address, chain) => {\n      AccountController.removeAddressLabel(address, chain);\n    };\n    this.getAddress = chainNamespace => {\n      if (ChainController.state.activeChain === chainNamespace || !chainNamespace) {\n        return AccountController.state.address;\n      }\n      return ChainController.getAccountProp('address', chainNamespace);\n    };\n    this.setApprovedCaipNetworksData = namespace => ChainController.setApprovedCaipNetworksData(namespace);\n    this.resetNetwork = namespace => {\n      ChainController.resetNetwork(namespace);\n    };\n    this.addConnector = connector => {\n      ConnectorController.addConnector(connector);\n    };\n    this.resetWcConnection = () => {\n      ConnectionController.resetWcConnection();\n    };\n    this.setAddressExplorerUrl = (addressExplorerUrl, chain) => {\n      AccountController.setAddressExplorerUrl(addressExplorerUrl, chain);\n    };\n    this.setSmartAccountDeployed = (isDeployed, chain) => {\n      AccountController.setSmartAccountDeployed(isDeployed, chain);\n    };\n    this.setSmartAccountEnabledNetworks = (smartAccountEnabledNetworks, chain) => {\n      ChainController.setSmartAccountEnabledNetworks(smartAccountEnabledNetworks, chain);\n    };\n    this.setPreferredAccountType = (preferredAccountType, chain) => {\n      AccountController.setPreferredAccountType(preferredAccountType, chain);\n    };\n    this.setEIP6963Enabled = enabled => {\n      OptionsController.setEIP6963Enabled(enabled);\n    };\n    this.handleUnsafeRPCRequest = () => {\n      if (this.isOpen()) {\n        // If we are on the modal but there is no transaction stack, close the modal\n        if (this.isTransactionStackEmpty()) {\n          return;\n        }\n        // Check if we need to replace or redirect\n        this.redirect('ApproveTransaction');\n      } else {\n        // If called from outside the modal, open ApproveTransaction\n        this.open({\n          view: 'ApproveTransaction'\n        });\n      }\n    };\n    this.options = options;\n    this.version = options.sdkVersion;\n    this.caipNetworks = this.extendCaipNetworks(options);\n    this.chainNamespaces = [...new Set(this.caipNetworks?.map(caipNetwork => caipNetwork.chainNamespace))];\n    this.defaultCaipNetwork = this.extendDefaultCaipNetwork(options);\n    this.chainAdapters = this.createAdapters(options.adapters);\n    this.initialize(options);\n    this.sendInitializeEvent(options);\n  }\n  async initialize(options) {\n    this.initControllers(options);\n    await this.initChainAdapters();\n    await this.injectModalUi();\n    await this.syncExistingConnection();\n    PublicStateController.set({\n      initialized: true\n    });\n  }\n  sendInitializeEvent(options) {\n    const {\n      ...optionsCopy\n    } = options;\n    delete optionsCopy.adapters;\n    EventsController.sendEvent({\n      type: 'track',\n      event: 'INITIALIZE',\n      properties: {\n        ...optionsCopy,\n        networks: options.networks.map(n => n.id),\n        siweConfig: {\n          options: options.siweConfig?.options || {}\n        }\n      }\n    });\n  }\n  // -- Controllers initialization ---------------------------------------------------\n  initControllers(options) {\n    this.initializeOptionsController(options);\n    this.initializeChainController(options);\n    this.initializeThemeController(options);\n    this.initializeConnectionController(options);\n    this.initializeConnectorController();\n  }\n  initializeThemeController(options) {\n    if (options.themeMode) {\n      ThemeController.setThemeMode(options.themeMode);\n    }\n    if (options.themeVariables) {\n      ThemeController.setThemeVariables(options.themeVariables);\n    }\n  }\n  initializeChainController(options) {\n    if (!this.connectionControllerClient || !this.networkControllerClient) {\n      throw new Error('ConnectionControllerClient and NetworkControllerClient must be set');\n    }\n    ChainController.initialize(options.adapters ?? [], this.caipNetworks, {\n      connectionControllerClient: this.connectionControllerClient,\n      networkControllerClient: this.networkControllerClient\n    });\n    const network = this.getDefaultNetwork();\n    if (network) {\n      ChainController.setActiveCaipNetwork(network);\n    }\n  }\n  initializeConnectionController(options) {\n    ConnectionController.setWcBasic(options.basic ?? false);\n  }\n  initializeConnectorController() {\n    ConnectorController.initialize(this.chainNamespaces);\n  }\n  initializeOptionsController(options) {\n    OptionsController.setDebug(options.debug !== false);\n    // On by default\n    OptionsController.setEnableWalletConnect(options.enableWalletConnect !== false);\n    OptionsController.setEnableWalletGuide(options.enableWalletGuide !== false);\n    OptionsController.setEnableWallets(options.enableWallets !== false);\n    OptionsController.setEIP6963Enabled(options.enableEIP6963 !== false);\n    OptionsController.setEnableNetworkSwitch(options.enableNetworkSwitch !== false);\n    OptionsController.setEnableAuthLogger(options.enableAuthLogger !== false);\n    OptionsController.setCustomRpcUrls(options.customRpcUrls);\n    OptionsController.setSdkVersion(options.sdkVersion);\n    OptionsController.setProjectId(options.projectId);\n    OptionsController.setEnableEmbedded(options.enableEmbedded);\n    OptionsController.setAllWallets(options.allWallets);\n    OptionsController.setIncludeWalletIds(options.includeWalletIds);\n    OptionsController.setExcludeWalletIds(options.excludeWalletIds);\n    OptionsController.setFeaturedWalletIds(options.featuredWalletIds);\n    OptionsController.setTokens(options.tokens);\n    OptionsController.setTermsConditionsUrl(options.termsConditionsUrl);\n    OptionsController.setPrivacyPolicyUrl(options.privacyPolicyUrl);\n    OptionsController.setCustomWallets(options.customWallets);\n    OptionsController.setFeatures(options.features);\n    OptionsController.setAllowUnsupportedChain(options.allowUnsupportedChain);\n    OptionsController.setDefaultAccountTypes(options.defaultAccountTypes);\n    OptionsController.setUniversalProviderConfigOverride(options.universalProviderConfigOverride);\n    const defaultMetaData = this.getDefaultMetaData();\n    if (!options.metadata && defaultMetaData) {\n      options.metadata = defaultMetaData;\n    }\n    OptionsController.setMetadata(options.metadata);\n    OptionsController.setDisableAppend(options.disableAppend);\n    OptionsController.setEnableEmbedded(options.enableEmbedded);\n    OptionsController.setSIWX(options.siwx);\n    if (!options.projectId) {\n      AlertController.open(ErrorUtil.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, 'error');\n      return;\n    }\n    const evmAdapter = options.adapters?.find(adapter => adapter.namespace === ConstantsUtil.CHAIN.EVM);\n    // Set the SIWE client for EVM chains\n    if (evmAdapter) {\n      if (options.siweConfig) {\n        if (options.siwx) {\n          throw new Error('Cannot set both `siweConfig` and `siwx` options');\n        }\n        OptionsController.setSIWX(options.siweConfig.mapToSIWX());\n      }\n    }\n  }\n  getDefaultMetaData() {\n    if (typeof window !== 'undefined' && typeof document !== 'undefined') {\n      return {\n        name: document.getElementsByTagName('title')?.[0]?.textContent || '',\n        description: document.querySelector('meta[property=\"og:description\"]')?.content || '',\n        url: window.location.origin,\n        icons: [document.querySelector('link[rel~=\"icon\"]')?.href || '']\n      };\n    }\n    return null;\n  }\n  // -- Network Initialization ---------------------------------------------------\n  setUnsupportedNetwork(chainId) {\n    const namespace = this.getActiveChainNamespace();\n    if (namespace) {\n      const unsupportedNetwork = CaipNetworksUtil.getUnsupportedNetwork(`${namespace}:${chainId}`);\n      ChainController.setActiveCaipNetwork(unsupportedNetwork);\n    }\n  }\n  getDefaultNetwork() {\n    return CaipNetworksUtil.getCaipNetworkFromStorage(this.defaultCaipNetwork);\n  }\n  extendCaipNetwork(network, options) {\n    const extendedNetwork = CaipNetworksUtil.extendCaipNetwork(network, {\n      customNetworkImageUrls: options.chainImages,\n      projectId: options.projectId\n    });\n    return extendedNetwork;\n  }\n  extendCaipNetworks(options) {\n    const extendedNetworks = CaipNetworksUtil.extendCaipNetworks(options.networks, {\n      customNetworkImageUrls: options.chainImages,\n      customRpcUrls: options.customRpcUrls,\n      projectId: options.projectId\n    });\n    return extendedNetworks;\n  }\n  extendDefaultCaipNetwork(options) {\n    const defaultNetwork = options.networks.find(n => n.id === options.defaultNetwork?.id);\n    const extendedNetwork = defaultNetwork ? CaipNetworksUtil.extendCaipNetwork(defaultNetwork, {\n      customNetworkImageUrls: options.chainImages,\n      customRpcUrls: options.customRpcUrls,\n      projectId: options.projectId\n    }) : undefined;\n    return extendedNetwork;\n  }\n  // -- Client Initialization ---------------------------------------------------\n  createClients() {\n    this.connectionControllerClient = {\n      connectWalletConnect: async () => {\n        const activeChain = ChainController.state.activeChain;\n        const adapter = this.getAdapter(activeChain);\n        const chainId = this.getCaipNetwork(activeChain)?.id;\n        if (!adapter) {\n          throw new Error('Adapter not found');\n        }\n        const result = await adapter.connectWalletConnect(chainId);\n        this.close();\n        this.setClientId(result?.clientId || null);\n        StorageUtil.setConnectedNamespaces([...ChainController.state.chains.keys()]);\n        this.chainNamespaces.forEach(namespace => {\n          ConnectorController.setConnectorId(UtilConstantsUtil.CONNECTOR_TYPE_WALLET_CONNECT, namespace);\n        });\n        await this.syncWalletConnectAccount();\n      },\n      connectExternal: async ({\n        id,\n        info,\n        type,\n        provider,\n        chain,\n        caipNetwork\n      }) => {\n        const activeChain = ChainController.state.activeChain;\n        const chainToUse = chain || activeChain;\n        const adapter = this.getAdapter(chainToUse);\n        if (chain && chain !== activeChain && !caipNetwork) {\n          const toConnectNetwork = this.caipNetworks?.find(network => network.chainNamespace === chain);\n          if (toConnectNetwork) {\n            this.setCaipNetwork(toConnectNetwork);\n          }\n        }\n        if (!adapter) {\n          throw new Error('Adapter not found');\n        }\n        const fallbackCaipNetwork = this.getCaipNetwork(chainToUse);\n        const res = await adapter.connect({\n          id,\n          info,\n          type,\n          provider,\n          chainId: caipNetwork?.id || fallbackCaipNetwork?.id,\n          rpcUrl: caipNetwork?.rpcUrls?.default?.http?.[0] || fallbackCaipNetwork?.rpcUrls?.default?.http?.[0]\n        });\n        if (!res) {\n          return;\n        }\n        StorageUtil.addConnectedNamespace(chainToUse);\n        this.syncProvider({\n          ...res,\n          chainNamespace: chainToUse\n        });\n        await this.syncAccount({\n          ...res,\n          chainNamespace: chainToUse\n        });\n        const {\n          accounts\n        } = await adapter.getAccounts({\n          namespace: chainToUse,\n          id\n        });\n        this.setAllAccounts(accounts, chainToUse);\n      },\n      reconnectExternal: async ({\n        id,\n        info,\n        type,\n        provider\n      }) => {\n        const namespace = ChainController.state.activeChain;\n        const adapter = this.getAdapter(namespace);\n        if (adapter?.reconnect) {\n          await adapter?.reconnect({\n            id,\n            info,\n            type,\n            provider,\n            chainId: this.getCaipNetwork()?.id\n          });\n          StorageUtil.addConnectedNamespace(namespace);\n        }\n      },\n      disconnect: async chainNamespace => {\n        const namespace = chainNamespace || ChainController.state.activeChain;\n        const adapter = this.getAdapter(namespace);\n        const provider = ProviderUtil.getProvider(namespace);\n        const providerType = ProviderUtil.getProviderId(namespace);\n        await adapter?.disconnect({\n          provider,\n          providerType\n        });\n        StorageUtil.removeConnectedNamespace(namespace);\n        ProviderUtil.resetChain(namespace);\n        this.setUser(undefined, namespace);\n        this.setStatus('disconnected', namespace);\n        this.hasSwitchedToPreferredAccountTypeOnConnect = false;\n      },\n      checkInstalled: ids => {\n        if (!ids) {\n          return Boolean(window.ethereum);\n        }\n        return ids.some(id => Boolean(window.ethereum?.[String(id)]));\n      },\n      signMessage: async message => {\n        const adapter = this.getAdapter(ChainController.state.activeChain);\n        const result = await adapter?.signMessage({\n          message,\n          address: AccountController.state.address,\n          provider: ProviderUtil.getProvider(ChainController.state.activeChain)\n        });\n        return result?.signature || '';\n      },\n      sendTransaction: async args => {\n        if (args.chainNamespace === ConstantsUtil.CHAIN.EVM) {\n          const adapter = this.getAdapter(ChainController.state.activeChain);\n          const provider = ProviderUtil.getProvider(ChainController.state.activeChain);\n          const result = await adapter?.sendTransaction({\n            ...args,\n            caipNetwork: this.getCaipNetwork(),\n            provider\n          });\n          return result?.hash || '';\n        }\n        return '';\n      },\n      estimateGas: async args => {\n        if (args.chainNamespace === ConstantsUtil.CHAIN.EVM) {\n          const adapter = this.getAdapter(ChainController.state.activeChain);\n          const provider = ProviderUtil.getProvider(ChainController.state.activeChain);\n          const caipNetwork = this.getCaipNetwork();\n          if (!caipNetwork) {\n            throw new Error('CaipNetwork is undefined');\n          }\n          const result = await adapter?.estimateGas({\n            ...args,\n            provider,\n            caipNetwork\n          });\n          return result?.gas || 0n;\n        }\n        return 0n;\n      },\n      getEnsAvatar: async () => {\n        const adapter = this.getAdapter(ChainController.state.activeChain);\n        const result = await adapter?.getProfile({\n          address: AccountController.state.address,\n          chainId: Number(this.getCaipNetwork()?.id)\n        });\n        return result?.profileImage || false;\n      },\n      getEnsAddress: async name => {\n        const adapter = this.getAdapter(ChainController.state.activeChain);\n        const caipNetwork = this.getCaipNetwork();\n        if (!caipNetwork) {\n          return false;\n        }\n        const result = await adapter?.getEnsAddress({\n          name,\n          caipNetwork\n        });\n        return result?.address || false;\n      },\n      writeContract: async args => {\n        const adapter = this.getAdapter(ChainController.state.activeChain);\n        const caipNetwork = this.getCaipNetwork();\n        const caipAddress = this.getCaipAddress();\n        const provider = ProviderUtil.getProvider(ChainController.state.activeChain);\n        if (!caipNetwork || !caipAddress) {\n          throw new Error('CaipNetwork or CaipAddress is undefined');\n        }\n        const result = await adapter?.writeContract({\n          ...args,\n          caipNetwork,\n          provider,\n          caipAddress\n        });\n        return result?.hash;\n      },\n      parseUnits: (value, decimals) => {\n        const adapter = this.getAdapter(ChainController.state.activeChain);\n        return adapter?.parseUnits({\n          value,\n          decimals\n        }) ?? 0n;\n      },\n      formatUnits: (value, decimals) => {\n        const adapter = this.getAdapter(ChainController.state.activeChain);\n        return adapter?.formatUnits({\n          value,\n          decimals\n        }) ?? '0';\n      },\n      getCapabilities: async params => {\n        const adapter = this.getAdapter(ChainController.state.activeChain);\n        return await adapter?.getCapabilities(params);\n      },\n      grantPermissions: async params => {\n        const adapter = this.getAdapter(ChainController.state.activeChain);\n        return await adapter?.grantPermissions(params);\n      },\n      revokePermissions: async params => {\n        const adapter = this.getAdapter(ChainController.state.activeChain);\n        if (adapter?.revokePermissions) {\n          return await adapter.revokePermissions(params);\n        }\n        return '0x';\n      },\n      walletGetAssets: async params => {\n        const adapter = this.getAdapter(ChainController.state.activeChain);\n        return (await adapter?.walletGetAssets(params)) ?? {};\n      }\n    };\n    this.networkControllerClient = {\n      switchCaipNetwork: async caipNetwork => await this.switchCaipNetwork(caipNetwork),\n      // eslint-disable-next-line @typescript-eslint/require-await\n      getApprovedCaipNetworksData: async () => this.getApprovedCaipNetworksData()\n    };\n    ConnectionController.setClient(this.connectionControllerClient);\n  }\n  getApprovedCaipNetworksData() {\n    const providerType = ProviderUtil.getProviderId(ChainController.state.activeChain);\n    if (providerType === UtilConstantsUtil.CONNECTOR_TYPE_WALLET_CONNECT) {\n      const namespaces = this.universalProvider?.session?.namespaces;\n      return {\n        /*\n         * MetaMask Wallet only returns 1 namespace in the session object. This makes it imposible\n         * to switch to other networks. Setting supportsAllNetworks to true for MetaMask Wallet\n         * will make it possible to switch to other networks.\n         */\n        supportsAllNetworks: this.universalProvider?.session?.peer?.metadata.name === 'MetaMask Wallet',\n        approvedCaipNetworkIds: this.getChainsFromNamespaces(namespaces)\n      };\n    }\n    return {\n      supportsAllNetworks: true,\n      approvedCaipNetworkIds: []\n    };\n  }\n  async switchCaipNetwork(caipNetwork) {\n    if (!caipNetwork) {\n      return;\n    }\n    const networkNamespace = caipNetwork.chainNamespace;\n    const namespaceAddress = this.getAddressByChainNamespace(caipNetwork.chainNamespace);\n    if (namespaceAddress) {\n      const provider = ProviderUtil.getProvider(networkNamespace);\n      const providerType = ProviderUtil.getProviderId(networkNamespace);\n      if (caipNetwork.chainNamespace === ChainController.state.activeChain) {\n        const adapter = this.getAdapter(networkNamespace);\n        await adapter?.switchNetwork({\n          caipNetwork,\n          provider,\n          providerType\n        });\n      } else {\n        this.setCaipNetwork(caipNetwork);\n        if (providerType === UtilConstantsUtil.CONNECTOR_TYPE_WALLET_CONNECT) {\n          this.syncWalletConnectAccount();\n        } else {\n          const address = this.getAddressByChainNamespace(networkNamespace);\n          if (address) {\n            this.syncAccount({\n              address,\n              chainId: caipNetwork.id,\n              chainNamespace: networkNamespace\n            });\n          }\n        }\n      }\n    } else {\n      this.setCaipNetwork(caipNetwork);\n    }\n  }\n  getChainsFromNamespaces(namespaces = {}) {\n    return Object.values(namespaces).flatMap(namespace => {\n      const chains = namespace.chains || [];\n      const accountsChains = namespace.accounts.map(account => {\n        const {\n          chainId,\n          chainNamespace\n        } = ParseUtil.parseCaipAddress(account);\n        return `${chainNamespace}:${chainId}`;\n      });\n      return Array.from(new Set([...chains, ...accountsChains]));\n    });\n  }\n  // -- Adapter Initialization ---------------------------------------------------\n  createAdapters(blueprints) {\n    this.createClients();\n    return this.chainNamespaces.reduce((adapters, namespace) => {\n      const blueprint = blueprints?.find(b => b.namespace === namespace);\n      if (blueprint) {\n        adapters[namespace] = blueprint;\n        adapters[namespace].namespace = namespace;\n        adapters[namespace].construct({\n          namespace,\n          projectId: this.options?.projectId,\n          networks: this.caipNetworks\n        });\n      } else {\n        adapters[namespace] = new UniversalAdapter({\n          namespace,\n          networks: this.caipNetworks\n        });\n      }\n      return adapters;\n      // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter\n    }, {});\n  }\n  async initChainAdapter(namespace) {\n    this.onConnectors(namespace);\n    this.listenAdapter(namespace);\n    this.chainAdapters?.[namespace].syncConnectors(this.options, this);\n    await this.createUniversalProviderForAdapter(namespace);\n  }\n  async initChainAdapters() {\n    await Promise.all(this.chainNamespaces.map(async namespace => {\n      await this.initChainAdapter(namespace);\n    }));\n  }\n  onConnectors(chainNamespace) {\n    const adapter = this.getAdapter(chainNamespace);\n    adapter?.on('connectors', this.setConnectors.bind(this));\n  }\n  listenAdapter(chainNamespace) {\n    const adapter = this.getAdapter(chainNamespace);\n    if (!adapter) {\n      return;\n    }\n    const connectionStatus = StorageUtil.getConnectionStatus();\n    if (connectionStatus === 'connected') {\n      this.setStatus('connecting', chainNamespace);\n    } else if (connectionStatus === 'disconnected') {\n      /*\n       * Address cache is kept after disconnecting from the wallet\n       * but should be cleared if appkit is launched in disconnected state\n       */\n      StorageUtil.clearAddressCache();\n      this.setStatus(connectionStatus, chainNamespace);\n    } else {\n      this.setStatus(connectionStatus, chainNamespace);\n    }\n    adapter.on('switchNetwork', ({\n      address,\n      chainId\n    }) => {\n      const caipNetwork = this.caipNetworks?.find(n => n.id === chainId || n.caipNetworkId === chainId);\n      const isSameNamespace = ChainController.state.activeChain === chainNamespace;\n      const accountAddress = ChainController.getAccountProp('address', chainNamespace);\n      if (caipNetwork) {\n        const account = isSameNamespace && address ? address : accountAddress;\n        if (account) {\n          this.syncAccount({\n            address: account,\n            chainId,\n            chainNamespace\n          });\n        }\n      } else {\n        this.setUnsupportedNetwork(chainId);\n      }\n    });\n    adapter.on('disconnect', this.disconnect.bind(this, chainNamespace));\n    adapter.on('pendingTransactions', () => {\n      const address = AccountController.state.address;\n      const activeCaipNetwork = ChainController.state.activeCaipNetwork;\n      if (!address || !activeCaipNetwork?.id) {\n        return;\n      }\n      this.updateNativeBalance(address, activeCaipNetwork.id, activeCaipNetwork.chainNamespace);\n    });\n    adapter.on('accountChanged', ({\n      address,\n      chainId\n    }) => {\n      const isActiveChain = ChainController.state.activeChain === chainNamespace;\n      if (isActiveChain && chainId) {\n        this.syncAccount({\n          address,\n          chainId,\n          chainNamespace\n        });\n      } else if (isActiveChain && ChainController.state.activeCaipNetwork?.id) {\n        this.syncAccount({\n          address,\n          chainId: ChainController.state.activeCaipNetwork?.id,\n          chainNamespace\n        });\n      } else {\n        this.syncAccountInfo(address, chainId, chainNamespace);\n      }\n    });\n  }\n  async createUniversalProviderForAdapter(chainNamespace) {\n    await this.getUniversalProvider();\n    if (this.universalProvider) {\n      this.chainAdapters?.[chainNamespace]?.setUniversalProvider?.(this.universalProvider);\n    }\n  }\n  // -- Connection Sync ---------------------------------------------------\n  async syncExistingConnection() {\n    await Promise.allSettled(this.chainNamespaces.map(namespace => this.syncNamespaceConnection(namespace)));\n  }\n  async syncNamespaceConnection(namespace) {\n    try {\n      const connectorId = ConnectorController.getConnectorId(namespace);\n      this.setStatus('connecting', namespace);\n      switch (connectorId) {\n        case ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT:\n          await this.syncWalletConnectAccount();\n          break;\n        case ConstantsUtil.CONNECTOR_ID.AUTH:\n          // Handled during initialization of adapters' auth provider\n          break;\n        default:\n          await this.syncAdapterConnection(namespace);\n      }\n    } catch (err) {\n      console.warn(\"AppKit couldn't sync existing connection\", err);\n      this.setStatus('disconnected', namespace);\n    }\n  }\n  async syncAdapterConnection(namespace) {\n    const adapter = this.getAdapter(namespace);\n    const connectorId = ConnectorController.getConnectorId(namespace);\n    const caipNetwork = this.getCaipNetwork(namespace);\n    const connector = ConnectorController.getConnectors(namespace).find(c => c.id === connectorId);\n    try {\n      if (!adapter || !connector) {\n        throw new Error(`Adapter or connector not found for namespace ${namespace}`);\n      }\n      if (!caipNetwork?.id) {\n        throw new Error('CaipNetwork not found');\n      }\n      const connection = await adapter?.syncConnection({\n        namespace,\n        id: connector.id,\n        chainId: caipNetwork.id,\n        rpcUrl: caipNetwork?.rpcUrls?.default?.http?.[0]\n      });\n      if (connection) {\n        const accounts = await adapter?.getAccounts({\n          namespace,\n          id: connector.id\n        });\n        if (accounts && accounts.accounts.length > 0) {\n          this.setAllAccounts(accounts.accounts, namespace);\n        } else {\n          this.setAllAccounts([CoreHelperUtil.createAccount(namespace, connection.address, 'eoa')], namespace);\n        }\n        this.syncProvider({\n          ...connection,\n          chainNamespace: namespace\n        });\n        await this.syncAccount({\n          ...connection,\n          chainNamespace: namespace\n        });\n        this.setStatus('connected', namespace);\n      } else {\n        this.setStatus('disconnected', namespace);\n      }\n    } catch (e) {\n      this.setStatus('disconnected', namespace);\n    }\n  }\n  async syncWalletConnectAccount() {\n    const syncTasks = this.chainNamespaces.map(async chainNamespace => {\n      const adapter = this.getAdapter(chainNamespace);\n      const namespaceAccounts = this.universalProvider?.session?.namespaces?.[chainNamespace]?.accounts || [];\n      // We try and find the address for this network in the session object.\n      const activeChainId = ChainController.state.activeCaipNetwork?.id;\n      const sessionAddress = namespaceAccounts.find(account => {\n        const {\n          chainId\n        } = ParseUtil.parseCaipAddress(account);\n        return chainId === activeChainId?.toString();\n      }) || namespaceAccounts[0];\n      if (sessionAddress) {\n        const caipAddress = ParseUtil.validateCaipAddress(sessionAddress);\n        const {\n          chainId,\n          address\n        } = ParseUtil.parseCaipAddress(caipAddress);\n        ProviderUtil.setProviderId(chainNamespace, UtilConstantsUtil.CONNECTOR_TYPE_WALLET_CONNECT);\n        if (this.caipNetworks && ChainController.state.activeCaipNetwork && adapter?.namespace !== ConstantsUtil.CHAIN.EVM) {\n          const provider = adapter?.getWalletConnectProvider({\n            caipNetworks: this.caipNetworks,\n            provider: this.universalProvider,\n            activeCaipNetwork: ChainController.state.activeCaipNetwork\n          });\n          ProviderUtil.setProvider(chainNamespace, provider);\n        } else {\n          ProviderUtil.setProvider(chainNamespace, this.universalProvider);\n        }\n        ConnectorController.setConnectorId(ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT, chainNamespace);\n        StorageUtil.addConnectedNamespace(chainNamespace);\n        this.syncWalletConnectAccounts(chainNamespace);\n        await this.syncAccount({\n          address,\n          chainId,\n          chainNamespace\n        });\n      } else {\n        this.setStatus('disconnected', chainNamespace);\n      }\n      await ChainController.setApprovedCaipNetworksData(chainNamespace);\n    });\n    await Promise.all(syncTasks);\n  }\n  syncWalletConnectAccounts(chainNamespace) {\n    const addresses = this.universalProvider?.session?.namespaces?.[chainNamespace]?.accounts?.map(account => {\n      const {\n        address\n      } = ParseUtil.parseCaipAddress(account);\n      return address;\n    }).filter((address, index, self) => self.indexOf(address) === index);\n    if (addresses) {\n      this.setAllAccounts(addresses.map(address => CoreHelperUtil.createAccount(chainNamespace, address, chainNamespace === 'bip122' ? 'payment' : 'eoa')), chainNamespace);\n    }\n  }\n  syncProvider({\n    type,\n    provider,\n    id,\n    chainNamespace\n  }) {\n    ProviderUtil.setProviderId(chainNamespace, type);\n    ProviderUtil.setProvider(chainNamespace, provider);\n    ConnectorController.setConnectorId(id, chainNamespace);\n  }\n  async syncAccount(params) {\n    const isActiveNamespace = params.chainNamespace === ChainController.state.activeChain;\n    const networkOfChain = ChainController.getCaipNetworkByNamespace(params.chainNamespace, params.chainId);\n    const {\n      address,\n      chainId,\n      chainNamespace\n    } = params;\n    const {\n      chainId: activeChainId\n    } = StorageUtil.getActiveNetworkProps();\n    const chainIdToUse = chainId || activeChainId;\n    const isUnsupportedNetwork = ChainController.state.activeCaipNetwork?.name === ConstantsUtil.UNSUPPORTED_NETWORK_NAME;\n    const shouldSupportAllNetworks = ChainController.getNetworkProp('supportsAllNetworks', chainNamespace);\n    this.setStatus('connected', chainNamespace);\n    if (isUnsupportedNetwork && !shouldSupportAllNetworks) {\n      return;\n    }\n    if (chainIdToUse) {\n      let caipNetwork = this.caipNetworks?.find(n => n.id.toString() === chainIdToUse.toString());\n      let fallbackCaipNetwork = this.caipNetworks?.find(n => n.chainNamespace === chainNamespace);\n      // If doesn't support all networks, we need to use approved networks\n      if (!shouldSupportAllNetworks && !caipNetwork && !fallbackCaipNetwork) {\n        // Connection can be requested for a chain that is not supported by the wallet so we need to use approved networks here\n        const caipNetworkIds = this.getApprovedCaipNetworkIds() || [];\n        const caipNetworkId = caipNetworkIds.find(id => ParseUtil.parseCaipNetworkId(id)?.chainId === chainIdToUse.toString());\n        const fallBackCaipNetworkId = caipNetworkIds.find(id => ParseUtil.parseCaipNetworkId(id)?.chainNamespace === chainNamespace);\n        caipNetwork = this.caipNetworks?.find(n => n.caipNetworkId === caipNetworkId);\n        fallbackCaipNetwork = this.caipNetworks?.find(n => n.caipNetworkId === fallBackCaipNetworkId ||\n        // This is a workaround used in Solana network to support deprecated caipNetworkId\n        'deprecatedCaipNetworkId' in n && n.deprecatedCaipNetworkId === fallBackCaipNetworkId);\n      }\n      const network = caipNetwork || fallbackCaipNetwork;\n      if (network?.chainNamespace === ChainController.state.activeChain) {\n        // If the network is unsupported and the user doesn't allow unsupported chains, we show the unsupported chain UI\n        if (OptionsController.state.enableNetworkSwitch && !OptionsController.state.allowUnsupportedChain && ChainController.state.activeCaipNetwork?.name === ConstantsUtil.UNSUPPORTED_NETWORK_NAME) {\n          ChainController.showUnsupportedChainUI();\n        } else {\n          this.setCaipNetwork(network);\n        }\n      } else if (!isActiveNamespace) {\n        if (networkOfChain) {\n          this.setCaipNetworkOfNamespace(networkOfChain, chainNamespace);\n        }\n      }\n      this.syncConnectedWalletInfo(chainNamespace);\n      if (!HelpersUtil.isLowerCaseMatch(address, AccountController.state.address)) {\n        this.syncAccountInfo(address, network?.id, chainNamespace);\n      }\n      if (isActiveNamespace) {\n        await this.syncBalance({\n          address,\n          chainId: network?.id,\n          chainNamespace\n        });\n      } else {\n        await this.syncBalance({\n          address,\n          chainId: networkOfChain?.id,\n          chainNamespace\n        });\n      }\n    }\n  }\n  async syncAccountInfo(address, chainId, chainNamespace) {\n    const caipAddress = this.getCaipAddress(chainNamespace);\n    const newChainId = chainId || caipAddress?.split(':')[1];\n    if (!newChainId) {\n      return;\n    }\n    const newCaipAddress = `${chainNamespace}:${newChainId}:${address}`;\n    this.setCaipAddress(newCaipAddress, chainNamespace);\n    await this.syncIdentity({\n      address,\n      chainId: newChainId,\n      chainNamespace\n    });\n  }\n  async syncReownName(address, chainNamespace) {\n    try {\n      const registeredWcNames = await this.getReownName(address);\n      if (registeredWcNames[0]) {\n        const wcName = registeredWcNames[0];\n        this.setProfileName(wcName.name, chainNamespace);\n      } else {\n        this.setProfileName(null, chainNamespace);\n      }\n    } catch {\n      this.setProfileName(null, chainNamespace);\n    }\n  }\n  syncConnectedWalletInfo(chainNamespace) {\n    const connectorId = ConnectorController.getConnectorId(chainNamespace);\n    const providerType = ProviderUtil.getProviderId(chainNamespace);\n    if (providerType === UtilConstantsUtil.CONNECTOR_TYPE_ANNOUNCED || providerType === UtilConstantsUtil.CONNECTOR_TYPE_INJECTED) {\n      if (connectorId) {\n        const connector = this.getConnectors().find(c => c.id === connectorId);\n        if (connector) {\n          const {\n            info,\n            name,\n            imageUrl\n          } = connector;\n          const icon = imageUrl || this.getConnectorImage(connector);\n          this.setConnectedWalletInfo({\n            name,\n            icon,\n            ...info\n          }, chainNamespace);\n        }\n      }\n    } else if (providerType === UtilConstantsUtil.CONNECTOR_TYPE_WALLET_CONNECT) {\n      const provider = ProviderUtil.getProvider(chainNamespace);\n      if (provider?.session) {\n        this.setConnectedWalletInfo({\n          ...provider.session.peer.metadata,\n          name: provider.session.peer.metadata.name,\n          icon: provider.session.peer.metadata.icons?.[0]\n        }, chainNamespace);\n      }\n    } else if (connectorId) {\n      if (connectorId === ConstantsUtil.CONNECTOR_ID.COINBASE) {\n        const connector = this.getConnectors().find(c => c.id === ConstantsUtil.CONNECTOR_ID.COINBASE);\n        this.setConnectedWalletInfo({\n          name: 'Coinbase Wallet',\n          icon: this.getConnectorImage(connector)\n        }, chainNamespace);\n      } else {\n        this.setConnectedWalletInfo({\n          name: connectorId\n        }, chainNamespace);\n      }\n    }\n  }\n  async syncBalance(params) {\n    const caipNetwork = NetworkUtil.getNetworksByNamespace(this.caipNetworks, params.chainNamespace).find(n => n.id.toString() === params.chainId?.toString());\n    if (!caipNetwork || !params.chainId) {\n      return;\n    }\n    await this.updateNativeBalance(params.address, params.chainId, params.chainNamespace);\n  }\n  async updateNativeBalance(address, chainId, namespace) {\n    const adapter = this.getAdapter(namespace);\n    if (adapter) {\n      const balance = await adapter.getBalance({\n        address,\n        chainId,\n        caipNetwork: this.getCaipNetwork(namespace),\n        tokens: this.options.tokens\n      });\n      this.setBalance(balance.balance, balance.symbol, namespace);\n    }\n  }\n  // -- Universal Provider ---------------------------------------------------\n  async initializeUniversalAdapter() {\n    const logger = LoggerUtil.createLogger((error, ...args) => {\n      if (error) {\n        this.handleAlertError(error);\n      }\n      // eslint-disable-next-line no-console\n      console.error(...args);\n    });\n    const universalProviderOptions = {\n      projectId: this.options?.projectId,\n      metadata: {\n        name: this.options?.metadata ? this.options?.metadata.name : '',\n        description: this.options?.metadata ? this.options?.metadata.description : '',\n        url: this.options?.metadata ? this.options?.metadata.url : '',\n        icons: this.options?.metadata ? this.options?.metadata.icons : ['']\n      },\n      logger\n    };\n    OptionsController.setManualWCControl(Boolean(this.options?.manualWCControl));\n    this.universalProvider = this.options.universalProvider ?? (await UniversalProvider.init(universalProviderOptions));\n    this.listenWalletConnect();\n  }\n  listenWalletConnect() {\n    if (this.universalProvider) {\n      this.universalProvider.on('display_uri', uri => {\n        ConnectionController.setUri(uri);\n      });\n      this.universalProvider.on('connect', ConnectionController.finalizeWcConnection);\n      this.universalProvider.on('disconnect', () => {\n        this.chainNamespaces.forEach(namespace => {\n          this.resetAccount(namespace);\n        });\n        ConnectionController.resetWcConnection();\n      });\n      this.universalProvider.on('chainChanged', chainId => {\n        // eslint-disable-next-line eqeqeq\n        const caipNetwork = this.caipNetworks?.find(c => c.id == chainId);\n        const currentCaipNetwork = this.getCaipNetwork();\n        if (!caipNetwork) {\n          this.setUnsupportedNetwork(chainId);\n          return;\n        }\n        if (currentCaipNetwork?.id !== caipNetwork?.id) {\n          this.setCaipNetwork(caipNetwork);\n        }\n      });\n      this.universalProvider.on('session_event', callbackData => {\n        if (WcHelpersUtil.isSessionEventData(callbackData)) {\n          const {\n            name,\n            data\n          } = callbackData.params.event;\n          if (name === 'accountsChanged' && Array.isArray(data) && CoreHelperUtil.isCaipAddress(data[0])) {\n            this.syncAccount(ParseUtil.parseCaipAddress(data[0]));\n          }\n        }\n      });\n    }\n  }\n  createUniversalProvider() {\n    if (!this.universalProviderInitPromise && CoreHelperUtil.isClient() && this.options?.projectId) {\n      this.universalProviderInitPromise = this.initializeUniversalAdapter();\n    }\n    return this.universalProviderInitPromise;\n  }\n  async getUniversalProvider() {\n    if (!this.universalProvider) {\n      try {\n        await this.createUniversalProvider();\n      } catch (err) {\n        EventsController.sendEvent({\n          type: 'error',\n          event: 'INTERNAL_SDK_ERROR',\n          properties: {\n            errorType: 'UniversalProviderInitError',\n            errorMessage: err instanceof Error ? err.message : 'Unknown',\n            uncaught: false\n          }\n        });\n        // eslint-disable-next-line no-console\n        console.error('AppKit:getUniversalProvider - Cannot create provider', err);\n      }\n    }\n    return this.universalProvider;\n  }\n  // - Utils -------------------------------------------------------------------\n  handleAlertError(error) {\n    const matchedUniversalProviderError = Object.entries(ErrorUtil.UniversalProviderErrors).find(([, {\n      message\n    }]) => error.message.includes(message));\n    const [errorKey, errorValue] = matchedUniversalProviderError ?? [];\n    const {\n      message,\n      alertErrorKey\n    } = errorValue ?? {};\n    if (errorKey && message && !this.reportedAlertErrors[errorKey]) {\n      const alertError = ErrorUtil.ALERT_ERRORS[alertErrorKey];\n      if (alertError) {\n        AlertController.open(alertError, 'error');\n        this.reportedAlertErrors[errorKey] = true;\n      }\n    }\n  }\n  getAdapter(namespace) {\n    if (!namespace) {\n      return undefined;\n    }\n    return this.chainAdapters?.[namespace];\n  }\n  createAdapter(blueprint) {\n    if (!blueprint) {\n      return;\n    }\n    const namespace = blueprint.namespace;\n    if (!namespace) {\n      return;\n    }\n    this.createClients();\n    const adapterBlueprint = blueprint;\n    adapterBlueprint.namespace = namespace;\n    adapterBlueprint.construct({\n      namespace,\n      projectId: this.options?.projectId,\n      networks: this.caipNetworks\n    });\n    if (!this.chainNamespaces.includes(namespace)) {\n      this.chainNamespaces.push(namespace);\n    }\n    if (this.chainAdapters) {\n      this.chainAdapters[namespace] = adapterBlueprint;\n    }\n  }\n  // -- Public -------------------------------------------------------------------\n  async open(options) {\n    await this.injectModalUi();\n    if (options?.uri) {\n      ConnectionController.setUri(options.uri);\n    }\n    await ModalController.open(options);\n  }\n  async close() {\n    await this.injectModalUi();\n    ModalController.close();\n  }\n  setLoading(loading, namespace) {\n    ModalController.setLoading(loading, namespace);\n  }\n  async disconnect(chainNamespace) {\n    await ConnectionController.disconnect(chainNamespace);\n  }\n  // -- review these -------------------------------------------------------------------\n  getError() {\n    return '';\n  }\n  getChainId() {\n    return ChainController.state.activeCaipNetwork?.id;\n  }\n  async switchNetwork(appKitNetwork) {\n    const network = this.caipNetworks?.find(n => n.id === appKitNetwork.id);\n    if (!network) {\n      AlertController.open(ErrorUtil.ALERT_ERRORS.SWITCH_NETWORK_NOT_FOUND, 'error');\n      return;\n    }\n    await ChainController.switchActiveNetwork(network);\n  }\n  getWalletProvider() {\n    return ChainController.state.activeChain ? ProviderUtil.state.providers[ChainController.state.activeChain] : null;\n  }\n  getWalletProviderType() {\n    return ProviderUtil.getProviderId(ChainController.state.activeChain);\n  }\n  subscribeProviders(callback) {\n    return ProviderUtil.subscribeProviders(callback);\n  }\n  getThemeMode() {\n    return ThemeController.state.themeMode;\n  }\n  getThemeVariables() {\n    return ThemeController.state.themeVariables;\n  }\n  setThemeMode(themeMode) {\n    ThemeController.setThemeMode(themeMode);\n    setColorTheme(ThemeController.state.themeMode);\n  }\n  setTermsConditionsUrl(termsConditionsUrl) {\n    OptionsController.setTermsConditionsUrl(termsConditionsUrl);\n  }\n  setPrivacyPolicyUrl(privacyPolicyUrl) {\n    OptionsController.setPrivacyPolicyUrl(privacyPolicyUrl);\n  }\n  setThemeVariables(themeVariables) {\n    ThemeController.setThemeVariables(themeVariables);\n    setThemeVariables(ThemeController.state.themeVariables);\n  }\n  subscribeTheme(callback) {\n    return ThemeController.subscribe(callback);\n  }\n  getWalletInfo() {\n    return AccountController.state.connectedWalletInfo;\n  }\n  getAccount(namespace) {\n    const authConnector = ConnectorController.getAuthConnector(namespace);\n    const accountState = ChainController.getAccountData(namespace);\n    if (!accountState) {\n      return undefined;\n    }\n    return {\n      allAccounts: accountState.allAccounts,\n      caipAddress: accountState.caipAddress,\n      address: CoreHelperUtil.getPlainAddress(accountState.caipAddress),\n      isConnected: Boolean(accountState.caipAddress),\n      status: accountState.status,\n      embeddedWalletInfo: authConnector ? {\n        user: accountState.user,\n        authProvider: accountState.socialProvider || 'email',\n        accountType: accountState.preferredAccountType,\n        isSmartAccountDeployed: Boolean(accountState.smartAccountDeployed)\n      } : undefined\n    };\n  }\n  subscribeAccount(callback, namespace) {\n    const updateVal = () => {\n      const account = this.getAccount(namespace);\n      if (!account) {\n        return;\n      }\n      callback(account);\n    };\n    if (namespace) {\n      ChainController.subscribeChainProp('accountState', updateVal, namespace);\n    } else {\n      ChainController.subscribe(updateVal);\n    }\n    ConnectorController.subscribe(updateVal);\n  }\n  subscribeNetwork(callback) {\n    return ChainController.subscribe(({\n      activeCaipNetwork\n    }) => {\n      callback({\n        caipNetwork: activeCaipNetwork,\n        chainId: activeCaipNetwork?.id,\n        caipNetworkId: activeCaipNetwork?.caipNetworkId\n      });\n    });\n  }\n  subscribeWalletInfo(callback) {\n    return AccountController.subscribeKey('connectedWalletInfo', callback);\n  }\n  subscribeShouldUpdateToAddress(callback) {\n    AccountController.subscribeKey('shouldUpdateToAddress', callback);\n  }\n  subscribeCaipNetworkChange(callback) {\n    ChainController.subscribeKey('activeCaipNetwork', callback);\n  }\n  getState() {\n    return PublicStateController.state;\n  }\n  subscribeState(callback) {\n    return PublicStateController.subscribe(callback);\n  }\n  showErrorMessage(message) {\n    SnackController.showError(message);\n  }\n  showSuccessMessage(message) {\n    SnackController.showSuccess(message);\n  }\n  getEvent() {\n    return {\n      ...EventsController.state\n    };\n  }\n  subscribeEvents(callback) {\n    return EventsController.subscribe(callback);\n  }\n  replace(route) {\n    RouterController.replace(route);\n  }\n  redirect(route) {\n    RouterController.push(route);\n  }\n  popTransactionStack(cancel) {\n    RouterController.popTransactionStack(cancel);\n  }\n  isOpen() {\n    return ModalController.state.open;\n  }\n  isTransactionStackEmpty() {\n    return RouterController.state.transactionStack.length === 0;\n  }\n  isTransactionShouldReplaceView() {\n    return RouterController.state.transactionStack[RouterController.state.transactionStack.length - 1]?.replace;\n  }\n  static getInstance() {\n    return this.instance;\n  }\n  updateFeatures(newFeatures) {\n    OptionsController.setFeatures(newFeatures);\n  }\n  updateOptions(newOptions) {\n    const currentOptions = OptionsController.state || {};\n    const updatedOptions = {\n      ...currentOptions,\n      ...newOptions\n    };\n    OptionsController.setOptions(updatedOptions);\n  }\n  setConnectMethodsOrder(connectMethodsOrder) {\n    OptionsController.setConnectMethodsOrder(connectMethodsOrder);\n  }\n  setWalletFeaturesOrder(walletFeaturesOrder) {\n    OptionsController.setWalletFeaturesOrder(walletFeaturesOrder);\n  }\n  setCollapseWallets(collapseWallets) {\n    OptionsController.setCollapseWallets(collapseWallets);\n  }\n  setSocialsOrder(socialsOrder) {\n    OptionsController.setSocialsOrder(socialsOrder);\n  }\n  getConnectMethodsOrder() {\n    return WalletUtil.getConnectOrderMethod(OptionsController.state.features, ConnectorController.getConnectors());\n  }\n  /**\n   * Removes an adapter from the AppKit.\n   * @param namespace - The namespace of the adapter to remove.\n   */\n  removeAdapter(namespace) {\n    const isConnected = this.getIsConnectedState();\n    const adapter = this.getAdapter(namespace);\n    if (!adapter || !this.chainAdapters || isConnected) {\n      return;\n    }\n    const newCaipNetworks = this.caipNetworks?.filter(network => network.chainNamespace !== namespace);\n    ChainController.removeAdapter(namespace);\n    ConnectorController.removeAdapter(namespace);\n    this.chainNamespaces = this.chainNamespaces.filter(n => n !== namespace);\n    this.caipNetworks = newCaipNetworks;\n    adapter.removeAllEventListeners();\n    Reflect.deleteProperty(this.chainAdapters, namespace);\n  }\n  /**\n   * Adds an adapter to the AppKit.\n   * @param adapter - The adapter instance.\n   * @param networks - The list of networks that this adapter supports / uses.\n   */\n  addAdapter(adapter, networks) {\n    const namespace = adapter.namespace;\n    if (!this.connectionControllerClient || !this.networkControllerClient) {\n      return;\n    }\n    if (!this.chainAdapters || !namespace) {\n      return;\n    }\n    const extendedAdapterNetworks = this.extendCaipNetworks({\n      ...this.options,\n      networks\n    });\n    this.caipNetworks = [...(this.caipNetworks || []), ...extendedAdapterNetworks];\n    this.createAdapter(adapter);\n    this.initChainAdapter(namespace);\n    ChainController.addAdapter(adapter, {\n      connectionControllerClient: this.connectionControllerClient,\n      networkControllerClient: this.networkControllerClient\n    }, extendedAdapterNetworks);\n  }\n  /**\n   * Adds a network to an existing adapter in AppKit.\n   * @param namespace - The chain namespace to add the network to (e.g. 'eip155', 'solana')\n   * @param network - The network configuration to add\n   * @throws Error if adapter for namespace doesn't exist\n   */\n  addNetwork(namespace, network) {\n    if (this.chainAdapters && !this.chainAdapters[namespace]) {\n      throw new Error(`Adapter for namespace ${namespace} doesn't exist`);\n    }\n    const extendedNetwork = this.extendCaipNetwork(network, this.options);\n    ChainController.addNetwork(extendedNetwork);\n    if (this.caipNetworks && !this.caipNetworks?.find(n => n.id === extendedNetwork.id)) {\n      this.caipNetworks.push(extendedNetwork);\n    }\n  }\n  /**\n   * Removes a network from an existing adapter in AppKit.\n   * @param namespace - The chain namespace the network belongs to\n   * @param networkId - The network ID to remove\n   * @throws Error if adapter for namespace doesn't exist or if removing last network\n   */\n  removeNetwork(namespace, networkId) {\n    if (this.chainAdapters && !this.chainAdapters[namespace]) {\n      throw new Error(`Adapter for namespace ${namespace} doesn't exist`);\n    }\n    const networkToRemove = this.caipNetworks?.find(n => n.id === networkId);\n    if (!networkToRemove) {\n      throw new Error(`Network with ID ${networkId} not found`);\n    }\n    if (!this.caipNetworks) {\n      return;\n    }\n    const remainingNetworks = this.caipNetworks.filter(n => n.chainNamespace === namespace && n.id !== networkId);\n    if (!remainingNetworks?.length) {\n      throw new Error('Cannot remove last network for a namespace');\n    }\n    ChainController.removeNetwork(namespace, networkId);\n    this.caipNetworks = [...remainingNetworks];\n  }\n}\n//# sourceMappingURL=appkit-base-client.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}