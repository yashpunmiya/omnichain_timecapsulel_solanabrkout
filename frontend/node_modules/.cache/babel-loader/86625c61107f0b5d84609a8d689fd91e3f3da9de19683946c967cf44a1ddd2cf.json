{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TemplateLiteralGenerateError = void 0;\nexports.TemplateLiteralExpressionGenerate = TemplateLiteralExpressionGenerate;\nexports.TemplateLiteralGenerate = TemplateLiteralGenerate;\nconst finite_1 = require(\"./finite\");\nconst parse_1 = require(\"./parse\");\nconst index_1 = require(\"../error/index\");\n// ------------------------------------------------------------------\n// TemplateLiteralGenerateError\n// ------------------------------------------------------------------\nclass TemplateLiteralGenerateError extends index_1.TypeBoxError {}\nexports.TemplateLiteralGenerateError = TemplateLiteralGenerateError;\n// ------------------------------------------------------------------\n// TemplateLiteralExpressionGenerate\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction* GenerateReduce(buffer) {\n  if (buffer.length === 1) return yield* buffer[0];\n  for (const left of buffer[0]) {\n    for (const right of GenerateReduce(buffer.slice(1))) {\n      yield `${left}${right}`;\n    }\n  }\n}\n// prettier-ignore\nfunction* GenerateAnd(expression) {\n  return yield* GenerateReduce(expression.expr.map(expr => [...TemplateLiteralExpressionGenerate(expr)]));\n}\n// prettier-ignore\nfunction* GenerateOr(expression) {\n  for (const expr of expression.expr) yield* TemplateLiteralExpressionGenerate(expr);\n}\n// prettier-ignore\nfunction* GenerateConst(expression) {\n  return yield expression.const;\n}\nfunction* TemplateLiteralExpressionGenerate(expression) {\n  return expression.type === 'and' ? yield* GenerateAnd(expression) : expression.type === 'or' ? yield* GenerateOr(expression) : expression.type === 'const' ? yield* GenerateConst(expression) : (() => {\n    throw new TemplateLiteralGenerateError('Unknown expression');\n  })();\n}\n/** Generates a tuple of strings from the given TemplateLiteral. Returns an empty tuple if infinite. */\nfunction TemplateLiteralGenerate(schema) {\n  const expression = (0, parse_1.TemplateLiteralParseExact)(schema.pattern);\n  // prettier-ignore\n  return (0, finite_1.IsTemplateLiteralExpressionFinite)(expression) ? [...TemplateLiteralExpressionGenerate(expression)] : [];\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","TemplateLiteralGenerateError","TemplateLiteralExpressionGenerate","TemplateLiteralGenerate","finite_1","require","parse_1","index_1","TypeBoxError","GenerateReduce","buffer","length","left","right","slice","GenerateAnd","expression","expr","map","GenerateOr","GenerateConst","const","type","schema","TemplateLiteralParseExact","pattern","IsTemplateLiteralExpressionFinite"],"sources":["C:/Users/yyash/Coding/solana-brkout/frontend/node_modules/@sinclair/typebox/build/cjs/type/template-literal/generate.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TemplateLiteralGenerateError = void 0;\nexports.TemplateLiteralExpressionGenerate = TemplateLiteralExpressionGenerate;\nexports.TemplateLiteralGenerate = TemplateLiteralGenerate;\nconst finite_1 = require(\"./finite\");\nconst parse_1 = require(\"./parse\");\nconst index_1 = require(\"../error/index\");\n// ------------------------------------------------------------------\n// TemplateLiteralGenerateError\n// ------------------------------------------------------------------\nclass TemplateLiteralGenerateError extends index_1.TypeBoxError {\n}\nexports.TemplateLiteralGenerateError = TemplateLiteralGenerateError;\n// ------------------------------------------------------------------\n// TemplateLiteralExpressionGenerate\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction* GenerateReduce(buffer) {\n    if (buffer.length === 1)\n        return yield* buffer[0];\n    for (const left of buffer[0]) {\n        for (const right of GenerateReduce(buffer.slice(1))) {\n            yield `${left}${right}`;\n        }\n    }\n}\n// prettier-ignore\nfunction* GenerateAnd(expression) {\n    return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));\n}\n// prettier-ignore\nfunction* GenerateOr(expression) {\n    for (const expr of expression.expr)\n        yield* TemplateLiteralExpressionGenerate(expr);\n}\n// prettier-ignore\nfunction* GenerateConst(expression) {\n    return yield expression.const;\n}\nfunction* TemplateLiteralExpressionGenerate(expression) {\n    return expression.type === 'and'\n        ? yield* GenerateAnd(expression)\n        : expression.type === 'or'\n            ? yield* GenerateOr(expression)\n            : expression.type === 'const'\n                ? yield* GenerateConst(expression)\n                : (() => {\n                    throw new TemplateLiteralGenerateError('Unknown expression');\n                })();\n}\n/** Generates a tuple of strings from the given TemplateLiteral. Returns an empty tuple if infinite. */\nfunction TemplateLiteralGenerate(schema) {\n    const expression = (0, parse_1.TemplateLiteralParseExact)(schema.pattern);\n    // prettier-ignore\n    return ((0, finite_1.IsTemplateLiteralExpressionFinite)(expression)\n        ? [...TemplateLiteralExpressionGenerate(expression)]\n        : []);\n}\n"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,4BAA4B,GAAG,KAAK,CAAC;AAC7CF,OAAO,CAACG,iCAAiC,GAAGA,iCAAiC;AAC7EH,OAAO,CAACI,uBAAuB,GAAGA,uBAAuB;AACzD,MAAMC,QAAQ,GAAGC,OAAO,CAAC,UAAU,CAAC;AACpC,MAAMC,OAAO,GAAGD,OAAO,CAAC,SAAS,CAAC;AAClC,MAAME,OAAO,GAAGF,OAAO,CAAC,gBAAgB,CAAC;AACzC;AACA;AACA;AACA,MAAMJ,4BAA4B,SAASM,OAAO,CAACC,YAAY,CAAC;AAEhET,OAAO,CAACE,4BAA4B,GAAGA,4BAA4B;AACnE;AACA;AACA;AACA;AACA,UAAUQ,cAAcA,CAACC,MAAM,EAAE;EAC7B,IAAIA,MAAM,CAACC,MAAM,KAAK,CAAC,EACnB,OAAO,OAAOD,MAAM,CAAC,CAAC,CAAC;EAC3B,KAAK,MAAME,IAAI,IAAIF,MAAM,CAAC,CAAC,CAAC,EAAE;IAC1B,KAAK,MAAMG,KAAK,IAAIJ,cAAc,CAACC,MAAM,CAACI,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE;MACjD,MAAM,GAAGF,IAAI,GAAGC,KAAK,EAAE;IAC3B;EACJ;AACJ;AACA;AACA,UAAUE,WAAWA,CAACC,UAAU,EAAE;EAC9B,OAAO,OAAOP,cAAc,CAACO,UAAU,CAACC,IAAI,CAACC,GAAG,CAAED,IAAI,IAAK,CAAC,GAAGf,iCAAiC,CAACe,IAAI,CAAC,CAAC,CAAC,CAAC;AAC7G;AACA;AACA,UAAUE,UAAUA,CAACH,UAAU,EAAE;EAC7B,KAAK,MAAMC,IAAI,IAAID,UAAU,CAACC,IAAI,EAC9B,OAAOf,iCAAiC,CAACe,IAAI,CAAC;AACtD;AACA;AACA,UAAUG,aAAaA,CAACJ,UAAU,EAAE;EAChC,OAAO,MAAMA,UAAU,CAACK,KAAK;AACjC;AACA,UAAUnB,iCAAiCA,CAACc,UAAU,EAAE;EACpD,OAAOA,UAAU,CAACM,IAAI,KAAK,KAAK,GAC1B,OAAOP,WAAW,CAACC,UAAU,CAAC,GAC9BA,UAAU,CAACM,IAAI,KAAK,IAAI,GACpB,OAAOH,UAAU,CAACH,UAAU,CAAC,GAC7BA,UAAU,CAACM,IAAI,KAAK,OAAO,GACvB,OAAOF,aAAa,CAACJ,UAAU,CAAC,GAChC,CAAC,MAAM;IACL,MAAM,IAAIf,4BAA4B,CAAC,oBAAoB,CAAC;EAChE,CAAC,EAAE,CAAC;AACpB;AACA;AACA,SAASE,uBAAuBA,CAACoB,MAAM,EAAE;EACrC,MAAMP,UAAU,GAAG,CAAC,CAAC,EAAEV,OAAO,CAACkB,yBAAyB,EAAED,MAAM,CAACE,OAAO,CAAC;EACzE;EACA,OAAQ,CAAC,CAAC,EAAErB,QAAQ,CAACsB,iCAAiC,EAAEV,UAAU,CAAC,GAC7D,CAAC,GAAGd,iCAAiC,CAACc,UAAU,CAAC,CAAC,GAClD,EAAE;AACZ","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}