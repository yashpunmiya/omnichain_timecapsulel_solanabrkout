{"ast":null,"code":"import { BytesSizeMismatchError } from '../errors/abi.js';\nimport { InvalidAddressError } from '../errors/address.js';\nimport { InvalidDomainError, InvalidPrimaryTypeError, InvalidStructTypeError } from '../errors/typedData.js';\nimport { isAddress } from './address/isAddress.js';\nimport { size } from './data/size.js';\nimport { numberToHex } from './encoding/toHex.js';\nimport { bytesRegex, integerRegex } from './regex.js';\nimport { hashDomain } from './signature/hashTypedData.js';\nimport { stringify } from './stringify.js';\nexport function serializeTypedData(parameters) {\n  const {\n    domain: domain_,\n    message: message_,\n    primaryType,\n    types\n  } = parameters;\n  const normalizeData = (struct, data_) => {\n    const data = {\n      ...data_\n    };\n    for (const param of struct) {\n      const {\n        name,\n        type\n      } = param;\n      if (type === 'address') data[name] = data[name].toLowerCase();\n    }\n    return data;\n  };\n  const domain = (() => {\n    if (!types.EIP712Domain) return {};\n    if (!domain_) return {};\n    return normalizeData(types.EIP712Domain, domain_);\n  })();\n  const message = (() => {\n    if (primaryType === 'EIP712Domain') return undefined;\n    return normalizeData(types[primaryType], message_);\n  })();\n  return stringify({\n    domain,\n    message,\n    primaryType,\n    types\n  });\n}\nexport function validateTypedData(parameters) {\n  const {\n    domain,\n    message,\n    primaryType,\n    types\n  } = parameters;\n  const validateData = (struct, data) => {\n    for (const param of struct) {\n      const {\n        name,\n        type\n      } = param;\n      const value = data[name];\n      const integerMatch = type.match(integerRegex);\n      if (integerMatch && (typeof value === 'number' || typeof value === 'bigint')) {\n        const [_type, base, size_] = integerMatch;\n        // If number cannot be cast to a sized hex value, it is out of range\n        // and will throw.\n        numberToHex(value, {\n          signed: base === 'int',\n          size: Number.parseInt(size_) / 8\n        });\n      }\n      if (type === 'address' && typeof value === 'string' && !isAddress(value)) throw new InvalidAddressError({\n        address: value\n      });\n      const bytesMatch = type.match(bytesRegex);\n      if (bytesMatch) {\n        const [_type, size_] = bytesMatch;\n        if (size_ && size(value) !== Number.parseInt(size_)) throw new BytesSizeMismatchError({\n          expectedSize: Number.parseInt(size_),\n          givenSize: size(value)\n        });\n      }\n      const struct = types[type];\n      if (struct) {\n        validateReference(type);\n        validateData(struct, value);\n      }\n    }\n  };\n  // Validate domain types.\n  if (types.EIP712Domain && domain) {\n    if (typeof domain !== 'object') throw new InvalidDomainError({\n      domain\n    });\n    validateData(types.EIP712Domain, domain);\n  }\n  // Validate message types.\n  if (primaryType !== 'EIP712Domain') {\n    if (types[primaryType]) validateData(types[primaryType], message);else throw new InvalidPrimaryTypeError({\n      primaryType,\n      types\n    });\n  }\n}\nexport function getTypesForEIP712Domain({\n  domain\n}) {\n  return [typeof domain?.name === 'string' && {\n    name: 'name',\n    type: 'string'\n  }, domain?.version && {\n    name: 'version',\n    type: 'string'\n  }, (typeof domain?.chainId === 'number' || typeof domain?.chainId === 'bigint') && {\n    name: 'chainId',\n    type: 'uint256'\n  }, domain?.verifyingContract && {\n    name: 'verifyingContract',\n    type: 'address'\n  }, domain?.salt && {\n    name: 'salt',\n    type: 'bytes32'\n  }].filter(Boolean);\n}\nexport function domainSeparator({\n  domain\n}) {\n  return hashDomain({\n    domain,\n    types: {\n      EIP712Domain: getTypesForEIP712Domain({\n        domain\n      })\n    }\n  });\n}\n/** @internal */\nfunction validateReference(type) {\n  // Struct type must not be a Solidity type.\n  if (type === 'address' || type === 'bool' || type === 'string' || type.startsWith('bytes') || type.startsWith('uint') || type.startsWith('int')) throw new InvalidStructTypeError({\n    type\n  });\n}\n//# sourceMappingURL=typedData.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}