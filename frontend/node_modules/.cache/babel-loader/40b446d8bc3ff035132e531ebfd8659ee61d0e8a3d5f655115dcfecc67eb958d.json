{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ValueErrorIterator = exports.ValueErrorsUnknownTypeError = exports.ValueErrorType = void 0;\nexports.Errors = Errors;\nconst index_1 = require(\"../system/index\");\nconst index_2 = require(\"../type/keyof/index\");\nconst index_3 = require(\"../type/registry/index\");\nconst extends_undefined_1 = require(\"../type/extends/extends-undefined\");\nconst function_1 = require(\"./function\");\nconst index_4 = require(\"../type/error/index\");\nconst index_5 = require(\"../value/deref/index\");\nconst index_6 = require(\"../value/hash/index\");\nconst index_7 = require(\"../value/check/index\");\nconst index_8 = require(\"../type/symbols/index\");\nconst index_9 = require(\"../type/never/index\");\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\n// prettier-ignore\nconst index_10 = require(\"../value/guard/index\");\n// ------------------------------------------------------------------\n// ValueErrorType\n// ------------------------------------------------------------------\nvar ValueErrorType;\n(function (ValueErrorType) {\n  ValueErrorType[ValueErrorType[\"ArrayContains\"] = 0] = \"ArrayContains\";\n  ValueErrorType[ValueErrorType[\"ArrayMaxContains\"] = 1] = \"ArrayMaxContains\";\n  ValueErrorType[ValueErrorType[\"ArrayMaxItems\"] = 2] = \"ArrayMaxItems\";\n  ValueErrorType[ValueErrorType[\"ArrayMinContains\"] = 3] = \"ArrayMinContains\";\n  ValueErrorType[ValueErrorType[\"ArrayMinItems\"] = 4] = \"ArrayMinItems\";\n  ValueErrorType[ValueErrorType[\"ArrayUniqueItems\"] = 5] = \"ArrayUniqueItems\";\n  ValueErrorType[ValueErrorType[\"Array\"] = 6] = \"Array\";\n  ValueErrorType[ValueErrorType[\"AsyncIterator\"] = 7] = \"AsyncIterator\";\n  ValueErrorType[ValueErrorType[\"BigIntExclusiveMaximum\"] = 8] = \"BigIntExclusiveMaximum\";\n  ValueErrorType[ValueErrorType[\"BigIntExclusiveMinimum\"] = 9] = \"BigIntExclusiveMinimum\";\n  ValueErrorType[ValueErrorType[\"BigIntMaximum\"] = 10] = \"BigIntMaximum\";\n  ValueErrorType[ValueErrorType[\"BigIntMinimum\"] = 11] = \"BigIntMinimum\";\n  ValueErrorType[ValueErrorType[\"BigIntMultipleOf\"] = 12] = \"BigIntMultipleOf\";\n  ValueErrorType[ValueErrorType[\"BigInt\"] = 13] = \"BigInt\";\n  ValueErrorType[ValueErrorType[\"Boolean\"] = 14] = \"Boolean\";\n  ValueErrorType[ValueErrorType[\"DateExclusiveMaximumTimestamp\"] = 15] = \"DateExclusiveMaximumTimestamp\";\n  ValueErrorType[ValueErrorType[\"DateExclusiveMinimumTimestamp\"] = 16] = \"DateExclusiveMinimumTimestamp\";\n  ValueErrorType[ValueErrorType[\"DateMaximumTimestamp\"] = 17] = \"DateMaximumTimestamp\";\n  ValueErrorType[ValueErrorType[\"DateMinimumTimestamp\"] = 18] = \"DateMinimumTimestamp\";\n  ValueErrorType[ValueErrorType[\"DateMultipleOfTimestamp\"] = 19] = \"DateMultipleOfTimestamp\";\n  ValueErrorType[ValueErrorType[\"Date\"] = 20] = \"Date\";\n  ValueErrorType[ValueErrorType[\"Function\"] = 21] = \"Function\";\n  ValueErrorType[ValueErrorType[\"IntegerExclusiveMaximum\"] = 22] = \"IntegerExclusiveMaximum\";\n  ValueErrorType[ValueErrorType[\"IntegerExclusiveMinimum\"] = 23] = \"IntegerExclusiveMinimum\";\n  ValueErrorType[ValueErrorType[\"IntegerMaximum\"] = 24] = \"IntegerMaximum\";\n  ValueErrorType[ValueErrorType[\"IntegerMinimum\"] = 25] = \"IntegerMinimum\";\n  ValueErrorType[ValueErrorType[\"IntegerMultipleOf\"] = 26] = \"IntegerMultipleOf\";\n  ValueErrorType[ValueErrorType[\"Integer\"] = 27] = \"Integer\";\n  ValueErrorType[ValueErrorType[\"IntersectUnevaluatedProperties\"] = 28] = \"IntersectUnevaluatedProperties\";\n  ValueErrorType[ValueErrorType[\"Intersect\"] = 29] = \"Intersect\";\n  ValueErrorType[ValueErrorType[\"Iterator\"] = 30] = \"Iterator\";\n  ValueErrorType[ValueErrorType[\"Kind\"] = 31] = \"Kind\";\n  ValueErrorType[ValueErrorType[\"Literal\"] = 32] = \"Literal\";\n  ValueErrorType[ValueErrorType[\"Never\"] = 33] = \"Never\";\n  ValueErrorType[ValueErrorType[\"Not\"] = 34] = \"Not\";\n  ValueErrorType[ValueErrorType[\"Null\"] = 35] = \"Null\";\n  ValueErrorType[ValueErrorType[\"NumberExclusiveMaximum\"] = 36] = \"NumberExclusiveMaximum\";\n  ValueErrorType[ValueErrorType[\"NumberExclusiveMinimum\"] = 37] = \"NumberExclusiveMinimum\";\n  ValueErrorType[ValueErrorType[\"NumberMaximum\"] = 38] = \"NumberMaximum\";\n  ValueErrorType[ValueErrorType[\"NumberMinimum\"] = 39] = \"NumberMinimum\";\n  ValueErrorType[ValueErrorType[\"NumberMultipleOf\"] = 40] = \"NumberMultipleOf\";\n  ValueErrorType[ValueErrorType[\"Number\"] = 41] = \"Number\";\n  ValueErrorType[ValueErrorType[\"ObjectAdditionalProperties\"] = 42] = \"ObjectAdditionalProperties\";\n  ValueErrorType[ValueErrorType[\"ObjectMaxProperties\"] = 43] = \"ObjectMaxProperties\";\n  ValueErrorType[ValueErrorType[\"ObjectMinProperties\"] = 44] = \"ObjectMinProperties\";\n  ValueErrorType[ValueErrorType[\"ObjectRequiredProperty\"] = 45] = \"ObjectRequiredProperty\";\n  ValueErrorType[ValueErrorType[\"Object\"] = 46] = \"Object\";\n  ValueErrorType[ValueErrorType[\"Promise\"] = 47] = \"Promise\";\n  ValueErrorType[ValueErrorType[\"RegExp\"] = 48] = \"RegExp\";\n  ValueErrorType[ValueErrorType[\"StringFormatUnknown\"] = 49] = \"StringFormatUnknown\";\n  ValueErrorType[ValueErrorType[\"StringFormat\"] = 50] = \"StringFormat\";\n  ValueErrorType[ValueErrorType[\"StringMaxLength\"] = 51] = \"StringMaxLength\";\n  ValueErrorType[ValueErrorType[\"StringMinLength\"] = 52] = \"StringMinLength\";\n  ValueErrorType[ValueErrorType[\"StringPattern\"] = 53] = \"StringPattern\";\n  ValueErrorType[ValueErrorType[\"String\"] = 54] = \"String\";\n  ValueErrorType[ValueErrorType[\"Symbol\"] = 55] = \"Symbol\";\n  ValueErrorType[ValueErrorType[\"TupleLength\"] = 56] = \"TupleLength\";\n  ValueErrorType[ValueErrorType[\"Tuple\"] = 57] = \"Tuple\";\n  ValueErrorType[ValueErrorType[\"Uint8ArrayMaxByteLength\"] = 58] = \"Uint8ArrayMaxByteLength\";\n  ValueErrorType[ValueErrorType[\"Uint8ArrayMinByteLength\"] = 59] = \"Uint8ArrayMinByteLength\";\n  ValueErrorType[ValueErrorType[\"Uint8Array\"] = 60] = \"Uint8Array\";\n  ValueErrorType[ValueErrorType[\"Undefined\"] = 61] = \"Undefined\";\n  ValueErrorType[ValueErrorType[\"Union\"] = 62] = \"Union\";\n  ValueErrorType[ValueErrorType[\"Void\"] = 63] = \"Void\";\n})(ValueErrorType || (exports.ValueErrorType = ValueErrorType = {}));\n// ------------------------------------------------------------------\n// ValueErrors\n// ------------------------------------------------------------------\nclass ValueErrorsUnknownTypeError extends index_4.TypeBoxError {\n  constructor(schema) {\n    super('Unknown type');\n    this.schema = schema;\n  }\n}\nexports.ValueErrorsUnknownTypeError = ValueErrorsUnknownTypeError;\n// ------------------------------------------------------------------\n// EscapeKey\n// ------------------------------------------------------------------\nfunction EscapeKey(key) {\n  return key.replace(/~/g, '~0').replace(/\\//g, '~1'); // RFC6901 Path\n}\n// ------------------------------------------------------------------\n// Guards\n// ------------------------------------------------------------------\nfunction IsDefined(value) {\n  return value !== undefined;\n}\n// ------------------------------------------------------------------\n// ValueErrorIterator\n// ------------------------------------------------------------------\nclass ValueErrorIterator {\n  constructor(iterator) {\n    this.iterator = iterator;\n  }\n  [Symbol.iterator]() {\n    return this.iterator;\n  }\n  /** Returns the first value error or undefined if no errors */\n  First() {\n    const next = this.iterator.next();\n    return next.done ? undefined : next.value;\n  }\n}\nexports.ValueErrorIterator = ValueErrorIterator;\n// --------------------------------------------------------------------------\n// Create\n// --------------------------------------------------------------------------\nfunction Create(errorType, schema, path, value, errors = []) {\n  return {\n    type: errorType,\n    schema,\n    path,\n    value,\n    message: (0, function_1.GetErrorFunction)()({\n      errorType,\n      path,\n      schema,\n      value,\n      errors\n    }),\n    errors\n  };\n}\n// --------------------------------------------------------------------------\n// Types\n// --------------------------------------------------------------------------\nfunction* FromAny(schema, references, path, value) {}\nfunction* FromArray(schema, references, path, value) {\n  if (!(0, index_10.IsArray)(value)) {\n    return yield Create(ValueErrorType.Array, schema, path, value);\n  }\n  if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {\n    yield Create(ValueErrorType.ArrayMinItems, schema, path, value);\n  }\n  if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {\n    yield Create(ValueErrorType.ArrayMaxItems, schema, path, value);\n  }\n  for (let i = 0; i < value.length; i++) {\n    yield* Visit(schema.items, references, `${path}/${i}`, value[i]);\n  }\n  // prettier-ignore\n  if (schema.uniqueItems === true && !function () {\n    const set = new Set();\n    for (const element of value) {\n      const hashed = (0, index_6.Hash)(element);\n      if (set.has(hashed)) {\n        return false;\n      } else {\n        set.add(hashed);\n      }\n    }\n    return true;\n  }()) {\n    yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value);\n  }\n  // contains\n  if (!(IsDefined(schema.contains) || IsDefined(schema.minContains) || IsDefined(schema.maxContains))) {\n    return;\n  }\n  const containsSchema = IsDefined(schema.contains) ? schema.contains : (0, index_9.Never)();\n  const containsCount = value.reduce((acc, value, index) => Visit(containsSchema, references, `${path}${index}`, value).next().done === true ? acc + 1 : acc, 0);\n  if (containsCount === 0) {\n    yield Create(ValueErrorType.ArrayContains, schema, path, value);\n  }\n  if ((0, index_10.IsNumber)(schema.minContains) && containsCount < schema.minContains) {\n    yield Create(ValueErrorType.ArrayMinContains, schema, path, value);\n  }\n  if ((0, index_10.IsNumber)(schema.maxContains) && containsCount > schema.maxContains) {\n    yield Create(ValueErrorType.ArrayMaxContains, schema, path, value);\n  }\n}\nfunction* FromAsyncIterator(schema, references, path, value) {\n  if (!(0, index_10.IsAsyncIterator)(value)) yield Create(ValueErrorType.AsyncIterator, schema, path, value);\n}\nfunction* FromBigInt(schema, references, path, value) {\n  if (!(0, index_10.IsBigInt)(value)) return yield Create(ValueErrorType.BigInt, schema, path, value);\n  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n    yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value);\n  }\n  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n    yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value);\n  }\n  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n    yield Create(ValueErrorType.BigIntMaximum, schema, path, value);\n  }\n  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n    yield Create(ValueErrorType.BigIntMinimum, schema, path, value);\n  }\n  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {\n    yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value);\n  }\n}\nfunction* FromBoolean(schema, references, path, value) {\n  if (!(0, index_10.IsBoolean)(value)) yield Create(ValueErrorType.Boolean, schema, path, value);\n}\nfunction* FromConstructor(schema, references, path, value) {\n  yield* Visit(schema.returns, references, path, value.prototype);\n}\nfunction* FromDate(schema, references, path, value) {\n  if (!(0, index_10.IsDate)(value)) return yield Create(ValueErrorType.Date, schema, path, value);\n  if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {\n    yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value);\n  }\n  if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {\n    yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value);\n  }\n  if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {\n    yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value);\n  }\n  if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {\n    yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value);\n  }\n  if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {\n    yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value);\n  }\n}\nfunction* FromFunction(schema, references, path, value) {\n  if (!(0, index_10.IsFunction)(value)) yield Create(ValueErrorType.Function, schema, path, value);\n}\nfunction* FromInteger(schema, references, path, value) {\n  if (!(0, index_10.IsInteger)(value)) return yield Create(ValueErrorType.Integer, schema, path, value);\n  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n    yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value);\n  }\n  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n    yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value);\n  }\n  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n    yield Create(ValueErrorType.IntegerMaximum, schema, path, value);\n  }\n  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n    yield Create(ValueErrorType.IntegerMinimum, schema, path, value);\n  }\n  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n    yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value);\n  }\n}\nfunction* FromIntersect(schema, references, path, value) {\n  let hasError = false;\n  for (const inner of schema.allOf) {\n    for (const error of Visit(inner, references, path, value)) {\n      hasError = true;\n      yield error;\n    }\n  }\n  if (hasError) {\n    return yield Create(ValueErrorType.Intersect, schema, path, value);\n  }\n  if (schema.unevaluatedProperties === false) {\n    const keyCheck = new RegExp((0, index_2.KeyOfPattern)(schema));\n    for (const valueKey of Object.getOwnPropertyNames(value)) {\n      if (!keyCheck.test(valueKey)) {\n        yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value);\n      }\n    }\n  }\n  if (typeof schema.unevaluatedProperties === 'object') {\n    const keyCheck = new RegExp((0, index_2.KeyOfPattern)(schema));\n    for (const valueKey of Object.getOwnPropertyNames(value)) {\n      if (!keyCheck.test(valueKey)) {\n        const next = Visit(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();\n        if (!next.done) yield next.value; // yield interior\n      }\n    }\n  }\n}\nfunction* FromIterator(schema, references, path, value) {\n  if (!(0, index_10.IsIterator)(value)) yield Create(ValueErrorType.Iterator, schema, path, value);\n}\nfunction* FromLiteral(schema, references, path, value) {\n  if (!(value === schema.const)) yield Create(ValueErrorType.Literal, schema, path, value);\n}\nfunction* FromNever(schema, references, path, value) {\n  yield Create(ValueErrorType.Never, schema, path, value);\n}\nfunction* FromNot(schema, references, path, value) {\n  if (Visit(schema.not, references, path, value).next().done === true) yield Create(ValueErrorType.Not, schema, path, value);\n}\nfunction* FromNull(schema, references, path, value) {\n  if (!(0, index_10.IsNull)(value)) yield Create(ValueErrorType.Null, schema, path, value);\n}\nfunction* FromNumber(schema, references, path, value) {\n  if (!index_1.TypeSystemPolicy.IsNumberLike(value)) return yield Create(ValueErrorType.Number, schema, path, value);\n  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n    yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value);\n  }\n  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n    yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value);\n  }\n  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n    yield Create(ValueErrorType.NumberMaximum, schema, path, value);\n  }\n  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n    yield Create(ValueErrorType.NumberMinimum, schema, path, value);\n  }\n  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n    yield Create(ValueErrorType.NumberMultipleOf, schema, path, value);\n  }\n}\nfunction* FromObject(schema, references, path, value) {\n  if (!index_1.TypeSystemPolicy.IsObjectLike(value)) return yield Create(ValueErrorType.Object, schema, path, value);\n  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);\n  }\n  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);\n  }\n  const requiredKeys = Array.isArray(schema.required) ? schema.required : [];\n  const knownKeys = Object.getOwnPropertyNames(schema.properties);\n  const unknownKeys = Object.getOwnPropertyNames(value);\n  for (const requiredKey of requiredKeys) {\n    if (unknownKeys.includes(requiredKey)) continue;\n    yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);\n  }\n  if (schema.additionalProperties === false) {\n    for (const valueKey of unknownKeys) {\n      if (!knownKeys.includes(valueKey)) {\n        yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);\n      }\n    }\n  }\n  if (typeof schema.additionalProperties === 'object') {\n    for (const valueKey of unknownKeys) {\n      if (knownKeys.includes(valueKey)) continue;\n      yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);\n    }\n  }\n  for (const knownKey of knownKeys) {\n    const property = schema.properties[knownKey];\n    if (schema.required && schema.required.includes(knownKey)) {\n      yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);\n      if ((0, extends_undefined_1.ExtendsUndefinedCheck)(schema) && !(knownKey in value)) {\n        yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);\n      }\n    } else {\n      if (index_1.TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {\n        yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);\n      }\n    }\n  }\n}\nfunction* FromPromise(schema, references, path, value) {\n  if (!(0, index_10.IsPromise)(value)) yield Create(ValueErrorType.Promise, schema, path, value);\n}\nfunction* FromRecord(schema, references, path, value) {\n  if (!index_1.TypeSystemPolicy.IsRecordLike(value)) return yield Create(ValueErrorType.Object, schema, path, value);\n  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);\n  }\n  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);\n  }\n  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];\n  const regex = new RegExp(patternKey);\n  for (const [propertyKey, propertyValue] of Object.entries(value)) {\n    if (regex.test(propertyKey)) yield* Visit(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n  }\n  if (typeof schema.additionalProperties === 'object') {\n    for (const [propertyKey, propertyValue] of Object.entries(value)) {\n      if (!regex.test(propertyKey)) yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n    }\n  }\n  if (schema.additionalProperties === false) {\n    for (const [propertyKey, propertyValue] of Object.entries(value)) {\n      if (regex.test(propertyKey)) continue;\n      return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n    }\n  }\n}\nfunction* FromRef(schema, references, path, value) {\n  yield* Visit((0, index_5.Deref)(schema, references), references, path, value);\n}\nfunction* FromRegExp(schema, references, path, value) {\n  if (!(0, index_10.IsString)(value)) return yield Create(ValueErrorType.String, schema, path, value);\n  if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {\n    yield Create(ValueErrorType.StringMinLength, schema, path, value);\n  }\n  if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {\n    yield Create(ValueErrorType.StringMaxLength, schema, path, value);\n  }\n  const regex = new RegExp(schema.source, schema.flags);\n  if (!regex.test(value)) {\n    return yield Create(ValueErrorType.RegExp, schema, path, value);\n  }\n}\nfunction* FromString(schema, references, path, value) {\n  if (!(0, index_10.IsString)(value)) return yield Create(ValueErrorType.String, schema, path, value);\n  if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {\n    yield Create(ValueErrorType.StringMinLength, schema, path, value);\n  }\n  if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {\n    yield Create(ValueErrorType.StringMaxLength, schema, path, value);\n  }\n  if ((0, index_10.IsString)(schema.pattern)) {\n    const regex = new RegExp(schema.pattern);\n    if (!regex.test(value)) {\n      yield Create(ValueErrorType.StringPattern, schema, path, value);\n    }\n  }\n  if ((0, index_10.IsString)(schema.format)) {\n    if (!index_3.FormatRegistry.Has(schema.format)) {\n      yield Create(ValueErrorType.StringFormatUnknown, schema, path, value);\n    } else {\n      const format = index_3.FormatRegistry.Get(schema.format);\n      if (!format(value)) {\n        yield Create(ValueErrorType.StringFormat, schema, path, value);\n      }\n    }\n  }\n}\nfunction* FromSymbol(schema, references, path, value) {\n  if (!(0, index_10.IsSymbol)(value)) yield Create(ValueErrorType.Symbol, schema, path, value);\n}\nfunction* FromTemplateLiteral(schema, references, path, value) {\n  if (!(0, index_10.IsString)(value)) return yield Create(ValueErrorType.String, schema, path, value);\n  const regex = new RegExp(schema.pattern);\n  if (!regex.test(value)) {\n    yield Create(ValueErrorType.StringPattern, schema, path, value);\n  }\n}\nfunction* FromThis(schema, references, path, value) {\n  yield* Visit((0, index_5.Deref)(schema, references), references, path, value);\n}\nfunction* FromTuple(schema, references, path, value) {\n  if (!(0, index_10.IsArray)(value)) return yield Create(ValueErrorType.Tuple, schema, path, value);\n  if (schema.items === undefined && !(value.length === 0)) {\n    return yield Create(ValueErrorType.TupleLength, schema, path, value);\n  }\n  if (!(value.length === schema.maxItems)) {\n    return yield Create(ValueErrorType.TupleLength, schema, path, value);\n  }\n  if (!schema.items) {\n    return;\n  }\n  for (let i = 0; i < schema.items.length; i++) {\n    yield* Visit(schema.items[i], references, `${path}/${i}`, value[i]);\n  }\n}\nfunction* FromUndefined(schema, references, path, value) {\n  if (!(0, index_10.IsUndefined)(value)) yield Create(ValueErrorType.Undefined, schema, path, value);\n}\nfunction* FromUnion(schema, references, path, value) {\n  if ((0, index_7.Check)(schema, references, value)) return;\n  const errors = schema.anyOf.map(variant => new ValueErrorIterator(Visit(variant, references, path, value)));\n  yield Create(ValueErrorType.Union, schema, path, value, errors);\n}\nfunction* FromUint8Array(schema, references, path, value) {\n  if (!(0, index_10.IsUint8Array)(value)) return yield Create(ValueErrorType.Uint8Array, schema, path, value);\n  if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {\n    yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value);\n  }\n  if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {\n    yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value);\n  }\n}\nfunction* FromUnknown(schema, references, path, value) {}\nfunction* FromVoid(schema, references, path, value) {\n  if (!index_1.TypeSystemPolicy.IsVoidLike(value)) yield Create(ValueErrorType.Void, schema, path, value);\n}\nfunction* FromKind(schema, references, path, value) {\n  const check = index_3.TypeRegistry.Get(schema[index_8.Kind]);\n  if (!check(schema, value)) yield Create(ValueErrorType.Kind, schema, path, value);\n}\nfunction* Visit(schema, references, path, value) {\n  const references_ = IsDefined(schema.$id) ? [...references, schema] : references;\n  const schema_ = schema;\n  switch (schema_[index_8.Kind]) {\n    case 'Any':\n      return yield* FromAny(schema_, references_, path, value);\n    case 'Array':\n      return yield* FromArray(schema_, references_, path, value);\n    case 'AsyncIterator':\n      return yield* FromAsyncIterator(schema_, references_, path, value);\n    case 'BigInt':\n      return yield* FromBigInt(schema_, references_, path, value);\n    case 'Boolean':\n      return yield* FromBoolean(schema_, references_, path, value);\n    case 'Constructor':\n      return yield* FromConstructor(schema_, references_, path, value);\n    case 'Date':\n      return yield* FromDate(schema_, references_, path, value);\n    case 'Function':\n      return yield* FromFunction(schema_, references_, path, value);\n    case 'Integer':\n      return yield* FromInteger(schema_, references_, path, value);\n    case 'Intersect':\n      return yield* FromIntersect(schema_, references_, path, value);\n    case 'Iterator':\n      return yield* FromIterator(schema_, references_, path, value);\n    case 'Literal':\n      return yield* FromLiteral(schema_, references_, path, value);\n    case 'Never':\n      return yield* FromNever(schema_, references_, path, value);\n    case 'Not':\n      return yield* FromNot(schema_, references_, path, value);\n    case 'Null':\n      return yield* FromNull(schema_, references_, path, value);\n    case 'Number':\n      return yield* FromNumber(schema_, references_, path, value);\n    case 'Object':\n      return yield* FromObject(schema_, references_, path, value);\n    case 'Promise':\n      return yield* FromPromise(schema_, references_, path, value);\n    case 'Record':\n      return yield* FromRecord(schema_, references_, path, value);\n    case 'Ref':\n      return yield* FromRef(schema_, references_, path, value);\n    case 'RegExp':\n      return yield* FromRegExp(schema_, references_, path, value);\n    case 'String':\n      return yield* FromString(schema_, references_, path, value);\n    case 'Symbol':\n      return yield* FromSymbol(schema_, references_, path, value);\n    case 'TemplateLiteral':\n      return yield* FromTemplateLiteral(schema_, references_, path, value);\n    case 'This':\n      return yield* FromThis(schema_, references_, path, value);\n    case 'Tuple':\n      return yield* FromTuple(schema_, references_, path, value);\n    case 'Undefined':\n      return yield* FromUndefined(schema_, references_, path, value);\n    case 'Union':\n      return yield* FromUnion(schema_, references_, path, value);\n    case 'Uint8Array':\n      return yield* FromUint8Array(schema_, references_, path, value);\n    case 'Unknown':\n      return yield* FromUnknown(schema_, references_, path, value);\n    case 'Void':\n      return yield* FromVoid(schema_, references_, path, value);\n    default:\n      if (!index_3.TypeRegistry.Has(schema_[index_8.Kind])) throw new ValueErrorsUnknownTypeError(schema);\n      return yield* FromKind(schema_, references_, path, value);\n  }\n}\n/** Returns an iterator for each error in this value. */\nfunction Errors(...args) {\n  const iterator = args.length === 3 ? Visit(args[0], args[1], '', args[2]) : Visit(args[0], [], '', args[1]);\n  return new ValueErrorIterator(iterator);\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","ValueErrorIterator","ValueErrorsUnknownTypeError","ValueErrorType","Errors","index_1","require","index_2","index_3","extends_undefined_1","function_1","index_4","index_5","index_6","index_7","index_8","index_9","index_10","TypeBoxError","constructor","schema","EscapeKey","key","replace","IsDefined","undefined","iterator","Symbol","First","next","done","Create","errorType","path","errors","type","message","GetErrorFunction","FromAny","references","FromArray","IsArray","Array","minItems","length","ArrayMinItems","maxItems","ArrayMaxItems","i","Visit","items","uniqueItems","set","Set","element","hashed","Hash","has","add","ArrayUniqueItems","contains","minContains","maxContains","containsSchema","Never","containsCount","reduce","acc","index","ArrayContains","IsNumber","ArrayMinContains","ArrayMaxContains","FromAsyncIterator","IsAsyncIterator","AsyncIterator","FromBigInt","IsBigInt","BigInt","exclusiveMaximum","BigIntExclusiveMaximum","exclusiveMinimum","BigIntExclusiveMinimum","maximum","BigIntMaximum","minimum","BigIntMinimum","multipleOf","BigIntMultipleOf","FromBoolean","IsBoolean","Boolean","FromConstructor","returns","prototype","FromDate","IsDate","Date","exclusiveMaximumTimestamp","getTime","DateExclusiveMaximumTimestamp","exclusiveMinimumTimestamp","DateExclusiveMinimumTimestamp","maximumTimestamp","DateMaximumTimestamp","minimumTimestamp","DateMinimumTimestamp","multipleOfTimestamp","DateMultipleOfTimestamp","FromFunction","IsFunction","Function","FromInteger","IsInteger","Integer","IntegerExclusiveMaximum","IntegerExclusiveMinimum","IntegerMaximum","IntegerMinimum","IntegerMultipleOf","FromIntersect","hasError","inner","allOf","error","Intersect","unevaluatedProperties","keyCheck","RegExp","KeyOfPattern","valueKey","getOwnPropertyNames","test","IntersectUnevaluatedProperties","FromIterator","IsIterator","Iterator","FromLiteral","const","Literal","FromNever","FromNot","not","Not","FromNull","IsNull","Null","FromNumber","TypeSystemPolicy","IsNumberLike","Number","NumberExclusiveMaximum","NumberExclusiveMinimum","NumberMaximum","NumberMinimum","NumberMultipleOf","FromObject","IsObjectLike","minProperties","ObjectMinProperties","maxProperties","ObjectMaxProperties","requiredKeys","isArray","required","knownKeys","properties","unknownKeys","requiredKey","includes","ObjectRequiredProperty","additionalProperties","ObjectAdditionalProperties","knownKey","property","ExtendsUndefinedCheck","IsExactOptionalProperty","FromPromise","IsPromise","Promise","FromRecord","IsRecordLike","patternKey","patternSchema","entries","patternProperties","regex","propertyKey","propertyValue","FromRef","Deref","FromRegExp","IsString","String","minLength","StringMinLength","maxLength","StringMaxLength","source","flags","FromString","pattern","StringPattern","format","FormatRegistry","Has","StringFormatUnknown","Get","StringFormat","FromSymbol","IsSymbol","FromTemplateLiteral","FromThis","FromTuple","Tuple","TupleLength","FromUndefined","IsUndefined","Undefined","FromUnion","Check","anyOf","map","variant","Union","FromUint8Array","IsUint8Array","Uint8Array","maxByteLength","Uint8ArrayMaxByteLength","minByteLength","Uint8ArrayMinByteLength","FromUnknown","FromVoid","IsVoidLike","Void","FromKind","check","TypeRegistry","Kind","references_","$id","schema_","args"],"sources":["C:/Users/yyash/Coding/solana-brkout/frontend/node_modules/@sinclair/typebox/build/cjs/errors/errors.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ValueErrorIterator = exports.ValueErrorsUnknownTypeError = exports.ValueErrorType = void 0;\nexports.Errors = Errors;\nconst index_1 = require(\"../system/index\");\nconst index_2 = require(\"../type/keyof/index\");\nconst index_3 = require(\"../type/registry/index\");\nconst extends_undefined_1 = require(\"../type/extends/extends-undefined\");\nconst function_1 = require(\"./function\");\nconst index_4 = require(\"../type/error/index\");\nconst index_5 = require(\"../value/deref/index\");\nconst index_6 = require(\"../value/hash/index\");\nconst index_7 = require(\"../value/check/index\");\nconst index_8 = require(\"../type/symbols/index\");\nconst index_9 = require(\"../type/never/index\");\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\n// prettier-ignore\nconst index_10 = require(\"../value/guard/index\");\n// ------------------------------------------------------------------\n// ValueErrorType\n// ------------------------------------------------------------------\nvar ValueErrorType;\n(function (ValueErrorType) {\n    ValueErrorType[ValueErrorType[\"ArrayContains\"] = 0] = \"ArrayContains\";\n    ValueErrorType[ValueErrorType[\"ArrayMaxContains\"] = 1] = \"ArrayMaxContains\";\n    ValueErrorType[ValueErrorType[\"ArrayMaxItems\"] = 2] = \"ArrayMaxItems\";\n    ValueErrorType[ValueErrorType[\"ArrayMinContains\"] = 3] = \"ArrayMinContains\";\n    ValueErrorType[ValueErrorType[\"ArrayMinItems\"] = 4] = \"ArrayMinItems\";\n    ValueErrorType[ValueErrorType[\"ArrayUniqueItems\"] = 5] = \"ArrayUniqueItems\";\n    ValueErrorType[ValueErrorType[\"Array\"] = 6] = \"Array\";\n    ValueErrorType[ValueErrorType[\"AsyncIterator\"] = 7] = \"AsyncIterator\";\n    ValueErrorType[ValueErrorType[\"BigIntExclusiveMaximum\"] = 8] = \"BigIntExclusiveMaximum\";\n    ValueErrorType[ValueErrorType[\"BigIntExclusiveMinimum\"] = 9] = \"BigIntExclusiveMinimum\";\n    ValueErrorType[ValueErrorType[\"BigIntMaximum\"] = 10] = \"BigIntMaximum\";\n    ValueErrorType[ValueErrorType[\"BigIntMinimum\"] = 11] = \"BigIntMinimum\";\n    ValueErrorType[ValueErrorType[\"BigIntMultipleOf\"] = 12] = \"BigIntMultipleOf\";\n    ValueErrorType[ValueErrorType[\"BigInt\"] = 13] = \"BigInt\";\n    ValueErrorType[ValueErrorType[\"Boolean\"] = 14] = \"Boolean\";\n    ValueErrorType[ValueErrorType[\"DateExclusiveMaximumTimestamp\"] = 15] = \"DateExclusiveMaximumTimestamp\";\n    ValueErrorType[ValueErrorType[\"DateExclusiveMinimumTimestamp\"] = 16] = \"DateExclusiveMinimumTimestamp\";\n    ValueErrorType[ValueErrorType[\"DateMaximumTimestamp\"] = 17] = \"DateMaximumTimestamp\";\n    ValueErrorType[ValueErrorType[\"DateMinimumTimestamp\"] = 18] = \"DateMinimumTimestamp\";\n    ValueErrorType[ValueErrorType[\"DateMultipleOfTimestamp\"] = 19] = \"DateMultipleOfTimestamp\";\n    ValueErrorType[ValueErrorType[\"Date\"] = 20] = \"Date\";\n    ValueErrorType[ValueErrorType[\"Function\"] = 21] = \"Function\";\n    ValueErrorType[ValueErrorType[\"IntegerExclusiveMaximum\"] = 22] = \"IntegerExclusiveMaximum\";\n    ValueErrorType[ValueErrorType[\"IntegerExclusiveMinimum\"] = 23] = \"IntegerExclusiveMinimum\";\n    ValueErrorType[ValueErrorType[\"IntegerMaximum\"] = 24] = \"IntegerMaximum\";\n    ValueErrorType[ValueErrorType[\"IntegerMinimum\"] = 25] = \"IntegerMinimum\";\n    ValueErrorType[ValueErrorType[\"IntegerMultipleOf\"] = 26] = \"IntegerMultipleOf\";\n    ValueErrorType[ValueErrorType[\"Integer\"] = 27] = \"Integer\";\n    ValueErrorType[ValueErrorType[\"IntersectUnevaluatedProperties\"] = 28] = \"IntersectUnevaluatedProperties\";\n    ValueErrorType[ValueErrorType[\"Intersect\"] = 29] = \"Intersect\";\n    ValueErrorType[ValueErrorType[\"Iterator\"] = 30] = \"Iterator\";\n    ValueErrorType[ValueErrorType[\"Kind\"] = 31] = \"Kind\";\n    ValueErrorType[ValueErrorType[\"Literal\"] = 32] = \"Literal\";\n    ValueErrorType[ValueErrorType[\"Never\"] = 33] = \"Never\";\n    ValueErrorType[ValueErrorType[\"Not\"] = 34] = \"Not\";\n    ValueErrorType[ValueErrorType[\"Null\"] = 35] = \"Null\";\n    ValueErrorType[ValueErrorType[\"NumberExclusiveMaximum\"] = 36] = \"NumberExclusiveMaximum\";\n    ValueErrorType[ValueErrorType[\"NumberExclusiveMinimum\"] = 37] = \"NumberExclusiveMinimum\";\n    ValueErrorType[ValueErrorType[\"NumberMaximum\"] = 38] = \"NumberMaximum\";\n    ValueErrorType[ValueErrorType[\"NumberMinimum\"] = 39] = \"NumberMinimum\";\n    ValueErrorType[ValueErrorType[\"NumberMultipleOf\"] = 40] = \"NumberMultipleOf\";\n    ValueErrorType[ValueErrorType[\"Number\"] = 41] = \"Number\";\n    ValueErrorType[ValueErrorType[\"ObjectAdditionalProperties\"] = 42] = \"ObjectAdditionalProperties\";\n    ValueErrorType[ValueErrorType[\"ObjectMaxProperties\"] = 43] = \"ObjectMaxProperties\";\n    ValueErrorType[ValueErrorType[\"ObjectMinProperties\"] = 44] = \"ObjectMinProperties\";\n    ValueErrorType[ValueErrorType[\"ObjectRequiredProperty\"] = 45] = \"ObjectRequiredProperty\";\n    ValueErrorType[ValueErrorType[\"Object\"] = 46] = \"Object\";\n    ValueErrorType[ValueErrorType[\"Promise\"] = 47] = \"Promise\";\n    ValueErrorType[ValueErrorType[\"RegExp\"] = 48] = \"RegExp\";\n    ValueErrorType[ValueErrorType[\"StringFormatUnknown\"] = 49] = \"StringFormatUnknown\";\n    ValueErrorType[ValueErrorType[\"StringFormat\"] = 50] = \"StringFormat\";\n    ValueErrorType[ValueErrorType[\"StringMaxLength\"] = 51] = \"StringMaxLength\";\n    ValueErrorType[ValueErrorType[\"StringMinLength\"] = 52] = \"StringMinLength\";\n    ValueErrorType[ValueErrorType[\"StringPattern\"] = 53] = \"StringPattern\";\n    ValueErrorType[ValueErrorType[\"String\"] = 54] = \"String\";\n    ValueErrorType[ValueErrorType[\"Symbol\"] = 55] = \"Symbol\";\n    ValueErrorType[ValueErrorType[\"TupleLength\"] = 56] = \"TupleLength\";\n    ValueErrorType[ValueErrorType[\"Tuple\"] = 57] = \"Tuple\";\n    ValueErrorType[ValueErrorType[\"Uint8ArrayMaxByteLength\"] = 58] = \"Uint8ArrayMaxByteLength\";\n    ValueErrorType[ValueErrorType[\"Uint8ArrayMinByteLength\"] = 59] = \"Uint8ArrayMinByteLength\";\n    ValueErrorType[ValueErrorType[\"Uint8Array\"] = 60] = \"Uint8Array\";\n    ValueErrorType[ValueErrorType[\"Undefined\"] = 61] = \"Undefined\";\n    ValueErrorType[ValueErrorType[\"Union\"] = 62] = \"Union\";\n    ValueErrorType[ValueErrorType[\"Void\"] = 63] = \"Void\";\n})(ValueErrorType || (exports.ValueErrorType = ValueErrorType = {}));\n// ------------------------------------------------------------------\n// ValueErrors\n// ------------------------------------------------------------------\nclass ValueErrorsUnknownTypeError extends index_4.TypeBoxError {\n    constructor(schema) {\n        super('Unknown type');\n        this.schema = schema;\n    }\n}\nexports.ValueErrorsUnknownTypeError = ValueErrorsUnknownTypeError;\n// ------------------------------------------------------------------\n// EscapeKey\n// ------------------------------------------------------------------\nfunction EscapeKey(key) {\n    return key.replace(/~/g, '~0').replace(/\\//g, '~1'); // RFC6901 Path\n}\n// ------------------------------------------------------------------\n// Guards\n// ------------------------------------------------------------------\nfunction IsDefined(value) {\n    return value !== undefined;\n}\n// ------------------------------------------------------------------\n// ValueErrorIterator\n// ------------------------------------------------------------------\nclass ValueErrorIterator {\n    constructor(iterator) {\n        this.iterator = iterator;\n    }\n    [Symbol.iterator]() {\n        return this.iterator;\n    }\n    /** Returns the first value error or undefined if no errors */\n    First() {\n        const next = this.iterator.next();\n        return next.done ? undefined : next.value;\n    }\n}\nexports.ValueErrorIterator = ValueErrorIterator;\n// --------------------------------------------------------------------------\n// Create\n// --------------------------------------------------------------------------\nfunction Create(errorType, schema, path, value, errors = []) {\n    return {\n        type: errorType,\n        schema,\n        path,\n        value,\n        message: (0, function_1.GetErrorFunction)()({ errorType, path, schema, value, errors }),\n        errors,\n    };\n}\n// --------------------------------------------------------------------------\n// Types\n// --------------------------------------------------------------------------\nfunction* FromAny(schema, references, path, value) { }\nfunction* FromArray(schema, references, path, value) {\n    if (!(0, index_10.IsArray)(value)) {\n        return yield Create(ValueErrorType.Array, schema, path, value);\n    }\n    if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {\n        yield Create(ValueErrorType.ArrayMinItems, schema, path, value);\n    }\n    if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {\n        yield Create(ValueErrorType.ArrayMaxItems, schema, path, value);\n    }\n    for (let i = 0; i < value.length; i++) {\n        yield* Visit(schema.items, references, `${path}/${i}`, value[i]);\n    }\n    // prettier-ignore\n    if (schema.uniqueItems === true && !((function () { const set = new Set(); for (const element of value) {\n        const hashed = (0, index_6.Hash)(element);\n        if (set.has(hashed)) {\n            return false;\n        }\n        else {\n            set.add(hashed);\n        }\n    } return true; })())) {\n        yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value);\n    }\n    // contains\n    if (!(IsDefined(schema.contains) || IsDefined(schema.minContains) || IsDefined(schema.maxContains))) {\n        return;\n    }\n    const containsSchema = IsDefined(schema.contains) ? schema.contains : (0, index_9.Never)();\n    const containsCount = value.reduce((acc, value, index) => (Visit(containsSchema, references, `${path}${index}`, value).next().done === true ? acc + 1 : acc), 0);\n    if (containsCount === 0) {\n        yield Create(ValueErrorType.ArrayContains, schema, path, value);\n    }\n    if ((0, index_10.IsNumber)(schema.minContains) && containsCount < schema.minContains) {\n        yield Create(ValueErrorType.ArrayMinContains, schema, path, value);\n    }\n    if ((0, index_10.IsNumber)(schema.maxContains) && containsCount > schema.maxContains) {\n        yield Create(ValueErrorType.ArrayMaxContains, schema, path, value);\n    }\n}\nfunction* FromAsyncIterator(schema, references, path, value) {\n    if (!(0, index_10.IsAsyncIterator)(value))\n        yield Create(ValueErrorType.AsyncIterator, schema, path, value);\n}\nfunction* FromBigInt(schema, references, path, value) {\n    if (!(0, index_10.IsBigInt)(value))\n        return yield Create(ValueErrorType.BigInt, schema, path, value);\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        yield Create(ValueErrorType.BigIntMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        yield Create(ValueErrorType.BigIntMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {\n        yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value);\n    }\n}\nfunction* FromBoolean(schema, references, path, value) {\n    if (!(0, index_10.IsBoolean)(value))\n        yield Create(ValueErrorType.Boolean, schema, path, value);\n}\nfunction* FromConstructor(schema, references, path, value) {\n    yield* Visit(schema.returns, references, path, value.prototype);\n}\nfunction* FromDate(schema, references, path, value) {\n    if (!(0, index_10.IsDate)(value))\n        return yield Create(ValueErrorType.Date, schema, path, value);\n    if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {\n        yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value);\n    }\n    if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {\n        yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value);\n    }\n    if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {\n        yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value);\n    }\n    if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {\n        yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value);\n    }\n    if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {\n        yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value);\n    }\n}\nfunction* FromFunction(schema, references, path, value) {\n    if (!(0, index_10.IsFunction)(value))\n        yield Create(ValueErrorType.Function, schema, path, value);\n}\nfunction* FromInteger(schema, references, path, value) {\n    if (!(0, index_10.IsInteger)(value))\n        return yield Create(ValueErrorType.Integer, schema, path, value);\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        yield Create(ValueErrorType.IntegerMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        yield Create(ValueErrorType.IntegerMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n        yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value);\n    }\n}\nfunction* FromIntersect(schema, references, path, value) {\n    let hasError = false;\n    for (const inner of schema.allOf) {\n        for (const error of Visit(inner, references, path, value)) {\n            hasError = true;\n            yield error;\n        }\n    }\n    if (hasError) {\n        return yield Create(ValueErrorType.Intersect, schema, path, value);\n    }\n    if (schema.unevaluatedProperties === false) {\n        const keyCheck = new RegExp((0, index_2.KeyOfPattern)(schema));\n        for (const valueKey of Object.getOwnPropertyNames(value)) {\n            if (!keyCheck.test(valueKey)) {\n                yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value);\n            }\n        }\n    }\n    if (typeof schema.unevaluatedProperties === 'object') {\n        const keyCheck = new RegExp((0, index_2.KeyOfPattern)(schema));\n        for (const valueKey of Object.getOwnPropertyNames(value)) {\n            if (!keyCheck.test(valueKey)) {\n                const next = Visit(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();\n                if (!next.done)\n                    yield next.value; // yield interior\n            }\n        }\n    }\n}\nfunction* FromIterator(schema, references, path, value) {\n    if (!(0, index_10.IsIterator)(value))\n        yield Create(ValueErrorType.Iterator, schema, path, value);\n}\nfunction* FromLiteral(schema, references, path, value) {\n    if (!(value === schema.const))\n        yield Create(ValueErrorType.Literal, schema, path, value);\n}\nfunction* FromNever(schema, references, path, value) {\n    yield Create(ValueErrorType.Never, schema, path, value);\n}\nfunction* FromNot(schema, references, path, value) {\n    if (Visit(schema.not, references, path, value).next().done === true)\n        yield Create(ValueErrorType.Not, schema, path, value);\n}\nfunction* FromNull(schema, references, path, value) {\n    if (!(0, index_10.IsNull)(value))\n        yield Create(ValueErrorType.Null, schema, path, value);\n}\nfunction* FromNumber(schema, references, path, value) {\n    if (!index_1.TypeSystemPolicy.IsNumberLike(value))\n        return yield Create(ValueErrorType.Number, schema, path, value);\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        yield Create(ValueErrorType.NumberMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        yield Create(ValueErrorType.NumberMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n        yield Create(ValueErrorType.NumberMultipleOf, schema, path, value);\n    }\n}\nfunction* FromObject(schema, references, path, value) {\n    if (!index_1.TypeSystemPolicy.IsObjectLike(value))\n        return yield Create(ValueErrorType.Object, schema, path, value);\n    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n        yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);\n    }\n    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n        yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);\n    }\n    const requiredKeys = Array.isArray(schema.required) ? schema.required : [];\n    const knownKeys = Object.getOwnPropertyNames(schema.properties);\n    const unknownKeys = Object.getOwnPropertyNames(value);\n    for (const requiredKey of requiredKeys) {\n        if (unknownKeys.includes(requiredKey))\n            continue;\n        yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);\n    }\n    if (schema.additionalProperties === false) {\n        for (const valueKey of unknownKeys) {\n            if (!knownKeys.includes(valueKey)) {\n                yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);\n            }\n        }\n    }\n    if (typeof schema.additionalProperties === 'object') {\n        for (const valueKey of unknownKeys) {\n            if (knownKeys.includes(valueKey))\n                continue;\n            yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);\n        }\n    }\n    for (const knownKey of knownKeys) {\n        const property = schema.properties[knownKey];\n        if (schema.required && schema.required.includes(knownKey)) {\n            yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);\n            if ((0, extends_undefined_1.ExtendsUndefinedCheck)(schema) && !(knownKey in value)) {\n                yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);\n            }\n        }\n        else {\n            if (index_1.TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {\n                yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);\n            }\n        }\n    }\n}\nfunction* FromPromise(schema, references, path, value) {\n    if (!(0, index_10.IsPromise)(value))\n        yield Create(ValueErrorType.Promise, schema, path, value);\n}\nfunction* FromRecord(schema, references, path, value) {\n    if (!index_1.TypeSystemPolicy.IsRecordLike(value))\n        return yield Create(ValueErrorType.Object, schema, path, value);\n    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n        yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);\n    }\n    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n        yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);\n    }\n    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];\n    const regex = new RegExp(patternKey);\n    for (const [propertyKey, propertyValue] of Object.entries(value)) {\n        if (regex.test(propertyKey))\n            yield* Visit(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n    }\n    if (typeof schema.additionalProperties === 'object') {\n        for (const [propertyKey, propertyValue] of Object.entries(value)) {\n            if (!regex.test(propertyKey))\n                yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n        }\n    }\n    if (schema.additionalProperties === false) {\n        for (const [propertyKey, propertyValue] of Object.entries(value)) {\n            if (regex.test(propertyKey))\n                continue;\n            return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n        }\n    }\n}\nfunction* FromRef(schema, references, path, value) {\n    yield* Visit((0, index_5.Deref)(schema, references), references, path, value);\n}\nfunction* FromRegExp(schema, references, path, value) {\n    if (!(0, index_10.IsString)(value))\n        return yield Create(ValueErrorType.String, schema, path, value);\n    if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {\n        yield Create(ValueErrorType.StringMinLength, schema, path, value);\n    }\n    if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {\n        yield Create(ValueErrorType.StringMaxLength, schema, path, value);\n    }\n    const regex = new RegExp(schema.source, schema.flags);\n    if (!regex.test(value)) {\n        return yield Create(ValueErrorType.RegExp, schema, path, value);\n    }\n}\nfunction* FromString(schema, references, path, value) {\n    if (!(0, index_10.IsString)(value))\n        return yield Create(ValueErrorType.String, schema, path, value);\n    if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {\n        yield Create(ValueErrorType.StringMinLength, schema, path, value);\n    }\n    if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {\n        yield Create(ValueErrorType.StringMaxLength, schema, path, value);\n    }\n    if ((0, index_10.IsString)(schema.pattern)) {\n        const regex = new RegExp(schema.pattern);\n        if (!regex.test(value)) {\n            yield Create(ValueErrorType.StringPattern, schema, path, value);\n        }\n    }\n    if ((0, index_10.IsString)(schema.format)) {\n        if (!index_3.FormatRegistry.Has(schema.format)) {\n            yield Create(ValueErrorType.StringFormatUnknown, schema, path, value);\n        }\n        else {\n            const format = index_3.FormatRegistry.Get(schema.format);\n            if (!format(value)) {\n                yield Create(ValueErrorType.StringFormat, schema, path, value);\n            }\n        }\n    }\n}\nfunction* FromSymbol(schema, references, path, value) {\n    if (!(0, index_10.IsSymbol)(value))\n        yield Create(ValueErrorType.Symbol, schema, path, value);\n}\nfunction* FromTemplateLiteral(schema, references, path, value) {\n    if (!(0, index_10.IsString)(value))\n        return yield Create(ValueErrorType.String, schema, path, value);\n    const regex = new RegExp(schema.pattern);\n    if (!regex.test(value)) {\n        yield Create(ValueErrorType.StringPattern, schema, path, value);\n    }\n}\nfunction* FromThis(schema, references, path, value) {\n    yield* Visit((0, index_5.Deref)(schema, references), references, path, value);\n}\nfunction* FromTuple(schema, references, path, value) {\n    if (!(0, index_10.IsArray)(value))\n        return yield Create(ValueErrorType.Tuple, schema, path, value);\n    if (schema.items === undefined && !(value.length === 0)) {\n        return yield Create(ValueErrorType.TupleLength, schema, path, value);\n    }\n    if (!(value.length === schema.maxItems)) {\n        return yield Create(ValueErrorType.TupleLength, schema, path, value);\n    }\n    if (!schema.items) {\n        return;\n    }\n    for (let i = 0; i < schema.items.length; i++) {\n        yield* Visit(schema.items[i], references, `${path}/${i}`, value[i]);\n    }\n}\nfunction* FromUndefined(schema, references, path, value) {\n    if (!(0, index_10.IsUndefined)(value))\n        yield Create(ValueErrorType.Undefined, schema, path, value);\n}\nfunction* FromUnion(schema, references, path, value) {\n    if ((0, index_7.Check)(schema, references, value))\n        return;\n    const errors = schema.anyOf.map((variant) => new ValueErrorIterator(Visit(variant, references, path, value)));\n    yield Create(ValueErrorType.Union, schema, path, value, errors);\n}\nfunction* FromUint8Array(schema, references, path, value) {\n    if (!(0, index_10.IsUint8Array)(value))\n        return yield Create(ValueErrorType.Uint8Array, schema, path, value);\n    if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {\n        yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value);\n    }\n    if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {\n        yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value);\n    }\n}\nfunction* FromUnknown(schema, references, path, value) { }\nfunction* FromVoid(schema, references, path, value) {\n    if (!index_1.TypeSystemPolicy.IsVoidLike(value))\n        yield Create(ValueErrorType.Void, schema, path, value);\n}\nfunction* FromKind(schema, references, path, value) {\n    const check = index_3.TypeRegistry.Get(schema[index_8.Kind]);\n    if (!check(schema, value))\n        yield Create(ValueErrorType.Kind, schema, path, value);\n}\nfunction* Visit(schema, references, path, value) {\n    const references_ = IsDefined(schema.$id) ? [...references, schema] : references;\n    const schema_ = schema;\n    switch (schema_[index_8.Kind]) {\n        case 'Any':\n            return yield* FromAny(schema_, references_, path, value);\n        case 'Array':\n            return yield* FromArray(schema_, references_, path, value);\n        case 'AsyncIterator':\n            return yield* FromAsyncIterator(schema_, references_, path, value);\n        case 'BigInt':\n            return yield* FromBigInt(schema_, references_, path, value);\n        case 'Boolean':\n            return yield* FromBoolean(schema_, references_, path, value);\n        case 'Constructor':\n            return yield* FromConstructor(schema_, references_, path, value);\n        case 'Date':\n            return yield* FromDate(schema_, references_, path, value);\n        case 'Function':\n            return yield* FromFunction(schema_, references_, path, value);\n        case 'Integer':\n            return yield* FromInteger(schema_, references_, path, value);\n        case 'Intersect':\n            return yield* FromIntersect(schema_, references_, path, value);\n        case 'Iterator':\n            return yield* FromIterator(schema_, references_, path, value);\n        case 'Literal':\n            return yield* FromLiteral(schema_, references_, path, value);\n        case 'Never':\n            return yield* FromNever(schema_, references_, path, value);\n        case 'Not':\n            return yield* FromNot(schema_, references_, path, value);\n        case 'Null':\n            return yield* FromNull(schema_, references_, path, value);\n        case 'Number':\n            return yield* FromNumber(schema_, references_, path, value);\n        case 'Object':\n            return yield* FromObject(schema_, references_, path, value);\n        case 'Promise':\n            return yield* FromPromise(schema_, references_, path, value);\n        case 'Record':\n            return yield* FromRecord(schema_, references_, path, value);\n        case 'Ref':\n            return yield* FromRef(schema_, references_, path, value);\n        case 'RegExp':\n            return yield* FromRegExp(schema_, references_, path, value);\n        case 'String':\n            return yield* FromString(schema_, references_, path, value);\n        case 'Symbol':\n            return yield* FromSymbol(schema_, references_, path, value);\n        case 'TemplateLiteral':\n            return yield* FromTemplateLiteral(schema_, references_, path, value);\n        case 'This':\n            return yield* FromThis(schema_, references_, path, value);\n        case 'Tuple':\n            return yield* FromTuple(schema_, references_, path, value);\n        case 'Undefined':\n            return yield* FromUndefined(schema_, references_, path, value);\n        case 'Union':\n            return yield* FromUnion(schema_, references_, path, value);\n        case 'Uint8Array':\n            return yield* FromUint8Array(schema_, references_, path, value);\n        case 'Unknown':\n            return yield* FromUnknown(schema_, references_, path, value);\n        case 'Void':\n            return yield* FromVoid(schema_, references_, path, value);\n        default:\n            if (!index_3.TypeRegistry.Has(schema_[index_8.Kind]))\n                throw new ValueErrorsUnknownTypeError(schema);\n            return yield* FromKind(schema_, references_, path, value);\n    }\n}\n/** Returns an iterator for each error in this value. */\nfunction Errors(...args) {\n    const iterator = args.length === 3 ? Visit(args[0], args[1], '', args[2]) : Visit(args[0], [], '', args[1]);\n    return new ValueErrorIterator(iterator);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}