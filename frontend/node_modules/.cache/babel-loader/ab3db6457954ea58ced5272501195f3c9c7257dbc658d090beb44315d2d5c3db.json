{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst fountainDecoder_1 = __importDefault(require(\"./fountainDecoder\"));\nconst bytewords_1 = __importDefault(require(\"./bytewords\"));\nconst assert_1 = __importDefault(require(\"assert\"));\nconst utils_1 = require(\"./utils\");\nconst errors_1 = require(\"./errors\");\nconst ur_1 = __importDefault(require(\"./ur\"));\nconst fountainEncoder_1 = require(\"./fountainEncoder\");\nclass URDecoder {\n  constructor(fountainDecoder = new fountainDecoder_1.default(), type = 'bytes') {\n    this.fountainDecoder = fountainDecoder;\n    this.type = type;\n    assert_1.default(utils_1.isURType(type), 'Invalid UR type');\n    this.expected_type = '';\n  }\n  static decodeBody(type, message) {\n    const cbor = bytewords_1.default.decode(message, bytewords_1.default.STYLES.MINIMAL);\n    return new ur_1.default(Buffer.from(cbor, 'hex'), type);\n  }\n  validatePart(type) {\n    if (this.expected_type) {\n      return this.expected_type === type;\n    }\n    if (!utils_1.isURType(type)) {\n      return false;\n    }\n    this.expected_type = type;\n    return true;\n  }\n  static decode(message) {\n    const [type, components] = this.parse(message);\n    if (components.length === 0) {\n      throw new errors_1.InvalidPathLengthError();\n    }\n    const body = components[0];\n    return URDecoder.decodeBody(type, body);\n  }\n  static parse(message) {\n    const lowercase = message.toLowerCase();\n    const prefix = lowercase.slice(0, 3);\n    if (prefix !== 'ur:') {\n      throw new errors_1.InvalidSchemeError();\n    }\n    const components = lowercase.slice(3).split('/');\n    const type = components[0];\n    if (components.length < 2) {\n      throw new errors_1.InvalidPathLengthError();\n    }\n    if (!utils_1.isURType(type)) {\n      throw new errors_1.InvalidTypeError();\n    }\n    return [type, components.slice(1)];\n  }\n  static parseSequenceComponent(s) {\n    const components = s.split('-');\n    if (components.length !== 2) {\n      throw new errors_1.InvalidSequenceComponentError();\n    }\n    const seqNum = utils_1.toUint32(Number(components[0]));\n    const seqLength = Number(components[1]);\n    if (seqNum < 1 || seqLength < 1) {\n      throw new errors_1.InvalidSequenceComponentError();\n    }\n    return [seqNum, seqLength];\n  }\n  receivePart(s) {\n    if (this.result !== undefined) {\n      return false;\n    }\n    const [type, components] = URDecoder.parse(s);\n    if (!this.validatePart(type)) {\n      return false;\n    }\n    // If this is a single-part UR then we're done\n    if (components.length === 1) {\n      this.result = URDecoder.decodeBody(type, components[0]);\n      return true;\n    }\n    if (components.length !== 2) {\n      throw new errors_1.InvalidPathLengthError();\n    }\n    const [seq, fragment] = components;\n    const [seqNum, seqLength] = URDecoder.parseSequenceComponent(seq);\n    const cbor = bytewords_1.default.decode(fragment, bytewords_1.default.STYLES.MINIMAL);\n    const part = fountainEncoder_1.FountainEncoderPart.fromCBOR(cbor);\n    if (seqNum !== part.seqNum || seqLength !== part.seqLength) {\n      return false;\n    }\n    if (!this.fountainDecoder.receivePart(part)) {\n      return false;\n    }\n    if (this.fountainDecoder.isSuccess()) {\n      this.result = new ur_1.default(this.fountainDecoder.resultMessage(), type);\n    } else if (this.fountainDecoder.isFailure()) {\n      this.error = new errors_1.InvalidSchemeError();\n    }\n    return true;\n  }\n  resultUR() {\n    return this.result ? this.result : new ur_1.default(Buffer.from([]));\n  }\n  isComplete() {\n    return this.result && this.result.cbor.length > 0;\n  }\n  isSuccess() {\n    return !this.error && this.isComplete();\n  }\n  isError() {\n    return this.error !== undefined;\n  }\n  resultError() {\n    return this.error ? this.error.message : '';\n  }\n  expectedPartCount() {\n    return this.fountainDecoder.expectedPartCount();\n  }\n  expectedPartIndexes() {\n    return this.fountainDecoder.getExpectedPartIndexes();\n  }\n  receivedPartIndexes() {\n    return this.fountainDecoder.getReceivedPartIndexes();\n  }\n  lastPartIndexes() {\n    return this.fountainDecoder.getLastPartIndexes();\n  }\n  estimatedPercentComplete() {\n    return this.fountainDecoder.estimatedPercentComplete();\n  }\n  getProgress() {\n    return this.fountainDecoder.getProgress();\n  }\n}\nexports.default = URDecoder;\n//# sourceMappingURL=urDecoder.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}