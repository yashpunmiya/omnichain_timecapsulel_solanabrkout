{"ast":null,"code":"import { formatAbiItem, formatAbiParams } from '../utils/abi/formatAbiItem.js';\nimport { size } from '../utils/data/size.js';\nimport { BaseError } from './base.js';\nexport class AbiConstructorNotFoundError extends BaseError {\n  constructor({\n    docsPath\n  }) {\n    super(['A constructor was not found on the ABI.', 'Make sure you are using the correct ABI and that the constructor exists on it.'].join('\\n'), {\n      docsPath,\n      name: 'AbiConstructorNotFoundError'\n    });\n  }\n}\nexport class AbiConstructorParamsNotFoundError extends BaseError {\n  constructor({\n    docsPath\n  }) {\n    super(['Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.', 'Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists.'].join('\\n'), {\n      docsPath,\n      name: 'AbiConstructorParamsNotFoundError'\n    });\n  }\n}\nexport class AbiDecodingDataSizeInvalidError extends BaseError {\n  constructor({\n    data,\n    size\n  }) {\n    super([`Data size of ${size} bytes is invalid.`, 'Size must be in increments of 32 bytes (size % 32 === 0).'].join('\\n'), {\n      metaMessages: [`Data: ${data} (${size} bytes)`],\n      name: 'AbiDecodingDataSizeInvalidError'\n    });\n  }\n}\nexport class AbiDecodingDataSizeTooSmallError extends BaseError {\n  constructor({\n    data,\n    params,\n    size\n  }) {\n    super([`Data size of ${size} bytes is too small for given parameters.`].join('\\n'), {\n      metaMessages: [`Params: (${formatAbiParams(params, {\n        includeName: true\n      })})`, `Data:   ${data} (${size} bytes)`],\n      name: 'AbiDecodingDataSizeTooSmallError'\n    });\n    Object.defineProperty(this, \"data\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"params\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"size\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.data = data;\n    this.params = params;\n    this.size = size;\n  }\n}\nexport class AbiDecodingZeroDataError extends BaseError {\n  constructor() {\n    super('Cannot decode zero data (\"0x\") with ABI parameters.', {\n      name: 'AbiDecodingZeroDataError'\n    });\n  }\n}\nexport class AbiEncodingArrayLengthMismatchError extends BaseError {\n  constructor({\n    expectedLength,\n    givenLength,\n    type\n  }) {\n    super([`ABI encoding array length mismatch for type ${type}.`, `Expected length: ${expectedLength}`, `Given length: ${givenLength}`].join('\\n'), {\n      name: 'AbiEncodingArrayLengthMismatchError'\n    });\n  }\n}\nexport class AbiEncodingBytesSizeMismatchError extends BaseError {\n  constructor({\n    expectedSize,\n    value\n  }) {\n    super(`Size of bytes \"${value}\" (bytes${size(value)}) does not match expected size (bytes${expectedSize}).`, {\n      name: 'AbiEncodingBytesSizeMismatchError'\n    });\n  }\n}\nexport class AbiEncodingLengthMismatchError extends BaseError {\n  constructor({\n    expectedLength,\n    givenLength\n  }) {\n    super(['ABI encoding params/values length mismatch.', `Expected length (params): ${expectedLength}`, `Given length (values): ${givenLength}`].join('\\n'), {\n      name: 'AbiEncodingLengthMismatchError'\n    });\n  }\n}\nexport class AbiErrorInputsNotFoundError extends BaseError {\n  constructor(errorName, {\n    docsPath\n  }) {\n    super([`Arguments (\\`args\\`) were provided to \"${errorName}\", but \"${errorName}\" on the ABI does not contain any parameters (\\`inputs\\`).`, 'Cannot encode error result without knowing what the parameter types are.', 'Make sure you are using the correct ABI and that the inputs exist on it.'].join('\\n'), {\n      docsPath,\n      name: 'AbiErrorInputsNotFoundError'\n    });\n  }\n}\nexport class AbiErrorNotFoundError extends BaseError {\n  constructor(errorName, {\n    docsPath\n  } = {}) {\n    super([`Error ${errorName ? `\"${errorName}\" ` : ''}not found on ABI.`, 'Make sure you are using the correct ABI and that the error exists on it.'].join('\\n'), {\n      docsPath,\n      name: 'AbiErrorNotFoundError'\n    });\n  }\n}\nexport class AbiErrorSignatureNotFoundError extends BaseError {\n  constructor(signature, {\n    docsPath\n  }) {\n    super([`Encoded error signature \"${signature}\" not found on ABI.`, 'Make sure you are using the correct ABI and that the error exists on it.', `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`].join('\\n'), {\n      docsPath,\n      name: 'AbiErrorSignatureNotFoundError'\n    });\n    Object.defineProperty(this, \"signature\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.signature = signature;\n  }\n}\nexport class AbiEventSignatureEmptyTopicsError extends BaseError {\n  constructor({\n    docsPath\n  }) {\n    super('Cannot extract event signature from empty topics.', {\n      docsPath,\n      name: 'AbiEventSignatureEmptyTopicsError'\n    });\n  }\n}\nexport class AbiEventSignatureNotFoundError extends BaseError {\n  constructor(signature, {\n    docsPath\n  }) {\n    super([`Encoded event signature \"${signature}\" not found on ABI.`, 'Make sure you are using the correct ABI and that the event exists on it.', `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`].join('\\n'), {\n      docsPath,\n      name: 'AbiEventSignatureNotFoundError'\n    });\n  }\n}\nexport class AbiEventNotFoundError extends BaseError {\n  constructor(eventName, {\n    docsPath\n  } = {}) {\n    super([`Event ${eventName ? `\"${eventName}\" ` : ''}not found on ABI.`, 'Make sure you are using the correct ABI and that the event exists on it.'].join('\\n'), {\n      docsPath,\n      name: 'AbiEventNotFoundError'\n    });\n  }\n}\nexport class AbiFunctionNotFoundError extends BaseError {\n  constructor(functionName, {\n    docsPath\n  } = {}) {\n    super([`Function ${functionName ? `\"${functionName}\" ` : ''}not found on ABI.`, 'Make sure you are using the correct ABI and that the function exists on it.'].join('\\n'), {\n      docsPath,\n      name: 'AbiFunctionNotFoundError'\n    });\n  }\n}\nexport class AbiFunctionOutputsNotFoundError extends BaseError {\n  constructor(functionName, {\n    docsPath\n  }) {\n    super([`Function \"${functionName}\" does not contain any \\`outputs\\` on ABI.`, 'Cannot decode function result without knowing what the parameter types are.', 'Make sure you are using the correct ABI and that the function exists on it.'].join('\\n'), {\n      docsPath,\n      name: 'AbiFunctionOutputsNotFoundError'\n    });\n  }\n}\nexport class AbiFunctionSignatureNotFoundError extends BaseError {\n  constructor(signature, {\n    docsPath\n  }) {\n    super([`Encoded function signature \"${signature}\" not found on ABI.`, 'Make sure you are using the correct ABI and that the function exists on it.', `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`].join('\\n'), {\n      docsPath,\n      name: 'AbiFunctionSignatureNotFoundError'\n    });\n  }\n}\nexport class AbiItemAmbiguityError extends BaseError {\n  constructor(x, y) {\n    super('Found ambiguous types in overloaded ABI items.', {\n      metaMessages: [`\\`${x.type}\\` in \\`${formatAbiItem(x.abiItem)}\\`, and`, `\\`${y.type}\\` in \\`${formatAbiItem(y.abiItem)}\\``, '', 'These types encode differently and cannot be distinguished at runtime.', 'Remove one of the ambiguous items in the ABI.'],\n      name: 'AbiItemAmbiguityError'\n    });\n  }\n}\nexport class BytesSizeMismatchError extends BaseError {\n  constructor({\n    expectedSize,\n    givenSize\n  }) {\n    super(`Expected bytes${expectedSize}, got bytes${givenSize}.`, {\n      name: 'BytesSizeMismatchError'\n    });\n  }\n}\nexport class DecodeLogDataMismatch extends BaseError {\n  constructor({\n    abiItem,\n    data,\n    params,\n    size\n  }) {\n    super([`Data size of ${size} bytes is too small for non-indexed event parameters.`].join('\\n'), {\n      metaMessages: [`Params: (${formatAbiParams(params, {\n        includeName: true\n      })})`, `Data:   ${data} (${size} bytes)`],\n      name: 'DecodeLogDataMismatch'\n    });\n    Object.defineProperty(this, \"abiItem\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"data\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"params\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"size\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.abiItem = abiItem;\n    this.data = data;\n    this.params = params;\n    this.size = size;\n  }\n}\nexport class DecodeLogTopicsMismatch extends BaseError {\n  constructor({\n    abiItem,\n    param\n  }) {\n    super([`Expected a topic for indexed event parameter${param.name ? ` \"${param.name}\"` : ''} on event \"${formatAbiItem(abiItem, {\n      includeName: true\n    })}\".`].join('\\n'), {\n      name: 'DecodeLogTopicsMismatch'\n    });\n    Object.defineProperty(this, \"abiItem\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.abiItem = abiItem;\n  }\n}\nexport class InvalidAbiEncodingTypeError extends BaseError {\n  constructor(type, {\n    docsPath\n  }) {\n    super([`Type \"${type}\" is not a valid encoding type.`, 'Please provide a valid ABI type.'].join('\\n'), {\n      docsPath,\n      name: 'InvalidAbiEncodingType'\n    });\n  }\n}\nexport class InvalidAbiDecodingTypeError extends BaseError {\n  constructor(type, {\n    docsPath\n  }) {\n    super([`Type \"${type}\" is not a valid decoding type.`, 'Please provide a valid ABI type.'].join('\\n'), {\n      docsPath,\n      name: 'InvalidAbiDecodingType'\n    });\n  }\n}\nexport class InvalidArrayError extends BaseError {\n  constructor(value) {\n    super([`Value \"${value}\" is not a valid array.`].join('\\n'), {\n      name: 'InvalidArrayError'\n    });\n  }\n}\nexport class InvalidDefinitionTypeError extends BaseError {\n  constructor(type) {\n    super([`\"${type}\" is not a valid definition type.`, 'Valid types: \"function\", \"event\", \"error\"'].join('\\n'), {\n      name: 'InvalidDefinitionTypeError'\n    });\n  }\n}\nexport class UnsupportedPackedAbiType extends BaseError {\n  constructor(type) {\n    super(`Type \"${type}\" is not supported for packed encoding.`, {\n      name: 'UnsupportedPackedAbiType'\n    });\n  }\n}\n//# sourceMappingURL=abi.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}