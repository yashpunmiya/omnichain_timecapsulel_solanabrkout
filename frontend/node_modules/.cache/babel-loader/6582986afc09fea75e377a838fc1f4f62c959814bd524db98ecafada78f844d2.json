{"ast":null,"code":"import { BlockNotFoundError } from '../../errors/block.js';\nimport { TransactionNotFoundError, TransactionReceiptNotFoundError, WaitForTransactionReceiptTimeoutError } from '../../errors/transaction.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { observe } from '../../utils/observe.js';\nimport { withResolvers } from '../../utils/promise/withResolvers.js';\nimport { withRetry } from '../../utils/promise/withRetry.js';\nimport { stringify } from '../../utils/stringify.js';\nimport { getBlock } from './getBlock.js';\nimport { getTransaction } from './getTransaction.js';\nimport { getTransactionReceipt } from './getTransactionReceipt.js';\nimport { watchBlockNumber } from './watchBlockNumber.js';\n/**\n * Waits for the [Transaction](https://viem.sh/docs/glossary/terms#transaction) to be included on a [Block](https://viem.sh/docs/glossary/terms#block) (one confirmation), and then returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms#transaction-receipt).\n *\n * - Docs: https://viem.sh/docs/actions/public/waitForTransactionReceipt\n * - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_sending-transactions\n * - JSON-RPC Methods:\n *   - Polls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) on each block until it has been processed.\n *   - If a Transaction has been replaced:\n *     - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) and extracts the transactions\n *     - Checks if one of the Transactions is a replacement\n *     - If so, calls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt).\n *\n * The `waitForTransactionReceipt` action additionally supports Replacement detection (e.g. sped up Transactions).\n *\n * Transactions can be replaced when a user modifies their transaction in their wallet (to speed up or cancel). Transactions are replaced when they are sent from the same nonce.\n *\n * There are 3 types of Transaction Replacement reasons:\n *\n * - `repriced`: The gas price has been modified (e.g. different `maxFeePerGas`)\n * - `cancelled`: The Transaction has been cancelled (e.g. `value === 0n`)\n * - `replaced`: The Transaction has been replaced (e.g. different `value` or `data`)\n *\n * @param client - Client to use\n * @param parameters - {@link WaitForTransactionReceiptParameters}\n * @returns The transaction receipt. {@link WaitForTransactionReceiptReturnType}\n *\n * @example\n * import { createPublicClient, waitForTransactionReceipt, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const transactionReceipt = await waitForTransactionReceipt(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport async function waitForTransactionReceipt(client, {\n  confirmations = 1,\n  hash,\n  onReplaced,\n  pollingInterval = client.pollingInterval,\n  retryCount = 6,\n  retryDelay = ({\n    count\n  }) => ~~(1 << count) * 200,\n  // exponential backoff\n  timeout = 180_000\n}) {\n  const observerId = stringify(['waitForTransactionReceipt', client.uid, hash]);\n  let transaction;\n  let replacedTransaction;\n  let receipt;\n  let retrying = false;\n  const {\n    promise,\n    resolve,\n    reject\n  } = withResolvers();\n  const timer = timeout ? setTimeout(() => reject(new WaitForTransactionReceiptTimeoutError({\n    hash\n  })), timeout) : undefined;\n  const _unobserve = observe(observerId, {\n    onReplaced,\n    resolve,\n    reject\n  }, emit => {\n    const _unwatch = getAction(client, watchBlockNumber, 'watchBlockNumber')({\n      emitMissed: true,\n      emitOnBegin: true,\n      poll: true,\n      pollingInterval,\n      async onBlockNumber(blockNumber_) {\n        const done = fn => {\n          clearTimeout(timer);\n          _unwatch();\n          fn();\n          _unobserve();\n        };\n        let blockNumber = blockNumber_;\n        if (retrying) return;\n        try {\n          // If we already have a valid receipt, let's check if we have enough\n          // confirmations. If we do, then we can resolve.\n          if (receipt) {\n            if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations)) return;\n            done(() => emit.resolve(receipt));\n            return;\n          }\n          // Get the transaction to check if it's been replaced.\n          // We need to retry as some RPC Providers may be slow to sync\n          // up mined transactions.\n          if (!transaction) {\n            retrying = true;\n            await withRetry(async () => {\n              transaction = await getAction(client, getTransaction, 'getTransaction')({\n                hash\n              });\n              if (transaction.blockNumber) blockNumber = transaction.blockNumber;\n            }, {\n              delay: retryDelay,\n              retryCount\n            });\n            retrying = false;\n          }\n          // Get the receipt to check if it's been processed.\n          receipt = await getAction(client, getTransactionReceipt, 'getTransactionReceipt')({\n            hash\n          });\n          // Check if we have enough confirmations. If not, continue polling.\n          if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations)) return;\n          done(() => emit.resolve(receipt));\n        } catch (err) {\n          // If the receipt is not found, the transaction will be pending.\n          // We need to check if it has potentially been replaced.\n          if (err instanceof TransactionNotFoundError || err instanceof TransactionReceiptNotFoundError) {\n            if (!transaction) {\n              retrying = false;\n              return;\n            }\n            try {\n              replacedTransaction = transaction;\n              // Let's retrieve the transactions from the current block.\n              // We need to retry as some RPC Providers may be slow to sync\n              // up mined blocks.\n              retrying = true;\n              const block = await withRetry(() => getAction(client, getBlock, 'getBlock')({\n                blockNumber,\n                includeTransactions: true\n              }), {\n                delay: retryDelay,\n                retryCount,\n                shouldRetry: ({\n                  error\n                }) => error instanceof BlockNotFoundError\n              });\n              retrying = false;\n              const replacementTransaction = block.transactions.find(({\n                from,\n                nonce\n              }) => from === replacedTransaction.from && nonce === replacedTransaction.nonce);\n              // If we couldn't find a replacement transaction, continue polling.\n              if (!replacementTransaction) return;\n              // If we found a replacement transaction, return it's receipt.\n              receipt = await getAction(client, getTransactionReceipt, 'getTransactionReceipt')({\n                hash: replacementTransaction.hash\n              });\n              // Check if we have enough confirmations. If not, continue polling.\n              if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations)) return;\n              let reason = 'replaced';\n              if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value && replacementTransaction.input === replacedTransaction.input) {\n                reason = 'repriced';\n              } else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) {\n                reason = 'cancelled';\n              }\n              done(() => {\n                emit.onReplaced?.({\n                  reason,\n                  replacedTransaction: replacedTransaction,\n                  transaction: replacementTransaction,\n                  transactionReceipt: receipt\n                });\n                emit.resolve(receipt);\n              });\n            } catch (err_) {\n              done(() => emit.reject(err_));\n            }\n          } else {\n            done(() => emit.reject(err));\n          }\n        }\n      }\n    });\n  });\n  return promise;\n}\n//# sourceMappingURL=waitForTransactionReceipt.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}