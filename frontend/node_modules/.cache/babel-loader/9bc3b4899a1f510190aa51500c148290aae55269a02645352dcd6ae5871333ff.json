{"ast":null,"code":"import semver from \"semver\";\n/**\n * The USB product IDs will be defined as MMII, encoding a model (MM) and an interface bitfield (II)\n *\n ** Model\n * Ledger Nano S : 0x10\n * Ledger Blue : 0x00\n * Ledger Nano X : 0x40\n *\n ** Interface support bitfield\n * Generic HID : 0x01\n * Keyboard HID : 0x02\n * U2F : 0x04\n * CCID : 0x08\n * WebUSB : 0x10\n */\nexport const IIGenericHID = 0x01;\nexport const IIKeyboardHID = 0x02;\nexport const IIU2F = 0x04;\nexport const IICCID = 0x08;\nexport const IIWebUSB = 0x10;\nexport var DeviceModelId;\n(function (DeviceModelId) {\n  /** Ledger Blue */\n  DeviceModelId[\"blue\"] = \"blue\";\n  /** Ledger Nano S */\n  DeviceModelId[\"nanoS\"] = \"nanoS\";\n  /** Ledger Nano S Plus */\n  DeviceModelId[\"nanoSP\"] = \"nanoSP\";\n  /** Ledger Nano X */\n  DeviceModelId[\"nanoX\"] = \"nanoX\";\n  /** Ledger Stax */\n  DeviceModelId[\"stax\"] = \"stax\";\n  /** Ledger Flex (\"europa\" is the internal name) */\n  DeviceModelId[\"europa\"] = \"europa\";\n})(DeviceModelId || (DeviceModelId = {}));\nconst devices = {\n  [DeviceModelId.blue]: {\n    id: DeviceModelId.blue,\n    productName: \"Ledger Blue\",\n    productIdMM: 0x00,\n    legacyUsbProductId: 0x0000,\n    usbOnly: true,\n    memorySize: 480 * 1024,\n    masks: [0x31000000, 0x31010000],\n    getBlockSize: _firwareVersion => 4 * 1024\n  },\n  [DeviceModelId.nanoS]: {\n    id: DeviceModelId.nanoS,\n    productName: \"Ledger Nano S\",\n    productIdMM: 0x10,\n    legacyUsbProductId: 0x0001,\n    usbOnly: true,\n    memorySize: 320 * 1024,\n    masks: [0x31100000],\n    getBlockSize: firmwareVersion => {\n      var _a;\n      return semver.lt((_a = semver.coerce(firmwareVersion)) !== null && _a !== void 0 ? _a : \"\", \"2.0.0\") ? 4 * 1024 : 2 * 1024;\n    }\n  },\n  [DeviceModelId.nanoX]: {\n    id: DeviceModelId.nanoX,\n    productName: \"Ledger Nano X\",\n    productIdMM: 0x40,\n    legacyUsbProductId: 0x0004,\n    usbOnly: false,\n    memorySize: 2 * 1024 * 1024,\n    masks: [0x33000000],\n    getBlockSize: _firwareVersion => 4 * 1024,\n    bluetoothSpec: [{\n      serviceUuid: \"13d63400-2c97-0004-0000-4c6564676572\",\n      notifyUuid: \"13d63400-2c97-0004-0001-4c6564676572\",\n      writeUuid: \"13d63400-2c97-0004-0002-4c6564676572\",\n      writeCmdUuid: \"13d63400-2c97-0004-0003-4c6564676572\"\n    }]\n  },\n  [DeviceModelId.nanoSP]: {\n    id: DeviceModelId.nanoSP,\n    productName: \"Ledger Nano S Plus\",\n    productIdMM: 0x50,\n    legacyUsbProductId: 0x0005,\n    usbOnly: true,\n    memorySize: 1533 * 1024,\n    masks: [0x33100000],\n    getBlockSize: _firmwareVersion => 32\n  },\n  [DeviceModelId.stax]: {\n    id: DeviceModelId.stax,\n    productName: \"Ledger Stax\",\n    productIdMM: 0x60,\n    legacyUsbProductId: 0x0006,\n    usbOnly: false,\n    memorySize: 1533 * 1024,\n    masks: [0x33200000],\n    getBlockSize: _firmwareVersion => 32,\n    bluetoothSpec: [{\n      serviceUuid: \"13d63400-2c97-6004-0000-4c6564676572\",\n      notifyUuid: \"13d63400-2c97-6004-0001-4c6564676572\",\n      writeUuid: \"13d63400-2c97-6004-0002-4c6564676572\",\n      writeCmdUuid: \"13d63400-2c97-6004-0003-4c6564676572\"\n    }]\n  },\n  [DeviceModelId.europa]: {\n    id: DeviceModelId.europa,\n    productName: \"Ledger Flex\",\n    productIdMM: 0x70,\n    legacyUsbProductId: 0x0007,\n    usbOnly: false,\n    memorySize: 1533 * 1024,\n    masks: [0x33300000],\n    getBlockSize: _firmwareVersion => 32,\n    bluetoothSpec: [{\n      serviceUuid: \"13d63400-2c97-3004-0000-4c6564676572\",\n      notifyUuid: \"13d63400-2c97-3004-0001-4c6564676572\",\n      writeUuid: \"13d63400-2c97-3004-0002-4c6564676572\",\n      writeCmdUuid: \"13d63400-2c97-3004-0003-4c6564676572\"\n    }]\n  }\n};\nconst productMap = {\n  Blue: DeviceModelId.blue,\n  \"Nano S\": DeviceModelId.nanoS,\n  \"Nano S Plus\": DeviceModelId.nanoSP,\n  \"Nano X\": DeviceModelId.nanoX,\n  Stax: DeviceModelId.stax,\n  Europa: DeviceModelId.europa\n};\nconst devicesList = Object.values(devices);\n/**\n *\n */\nexport const ledgerUSBVendorId = 0x2c97;\n/**\n *\n */\nexport const getDeviceModel = id => {\n  const info = devices[id];\n  if (!info) throw new Error(\"device '\" + id + \"' does not exist\");\n  return info;\n};\n/**\n * Given a `targetId`, return the deviceModel associated to it,\n * based on the first two bytes.\n */\nexport const identifyTargetId = targetId => {\n  const deviceModel = devicesList.find(({\n    masks\n  }) => masks.find(mask => (targetId & 0xffff0000) === mask));\n  return deviceModel;\n};\n/**\n * From a given USB product id, return the deviceModel associated to it.\n *\n * The mapping from the product id is only based on the 2 most significant bytes.\n * For example, Stax is defined with a product id of 0x60ii, a product id 0x6011 would be mapped to it.\n */\nexport const identifyUSBProductId = usbProductId => {\n  const legacy = devicesList.find(d => d.legacyUsbProductId === usbProductId);\n  if (legacy) return legacy;\n  const mm = usbProductId >> 8;\n  const deviceModel = devicesList.find(d => d.productIdMM === mm);\n  return deviceModel;\n};\nexport const identifyProductName = productName => {\n  const deviceModel = devicesList.find(d => d.id === productMap[productName]);\n  return deviceModel;\n};\nconst bluetoothServices = [];\nconst serviceUuidToInfos = {};\nfor (const id in devices) {\n  const deviceModel = devices[id];\n  const {\n    bluetoothSpec\n  } = deviceModel;\n  if (bluetoothSpec) {\n    for (let i = 0; i < bluetoothSpec.length; i++) {\n      const spec = bluetoothSpec[i];\n      bluetoothServices.push(spec.serviceUuid);\n      serviceUuidToInfos[spec.serviceUuid] = serviceUuidToInfos[spec.serviceUuid.replace(/-/g, \"\")] = Object.assign({\n        deviceModel\n      }, spec);\n    }\n  }\n}\n/**\n *\n */\nexport const getBluetoothServiceUuids = () => bluetoothServices;\n/**\n *\n */\nexport const getInfosForServiceUuid = uuid => serviceUuidToInfos[uuid.toLowerCase()];\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}