{"ast":null,"code":"import { IEvents as o } from \"@walletconnect/events\";\nimport n, { EventEmitter as l } from \"events\";\nvar a = Object.defineProperty,\n  u = (e, s, r) => s in e ? a(e, s, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: r\n  }) : e[s] = r,\n  c = (e, s, r) => u(e, typeof s != \"symbol\" ? s + \"\" : s, r);\nclass h extends o {\n  constructor(s) {\n    super(), this.opts = s, c(this, \"protocol\", \"wc\"), c(this, \"version\", 2);\n  }\n}\nclass g {\n  constructor(s, r, t) {\n    this.core = s, this.logger = r;\n  }\n}\nvar p = Object.defineProperty,\n  b = (e, s, r) => s in e ? p(e, s, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: r\n  }) : e[s] = r,\n  v = (e, s, r) => b(e, typeof s != \"symbol\" ? s + \"\" : s, r);\nclass I extends o {\n  constructor(s, r) {\n    super(), this.core = s, this.logger = r, v(this, \"records\", new Map());\n  }\n}\nclass y {\n  constructor(s, r) {\n    this.logger = s, this.core = r;\n  }\n}\nclass m extends o {\n  constructor(s, r) {\n    super(), this.relayer = s, this.logger = r;\n  }\n}\nclass d extends o {\n  constructor(s) {\n    super();\n  }\n}\nclass f {\n  constructor(s, r, t, q) {\n    this.core = s, this.logger = r, this.name = t;\n  }\n}\nvar E = Object.defineProperty,\n  x = (e, s, r) => s in e ? E(e, s, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: r\n  }) : e[s] = r,\n  w = (e, s, r) => x(e, typeof s != \"symbol\" ? s + \"\" : s, r);\nclass C {\n  constructor() {\n    w(this, \"map\", new Map());\n  }\n}\nclass P extends o {\n  constructor(s, r) {\n    super(), this.relayer = s, this.logger = r;\n  }\n}\nclass j {\n  constructor(s, r) {\n    this.core = s, this.logger = r;\n  }\n}\nclass S extends o {\n  constructor(s, r) {\n    super(), this.core = s, this.logger = r;\n  }\n}\nclass $ {\n  constructor(s, r) {\n    this.logger = s, this.core = r;\n  }\n}\nclass M {\n  constructor(s, r, t) {\n    this.core = s, this.logger = r, this.store = t;\n  }\n}\nclass O {\n  constructor(s, r) {\n    this.projectId = s, this.logger = r;\n  }\n}\nclass R {\n  constructor(s, r, t) {\n    this.core = s, this.logger = r, this.telemetryEnabled = t;\n  }\n}\nvar T = Object.defineProperty,\n  k = (e, s, r) => s in e ? T(e, s, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: r\n  }) : e[s] = r,\n  i = (e, s, r) => k(e, typeof s != \"symbol\" ? s + \"\" : s, r);\nclass H extends n {\n  constructor() {\n    super();\n  }\n}\nclass J {\n  constructor(s) {\n    this.opts = s, i(this, \"protocol\", \"wc\"), i(this, \"version\", 2);\n  }\n}\nclass K extends l {\n  constructor() {\n    super();\n  }\n}\nclass V {\n  constructor(s) {\n    this.client = s;\n  }\n}\nexport { h as ICore, g as ICrypto, O as IEchoClient, V as IEngine, K as IEngineEvents, R as IEventClient, S as IExpirer, I as IJsonRpcHistory, j as IKeyChain, y as IMessageTracker, $ as IPairing, m as IPublisher, d as IRelayer, J as ISignClient, H as ISignClientEvents, f as IStore, P as ISubscriber, C as ISubscriberTopicMap, M as IVerify };\n//# sourceMappingURL=index.es.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}