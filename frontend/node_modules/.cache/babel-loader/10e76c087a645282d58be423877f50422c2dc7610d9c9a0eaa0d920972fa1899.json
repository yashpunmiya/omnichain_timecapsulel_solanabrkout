{"ast":null,"code":"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/* replacement start */\nconst process = require('process/');\n\n/* replacement end */\n\nconst {\n  ArrayPrototypeIndexOf,\n  NumberIsInteger,\n  NumberIsNaN,\n  NumberParseInt,\n  ObjectDefineProperties,\n  ObjectKeys,\n  ObjectSetPrototypeOf,\n  Promise,\n  SafeSet,\n  SymbolAsyncDispose,\n  SymbolAsyncIterator,\n  Symbol\n} = require('../../ours/primordials');\nmodule.exports = Readable;\nReadable.ReadableState = ReadableState;\nconst {\n  EventEmitter: EE\n} = require('events');\nconst {\n  Stream,\n  prependListener\n} = require('./legacy');\nconst {\n  Buffer\n} = require('buffer');\nconst {\n  addAbortSignal\n} = require('./add-abort-signal');\nconst eos = require('./end-of-stream');\nlet debug = require('../../ours/util').debuglog('stream', fn => {\n  debug = fn;\n});\nconst BufferList = require('./buffer_list');\nconst destroyImpl = require('./destroy');\nconst {\n  getHighWaterMark,\n  getDefaultHighWaterMark\n} = require('./state');\nconst {\n  aggregateTwoErrors,\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_OUT_OF_RANGE,\n    ERR_STREAM_PUSH_AFTER_EOF,\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT\n  },\n  AbortError\n} = require('../../ours/errors');\nconst {\n  validateObject\n} = require('../validators');\nconst kPaused = Symbol('kPaused');\nconst {\n  StringDecoder\n} = require('string_decoder/');\nconst from = require('./from');\nObjectSetPrototypeOf(Readable.prototype, Stream.prototype);\nObjectSetPrototypeOf(Readable, Stream);\nconst nop = () => {};\nconst {\n  errorOrDestroy\n} = destroyImpl;\nconst kObjectMode = 1 << 0;\nconst kEnded = 1 << 1;\nconst kEndEmitted = 1 << 2;\nconst kReading = 1 << 3;\nconst kConstructed = 1 << 4;\nconst kSync = 1 << 5;\nconst kNeedReadable = 1 << 6;\nconst kEmittedReadable = 1 << 7;\nconst kReadableListening = 1 << 8;\nconst kResumeScheduled = 1 << 9;\nconst kErrorEmitted = 1 << 10;\nconst kEmitClose = 1 << 11;\nconst kAutoDestroy = 1 << 12;\nconst kDestroyed = 1 << 13;\nconst kClosed = 1 << 14;\nconst kCloseEmitted = 1 << 15;\nconst kMultiAwaitDrain = 1 << 16;\nconst kReadingMore = 1 << 17;\nconst kDataEmitted = 1 << 18;\n\n// TODO(benjamingr) it is likely slower to do it this way than with free functions\nfunction makeBitMapDescriptor(bit) {\n  return {\n    enumerable: false,\n    get() {\n      return (this.state & bit) !== 0;\n    },\n    set(value) {\n      if (value) this.state |= bit;else this.state &= ~bit;\n    }\n  };\n}\nObjectDefineProperties(ReadableState.prototype, {\n  objectMode: makeBitMapDescriptor(kObjectMode),\n  ended: makeBitMapDescriptor(kEnded),\n  endEmitted: makeBitMapDescriptor(kEndEmitted),\n  reading: makeBitMapDescriptor(kReading),\n  // Stream is still being constructed and cannot be\n  // destroyed until construction finished or failed.\n  // Async construction is opt in, therefore we start as\n  // constructed.\n  constructed: makeBitMapDescriptor(kConstructed),\n  // A flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  sync: makeBitMapDescriptor(kSync),\n  // Whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  needReadable: makeBitMapDescriptor(kNeedReadable),\n  emittedReadable: makeBitMapDescriptor(kEmittedReadable),\n  readableListening: makeBitMapDescriptor(kReadableListening),\n  resumeScheduled: makeBitMapDescriptor(kResumeScheduled),\n  // True if the error was already emitted and should not be thrown again.\n  errorEmitted: makeBitMapDescriptor(kErrorEmitted),\n  emitClose: makeBitMapDescriptor(kEmitClose),\n  autoDestroy: makeBitMapDescriptor(kAutoDestroy),\n  // Has it been destroyed.\n  destroyed: makeBitMapDescriptor(kDestroyed),\n  // Indicates whether the stream has finished destroying.\n  closed: makeBitMapDescriptor(kClosed),\n  // True if close has been emitted or would have been emitted\n  // depending on emitClose.\n  closeEmitted: makeBitMapDescriptor(kCloseEmitted),\n  multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain),\n  // If true, a maybeReadMore has been scheduled.\n  readingMore: makeBitMapDescriptor(kReadingMore),\n  dataEmitted: makeBitMapDescriptor(kDataEmitted)\n});\nfunction ReadableState(options, stream, isDuplex) {\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof require('./duplex');\n\n  // Bit map field to store ReadableState more effciently with 1 bit per field\n  // instead of a V8 slot per field.\n  this.state = kEmitClose | kAutoDestroy | kConstructed | kSync;\n  // Object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away.\n  if (options && options.objectMode) this.state |= kObjectMode;\n  if (isDuplex && options && options.readableObjectMode) this.state |= kObjectMode;\n\n  // The point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  this.highWaterMark = options ? getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex) : getDefaultHighWaterMark(false);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift().\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = [];\n  this.flowing = null;\n  this[kPaused] = null;\n\n  // Should close be emitted on destroy. Defaults to true.\n  if (options && options.emitClose === false) this.state &= ~kEmitClose;\n\n  // Should .destroy() be called after 'end' (and potentially 'finish').\n  if (options && options.autoDestroy === false) this.state &= ~kAutoDestroy;\n\n  // Indicates whether the stream has errored. When true no further\n  // _read calls, 'data' or 'readable' events should occur. This is needed\n  // since when autoDestroy is disabled we need a way to tell whether the\n  // stream has failed.\n  this.errored = null;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options && options.defaultEncoding || 'utf8';\n\n  // Ref the piped dest which we need a drain event on it\n  // type: null | Writable | Set<Writable>.\n  this.awaitDrainWriters = null;\n  this.decoder = null;\n  this.encoding = null;\n  if (options && options.encoding) {\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\nfunction Readable(options) {\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5.\n  const isDuplex = this instanceof require('./duplex');\n  this._readableState = new ReadableState(options, this, isDuplex);\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n    if (typeof options.construct === 'function') this._construct = options.construct;\n    if (options.signal && !isDuplex) addAbortSignal(options.signal, this);\n  }\n  Stream.call(this, options);\n  destroyImpl.construct(this, () => {\n    if (this._readableState.needReadable) {\n      maybeReadMore(this, this._readableState);\n    }\n  });\n}\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n};\nReadable.prototype[EE.captureRejectionSymbol] = function (err) {\n  this.destroy(err);\n};\nReadable.prototype[SymbolAsyncDispose] = function () {\n  let error;\n  if (!this.destroyed) {\n    error = this.readableEnded ? null : new AbortError();\n    this.destroy(error);\n  }\n  return new Promise((resolve, reject) => eos(this, err => err && err !== error ? reject(err) : resolve(null)));\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  return readableAddChunk(this, chunk, encoding, false);\n};\n\n// Unshift should *always* be something directly out of read().\nReadable.prototype.unshift = function (chunk, encoding) {\n  return readableAddChunk(this, chunk, encoding, true);\n};\nfunction readableAddChunk(stream, chunk, encoding, addToFront) {\n  debug('readableAddChunk', chunk);\n  const state = stream._readableState;\n  let err;\n  if ((state.state & kObjectMode) === 0) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (state.encoding !== encoding) {\n        if (addToFront && state.encoding) {\n          // When unshifting, if state.encoding is set, we have to save\n          // the string in the BufferList with the state encoding.\n          chunk = Buffer.from(chunk, encoding).toString(state.encoding);\n        } else {\n          chunk = Buffer.from(chunk, encoding);\n          encoding = '';\n        }\n      }\n    } else if (chunk instanceof Buffer) {\n      encoding = '';\n    } else if (Stream._isUint8Array(chunk)) {\n      chunk = Stream._uint8ArrayToBuffer(chunk);\n      encoding = '';\n    } else if (chunk != null) {\n      err = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n    }\n  }\n  if (err) {\n    errorOrDestroy(stream, err);\n  } else if (chunk === null) {\n    state.state &= ~kReading;\n    onEofChunk(stream, state);\n  } else if ((state.state & kObjectMode) !== 0 || chunk && chunk.length > 0) {\n    if (addToFront) {\n      if ((state.state & kEndEmitted) !== 0) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else if (state.destroyed || state.errored) return false;else addChunk(stream, state, chunk, true);\n    } else if (state.ended) {\n      errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n    } else if (state.destroyed || state.errored) {\n      return false;\n    } else {\n      state.state &= ~kReading;\n      if (state.decoder && !encoding) {\n        chunk = state.decoder.write(chunk);\n        if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n      } else {\n        addChunk(stream, state, chunk, false);\n      }\n    }\n  } else if (!addToFront) {\n    state.state &= ~kReading;\n    maybeReadMore(stream, state);\n  }\n\n  // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount('data') > 0) {\n    // Use the guard to avoid creating `Set()` repeatedly\n    // when we have multiple pipes.\n    if ((state.state & kMultiAwaitDrain) !== 0) {\n      state.awaitDrainWriters.clear();\n    } else {\n      state.awaitDrainWriters = null;\n    }\n    state.dataEmitted = true;\n    stream.emit('data', chunk);\n  } else {\n    // Update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if ((state.state & kNeedReadable) !== 0) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\nReadable.prototype.isPaused = function () {\n  const state = this._readableState;\n  return state[kPaused] === true || state.flowing === false;\n};\n\n// Backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  const decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder;\n  // If setEncoding(null), decoder.encoding equals utf8.\n  this._readableState.encoding = this._readableState.decoder.encoding;\n  const buffer = this._readableState.buffer;\n  // Iterate over current buffer to convert already stored Buffers:\n  let content = '';\n  for (const data of buffer) {\n    content += decoder.write(data);\n  }\n  buffer.clear();\n  if (content !== '') buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n};\n\n// Don't raise the hwm > 1GB.\nconst MAX_HWM = 0x40000000;\nfunction computeNewHighWaterMark(n) {\n  if (n > MAX_HWM) {\n    throw new ERR_OUT_OF_RANGE('size', '<= 1GiB', n);\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts.\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if ((state.state & kObjectMode) !== 0) return 1;\n  if (NumberIsNaN(n)) {\n    // Only flow one buffer at a time.\n    if (state.flowing && state.length) return state.buffer.first().length;\n    return state.length;\n  }\n  if (n <= state.length) return n;\n  return state.ended ? state.length : 0;\n}\n\n// You can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  // Same as parseInt(undefined, 10), however V8 7.3 performance regressed\n  // in this scenario, so we are doing it manually.\n  if (n === undefined) {\n    n = NaN;\n  } else if (!NumberIsInteger(n)) {\n    n = NumberParseInt(n, 10);\n  }\n  const state = this._readableState;\n  const nOrig = n;\n\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n !== 0) state.state &= ~kEmittedReadable;\n\n  // If we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n  n = howMuchToRead(n, state);\n\n  // If we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  let doRead = (state.state & kNeedReadable) !== 0;\n  debug('need readable', doRead);\n\n  // If we currently have less than the highWaterMark, then also read some.\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // However, if we've ended, then there's no point, if we're already\n  // reading, then it's unnecessary, if we're constructing we have to wait,\n  // and if we're destroyed or errored, then it's not allowed,\n  if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {\n    doRead = false;\n    debug('reading, ended or constructing', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.state |= kReading | kSync;\n    // If the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.state |= kNeedReadable;\n\n    // Call internal read method\n    try {\n      this._read(state.highWaterMark);\n    } catch (err) {\n      errorOrDestroy(this, err);\n    }\n    state.state &= ~kSync;\n\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n  let ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    if (state.multiAwaitDrain) {\n      state.awaitDrainWriters.clear();\n    } else {\n      state.awaitDrainWriters = null;\n    }\n  }\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n  if (ret !== null && !state.errorEmitted && !state.closeEmitted) {\n    state.dataEmitted = true;\n    this.emit('data', ret);\n  }\n  return ret;\n};\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n  if (state.decoder) {\n    const chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n  if (state.sync) {\n    // If we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call.\n    emitReadable(stream);\n  } else {\n    // Emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n    state.emittedReadable = true;\n    // We have to emit readable now that we are EOF. Modules\n    // in the ecosystem (e.g. dicer) rely on this event being sync.\n    emitReadable_(stream);\n  }\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  const state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\nfunction emitReadable_(stream) {\n  const state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n  if (!state.destroyed && !state.errored && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  }\n\n  // The stream needs another readable event if:\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n}\n\n// At this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore && state.constructed) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    const len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // Didn't get any data, stop spinning.\n      break;\n  }\n  state.readingMore = false;\n}\n\n// Abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  throw new ERR_METHOD_NOT_IMPLEMENTED('_read()');\n};\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  const src = this;\n  const state = this._readableState;\n  if (state.pipes.length === 1) {\n    if (!state.multiAwaitDrain) {\n      state.multiAwaitDrain = true;\n      state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);\n    }\n  }\n  state.pipes.push(dest);\n  debug('pipe count=%d opts=%j', state.pipes.length, pipeOpts);\n  const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  const endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n  let ondrain;\n  let cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // Cleanup event handlers once the pipe is broken.\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    if (ondrain) {\n      dest.removeListener('drain', ondrain);\n    }\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true;\n\n    // If the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n  function pause() {\n    // If the user unpiped during `dest.write()`, it is possible\n    // to get stuck in a permanently paused state if that write\n    // also returned false.\n    // => Check whether `dest` is still a piping destination.\n    if (!cleanedUp) {\n      if (state.pipes.length === 1 && state.pipes[0] === dest) {\n        debug('false write response, pause', 0);\n        state.awaitDrainWriters = dest;\n        state.multiAwaitDrain = false;\n      } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {\n        debug('false write response, pause', state.awaitDrainWriters.size);\n        state.awaitDrainWriters.add(dest);\n      }\n      src.pause();\n    }\n    if (!ondrain) {\n      // When the dest drains, it reduces the awaitDrain counter\n      // on the source.  This would be more elegant with a .once()\n      // handler in flow(), but adding and removing repeatedly is\n      // too slow.\n      ondrain = pipeOnDrain(src, dest);\n      dest.on('drain', ondrain);\n    }\n  }\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    const ret = dest.write(chunk);\n    debug('dest.write', ret);\n    if (ret === false) {\n      pause();\n    }\n  }\n\n  // If the dest has an error, then stop piping into it.\n  // However, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (dest.listenerCount('error') === 0) {\n      const s = dest._writableState || dest._readableState;\n      if (s && !s.errorEmitted) {\n        // User incorrectly emitted 'error' directly on the stream.\n        errorOrDestroy(dest, er);\n      } else {\n        dest.emit('error', er);\n      }\n    }\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // Tell the dest that it's being piped to.\n  dest.emit('pipe', src);\n\n  // Start the flow if it hasn't been started already.\n\n  if (dest.writableNeedDrain === true) {\n    pause();\n  } else if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n  return dest;\n};\nfunction pipeOnDrain(src, dest) {\n  return function pipeOnDrainFunctionResult() {\n    const state = src._readableState;\n\n    // `ondrain` will call directly,\n    // `this` maybe not a reference to dest,\n    // so we use the real dest here.\n    if (state.awaitDrainWriters === dest) {\n      debug('pipeOnDrain', 1);\n      state.awaitDrainWriters = null;\n    } else if (state.multiAwaitDrain) {\n      debug('pipeOnDrain', state.awaitDrainWriters.size);\n      state.awaitDrainWriters.delete(dest);\n    }\n    if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount('data')) {\n      src.resume();\n    }\n  };\n}\nReadable.prototype.unpipe = function (dest) {\n  const state = this._readableState;\n  const unpipeInfo = {\n    hasUnpiped: false\n  };\n\n  // If we're not piping anywhere, then do nothing.\n  if (state.pipes.length === 0) return this;\n  if (!dest) {\n    // remove all.\n    const dests = state.pipes;\n    state.pipes = [];\n    this.pause();\n    for (let i = 0; i < dests.length; i++) dests[i].emit('unpipe', this, {\n      hasUnpiped: false\n    });\n    return this;\n  }\n\n  // Try to find the right one.\n  const index = ArrayPrototypeIndexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  if (state.pipes.length === 0) this.pause();\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n};\n\n// Set up data events if they are asked for\n// Ensure readable listeners eventually get something.\nReadable.prototype.on = function (ev, fn) {\n  const res = Stream.prototype.on.call(this, ev, fn);\n  const state = this._readableState;\n  if (ev === 'data') {\n    // Update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0;\n\n    // Try start flowing on next tick if stream isn't explicitly paused.\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\nReadable.prototype.removeListener = function (ev, fn) {\n  const res = Stream.prototype.removeListener.call(this, ev, fn);\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n  return res;\n};\nReadable.prototype.off = Readable.prototype.removeListener;\nReadable.prototype.removeAllListeners = function (ev) {\n  const res = Stream.prototype.removeAllListeners.apply(this, arguments);\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n  return res;\n};\nfunction updateReadableListening(self) {\n  const state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n  if (state.resumeScheduled && state[kPaused] === false) {\n    // Flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true;\n\n    // Crude way to check if we should resume.\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  } else if (!state.readableListening) {\n    state.flowing = null;\n  }\n}\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  const state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    // We flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume().\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n  state[kPaused] = false;\n  return this;\n};\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n  if (!state.reading) {\n    stream.read(0);\n  }\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  this._readableState[kPaused] = true;\n  return this;\n};\nfunction flow(stream) {\n  const state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null);\n}\n\n// Wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  let paused = false;\n\n  // TODO (ronag): Should this.destroy(err) emit\n  // 'error' on the wrapped stream? Would require\n  // a static factory method, e.g. Readable.wrap(stream).\n\n  stream.on('data', chunk => {\n    if (!this.push(chunk) && stream.pause) {\n      paused = true;\n      stream.pause();\n    }\n  });\n  stream.on('end', () => {\n    this.push(null);\n  });\n  stream.on('error', err => {\n    errorOrDestroy(this, err);\n  });\n  stream.on('close', () => {\n    this.destroy();\n  });\n  stream.on('destroy', () => {\n    this.destroy();\n  });\n  this._read = () => {\n    if (paused && stream.resume) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  // Proxy all the other methods. Important when wrapping filters and duplexes.\n  const streamKeys = ObjectKeys(stream);\n  for (let j = 1; j < streamKeys.length; j++) {\n    const i = streamKeys[j];\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = stream[i].bind(stream);\n    }\n  }\n  return this;\n};\nReadable.prototype[SymbolAsyncIterator] = function () {\n  return streamToAsyncIterator(this);\n};\nReadable.prototype.iterator = function (options) {\n  if (options !== undefined) {\n    validateObject(options, 'options');\n  }\n  return streamToAsyncIterator(this, options);\n};\nfunction streamToAsyncIterator(stream, options) {\n  if (typeof stream.read !== 'function') {\n    stream = Readable.wrap(stream, {\n      objectMode: true\n    });\n  }\n  const iter = createAsyncIterator(stream, options);\n  iter.stream = stream;\n  return iter;\n}\nasync function* createAsyncIterator(stream, options) {\n  let callback = nop;\n  function next(resolve) {\n    if (this === stream) {\n      callback();\n      callback = nop;\n    } else {\n      callback = resolve;\n    }\n  }\n  stream.on('readable', next);\n  let error;\n  const cleanup = eos(stream, {\n    writable: false\n  }, err => {\n    error = err ? aggregateTwoErrors(error, err) : null;\n    callback();\n    callback = nop;\n  });\n  try {\n    while (true) {\n      const chunk = stream.destroyed ? null : stream.read();\n      if (chunk !== null) {\n        yield chunk;\n      } else if (error) {\n        throw error;\n      } else if (error === null) {\n        return;\n      } else {\n        await new Promise(next);\n      }\n    }\n  } catch (err) {\n    error = aggregateTwoErrors(error, err);\n    throw error;\n  } finally {\n    if ((error || (options === null || options === undefined ? undefined : options.destroyOnReturn) !== false) && (error === undefined || stream._readableState.autoDestroy)) {\n      destroyImpl.destroyer(stream, null);\n    } else {\n      stream.off('readable', next);\n      cleanup();\n    }\n  }\n}\n\n// Making it explicit these properties are not enumerable\n// because otherwise some prototype manipulation in\n// userland will fail.\nObjectDefineProperties(Readable.prototype, {\n  readable: {\n    __proto__: null,\n    get() {\n      const r = this._readableState;\n      // r.readable === false means that this is part of a Duplex stream\n      // where the readable side was disabled upon construction.\n      // Compat. The user might manually disable readable side through\n      // deprecated setter.\n      return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;\n    },\n    set(val) {\n      // Backwards compat.\n      if (this._readableState) {\n        this._readableState.readable = !!val;\n      }\n    }\n  },\n  readableDidRead: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return this._readableState.dataEmitted;\n    }\n  },\n  readableAborted: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);\n    }\n  },\n  readableHighWaterMark: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return this._readableState.highWaterMark;\n    }\n  },\n  readableBuffer: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return this._readableState && this._readableState.buffer;\n    }\n  },\n  readableFlowing: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return this._readableState.flowing;\n    },\n    set: function (state) {\n      if (this._readableState) {\n        this._readableState.flowing = state;\n      }\n    }\n  },\n  readableLength: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState.length;\n    }\n  },\n  readableObjectMode: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.objectMode : false;\n    }\n  },\n  readableEncoding: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.encoding : null;\n    }\n  },\n  errored: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.errored : null;\n    }\n  },\n  closed: {\n    __proto__: null,\n    get() {\n      return this._readableState ? this._readableState.closed : false;\n    }\n  },\n  destroyed: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.destroyed : false;\n    },\n    set(value) {\n      // We ignore the value if the stream\n      // has not been initialized yet.\n      if (!this._readableState) {\n        return;\n      }\n\n      // Backward compatibility, the user is explicitly\n      // managing destroyed.\n      this._readableState.destroyed = value;\n    }\n  },\n  readableEnded: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.endEmitted : false;\n    }\n  }\n});\nObjectDefineProperties(ReadableState.prototype, {\n  // Legacy getter for `pipesCount`.\n  pipesCount: {\n    __proto__: null,\n    get() {\n      return this.pipes.length;\n    }\n  },\n  // Legacy property for `paused`.\n  paused: {\n    __proto__: null,\n    get() {\n      return this[kPaused] !== false;\n    },\n    set(value) {\n      this[kPaused] = !!value;\n    }\n  }\n});\n\n// Exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered.\n  if (state.length === 0) return null;\n  let ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // Read it all, truncate the list.\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list.\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\nfunction endReadable(stream) {\n  const state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length);\n\n  // Check that we didn't get one last unshift.\n  if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.emit('end');\n    if (stream.writable && stream.allowHalfOpen === false) {\n      process.nextTick(endWritableNT, stream);\n    } else if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well.\n      const wState = stream._writableState;\n      const autoDestroy = !wState || wState.autoDestroy && (\n      // We don't expect the writable to ever 'finish'\n      // if writable is explicitly set to false.\n      wState.finished || wState.writable === false);\n      if (autoDestroy) {\n        stream.destroy();\n      }\n    }\n  }\n}\nfunction endWritableNT(stream) {\n  const writable = stream.writable && !stream.writableEnded && !stream.destroyed;\n  if (writable) {\n    stream.end();\n  }\n}\nReadable.from = function (iterable, opts) {\n  return from(Readable, iterable, opts);\n};\nlet webStreamsAdapters;\n\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === undefined) webStreamsAdapters = {};\n  return webStreamsAdapters;\n}\nReadable.fromWeb = function (readableStream, options) {\n  return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);\n};\nReadable.toWeb = function (streamReadable, options) {\n  return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options);\n};\nReadable.wrap = function (src, options) {\n  var _ref, _src$readableObjectMo;\n  return new Readable({\n    objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== undefined ? _src$readableObjectMo : src.objectMode) !== null && _ref !== undefined ? _ref : true,\n    ...options,\n    destroy(err, callback) {\n      destroyImpl.destroyer(src, err);\n      callback(err);\n    }\n  }).wrap(src);\n};","map":{"version":3,"names":["process","require","ArrayPrototypeIndexOf","NumberIsInteger","NumberIsNaN","NumberParseInt","ObjectDefineProperties","ObjectKeys","ObjectSetPrototypeOf","Promise","SafeSet","SymbolAsyncDispose","SymbolAsyncIterator","Symbol","module","exports","Readable","ReadableState","EventEmitter","EE","Stream","prependListener","Buffer","addAbortSignal","eos","debug","debuglog","fn","BufferList","destroyImpl","getHighWaterMark","getDefaultHighWaterMark","aggregateTwoErrors","codes","ERR_INVALID_ARG_TYPE","ERR_METHOD_NOT_IMPLEMENTED","ERR_OUT_OF_RANGE","ERR_STREAM_PUSH_AFTER_EOF","ERR_STREAM_UNSHIFT_AFTER_END_EVENT","AbortError","validateObject","kPaused","StringDecoder","from","prototype","nop","errorOrDestroy","kObjectMode","kEnded","kEndEmitted","kReading","kConstructed","kSync","kNeedReadable","kEmittedReadable","kReadableListening","kResumeScheduled","kErrorEmitted","kEmitClose","kAutoDestroy","kDestroyed","kClosed","kCloseEmitted","kMultiAwaitDrain","kReadingMore","kDataEmitted","makeBitMapDescriptor","bit","enumerable","get","state","set","value","objectMode","ended","endEmitted","reading","constructed","sync","needReadable","emittedReadable","readableListening","resumeScheduled","errorEmitted","emitClose","autoDestroy","destroyed","closed","closeEmitted","multiAwaitDrain","readingMore","dataEmitted","options","stream","isDuplex","readableObjectMode","highWaterMark","buffer","length","pipes","flowing","errored","defaultEncoding","awaitDrainWriters","decoder","encoding","_readableState","read","_read","destroy","_destroy","construct","_construct","signal","call","maybeReadMore","_undestroy","undestroy","err","cb","captureRejectionSymbol","error","readableEnded","resolve","reject","push","chunk","readableAddChunk","unshift","addToFront","toString","_isUint8Array","_uint8ArrayToBuffer","onEofChunk","addChunk","write","listenerCount","clear","emit","emitReadable","isPaused","setEncoding","enc","content","data","MAX_HWM","computeNewHighWaterMark","n","howMuchToRead","first","undefined","NaN","nOrig","endReadable","doRead","ret","fromList","end","emitReadable_","nextTick","flow","maybeReadMore_","len","pipe","dest","pipeOpts","src","doEnd","stdout","stderr","endFn","onend","unpipe","once","on","onunpipe","readable","unpipeInfo","hasUnpiped","cleanup","ondrain","cleanedUp","removeListener","onclose","onfinish","onerror","ondata","_writableState","needDrain","pause","includes","size","add","pipeOnDrain","er","s","writableNeedDrain","resume","pipeOnDrainFunctionResult","delete","dests","i","index","splice","ev","res","nReadingNextTick","addListener","updateReadableListening","off","removeAllListeners","apply","arguments","self","resume_","wrap","paused","streamKeys","j","bind","streamToAsyncIterator","iterator","iter","createAsyncIterator","callback","next","writable","destroyOnReturn","destroyer","__proto__","r","val","readableDidRead","readableAborted","readableHighWaterMark","readableBuffer","readableFlowing","readableLength","readableEncoding","pipesCount","_fromList","shift","join","concat","consume","endReadableNT","allowHalfOpen","endWritableNT","wState","finished","writableEnded","iterable","opts","webStreamsAdapters","lazyWebStreams","fromWeb","readableStream","newStreamReadableFromReadableStream","toWeb","streamReadable","newReadableStreamFromStreamReadable","_ref","_src$readableObjectMo"],"sources":["C:/Users/yyash/Coding/solana-brkout/frontend/node_modules/readable-stream/lib/internal/streams/readable.js"],"sourcesContent":["// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict'\n\n/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */\n\nconst {\n  ArrayPrototypeIndexOf,\n  NumberIsInteger,\n  NumberIsNaN,\n  NumberParseInt,\n  ObjectDefineProperties,\n  ObjectKeys,\n  ObjectSetPrototypeOf,\n  Promise,\n  SafeSet,\n  SymbolAsyncDispose,\n  SymbolAsyncIterator,\n  Symbol\n} = require('../../ours/primordials')\nmodule.exports = Readable\nReadable.ReadableState = ReadableState\nconst { EventEmitter: EE } = require('events')\nconst { Stream, prependListener } = require('./legacy')\nconst { Buffer } = require('buffer')\nconst { addAbortSignal } = require('./add-abort-signal')\nconst eos = require('./end-of-stream')\nlet debug = require('../../ours/util').debuglog('stream', (fn) => {\n  debug = fn\n})\nconst BufferList = require('./buffer_list')\nconst destroyImpl = require('./destroy')\nconst { getHighWaterMark, getDefaultHighWaterMark } = require('./state')\nconst {\n  aggregateTwoErrors,\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_OUT_OF_RANGE,\n    ERR_STREAM_PUSH_AFTER_EOF,\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT\n  },\n  AbortError\n} = require('../../ours/errors')\nconst { validateObject } = require('../validators')\nconst kPaused = Symbol('kPaused')\nconst { StringDecoder } = require('string_decoder/')\nconst from = require('./from')\nObjectSetPrototypeOf(Readable.prototype, Stream.prototype)\nObjectSetPrototypeOf(Readable, Stream)\nconst nop = () => {}\nconst { errorOrDestroy } = destroyImpl\nconst kObjectMode = 1 << 0\nconst kEnded = 1 << 1\nconst kEndEmitted = 1 << 2\nconst kReading = 1 << 3\nconst kConstructed = 1 << 4\nconst kSync = 1 << 5\nconst kNeedReadable = 1 << 6\nconst kEmittedReadable = 1 << 7\nconst kReadableListening = 1 << 8\nconst kResumeScheduled = 1 << 9\nconst kErrorEmitted = 1 << 10\nconst kEmitClose = 1 << 11\nconst kAutoDestroy = 1 << 12\nconst kDestroyed = 1 << 13\nconst kClosed = 1 << 14\nconst kCloseEmitted = 1 << 15\nconst kMultiAwaitDrain = 1 << 16\nconst kReadingMore = 1 << 17\nconst kDataEmitted = 1 << 18\n\n// TODO(benjamingr) it is likely slower to do it this way than with free functions\nfunction makeBitMapDescriptor(bit) {\n  return {\n    enumerable: false,\n    get() {\n      return (this.state & bit) !== 0\n    },\n    set(value) {\n      if (value) this.state |= bit\n      else this.state &= ~bit\n    }\n  }\n}\nObjectDefineProperties(ReadableState.prototype, {\n  objectMode: makeBitMapDescriptor(kObjectMode),\n  ended: makeBitMapDescriptor(kEnded),\n  endEmitted: makeBitMapDescriptor(kEndEmitted),\n  reading: makeBitMapDescriptor(kReading),\n  // Stream is still being constructed and cannot be\n  // destroyed until construction finished or failed.\n  // Async construction is opt in, therefore we start as\n  // constructed.\n  constructed: makeBitMapDescriptor(kConstructed),\n  // A flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  sync: makeBitMapDescriptor(kSync),\n  // Whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  needReadable: makeBitMapDescriptor(kNeedReadable),\n  emittedReadable: makeBitMapDescriptor(kEmittedReadable),\n  readableListening: makeBitMapDescriptor(kReadableListening),\n  resumeScheduled: makeBitMapDescriptor(kResumeScheduled),\n  // True if the error was already emitted and should not be thrown again.\n  errorEmitted: makeBitMapDescriptor(kErrorEmitted),\n  emitClose: makeBitMapDescriptor(kEmitClose),\n  autoDestroy: makeBitMapDescriptor(kAutoDestroy),\n  // Has it been destroyed.\n  destroyed: makeBitMapDescriptor(kDestroyed),\n  // Indicates whether the stream has finished destroying.\n  closed: makeBitMapDescriptor(kClosed),\n  // True if close has been emitted or would have been emitted\n  // depending on emitClose.\n  closeEmitted: makeBitMapDescriptor(kCloseEmitted),\n  multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain),\n  // If true, a maybeReadMore has been scheduled.\n  readingMore: makeBitMapDescriptor(kReadingMore),\n  dataEmitted: makeBitMapDescriptor(kDataEmitted)\n})\nfunction ReadableState(options, stream, isDuplex) {\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof require('./duplex')\n\n  // Bit map field to store ReadableState more effciently with 1 bit per field\n  // instead of a V8 slot per field.\n  this.state = kEmitClose | kAutoDestroy | kConstructed | kSync\n  // Object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away.\n  if (options && options.objectMode) this.state |= kObjectMode\n  if (isDuplex && options && options.readableObjectMode) this.state |= kObjectMode\n\n  // The point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  this.highWaterMark = options\n    ? getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex)\n    : getDefaultHighWaterMark(false)\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift().\n  this.buffer = new BufferList()\n  this.length = 0\n  this.pipes = []\n  this.flowing = null\n  this[kPaused] = null\n\n  // Should close be emitted on destroy. Defaults to true.\n  if (options && options.emitClose === false) this.state &= ~kEmitClose\n\n  // Should .destroy() be called after 'end' (and potentially 'finish').\n  if (options && options.autoDestroy === false) this.state &= ~kAutoDestroy\n\n  // Indicates whether the stream has errored. When true no further\n  // _read calls, 'data' or 'readable' events should occur. This is needed\n  // since when autoDestroy is disabled we need a way to tell whether the\n  // stream has failed.\n  this.errored = null\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = (options && options.defaultEncoding) || 'utf8'\n\n  // Ref the piped dest which we need a drain event on it\n  // type: null | Writable | Set<Writable>.\n  this.awaitDrainWriters = null\n  this.decoder = null\n  this.encoding = null\n  if (options && options.encoding) {\n    this.decoder = new StringDecoder(options.encoding)\n    this.encoding = options.encoding\n  }\n}\nfunction Readable(options) {\n  if (!(this instanceof Readable)) return new Readable(options)\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5.\n  const isDuplex = this instanceof require('./duplex')\n  this._readableState = new ReadableState(options, this, isDuplex)\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read\n    if (typeof options.destroy === 'function') this._destroy = options.destroy\n    if (typeof options.construct === 'function') this._construct = options.construct\n    if (options.signal && !isDuplex) addAbortSignal(options.signal, this)\n  }\n  Stream.call(this, options)\n  destroyImpl.construct(this, () => {\n    if (this._readableState.needReadable) {\n      maybeReadMore(this, this._readableState)\n    }\n  })\n}\nReadable.prototype.destroy = destroyImpl.destroy\nReadable.prototype._undestroy = destroyImpl.undestroy\nReadable.prototype._destroy = function (err, cb) {\n  cb(err)\n}\nReadable.prototype[EE.captureRejectionSymbol] = function (err) {\n  this.destroy(err)\n}\nReadable.prototype[SymbolAsyncDispose] = function () {\n  let error\n  if (!this.destroyed) {\n    error = this.readableEnded ? null : new AbortError()\n    this.destroy(error)\n  }\n  return new Promise((resolve, reject) => eos(this, (err) => (err && err !== error ? reject(err) : resolve(null))))\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  return readableAddChunk(this, chunk, encoding, false)\n}\n\n// Unshift should *always* be something directly out of read().\nReadable.prototype.unshift = function (chunk, encoding) {\n  return readableAddChunk(this, chunk, encoding, true)\n}\nfunction readableAddChunk(stream, chunk, encoding, addToFront) {\n  debug('readableAddChunk', chunk)\n  const state = stream._readableState\n  let err\n  if ((state.state & kObjectMode) === 0) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding\n      if (state.encoding !== encoding) {\n        if (addToFront && state.encoding) {\n          // When unshifting, if state.encoding is set, we have to save\n          // the string in the BufferList with the state encoding.\n          chunk = Buffer.from(chunk, encoding).toString(state.encoding)\n        } else {\n          chunk = Buffer.from(chunk, encoding)\n          encoding = ''\n        }\n      }\n    } else if (chunk instanceof Buffer) {\n      encoding = ''\n    } else if (Stream._isUint8Array(chunk)) {\n      chunk = Stream._uint8ArrayToBuffer(chunk)\n      encoding = ''\n    } else if (chunk != null) {\n      err = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk)\n    }\n  }\n  if (err) {\n    errorOrDestroy(stream, err)\n  } else if (chunk === null) {\n    state.state &= ~kReading\n    onEofChunk(stream, state)\n  } else if ((state.state & kObjectMode) !== 0 || (chunk && chunk.length > 0)) {\n    if (addToFront) {\n      if ((state.state & kEndEmitted) !== 0) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT())\n      else if (state.destroyed || state.errored) return false\n      else addChunk(stream, state, chunk, true)\n    } else if (state.ended) {\n      errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF())\n    } else if (state.destroyed || state.errored) {\n      return false\n    } else {\n      state.state &= ~kReading\n      if (state.decoder && !encoding) {\n        chunk = state.decoder.write(chunk)\n        if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false)\n        else maybeReadMore(stream, state)\n      } else {\n        addChunk(stream, state, chunk, false)\n      }\n    }\n  } else if (!addToFront) {\n    state.state &= ~kReading\n    maybeReadMore(stream, state)\n  }\n\n  // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0)\n}\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount('data') > 0) {\n    // Use the guard to avoid creating `Set()` repeatedly\n    // when we have multiple pipes.\n    if ((state.state & kMultiAwaitDrain) !== 0) {\n      state.awaitDrainWriters.clear()\n    } else {\n      state.awaitDrainWriters = null\n    }\n    state.dataEmitted = true\n    stream.emit('data', chunk)\n  } else {\n    // Update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length\n    if (addToFront) state.buffer.unshift(chunk)\n    else state.buffer.push(chunk)\n    if ((state.state & kNeedReadable) !== 0) emitReadable(stream)\n  }\n  maybeReadMore(stream, state)\n}\nReadable.prototype.isPaused = function () {\n  const state = this._readableState\n  return state[kPaused] === true || state.flowing === false\n}\n\n// Backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  const decoder = new StringDecoder(enc)\n  this._readableState.decoder = decoder\n  // If setEncoding(null), decoder.encoding equals utf8.\n  this._readableState.encoding = this._readableState.decoder.encoding\n  const buffer = this._readableState.buffer\n  // Iterate over current buffer to convert already stored Buffers:\n  let content = ''\n  for (const data of buffer) {\n    content += decoder.write(data)\n  }\n  buffer.clear()\n  if (content !== '') buffer.push(content)\n  this._readableState.length = content.length\n  return this\n}\n\n// Don't raise the hwm > 1GB.\nconst MAX_HWM = 0x40000000\nfunction computeNewHighWaterMark(n) {\n  if (n > MAX_HWM) {\n    throw new ERR_OUT_OF_RANGE('size', '<= 1GiB', n)\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts.\n    n--\n    n |= n >>> 1\n    n |= n >>> 2\n    n |= n >>> 4\n    n |= n >>> 8\n    n |= n >>> 16\n    n++\n  }\n  return n\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || (state.length === 0 && state.ended)) return 0\n  if ((state.state & kObjectMode) !== 0) return 1\n  if (NumberIsNaN(n)) {\n    // Only flow one buffer at a time.\n    if (state.flowing && state.length) return state.buffer.first().length\n    return state.length\n  }\n  if (n <= state.length) return n\n  return state.ended ? state.length : 0\n}\n\n// You can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n)\n  // Same as parseInt(undefined, 10), however V8 7.3 performance regressed\n  // in this scenario, so we are doing it manually.\n  if (n === undefined) {\n    n = NaN\n  } else if (!NumberIsInteger(n)) {\n    n = NumberParseInt(n, 10)\n  }\n  const state = this._readableState\n  const nOrig = n\n\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n)\n  if (n !== 0) state.state &= ~kEmittedReadable\n\n  // If we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (\n    n === 0 &&\n    state.needReadable &&\n    ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)\n  ) {\n    debug('read: emitReadable', state.length, state.ended)\n    if (state.length === 0 && state.ended) endReadable(this)\n    else emitReadable(this)\n    return null\n  }\n  n = howMuchToRead(n, state)\n\n  // If we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this)\n    return null\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  let doRead = (state.state & kNeedReadable) !== 0\n  debug('need readable', doRead)\n\n  // If we currently have less than the highWaterMark, then also read some.\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true\n    debug('length less than watermark', doRead)\n  }\n\n  // However, if we've ended, then there's no point, if we're already\n  // reading, then it's unnecessary, if we're constructing we have to wait,\n  // and if we're destroyed or errored, then it's not allowed,\n  if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {\n    doRead = false\n    debug('reading, ended or constructing', doRead)\n  } else if (doRead) {\n    debug('do read')\n    state.state |= kReading | kSync\n    // If the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.state |= kNeedReadable\n\n    // Call internal read method\n    try {\n      this._read(state.highWaterMark)\n    } catch (err) {\n      errorOrDestroy(this, err)\n    }\n    state.state &= ~kSync\n\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state)\n  }\n  let ret\n  if (n > 0) ret = fromList(n, state)\n  else ret = null\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark\n    n = 0\n  } else {\n    state.length -= n\n    if (state.multiAwaitDrain) {\n      state.awaitDrainWriters.clear()\n    } else {\n      state.awaitDrainWriters = null\n    }\n  }\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this)\n  }\n  if (ret !== null && !state.errorEmitted && !state.closeEmitted) {\n    state.dataEmitted = true\n    this.emit('data', ret)\n  }\n  return ret\n}\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk')\n  if (state.ended) return\n  if (state.decoder) {\n    const chunk = state.decoder.end()\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk)\n      state.length += state.objectMode ? 1 : chunk.length\n    }\n  }\n  state.ended = true\n  if (state.sync) {\n    // If we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call.\n    emitReadable(stream)\n  } else {\n    // Emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false\n    state.emittedReadable = true\n    // We have to emit readable now that we are EOF. Modules\n    // in the ecosystem (e.g. dicer) rely on this event being sync.\n    emitReadable_(stream)\n  }\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  const state = stream._readableState\n  debug('emitReadable', state.needReadable, state.emittedReadable)\n  state.needReadable = false\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing)\n    state.emittedReadable = true\n    process.nextTick(emitReadable_, stream)\n  }\n}\nfunction emitReadable_(stream) {\n  const state = stream._readableState\n  debug('emitReadable_', state.destroyed, state.length, state.ended)\n  if (!state.destroyed && !state.errored && (state.length || state.ended)) {\n    stream.emit('readable')\n    state.emittedReadable = false\n  }\n\n  // The stream needs another readable event if:\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark\n  flow(stream)\n}\n\n// At this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore && state.constructed) {\n    state.readingMore = true\n    process.nextTick(maybeReadMore_, stream, state)\n  }\n}\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (\n    !state.reading &&\n    !state.ended &&\n    (state.length < state.highWaterMark || (state.flowing && state.length === 0))\n  ) {\n    const len = state.length\n    debug('maybeReadMore read 0')\n    stream.read(0)\n    if (len === state.length)\n      // Didn't get any data, stop spinning.\n      break\n  }\n  state.readingMore = false\n}\n\n// Abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  throw new ERR_METHOD_NOT_IMPLEMENTED('_read()')\n}\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  const src = this\n  const state = this._readableState\n  if (state.pipes.length === 1) {\n    if (!state.multiAwaitDrain) {\n      state.multiAwaitDrain = true\n      state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : [])\n    }\n  }\n  state.pipes.push(dest)\n  debug('pipe count=%d opts=%j', state.pipes.length, pipeOpts)\n  const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr\n  const endFn = doEnd ? onend : unpipe\n  if (state.endEmitted) process.nextTick(endFn)\n  else src.once('end', endFn)\n  dest.on('unpipe', onunpipe)\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe')\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true\n        cleanup()\n      }\n    }\n  }\n  function onend() {\n    debug('onend')\n    dest.end()\n  }\n  let ondrain\n  let cleanedUp = false\n  function cleanup() {\n    debug('cleanup')\n    // Cleanup event handlers once the pipe is broken.\n    dest.removeListener('close', onclose)\n    dest.removeListener('finish', onfinish)\n    if (ondrain) {\n      dest.removeListener('drain', ondrain)\n    }\n    dest.removeListener('error', onerror)\n    dest.removeListener('unpipe', onunpipe)\n    src.removeListener('end', onend)\n    src.removeListener('end', unpipe)\n    src.removeListener('data', ondata)\n    cleanedUp = true\n\n    // If the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) ondrain()\n  }\n  function pause() {\n    // If the user unpiped during `dest.write()`, it is possible\n    // to get stuck in a permanently paused state if that write\n    // also returned false.\n    // => Check whether `dest` is still a piping destination.\n    if (!cleanedUp) {\n      if (state.pipes.length === 1 && state.pipes[0] === dest) {\n        debug('false write response, pause', 0)\n        state.awaitDrainWriters = dest\n        state.multiAwaitDrain = false\n      } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {\n        debug('false write response, pause', state.awaitDrainWriters.size)\n        state.awaitDrainWriters.add(dest)\n      }\n      src.pause()\n    }\n    if (!ondrain) {\n      // When the dest drains, it reduces the awaitDrain counter\n      // on the source.  This would be more elegant with a .once()\n      // handler in flow(), but adding and removing repeatedly is\n      // too slow.\n      ondrain = pipeOnDrain(src, dest)\n      dest.on('drain', ondrain)\n    }\n  }\n  src.on('data', ondata)\n  function ondata(chunk) {\n    debug('ondata')\n    const ret = dest.write(chunk)\n    debug('dest.write', ret)\n    if (ret === false) {\n      pause()\n    }\n  }\n\n  // If the dest has an error, then stop piping into it.\n  // However, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er)\n    unpipe()\n    dest.removeListener('error', onerror)\n    if (dest.listenerCount('error') === 0) {\n      const s = dest._writableState || dest._readableState\n      if (s && !s.errorEmitted) {\n        // User incorrectly emitted 'error' directly on the stream.\n        errorOrDestroy(dest, er)\n      } else {\n        dest.emit('error', er)\n      }\n    }\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror)\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish)\n    unpipe()\n  }\n  dest.once('close', onclose)\n  function onfinish() {\n    debug('onfinish')\n    dest.removeListener('close', onclose)\n    unpipe()\n  }\n  dest.once('finish', onfinish)\n  function unpipe() {\n    debug('unpipe')\n    src.unpipe(dest)\n  }\n\n  // Tell the dest that it's being piped to.\n  dest.emit('pipe', src)\n\n  // Start the flow if it hasn't been started already.\n\n  if (dest.writableNeedDrain === true) {\n    pause()\n  } else if (!state.flowing) {\n    debug('pipe resume')\n    src.resume()\n  }\n  return dest\n}\nfunction pipeOnDrain(src, dest) {\n  return function pipeOnDrainFunctionResult() {\n    const state = src._readableState\n\n    // `ondrain` will call directly,\n    // `this` maybe not a reference to dest,\n    // so we use the real dest here.\n    if (state.awaitDrainWriters === dest) {\n      debug('pipeOnDrain', 1)\n      state.awaitDrainWriters = null\n    } else if (state.multiAwaitDrain) {\n      debug('pipeOnDrain', state.awaitDrainWriters.size)\n      state.awaitDrainWriters.delete(dest)\n    }\n    if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount('data')) {\n      src.resume()\n    }\n  }\n}\nReadable.prototype.unpipe = function (dest) {\n  const state = this._readableState\n  const unpipeInfo = {\n    hasUnpiped: false\n  }\n\n  // If we're not piping anywhere, then do nothing.\n  if (state.pipes.length === 0) return this\n  if (!dest) {\n    // remove all.\n    const dests = state.pipes\n    state.pipes = []\n    this.pause()\n    for (let i = 0; i < dests.length; i++)\n      dests[i].emit('unpipe', this, {\n        hasUnpiped: false\n      })\n    return this\n  }\n\n  // Try to find the right one.\n  const index = ArrayPrototypeIndexOf(state.pipes, dest)\n  if (index === -1) return this\n  state.pipes.splice(index, 1)\n  if (state.pipes.length === 0) this.pause()\n  dest.emit('unpipe', this, unpipeInfo)\n  return this\n}\n\n// Set up data events if they are asked for\n// Ensure readable listeners eventually get something.\nReadable.prototype.on = function (ev, fn) {\n  const res = Stream.prototype.on.call(this, ev, fn)\n  const state = this._readableState\n  if (ev === 'data') {\n    // Update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0\n\n    // Try start flowing on next tick if stream isn't explicitly paused.\n    if (state.flowing !== false) this.resume()\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true\n      state.flowing = false\n      state.emittedReadable = false\n      debug('on readable', state.length, state.reading)\n      if (state.length) {\n        emitReadable(this)\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this)\n      }\n    }\n  }\n  return res\n}\nReadable.prototype.addListener = Readable.prototype.on\nReadable.prototype.removeListener = function (ev, fn) {\n  const res = Stream.prototype.removeListener.call(this, ev, fn)\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this)\n  }\n  return res\n}\nReadable.prototype.off = Readable.prototype.removeListener\nReadable.prototype.removeAllListeners = function (ev) {\n  const res = Stream.prototype.removeAllListeners.apply(this, arguments)\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this)\n  }\n  return res\n}\nfunction updateReadableListening(self) {\n  const state = self._readableState\n  state.readableListening = self.listenerCount('readable') > 0\n  if (state.resumeScheduled && state[kPaused] === false) {\n    // Flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true\n\n    // Crude way to check if we should resume.\n  } else if (self.listenerCount('data') > 0) {\n    self.resume()\n  } else if (!state.readableListening) {\n    state.flowing = null\n  }\n}\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0')\n  self.read(0)\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  const state = this._readableState\n  if (!state.flowing) {\n    debug('resume')\n    // We flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume().\n    state.flowing = !state.readableListening\n    resume(this, state)\n  }\n  state[kPaused] = false\n  return this\n}\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true\n    process.nextTick(resume_, stream, state)\n  }\n}\nfunction resume_(stream, state) {\n  debug('resume', state.reading)\n  if (!state.reading) {\n    stream.read(0)\n  }\n  state.resumeScheduled = false\n  stream.emit('resume')\n  flow(stream)\n  if (state.flowing && !state.reading) stream.read(0)\n}\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing)\n  if (this._readableState.flowing !== false) {\n    debug('pause')\n    this._readableState.flowing = false\n    this.emit('pause')\n  }\n  this._readableState[kPaused] = true\n  return this\n}\nfunction flow(stream) {\n  const state = stream._readableState\n  debug('flow', state.flowing)\n  while (state.flowing && stream.read() !== null);\n}\n\n// Wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  let paused = false\n\n  // TODO (ronag): Should this.destroy(err) emit\n  // 'error' on the wrapped stream? Would require\n  // a static factory method, e.g. Readable.wrap(stream).\n\n  stream.on('data', (chunk) => {\n    if (!this.push(chunk) && stream.pause) {\n      paused = true\n      stream.pause()\n    }\n  })\n  stream.on('end', () => {\n    this.push(null)\n  })\n  stream.on('error', (err) => {\n    errorOrDestroy(this, err)\n  })\n  stream.on('close', () => {\n    this.destroy()\n  })\n  stream.on('destroy', () => {\n    this.destroy()\n  })\n  this._read = () => {\n    if (paused && stream.resume) {\n      paused = false\n      stream.resume()\n    }\n  }\n\n  // Proxy all the other methods. Important when wrapping filters and duplexes.\n  const streamKeys = ObjectKeys(stream)\n  for (let j = 1; j < streamKeys.length; j++) {\n    const i = streamKeys[j]\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = stream[i].bind(stream)\n    }\n  }\n  return this\n}\nReadable.prototype[SymbolAsyncIterator] = function () {\n  return streamToAsyncIterator(this)\n}\nReadable.prototype.iterator = function (options) {\n  if (options !== undefined) {\n    validateObject(options, 'options')\n  }\n  return streamToAsyncIterator(this, options)\n}\nfunction streamToAsyncIterator(stream, options) {\n  if (typeof stream.read !== 'function') {\n    stream = Readable.wrap(stream, {\n      objectMode: true\n    })\n  }\n  const iter = createAsyncIterator(stream, options)\n  iter.stream = stream\n  return iter\n}\nasync function* createAsyncIterator(stream, options) {\n  let callback = nop\n  function next(resolve) {\n    if (this === stream) {\n      callback()\n      callback = nop\n    } else {\n      callback = resolve\n    }\n  }\n  stream.on('readable', next)\n  let error\n  const cleanup = eos(\n    stream,\n    {\n      writable: false\n    },\n    (err) => {\n      error = err ? aggregateTwoErrors(error, err) : null\n      callback()\n      callback = nop\n    }\n  )\n  try {\n    while (true) {\n      const chunk = stream.destroyed ? null : stream.read()\n      if (chunk !== null) {\n        yield chunk\n      } else if (error) {\n        throw error\n      } else if (error === null) {\n        return\n      } else {\n        await new Promise(next)\n      }\n    }\n  } catch (err) {\n    error = aggregateTwoErrors(error, err)\n    throw error\n  } finally {\n    if (\n      (error || (options === null || options === undefined ? undefined : options.destroyOnReturn) !== false) &&\n      (error === undefined || stream._readableState.autoDestroy)\n    ) {\n      destroyImpl.destroyer(stream, null)\n    } else {\n      stream.off('readable', next)\n      cleanup()\n    }\n  }\n}\n\n// Making it explicit these properties are not enumerable\n// because otherwise some prototype manipulation in\n// userland will fail.\nObjectDefineProperties(Readable.prototype, {\n  readable: {\n    __proto__: null,\n    get() {\n      const r = this._readableState\n      // r.readable === false means that this is part of a Duplex stream\n      // where the readable side was disabled upon construction.\n      // Compat. The user might manually disable readable side through\n      // deprecated setter.\n      return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted\n    },\n    set(val) {\n      // Backwards compat.\n      if (this._readableState) {\n        this._readableState.readable = !!val\n      }\n    }\n  },\n  readableDidRead: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return this._readableState.dataEmitted\n    }\n  },\n  readableAborted: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return !!(\n        this._readableState.readable !== false &&\n        (this._readableState.destroyed || this._readableState.errored) &&\n        !this._readableState.endEmitted\n      )\n    }\n  },\n  readableHighWaterMark: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return this._readableState.highWaterMark\n    }\n  },\n  readableBuffer: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return this._readableState && this._readableState.buffer\n    }\n  },\n  readableFlowing: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return this._readableState.flowing\n    },\n    set: function (state) {\n      if (this._readableState) {\n        this._readableState.flowing = state\n      }\n    }\n  },\n  readableLength: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState.length\n    }\n  },\n  readableObjectMode: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.objectMode : false\n    }\n  },\n  readableEncoding: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.encoding : null\n    }\n  },\n  errored: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.errored : null\n    }\n  },\n  closed: {\n    __proto__: null,\n    get() {\n      return this._readableState ? this._readableState.closed : false\n    }\n  },\n  destroyed: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.destroyed : false\n    },\n    set(value) {\n      // We ignore the value if the stream\n      // has not been initialized yet.\n      if (!this._readableState) {\n        return\n      }\n\n      // Backward compatibility, the user is explicitly\n      // managing destroyed.\n      this._readableState.destroyed = value\n    }\n  },\n  readableEnded: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.endEmitted : false\n    }\n  }\n})\nObjectDefineProperties(ReadableState.prototype, {\n  // Legacy getter for `pipesCount`.\n  pipesCount: {\n    __proto__: null,\n    get() {\n      return this.pipes.length\n    }\n  },\n  // Legacy property for `paused`.\n  paused: {\n    __proto__: null,\n    get() {\n      return this[kPaused] !== false\n    },\n    set(value) {\n      this[kPaused] = !!value\n    }\n  }\n})\n\n// Exposed for testing purposes only.\nReadable._fromList = fromList\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered.\n  if (state.length === 0) return null\n  let ret\n  if (state.objectMode) ret = state.buffer.shift()\n  else if (!n || n >= state.length) {\n    // Read it all, truncate the list.\n    if (state.decoder) ret = state.buffer.join('')\n    else if (state.buffer.length === 1) ret = state.buffer.first()\n    else ret = state.buffer.concat(state.length)\n    state.buffer.clear()\n  } else {\n    // read part of list.\n    ret = state.buffer.consume(n, state.decoder)\n  }\n  return ret\n}\nfunction endReadable(stream) {\n  const state = stream._readableState\n  debug('endReadable', state.endEmitted)\n  if (!state.endEmitted) {\n    state.ended = true\n    process.nextTick(endReadableNT, state, stream)\n  }\n}\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length)\n\n  // Check that we didn't get one last unshift.\n  if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {\n    state.endEmitted = true\n    stream.emit('end')\n    if (stream.writable && stream.allowHalfOpen === false) {\n      process.nextTick(endWritableNT, stream)\n    } else if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well.\n      const wState = stream._writableState\n      const autoDestroy =\n        !wState ||\n        (wState.autoDestroy &&\n          // We don't expect the writable to ever 'finish'\n          // if writable is explicitly set to false.\n          (wState.finished || wState.writable === false))\n      if (autoDestroy) {\n        stream.destroy()\n      }\n    }\n  }\n}\nfunction endWritableNT(stream) {\n  const writable = stream.writable && !stream.writableEnded && !stream.destroyed\n  if (writable) {\n    stream.end()\n  }\n}\nReadable.from = function (iterable, opts) {\n  return from(Readable, iterable, opts)\n}\nlet webStreamsAdapters\n\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === undefined) webStreamsAdapters = {}\n  return webStreamsAdapters\n}\nReadable.fromWeb = function (readableStream, options) {\n  return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options)\n}\nReadable.toWeb = function (streamReadable, options) {\n  return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options)\n}\nReadable.wrap = function (src, options) {\n  var _ref, _src$readableObjectMo\n  return new Readable({\n    objectMode:\n      (_ref =\n        (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== undefined\n          ? _src$readableObjectMo\n          : src.objectMode) !== null && _ref !== undefined\n        ? _ref\n        : true,\n    ...options,\n    destroy(err, callback) {\n      destroyImpl.destroyer(src, err)\n      callback(err)\n    }\n  }).wrap(src)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}