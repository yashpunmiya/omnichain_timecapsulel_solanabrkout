{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbstractMessageChannel = void 0;\nconst utils_1 = require(\"@trezor/utils\");\nclass AbstractMessageChannel extends utils_1.TypedEmitter {\n  messagePromises = {};\n  messagesQueue = [];\n  messageID = 0;\n  isConnected = false;\n  handshakeMaxRetries = 5;\n  handshakeRetryInterval = 2000;\n  handshakeFinished;\n  lazyHandshake;\n  legacyMode;\n  logger;\n  sendFn;\n  channel;\n  constructor({\n    sendFn,\n    channel,\n    logger,\n    lazyHandshake = false,\n    legacyMode = false\n  }) {\n    super();\n    this.channel = channel;\n    this.sendFn = sendFn;\n    this.lazyHandshake = lazyHandshake;\n    this.legacyMode = legacyMode;\n    this.logger = logger;\n  }\n  init() {\n    if (!this.handshakeFinished) {\n      this.handshakeFinished = (0, utils_1.createDeferred)();\n      if (this.legacyMode) {\n        setTimeout(() => {\n          this.handshakeFinished?.resolve();\n        }, 500);\n      }\n      if (!this.lazyHandshake) {\n        this.handshakeWithPeer();\n      }\n    }\n    return this.handshakeFinished.promise;\n  }\n  handshakeWithPeer() {\n    this.logger?.log(this.channel.here, 'handshake');\n    return (0, utils_1.scheduleAction)(async () => {\n      this.postMessage({\n        type: 'channel-handshake-request',\n        data: {\n          success: true,\n          payload: undefined\n        }\n      }, {\n        usePromise: false,\n        useQueue: false\n      });\n      await this.handshakeFinished?.promise;\n    }, {\n      attempts: this.handshakeMaxRetries,\n      timeout: this.handshakeRetryInterval\n    }).then(() => {\n      this.logger?.log(this.channel.here, 'handshake confirmed');\n      this.messagesQueue.forEach(message => {\n        message.channel = this.channel;\n        this.sendFn(message);\n      });\n      this.messagesQueue = [];\n    }).catch(() => {\n      this.handshakeFinished?.reject(new Error('handshake failed'));\n      this.handshakeFinished = undefined;\n    });\n  }\n  onMessage(_message) {\n    let message = _message;\n    if (this.legacyMode && message.type === undefined && 'data' in message && typeof message.data === 'object' && message.data !== null && 'type' in message.data && typeof message.data.type === 'string') {\n      message = message.data;\n    }\n    const {\n      channel,\n      id,\n      type,\n      ...data\n    } = message;\n    if (!this.legacyMode) {\n      if (!channel?.peer || channel.peer !== this.channel.here) {\n        return;\n      }\n      if (!channel?.here || this.channel.peer !== channel.here) {\n        return;\n      }\n    }\n    if (type === 'channel-handshake-request') {\n      this.postMessage({\n        type: 'channel-handshake-confirm',\n        data: {\n          success: true,\n          payload: undefined\n        }\n      }, {\n        usePromise: false,\n        useQueue: false\n      });\n      if (this.lazyHandshake) {\n        this.handshakeWithPeer();\n      }\n      return;\n    }\n    if (type === 'channel-handshake-confirm') {\n      this.handshakeFinished?.resolve(undefined);\n      return;\n    }\n    if (this.messagePromises[id]) {\n      this.messagePromises[id].resolve({\n        id,\n        ...data\n      });\n      delete this.messagePromises[id];\n    }\n    const messagePromisesLength = Object.keys(this.messagePromises).length;\n    if (messagePromisesLength > 5) {\n      this.logger?.warn(`too many message promises (${messagePromisesLength}). this feels unexpected!`);\n    }\n    this.emit('message', message);\n  }\n  postMessage(message, {\n    usePromise = true,\n    useQueue = true\n  } = {}) {\n    message.channel = this.channel;\n    if (!usePromise) {\n      try {\n        this.sendFn(message);\n      } catch {\n        if (useQueue) {\n          this.messagesQueue.push(message);\n        }\n      }\n      return;\n    }\n    this.messageID++;\n    message.id = this.messageID;\n    this.messagePromises[message.id] = (0, utils_1.createDeferred)();\n    try {\n      this.sendFn(message);\n    } catch {\n      if (useQueue) {\n        this.messagesQueue.push(message);\n      }\n    }\n    return this.messagePromises[message.id].promise;\n  }\n  resolveMessagePromises(resolvePayload) {\n    Object.keys(this.messagePromises).forEach(id => this.messagePromises[id].resolve({\n      id,\n      payload: resolvePayload\n    }));\n  }\n  clear() {\n    this.handshakeFinished = undefined;\n  }\n}\nexports.AbstractMessageChannel = AbstractMessageChannel;","map":{"version":3,"names":["Object","defineProperty","exports","value","AbstractMessageChannel","utils_1","require","TypedEmitter","messagePromises","messagesQueue","messageID","isConnected","handshakeMaxRetries","handshakeRetryInterval","handshakeFinished","lazyHandshake","legacyMode","logger","sendFn","channel","constructor","init","createDeferred","setTimeout","resolve","handshakeWithPeer","promise","log","here","scheduleAction","postMessage","type","data","success","payload","undefined","usePromise","useQueue","attempts","timeout","then","forEach","message","catch","reject","Error","onMessage","_message","id","peer","messagePromisesLength","keys","length","warn","emit","push","resolveMessagePromises","resolvePayload","clear"],"sources":["C:/Users/yyash/Coding/solana-brkout/frontend/node_modules/@trezor/connect-common/lib/messageChannel/abstract.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AbstractMessageChannel = void 0;\nconst utils_1 = require(\"@trezor/utils\");\nclass AbstractMessageChannel extends utils_1.TypedEmitter {\n    messagePromises = {};\n    messagesQueue = [];\n    messageID = 0;\n    isConnected = false;\n    handshakeMaxRetries = 5;\n    handshakeRetryInterval = 2000;\n    handshakeFinished;\n    lazyHandshake;\n    legacyMode;\n    logger;\n    sendFn;\n    channel;\n    constructor({ sendFn, channel, logger, lazyHandshake = false, legacyMode = false, }) {\n        super();\n        this.channel = channel;\n        this.sendFn = sendFn;\n        this.lazyHandshake = lazyHandshake;\n        this.legacyMode = legacyMode;\n        this.logger = logger;\n    }\n    init() {\n        if (!this.handshakeFinished) {\n            this.handshakeFinished = (0, utils_1.createDeferred)();\n            if (this.legacyMode) {\n                setTimeout(() => {\n                    this.handshakeFinished?.resolve();\n                }, 500);\n            }\n            if (!this.lazyHandshake) {\n                this.handshakeWithPeer();\n            }\n        }\n        return this.handshakeFinished.promise;\n    }\n    handshakeWithPeer() {\n        this.logger?.log(this.channel.here, 'handshake');\n        return (0, utils_1.scheduleAction)(async () => {\n            this.postMessage({\n                type: 'channel-handshake-request',\n                data: { success: true, payload: undefined },\n            }, { usePromise: false, useQueue: false });\n            await this.handshakeFinished?.promise;\n        }, {\n            attempts: this.handshakeMaxRetries,\n            timeout: this.handshakeRetryInterval,\n        })\n            .then(() => {\n            this.logger?.log(this.channel.here, 'handshake confirmed');\n            this.messagesQueue.forEach(message => {\n                message.channel = this.channel;\n                this.sendFn(message);\n            });\n            this.messagesQueue = [];\n        })\n            .catch(() => {\n            this.handshakeFinished?.reject(new Error('handshake failed'));\n            this.handshakeFinished = undefined;\n        });\n    }\n    onMessage(_message) {\n        let message = _message;\n        if (this.legacyMode &&\n            message.type === undefined &&\n            'data' in message &&\n            typeof message.data === 'object' &&\n            message.data !== null &&\n            'type' in message.data &&\n            typeof message.data.type === 'string') {\n            message = message.data;\n        }\n        const { channel, id, type, ...data } = message;\n        if (!this.legacyMode) {\n            if (!channel?.peer || channel.peer !== this.channel.here) {\n                return;\n            }\n            if (!channel?.here || this.channel.peer !== channel.here) {\n                return;\n            }\n        }\n        if (type === 'channel-handshake-request') {\n            this.postMessage({\n                type: 'channel-handshake-confirm',\n                data: { success: true, payload: undefined },\n            }, { usePromise: false, useQueue: false });\n            if (this.lazyHandshake) {\n                this.handshakeWithPeer();\n            }\n            return;\n        }\n        if (type === 'channel-handshake-confirm') {\n            this.handshakeFinished?.resolve(undefined);\n            return;\n        }\n        if (this.messagePromises[id]) {\n            this.messagePromises[id].resolve({ id, ...data });\n            delete this.messagePromises[id];\n        }\n        const messagePromisesLength = Object.keys(this.messagePromises).length;\n        if (messagePromisesLength > 5) {\n            this.logger?.warn(`too many message promises (${messagePromisesLength}). this feels unexpected!`);\n        }\n        this.emit('message', message);\n    }\n    postMessage(message, { usePromise = true, useQueue = true } = {}) {\n        message.channel = this.channel;\n        if (!usePromise) {\n            try {\n                this.sendFn(message);\n            }\n            catch {\n                if (useQueue) {\n                    this.messagesQueue.push(message);\n                }\n            }\n            return;\n        }\n        this.messageID++;\n        message.id = this.messageID;\n        this.messagePromises[message.id] = (0, utils_1.createDeferred)();\n        try {\n            this.sendFn(message);\n        }\n        catch {\n            if (useQueue) {\n                this.messagesQueue.push(message);\n            }\n        }\n        return this.messagePromises[message.id].promise;\n    }\n    resolveMessagePromises(resolvePayload) {\n        Object.keys(this.messagePromises).forEach(id => this.messagePromises[id].resolve({\n            id,\n            payload: resolvePayload,\n        }));\n    }\n    clear() {\n        this.handshakeFinished = undefined;\n    }\n}\nexports.AbstractMessageChannel = AbstractMessageChannel;\n//# sourceMappingURL=abstract.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}