{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TemplateLiteralFiniteError = void 0;\nexports.IsTemplateLiteralExpressionFinite = IsTemplateLiteralExpressionFinite;\nexports.IsTemplateLiteralFinite = IsTemplateLiteralFinite;\nconst parse_1 = require(\"./parse\");\nconst index_1 = require(\"../error/index\");\n// ------------------------------------------------------------------\n// TemplateLiteralFiniteError\n// ------------------------------------------------------------------\nclass TemplateLiteralFiniteError extends index_1.TypeBoxError {}\nexports.TemplateLiteralFiniteError = TemplateLiteralFiniteError;\n// ------------------------------------------------------------------\n// IsTemplateLiteralFiniteCheck\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction IsNumberExpression(expression) {\n  return expression.type === 'or' && expression.expr.length === 2 && expression.expr[0].type === 'const' && expression.expr[0].const === '0' && expression.expr[1].type === 'const' && expression.expr[1].const === '[1-9][0-9]*';\n}\n// prettier-ignore\nfunction IsBooleanExpression(expression) {\n  return expression.type === 'or' && expression.expr.length === 2 && expression.expr[0].type === 'const' && expression.expr[0].const === 'true' && expression.expr[1].type === 'const' && expression.expr[1].const === 'false';\n}\n// prettier-ignore\nfunction IsStringExpression(expression) {\n  return expression.type === 'const' && expression.const === '.*';\n}\n// ------------------------------------------------------------------\n// IsTemplateLiteralExpressionFinite\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction IsTemplateLiteralExpressionFinite(expression) {\n  return IsNumberExpression(expression) || IsStringExpression(expression) ? false : IsBooleanExpression(expression) ? true : expression.type === 'and' ? expression.expr.every(expr => IsTemplateLiteralExpressionFinite(expr)) : expression.type === 'or' ? expression.expr.every(expr => IsTemplateLiteralExpressionFinite(expr)) : expression.type === 'const' ? true : (() => {\n    throw new TemplateLiteralFiniteError(`Unknown expression type`);\n  })();\n}\n/** Returns true if this TemplateLiteral resolves to a finite set of values */\nfunction IsTemplateLiteralFinite(schema) {\n  const expression = (0, parse_1.TemplateLiteralParseExact)(schema.pattern);\n  return IsTemplateLiteralExpressionFinite(expression);\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","TemplateLiteralFiniteError","IsTemplateLiteralExpressionFinite","IsTemplateLiteralFinite","parse_1","require","index_1","TypeBoxError","IsNumberExpression","expression","type","expr","length","const","IsBooleanExpression","IsStringExpression","every","schema","TemplateLiteralParseExact","pattern"],"sources":["C:/Users/yyash/Coding/solana-brkout/frontend/node_modules/@sinclair/typebox/build/cjs/type/template-literal/finite.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TemplateLiteralFiniteError = void 0;\nexports.IsTemplateLiteralExpressionFinite = IsTemplateLiteralExpressionFinite;\nexports.IsTemplateLiteralFinite = IsTemplateLiteralFinite;\nconst parse_1 = require(\"./parse\");\nconst index_1 = require(\"../error/index\");\n// ------------------------------------------------------------------\n// TemplateLiteralFiniteError\n// ------------------------------------------------------------------\nclass TemplateLiteralFiniteError extends index_1.TypeBoxError {\n}\nexports.TemplateLiteralFiniteError = TemplateLiteralFiniteError;\n// ------------------------------------------------------------------\n// IsTemplateLiteralFiniteCheck\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction IsNumberExpression(expression) {\n    return (expression.type === 'or' &&\n        expression.expr.length === 2 &&\n        expression.expr[0].type === 'const' &&\n        expression.expr[0].const === '0' &&\n        expression.expr[1].type === 'const' &&\n        expression.expr[1].const === '[1-9][0-9]*');\n}\n// prettier-ignore\nfunction IsBooleanExpression(expression) {\n    return (expression.type === 'or' &&\n        expression.expr.length === 2 &&\n        expression.expr[0].type === 'const' &&\n        expression.expr[0].const === 'true' &&\n        expression.expr[1].type === 'const' &&\n        expression.expr[1].const === 'false');\n}\n// prettier-ignore\nfunction IsStringExpression(expression) {\n    return expression.type === 'const' && expression.const === '.*';\n}\n// ------------------------------------------------------------------\n// IsTemplateLiteralExpressionFinite\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction IsTemplateLiteralExpressionFinite(expression) {\n    return (IsNumberExpression(expression) || IsStringExpression(expression) ? false :\n        IsBooleanExpression(expression) ? true :\n            (expression.type === 'and') ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) :\n                (expression.type === 'or') ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) :\n                    (expression.type === 'const') ? true :\n                        (() => { throw new TemplateLiteralFiniteError(`Unknown expression type`); })());\n}\n/** Returns true if this TemplateLiteral resolves to a finite set of values */\nfunction IsTemplateLiteralFinite(schema) {\n    const expression = (0, parse_1.TemplateLiteralParseExact)(schema.pattern);\n    return IsTemplateLiteralExpressionFinite(expression);\n}\n"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,0BAA0B,GAAG,KAAK,CAAC;AAC3CF,OAAO,CAACG,iCAAiC,GAAGA,iCAAiC;AAC7EH,OAAO,CAACI,uBAAuB,GAAGA,uBAAuB;AACzD,MAAMC,OAAO,GAAGC,OAAO,CAAC,SAAS,CAAC;AAClC,MAAMC,OAAO,GAAGD,OAAO,CAAC,gBAAgB,CAAC;AACzC;AACA;AACA;AACA,MAAMJ,0BAA0B,SAASK,OAAO,CAACC,YAAY,CAAC;AAE9DR,OAAO,CAACE,0BAA0B,GAAGA,0BAA0B;AAC/D;AACA;AACA;AACA;AACA,SAASO,kBAAkBA,CAACC,UAAU,EAAE;EACpC,OAAQA,UAAU,CAACC,IAAI,KAAK,IAAI,IAC5BD,UAAU,CAACE,IAAI,CAACC,MAAM,KAAK,CAAC,IAC5BH,UAAU,CAACE,IAAI,CAAC,CAAC,CAAC,CAACD,IAAI,KAAK,OAAO,IACnCD,UAAU,CAACE,IAAI,CAAC,CAAC,CAAC,CAACE,KAAK,KAAK,GAAG,IAChCJ,UAAU,CAACE,IAAI,CAAC,CAAC,CAAC,CAACD,IAAI,KAAK,OAAO,IACnCD,UAAU,CAACE,IAAI,CAAC,CAAC,CAAC,CAACE,KAAK,KAAK,aAAa;AAClD;AACA;AACA,SAASC,mBAAmBA,CAACL,UAAU,EAAE;EACrC,OAAQA,UAAU,CAACC,IAAI,KAAK,IAAI,IAC5BD,UAAU,CAACE,IAAI,CAACC,MAAM,KAAK,CAAC,IAC5BH,UAAU,CAACE,IAAI,CAAC,CAAC,CAAC,CAACD,IAAI,KAAK,OAAO,IACnCD,UAAU,CAACE,IAAI,CAAC,CAAC,CAAC,CAACE,KAAK,KAAK,MAAM,IACnCJ,UAAU,CAACE,IAAI,CAAC,CAAC,CAAC,CAACD,IAAI,KAAK,OAAO,IACnCD,UAAU,CAACE,IAAI,CAAC,CAAC,CAAC,CAACE,KAAK,KAAK,OAAO;AAC5C;AACA;AACA,SAASE,kBAAkBA,CAACN,UAAU,EAAE;EACpC,OAAOA,UAAU,CAACC,IAAI,KAAK,OAAO,IAAID,UAAU,CAACI,KAAK,KAAK,IAAI;AACnE;AACA;AACA;AACA;AACA;AACA,SAASX,iCAAiCA,CAACO,UAAU,EAAE;EACnD,OAAQD,kBAAkB,CAACC,UAAU,CAAC,IAAIM,kBAAkB,CAACN,UAAU,CAAC,GAAG,KAAK,GAC5EK,mBAAmB,CAACL,UAAU,CAAC,GAAG,IAAI,GACjCA,UAAU,CAACC,IAAI,KAAK,KAAK,GAAID,UAAU,CAACE,IAAI,CAACK,KAAK,CAAEL,IAAI,IAAKT,iCAAiC,CAACS,IAAI,CAAC,CAAC,GACjGF,UAAU,CAACC,IAAI,KAAK,IAAI,GAAID,UAAU,CAACE,IAAI,CAACK,KAAK,CAAEL,IAAI,IAAKT,iCAAiC,CAACS,IAAI,CAAC,CAAC,GAChGF,UAAU,CAACC,IAAI,KAAK,OAAO,GAAI,IAAI,GAChC,CAAC,MAAM;IAAE,MAAM,IAAIT,0BAA0B,CAAC,yBAAyB,CAAC;EAAE,CAAC,EAAE,CAAC;AACtG;AACA;AACA,SAASE,uBAAuBA,CAACc,MAAM,EAAE;EACrC,MAAMR,UAAU,GAAG,CAAC,CAAC,EAAEL,OAAO,CAACc,yBAAyB,EAAED,MAAM,CAACE,OAAO,CAAC;EACzE,OAAOjB,iCAAiC,CAACO,UAAU,CAAC;AACxD","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}