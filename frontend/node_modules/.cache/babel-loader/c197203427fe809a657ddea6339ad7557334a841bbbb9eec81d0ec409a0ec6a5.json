{"ast":null,"code":"import { bytesPerBlob, bytesPerFieldElement, fieldElementsPerBlob, maxBytesPerTransaction } from '../../constants/blob.js';\nimport { BlobSizeTooLargeError, EmptyBlobError } from '../../errors/blob.js';\nimport { createCursor } from '../cursor.js';\nimport { size } from '../data/size.js';\nimport { hexToBytes } from '../encoding/toBytes.js';\nimport { bytesToHex } from '../encoding/toHex.js';\n/**\n * Transforms arbitrary data to blobs.\n *\n * @example\n * ```ts\n * import { toBlobs, stringToHex } from 'viem'\n *\n * const blobs = toBlobs({ data: stringToHex('hello world') })\n * ```\n */\nexport function toBlobs(parameters) {\n  const to = parameters.to ?? (typeof parameters.data === 'string' ? 'hex' : 'bytes');\n  const data = typeof parameters.data === 'string' ? hexToBytes(parameters.data) : parameters.data;\n  const size_ = size(data);\n  if (!size_) throw new EmptyBlobError();\n  if (size_ > maxBytesPerTransaction) throw new BlobSizeTooLargeError({\n    maxSize: maxBytesPerTransaction,\n    size: size_\n  });\n  const blobs = [];\n  let active = true;\n  let position = 0;\n  while (active) {\n    const blob = createCursor(new Uint8Array(bytesPerBlob));\n    let size = 0;\n    while (size < fieldElementsPerBlob) {\n      const bytes = data.slice(position, position + (bytesPerFieldElement - 1));\n      // Push a zero byte so the field element doesn't overflow the BLS modulus.\n      blob.pushByte(0x00);\n      // Push the current segment of data bytes.\n      blob.pushBytes(bytes);\n      // If we detect that the current segment of data bytes is less than 31 bytes,\n      // we can stop processing and push a terminator byte to indicate the end of the blob.\n      if (bytes.length < 31) {\n        blob.pushByte(0x80);\n        active = false;\n        break;\n      }\n      size++;\n      position += 31;\n    }\n    blobs.push(blob);\n  }\n  return to === 'bytes' ? blobs.map(x => x.bytes) : blobs.map(x => bytesToHex(x.bytes));\n}","map":{"version":3,"names":["bytesPerBlob","bytesPerFieldElement","fieldElementsPerBlob","maxBytesPerTransaction","BlobSizeTooLargeError","EmptyBlobError","createCursor","size","hexToBytes","bytesToHex","toBlobs","parameters","to","data","size_","maxSize","blobs","active","position","blob","Uint8Array","bytes","slice","pushByte","pushBytes","length","push","map","x"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@reown\\appkit-controllers\\node_modules\\@walletconnect\\utils\\node_modules\\viem\\utils\\blob\\toBlobs.ts"],"sourcesContent":["import {\n  bytesPerBlob,\n  bytesPerFieldElement,\n  fieldElementsPerBlob,\n  maxBytesPerTransaction,\n} from '../../constants/blob.js'\nimport {\n  BlobSizeTooLargeError,\n  type BlobSizeTooLargeErrorType,\n  EmptyBlobError,\n  type EmptyBlobErrorType,\n} from '../../errors/blob.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type CreateCursorErrorType, createCursor } from '../cursor.js'\nimport { type SizeErrorType, size } from '../data/size.js'\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type ToBlobsParameters<\n  data extends Hex | ByteArray = Hex | ByteArray,\n  to extends To | undefined = undefined,\n> = {\n  /** Data to transform to a blob. */\n  data: data | Hex | ByteArray\n  /** Return type. */\n  to?: to | To | undefined\n}\n\nexport type ToBlobsReturnType<to extends To> =\n  | (to extends 'bytes' ? readonly ByteArray[] : never)\n  | (to extends 'hex' ? readonly Hex[] : never)\n\nexport type ToBlobsErrorType =\n  | BlobSizeTooLargeErrorType\n  | BytesToHexErrorType\n  | CreateCursorErrorType\n  | EmptyBlobErrorType\n  | HexToBytesErrorType\n  | SizeErrorType\n  | ErrorType\n\n/**\n * Transforms arbitrary data to blobs.\n *\n * @example\n * ```ts\n * import { toBlobs, stringToHex } from 'viem'\n *\n * const blobs = toBlobs({ data: stringToHex('hello world') })\n * ```\n */\nexport function toBlobs<\n  const data extends Hex | ByteArray,\n  to extends To =\n    | (data extends Hex ? 'hex' : never)\n    | (data extends ByteArray ? 'bytes' : never),\n>(parameters: ToBlobsParameters<data, to>): ToBlobsReturnType<to> {\n  const to =\n    parameters.to ?? (typeof parameters.data === 'string' ? 'hex' : 'bytes')\n  const data = (\n    typeof parameters.data === 'string'\n      ? hexToBytes(parameters.data)\n      : parameters.data\n  ) as ByteArray\n\n  const size_ = size(data)\n  if (!size_) throw new EmptyBlobError()\n  if (size_ > maxBytesPerTransaction)\n    throw new BlobSizeTooLargeError({\n      maxSize: maxBytesPerTransaction,\n      size: size_,\n    })\n\n  const blobs = []\n\n  let active = true\n  let position = 0\n  while (active) {\n    const blob = createCursor(new Uint8Array(bytesPerBlob))\n\n    let size = 0\n    while (size < fieldElementsPerBlob) {\n      const bytes = data.slice(position, position + (bytesPerFieldElement - 1))\n\n      // Push a zero byte so the field element doesn't overflow the BLS modulus.\n      blob.pushByte(0x00)\n\n      // Push the current segment of data bytes.\n      blob.pushBytes(bytes)\n\n      // If we detect that the current segment of data bytes is less than 31 bytes,\n      // we can stop processing and push a terminator byte to indicate the end of the blob.\n      if (bytes.length < 31) {\n        blob.pushByte(0x80)\n        active = false\n        break\n      }\n\n      size++\n      position += 31\n    }\n\n    blobs.push(blob)\n  }\n\n  return (\n    to === 'bytes'\n      ? blobs.map((x) => x.bytes)\n      : blobs.map((x) => bytesToHex(x.bytes))\n  ) as any\n}\n"],"mappings":"AAAA,SACEA,YAAY,EACZC,oBAAoB,EACpBC,oBAAoB,EACpBC,sBAAsB,QACjB,yBAAyB;AAChC,SACEC,qBAAqB,EAErBC,cAAc,QAET,sBAAsB;AAG7B,SAAqCC,YAAY,QAAQ,cAAc;AACvE,SAA6BC,IAAI,QAAQ,iBAAiB;AAC1D,SAAmCC,UAAU,QAAQ,wBAAwB;AAC7E,SAAmCC,UAAU,QAAQ,sBAAsB;AA2B3E;;;;;;;;;;AAUA,OAAM,SAAUC,OAAOA,CAKrBC,UAAuC;EACvC,MAAMC,EAAE,GACND,UAAU,CAACC,EAAE,KAAK,OAAOD,UAAU,CAACE,IAAI,KAAK,QAAQ,GAAG,KAAK,GAAG,OAAO,CAAC;EAC1E,MAAMA,IAAI,GACR,OAAOF,UAAU,CAACE,IAAI,KAAK,QAAQ,GAC/BL,UAAU,CAACG,UAAU,CAACE,IAAI,CAAC,GAC3BF,UAAU,CAACE,IACH;EAEd,MAAMC,KAAK,GAAGP,IAAI,CAACM,IAAI,CAAC;EACxB,IAAI,CAACC,KAAK,EAAE,MAAM,IAAIT,cAAc,EAAE;EACtC,IAAIS,KAAK,GAAGX,sBAAsB,EAChC,MAAM,IAAIC,qBAAqB,CAAC;IAC9BW,OAAO,EAAEZ,sBAAsB;IAC/BI,IAAI,EAAEO;GACP,CAAC;EAEJ,MAAME,KAAK,GAAG,EAAE;EAEhB,IAAIC,MAAM,GAAG,IAAI;EACjB,IAAIC,QAAQ,GAAG,CAAC;EAChB,OAAOD,MAAM,EAAE;IACb,MAAME,IAAI,GAAGb,YAAY,CAAC,IAAIc,UAAU,CAACpB,YAAY,CAAC,CAAC;IAEvD,IAAIO,IAAI,GAAG,CAAC;IACZ,OAAOA,IAAI,GAAGL,oBAAoB,EAAE;MAClC,MAAMmB,KAAK,GAAGR,IAAI,CAACS,KAAK,CAACJ,QAAQ,EAAEA,QAAQ,IAAIjB,oBAAoB,GAAG,CAAC,CAAC,CAAC;MAEzE;MACAkB,IAAI,CAACI,QAAQ,CAAC,IAAI,CAAC;MAEnB;MACAJ,IAAI,CAACK,SAAS,CAACH,KAAK,CAAC;MAErB;MACA;MACA,IAAIA,KAAK,CAACI,MAAM,GAAG,EAAE,EAAE;QACrBN,IAAI,CAACI,QAAQ,CAAC,IAAI,CAAC;QACnBN,MAAM,GAAG,KAAK;QACd;MACF;MAEAV,IAAI,EAAE;MACNW,QAAQ,IAAI,EAAE;IAChB;IAEAF,KAAK,CAACU,IAAI,CAACP,IAAI,CAAC;EAClB;EAEA,OACEP,EAAE,KAAK,OAAO,GACVI,KAAK,CAACW,GAAG,CAAEC,CAAC,IAAKA,CAAC,CAACP,KAAK,CAAC,GACzBL,KAAK,CAACW,GAAG,CAAEC,CAAC,IAAKnB,UAAU,CAACmB,CAAC,CAACP,KAAK,CAAC,CAAC;AAE7C","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}