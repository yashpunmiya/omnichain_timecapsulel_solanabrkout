{"ast":null,"code":"import { keccak256 } from 'ethereum-cryptography/keccak.js';\nimport { secp256k1 } from 'ethereum-cryptography/secp256k1.js';\nimport { bytesToBigInt, bytesToHex, bytesToInt, concatBytes, setLengthLeft, toBytes, utf8ToBytes } from './bytes.js';\nimport { BIGINT_0, BIGINT_1, BIGINT_2, BIGINT_27, SECP256K1_ORDER, SECP256K1_ORDER_DIV_2 } from './constants.js';\nimport { assertIsBytes } from './helpers.js';\n/**\n * Returns the ECDSA signature of a message hash.\n *\n * If `chainId` is provided assume an EIP-155-style signature and calculate the `v` value\n * accordingly, otherwise return a \"static\" `v` just derived from the `recovery` bit\n */\nexport function ecsign(msgHash, privateKey, chainId) {\n  const sig = secp256k1.sign(msgHash, privateKey);\n  const buf = sig.toCompactRawBytes();\n  const r = buf.slice(0, 32);\n  const s = buf.slice(32, 64);\n  const v = chainId === undefined ? BigInt(sig.recovery + 27) : BigInt(sig.recovery + 35) + BigInt(chainId) * BIGINT_2;\n  return {\n    r,\n    s,\n    v\n  };\n}\nexport function calculateSigRecovery(v, chainId) {\n  if (v === BIGINT_0 || v === BIGINT_1) return v;\n  if (chainId === undefined) {\n    return v - BIGINT_27;\n  }\n  return v - (chainId * BIGINT_2 + BigInt(35));\n}\nfunction isValidSigRecovery(recovery) {\n  return recovery === BIGINT_0 || recovery === BIGINT_1;\n}\n/**\n * ECDSA public key recovery from signature.\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @returns Recovered public key\n */\nexport const ecrecover = function (msgHash, v, r, s, chainId) {\n  const signature = concatBytes(setLengthLeft(r, 32), setLengthLeft(s, 32));\n  const recovery = calculateSigRecovery(v, chainId);\n  if (!isValidSigRecovery(recovery)) {\n    throw new Error('Invalid signature v value');\n  }\n  const sig = secp256k1.Signature.fromCompact(signature).addRecoveryBit(Number(recovery));\n  const senderPubKey = sig.recoverPublicKey(msgHash);\n  return senderPubKey.toRawBytes(false).slice(1);\n};\n/**\n * Convert signature parameters into the format of `eth_sign` RPC method.\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @returns Signature\n */\nexport const toRpcSig = function (v, r, s, chainId) {\n  const recovery = calculateSigRecovery(v, chainId);\n  if (!isValidSigRecovery(recovery)) {\n    throw new Error('Invalid signature v value');\n  }\n  // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin\n  return bytesToHex(concatBytes(setLengthLeft(r, 32), setLengthLeft(s, 32), toBytes(v)));\n};\n/**\n * Convert signature parameters into the format of Compact Signature Representation (EIP-2098).\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @returns Signature\n */\nexport const toCompactSig = function (v, r, s, chainId) {\n  const recovery = calculateSigRecovery(v, chainId);\n  if (!isValidSigRecovery(recovery)) {\n    throw new Error('Invalid signature v value');\n  }\n  const ss = Uint8Array.from([...s]);\n  if (v > BigInt(28) && v % BIGINT_2 === BIGINT_1 || v === BIGINT_1 || v === BigInt(28)) {\n    ss[0] |= 0x80;\n  }\n  return bytesToHex(concatBytes(setLengthLeft(r, 32), setLengthLeft(ss, 32)));\n};\n/**\n * Convert signature format of the `eth_sign` RPC method to signature parameters\n *\n * NOTE: For an extracted `v` value < 27 (see Geth bug https://github.com/ethereum/go-ethereum/issues/2053)\n * `v + 27` is returned for the `v` value\n * NOTE: After EIP1559, `v` could be `0` or `1` but this function assumes\n * it's a signed message (EIP-191 or EIP-712) adding `27` at the end. Remove if needed.\n */\nexport const fromRpcSig = function (sig) {\n  const bytes = toBytes(sig);\n  let r;\n  let s;\n  let v;\n  if (bytes.length >= 65) {\n    r = bytes.subarray(0, 32);\n    s = bytes.subarray(32, 64);\n    v = bytesToBigInt(bytes.subarray(64));\n  } else if (bytes.length === 64) {\n    // Compact Signature Representation (https://eips.ethereum.org/EIPS/eip-2098)\n    r = bytes.subarray(0, 32);\n    s = bytes.subarray(32, 64);\n    v = BigInt(bytesToInt(bytes.subarray(32, 33)) >> 7);\n    s[0] &= 0x7f;\n  } else {\n    throw new Error('Invalid signature length');\n  }\n  // support both versions of `eth_sign` responses\n  if (v < 27) {\n    v = v + BIGINT_27;\n  }\n  return {\n    v,\n    r,\n    s\n  };\n};\n/**\n * Validate a ECDSA signature.\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @param homesteadOrLater Indicates whether this is being used on either the homestead hardfork or a later one\n */\nexport const isValidSignature = function (v, r, s, homesteadOrLater = true, chainId) {\n  if (r.length !== 32 || s.length !== 32) {\n    return false;\n  }\n  if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {\n    return false;\n  }\n  const rBigInt = bytesToBigInt(r);\n  const sBigInt = bytesToBigInt(s);\n  if (rBigInt === BIGINT_0 || rBigInt >= SECP256K1_ORDER || sBigInt === BIGINT_0 || sBigInt >= SECP256K1_ORDER) {\n    return false;\n  }\n  if (homesteadOrLater && sBigInt >= SECP256K1_ORDER_DIV_2) {\n    return false;\n  }\n  return true;\n};\n/**\n * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.\n * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`\n * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key\n * used to produce the signature.\n */\nexport const hashPersonalMessage = function (message) {\n  assertIsBytes(message);\n  const prefix = utf8ToBytes(`\\u0019Ethereum Signed Message:\\n${message.length}`);\n  return keccak256(concatBytes(prefix, message));\n};","map":{"version":3,"names":["keccak256","secp256k1","bytesToBigInt","bytesToHex","bytesToInt","concatBytes","setLengthLeft","toBytes","utf8ToBytes","BIGINT_0","BIGINT_1","BIGINT_2","BIGINT_27","SECP256K1_ORDER","SECP256K1_ORDER_DIV_2","assertIsBytes","ecsign","msgHash","privateKey","chainId","sig","sign","buf","toCompactRawBytes","r","slice","s","v","undefined","BigInt","recovery","calculateSigRecovery","isValidSigRecovery","ecrecover","signature","Error","Signature","fromCompact","addRecoveryBit","Number","senderPubKey","recoverPublicKey","toRawBytes","toRpcSig","toCompactSig","ss","Uint8Array","from","fromRpcSig","bytes","length","subarray","isValidSignature","homesteadOrLater","rBigInt","sBigInt","hashPersonalMessage","message","prefix"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@ethereumjs\\util\\src\\signature.ts"],"sourcesContent":["import { keccak256 } from 'ethereum-cryptography/keccak.js'\nimport { secp256k1 } from 'ethereum-cryptography/secp256k1.js'\n\nimport {\n  bytesToBigInt,\n  bytesToHex,\n  bytesToInt,\n  concatBytes,\n  setLengthLeft,\n  toBytes,\n  utf8ToBytes,\n} from './bytes.js'\nimport {\n  BIGINT_0,\n  BIGINT_1,\n  BIGINT_2,\n  BIGINT_27,\n  SECP256K1_ORDER,\n  SECP256K1_ORDER_DIV_2,\n} from './constants.js'\nimport { assertIsBytes } from './helpers.js'\n\nimport type { PrefixedHexString } from './types.js'\n\nexport interface ECDSASignature {\n  v: bigint\n  r: Uint8Array\n  s: Uint8Array\n}\n\n/**\n * Returns the ECDSA signature of a message hash.\n *\n * If `chainId` is provided assume an EIP-155-style signature and calculate the `v` value\n * accordingly, otherwise return a \"static\" `v` just derived from the `recovery` bit\n */\nexport function ecsign(\n  msgHash: Uint8Array,\n  privateKey: Uint8Array,\n  chainId?: bigint\n): ECDSASignature {\n  const sig = secp256k1.sign(msgHash, privateKey)\n  const buf = sig.toCompactRawBytes()\n  const r = buf.slice(0, 32)\n  const s = buf.slice(32, 64)\n\n  const v =\n    chainId === undefined\n      ? BigInt(sig.recovery! + 27)\n      : BigInt(sig.recovery! + 35) + BigInt(chainId) * BIGINT_2\n\n  return { r, s, v }\n}\n\nexport function calculateSigRecovery(v: bigint, chainId?: bigint): bigint {\n  if (v === BIGINT_0 || v === BIGINT_1) return v\n\n  if (chainId === undefined) {\n    return v - BIGINT_27\n  }\n  return v - (chainId * BIGINT_2 + BigInt(35))\n}\n\nfunction isValidSigRecovery(recovery: bigint): boolean {\n  return recovery === BIGINT_0 || recovery === BIGINT_1\n}\n\n/**\n * ECDSA public key recovery from signature.\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @returns Recovered public key\n */\nexport const ecrecover = function (\n  msgHash: Uint8Array,\n  v: bigint,\n  r: Uint8Array,\n  s: Uint8Array,\n  chainId?: bigint\n): Uint8Array {\n  const signature = concatBytes(setLengthLeft(r, 32), setLengthLeft(s, 32))\n  const recovery = calculateSigRecovery(v, chainId)\n  if (!isValidSigRecovery(recovery)) {\n    throw new Error('Invalid signature v value')\n  }\n\n  const sig = secp256k1.Signature.fromCompact(signature).addRecoveryBit(Number(recovery))\n  const senderPubKey = sig.recoverPublicKey(msgHash)\n  return senderPubKey.toRawBytes(false).slice(1)\n}\n\n/**\n * Convert signature parameters into the format of `eth_sign` RPC method.\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @returns Signature\n */\nexport const toRpcSig = function (\n  v: bigint,\n  r: Uint8Array,\n  s: Uint8Array,\n  chainId?: bigint\n): string {\n  const recovery = calculateSigRecovery(v, chainId)\n  if (!isValidSigRecovery(recovery)) {\n    throw new Error('Invalid signature v value')\n  }\n\n  // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin\n\n  return bytesToHex(concatBytes(setLengthLeft(r, 32), setLengthLeft(s, 32), toBytes(v)))\n}\n\n/**\n * Convert signature parameters into the format of Compact Signature Representation (EIP-2098).\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @returns Signature\n */\nexport const toCompactSig = function (\n  v: bigint,\n  r: Uint8Array,\n  s: Uint8Array,\n  chainId?: bigint\n): string {\n  const recovery = calculateSigRecovery(v, chainId)\n  if (!isValidSigRecovery(recovery)) {\n    throw new Error('Invalid signature v value')\n  }\n\n  const ss = Uint8Array.from([...s])\n  if ((v > BigInt(28) && v % BIGINT_2 === BIGINT_1) || v === BIGINT_1 || v === BigInt(28)) {\n    ss[0] |= 0x80\n  }\n\n  return bytesToHex(concatBytes(setLengthLeft(r, 32), setLengthLeft(ss, 32)))\n}\n\n/**\n * Convert signature format of the `eth_sign` RPC method to signature parameters\n *\n * NOTE: For an extracted `v` value < 27 (see Geth bug https://github.com/ethereum/go-ethereum/issues/2053)\n * `v + 27` is returned for the `v` value\n * NOTE: After EIP1559, `v` could be `0` or `1` but this function assumes\n * it's a signed message (EIP-191 or EIP-712) adding `27` at the end. Remove if needed.\n */\nexport const fromRpcSig = function (sig: PrefixedHexString): ECDSASignature {\n  const bytes: Uint8Array = toBytes(sig)\n\n  let r: Uint8Array\n  let s: Uint8Array\n  let v: bigint\n  if (bytes.length >= 65) {\n    r = bytes.subarray(0, 32)\n    s = bytes.subarray(32, 64)\n    v = bytesToBigInt(bytes.subarray(64))\n  } else if (bytes.length === 64) {\n    // Compact Signature Representation (https://eips.ethereum.org/EIPS/eip-2098)\n    r = bytes.subarray(0, 32)\n    s = bytes.subarray(32, 64)\n    v = BigInt(bytesToInt(bytes.subarray(32, 33)) >> 7)\n    s[0] &= 0x7f\n  } else {\n    throw new Error('Invalid signature length')\n  }\n\n  // support both versions of `eth_sign` responses\n  if (v < 27) {\n    v = v + BIGINT_27\n  }\n\n  return {\n    v,\n    r,\n    s,\n  }\n}\n\n/**\n * Validate a ECDSA signature.\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @param homesteadOrLater Indicates whether this is being used on either the homestead hardfork or a later one\n */\nexport const isValidSignature = function (\n  v: bigint,\n  r: Uint8Array,\n  s: Uint8Array,\n  homesteadOrLater: boolean = true,\n  chainId?: bigint\n): boolean {\n  if (r.length !== 32 || s.length !== 32) {\n    return false\n  }\n\n  if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {\n    return false\n  }\n\n  const rBigInt = bytesToBigInt(r)\n  const sBigInt = bytesToBigInt(s)\n\n  if (\n    rBigInt === BIGINT_0 ||\n    rBigInt >= SECP256K1_ORDER ||\n    sBigInt === BIGINT_0 ||\n    sBigInt >= SECP256K1_ORDER\n  ) {\n    return false\n  }\n\n  if (homesteadOrLater && sBigInt >= SECP256K1_ORDER_DIV_2) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.\n * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`\n * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key\n * used to produce the signature.\n */\nexport const hashPersonalMessage = function (message: Uint8Array): Uint8Array {\n  assertIsBytes(message)\n  const prefix = utf8ToBytes(`\\u0019Ethereum Signed Message:\\n${message.length}`)\n  return keccak256(concatBytes(prefix, message))\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}