{"ast":null,"code":"import { InvalidAddressError } from '../../errors/address.js';\nimport { stringToBytes } from '../encoding/toBytes.js';\nimport { keccak256 } from '../hash/keccak256.js';\nimport { LruMap } from '../lru.js';\nimport { isAddress } from './isAddress.js';\nconst checksumAddressCache = /*#__PURE__*/new LruMap(8192);\nexport function checksumAddress(address_,\n/**\n * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the\n * wider Ethereum ecosystem, meaning it will break when validated against an application/tool\n * that relies on EIP-55 checksum encoding (checksum without chainId).\n *\n * It is highly recommended to not use this feature unless you\n * know what you are doing.\n *\n * See more: https://github.com/ethereum/EIPs/issues/1121\n */\nchainId) {\n  if (checksumAddressCache.has(`${address_}.${chainId}`)) return checksumAddressCache.get(`${address_}.${chainId}`);\n  const hexAddress = chainId ? `${chainId}${address_.toLowerCase()}` : address_.substring(2).toLowerCase();\n  const hash = keccak256(stringToBytes(hexAddress), 'bytes');\n  const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split('');\n  for (let i = 0; i < 40; i += 2) {\n    if (hash[i >> 1] >> 4 >= 8 && address[i]) {\n      address[i] = address[i].toUpperCase();\n    }\n    if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {\n      address[i + 1] = address[i + 1].toUpperCase();\n    }\n  }\n  const result = `0x${address.join('')}`;\n  checksumAddressCache.set(`${address_}.${chainId}`, result);\n  return result;\n}\nexport function getAddress(address,\n/**\n * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the\n * wider Ethereum ecosystem, meaning it will break when validated against an application/tool\n * that relies on EIP-55 checksum encoding (checksum without chainId).\n *\n * It is highly recommended to not use this feature unless you\n * know what you are doing.\n *\n * See more: https://github.com/ethereum/EIPs/issues/1121\n */\nchainId) {\n  if (!isAddress(address, {\n    strict: false\n  })) throw new InvalidAddressError({\n    address\n  });\n  return checksumAddress(address, chainId);\n}","map":{"version":3,"names":["InvalidAddressError","stringToBytes","keccak256","LruMap","isAddress","checksumAddressCache","checksumAddress","address_","chainId","has","get","hexAddress","toLowerCase","substring","hash","address","length","split","i","toUpperCase","result","join","set","getAddress","strict"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@reown\\appkit-controllers\\node_modules\\@walletconnect\\utils\\node_modules\\viem\\utils\\address\\getAddress.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport { InvalidAddressError } from '../../errors/address.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport {\n  type StringToBytesErrorType,\n  stringToBytes,\n} from '../encoding/toBytes.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport { LruMap } from '../lru.js'\nimport { type IsAddressErrorType, isAddress } from './isAddress.js'\n\nconst checksumAddressCache = /*#__PURE__*/ new LruMap<Address>(8192)\n\nexport type ChecksumAddressErrorType =\n  | Keccak256ErrorType\n  | StringToBytesErrorType\n  | ErrorType\n\nexport function checksumAddress(\n  address_: Address,\n  /**\n   * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the\n   * wider Ethereum ecosystem, meaning it will break when validated against an application/tool\n   * that relies on EIP-55 checksum encoding (checksum without chainId).\n   *\n   * It is highly recommended to not use this feature unless you\n   * know what you are doing.\n   *\n   * See more: https://github.com/ethereum/EIPs/issues/1121\n   */\n  chainId?: number | undefined,\n): Address {\n  if (checksumAddressCache.has(`${address_}.${chainId}`))\n    return checksumAddressCache.get(`${address_}.${chainId}`)!\n\n  const hexAddress = chainId\n    ? `${chainId}${address_.toLowerCase()}`\n    : address_.substring(2).toLowerCase()\n  const hash = keccak256(stringToBytes(hexAddress), 'bytes')\n\n  const address = (\n    chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress\n  ).split('')\n  for (let i = 0; i < 40; i += 2) {\n    if (hash[i >> 1] >> 4 >= 8 && address[i]) {\n      address[i] = address[i].toUpperCase()\n    }\n    if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {\n      address[i + 1] = address[i + 1].toUpperCase()\n    }\n  }\n\n  const result = `0x${address.join('')}` as const\n  checksumAddressCache.set(`${address_}.${chainId}`, result)\n  return result\n}\n\nexport type GetAddressErrorType =\n  | ChecksumAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\nexport function getAddress(\n  address: string,\n  /**\n   * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the\n   * wider Ethereum ecosystem, meaning it will break when validated against an application/tool\n   * that relies on EIP-55 checksum encoding (checksum without chainId).\n   *\n   * It is highly recommended to not use this feature unless you\n   * know what you are doing.\n   *\n   * See more: https://github.com/ethereum/EIPs/issues/1121\n   */\n  chainId?: number,\n): Address {\n  if (!isAddress(address, { strict: false }))\n    throw new InvalidAddressError({ address })\n  return checksumAddress(address, chainId)\n}\n"],"mappings":"AAEA,SAASA,mBAAmB,QAAQ,yBAAyB;AAE7D,SAEEC,aAAa,QACR,wBAAwB;AAC/B,SAAkCC,SAAS,QAAQ,sBAAsB;AACzE,SAASC,MAAM,QAAQ,WAAW;AAClC,SAAkCC,SAAS,QAAQ,gBAAgB;AAEnE,MAAMC,oBAAoB,GAAG,aAAc,IAAIF,MAAM,CAAU,IAAI,CAAC;AAOpE,OAAM,SAAUG,eAAeA,CAC7BC,QAAiB;AACjB;;;;;;;;;;AAUAC,OAA4B;EAE5B,IAAIH,oBAAoB,CAACI,GAAG,CAAC,GAAGF,QAAQ,IAAIC,OAAO,EAAE,CAAC,EACpD,OAAOH,oBAAoB,CAACK,GAAG,CAAC,GAAGH,QAAQ,IAAIC,OAAO,EAAE,CAAE;EAE5D,MAAMG,UAAU,GAAGH,OAAO,GACtB,GAAGA,OAAO,GAAGD,QAAQ,CAACK,WAAW,EAAE,EAAE,GACrCL,QAAQ,CAACM,SAAS,CAAC,CAAC,CAAC,CAACD,WAAW,EAAE;EACvC,MAAME,IAAI,GAAGZ,SAAS,CAACD,aAAa,CAACU,UAAU,CAAC,EAAE,OAAO,CAAC;EAE1D,MAAMI,OAAO,GAAG,CACdP,OAAO,GAAGG,UAAU,CAACE,SAAS,CAAC,GAAGL,OAAO,IAAI,CAACQ,MAAM,CAAC,GAAGL,UAAU,EAClEM,KAAK,CAAC,EAAE,CAAC;EACX,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,EAAE,EAAEA,CAAC,IAAI,CAAC,EAAE;IAC9B,IAAIJ,IAAI,CAACI,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,IAAIH,OAAO,CAACG,CAAC,CAAC,EAAE;MACxCH,OAAO,CAACG,CAAC,CAAC,GAAGH,OAAO,CAACG,CAAC,CAAC,CAACC,WAAW,EAAE;IACvC;IACA,IAAI,CAACL,IAAI,CAACI,CAAC,IAAI,CAAC,CAAC,GAAG,IAAI,KAAK,CAAC,IAAIH,OAAO,CAACG,CAAC,GAAG,CAAC,CAAC,EAAE;MAChDH,OAAO,CAACG,CAAC,GAAG,CAAC,CAAC,GAAGH,OAAO,CAACG,CAAC,GAAG,CAAC,CAAC,CAACC,WAAW,EAAE;IAC/C;EACF;EAEA,MAAMC,MAAM,GAAG,KAAKL,OAAO,CAACM,IAAI,CAAC,EAAE,CAAC,EAAW;EAC/ChB,oBAAoB,CAACiB,GAAG,CAAC,GAAGf,QAAQ,IAAIC,OAAO,EAAE,EAAEY,MAAM,CAAC;EAC1D,OAAOA,MAAM;AACf;AAOA,OAAM,SAAUG,UAAUA,CACxBR,OAAe;AACf;;;;;;;;;;AAUAP,OAAgB;EAEhB,IAAI,CAACJ,SAAS,CAACW,OAAO,EAAE;IAAES,MAAM,EAAE;EAAK,CAAE,CAAC,EACxC,MAAM,IAAIxB,mBAAmB,CAAC;IAAEe;EAAO,CAAE,CAAC;EAC5C,OAAOT,eAAe,CAACS,OAAO,EAAEP,OAAO,CAAC;AAC1C","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}