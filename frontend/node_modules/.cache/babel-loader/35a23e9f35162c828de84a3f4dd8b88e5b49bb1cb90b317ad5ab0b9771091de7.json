{"ast":null,"code":"import { RELAYER_EVENTS as Xe, TRANSPORT_TYPES as P, EXPIRER_EVENTS as Tt, PAIRING_EVENTS as Je, RELAYER_DEFAULT_PROTOCOL as qt, EVENT_CLIENT_SESSION_TRACES as k, EVENT_CLIENT_SESSION_ERRORS as H, EVENT_CLIENT_AUTHENTICATE_TRACES as z, EVENT_CLIENT_AUTHENTICATE_ERRORS as re, EVENT_CLIENT_PAIRING_ERRORS as Pt, EVENT_CLIENT_PAIRING_TRACES as Nt, VERIFY_SERVER as Ot, Store as B, Core as bt } from \"@walletconnect/core\";\nimport { pino as At, getDefaultLoggerOptions as xt, generateChildLogger as Ct, getLoggerContext as Vt } from \"@walletconnect/logger\";\nimport { IEngine as Dt, ISignClient as Lt } from \"@walletconnect/types\";\nimport { THIRTY_DAYS as kt, SEVEN_DAYS as Be, FIVE_MINUTES as C, ONE_DAY as K, ONE_HOUR as We, ONE_SECOND as Ze, toMiliseconds as Oe } from \"@walletconnect/time\";\nimport { getInternalError as y, BASE64URL as ne, BASE64 as de, hashMessage as W, parseExpirerTarget as Mt, isValidString as Y, isExpired as Z, isValidId as $t, calcExpiry as V, engineEvent as R, createDelayedPromise as ee, getSdkError as O, getDeepLink as Ut, handleDeeplinkRedirect as Kt, isSessionCompatible as Gt, hashKey as be, parseChainId as Ae, createEncodedRecap as jt, getRecapFromResources as xe, mergeEncodedRecaps as Ft, TYPE_2 as Qt, getLinkModeURL as ue, validateSignedCacao as et, getNamespacedDidChainId as tt, getDidAddress as st, getMethodsFromRecap as it, getChainsFromRecap as rt, buildNamespacesFromAuth as nt, formatMessage as Ht, MemoryStore as oe, isValidParams as M, isUndefined as X, isValidRelays as zt, isValidObject as ot, isValidRequiredNamespaces as Yt, isValidNamespaces as Ce, isConformingNamespaces as at, isValidErrorReason as Xt, isValidRelay as Jt, isValidController as Bt, isValidNamespacesChainId as ct, isValidRequest as Wt, isValidNamespacesRequest as Zt, isValidRequestExpiry as es, isValidResponse as ts, isValidEvent as ss, isValidNamespacesEvent as is, getSearchParamFromURL as lt, isTestRun as rs, isReactNative as ns, isValidArray as os, extractSolanaTransactionId as as, TYPE_1 as Ve, getAppMetadata as cs } from \"@walletconnect/utils\";\nimport ls, { EventEmitter as ps } from \"events\";\nimport { isJsonRpcRequest as hs, isJsonRpcResponse as ds, payloadId as G, getBigIntRpcId as ge, isJsonRpcResult as j, isJsonRpcError as F, formatJsonRpcRequest as ye, formatJsonRpcResult as us, formatJsonRpcError as gs } from \"@walletconnect/jsonrpc-utils\";\nconst De = \"wc\",\n  Le = 2,\n  ke = \"client\",\n  we = `${De}@${Le}:${ke}:`,\n  me = {\n    name: ke,\n    logger: \"error\",\n    controller: !1,\n    relayUrl: \"wss://relay.walletconnect.org\"\n  },\n  ys = {\n    session_proposal: \"session_proposal\",\n    session_update: \"session_update\",\n    session_extend: \"session_extend\",\n    session_ping: \"session_ping\",\n    session_delete: \"session_delete\",\n    session_expire: \"session_expire\",\n    session_request: \"session_request\",\n    session_request_sent: \"session_request_sent\",\n    session_event: \"session_event\",\n    proposal_expire: \"proposal_expire\",\n    session_authenticate: \"session_authenticate\",\n    session_request_expire: \"session_request_expire\",\n    session_connect: \"session_connect\"\n  },\n  ws = {\n    database: \":memory:\"\n  },\n  Me = \"WALLETCONNECT_DEEPLINK_CHOICE\",\n  ms = {\n    created: \"history_created\",\n    updated: \"history_updated\",\n    deleted: \"history_deleted\",\n    sync: \"history_sync\"\n  },\n  _s = \"history\",\n  Es = \"0.3\",\n  pt = \"proposal\",\n  fs = kt,\n  $e = \"Proposal expired\",\n  ht = \"session\",\n  J = Be,\n  dt = \"engine\",\n  N = {\n    wc_sessionPropose: {\n      req: {\n        ttl: C,\n        prompt: !0,\n        tag: 1100\n      },\n      res: {\n        ttl: C,\n        prompt: !1,\n        tag: 1101\n      },\n      reject: {\n        ttl: C,\n        prompt: !1,\n        tag: 1120\n      },\n      autoReject: {\n        ttl: C,\n        prompt: !1,\n        tag: 1121\n      }\n    },\n    wc_sessionSettle: {\n      req: {\n        ttl: C,\n        prompt: !1,\n        tag: 1102\n      },\n      res: {\n        ttl: C,\n        prompt: !1,\n        tag: 1103\n      }\n    },\n    wc_sessionUpdate: {\n      req: {\n        ttl: K,\n        prompt: !1,\n        tag: 1104\n      },\n      res: {\n        ttl: K,\n        prompt: !1,\n        tag: 1105\n      }\n    },\n    wc_sessionExtend: {\n      req: {\n        ttl: K,\n        prompt: !1,\n        tag: 1106\n      },\n      res: {\n        ttl: K,\n        prompt: !1,\n        tag: 1107\n      }\n    },\n    wc_sessionRequest: {\n      req: {\n        ttl: C,\n        prompt: !0,\n        tag: 1108\n      },\n      res: {\n        ttl: C,\n        prompt: !1,\n        tag: 1109\n      }\n    },\n    wc_sessionEvent: {\n      req: {\n        ttl: C,\n        prompt: !0,\n        tag: 1110\n      },\n      res: {\n        ttl: C,\n        prompt: !1,\n        tag: 1111\n      }\n    },\n    wc_sessionDelete: {\n      req: {\n        ttl: K,\n        prompt: !1,\n        tag: 1112\n      },\n      res: {\n        ttl: K,\n        prompt: !1,\n        tag: 1113\n      }\n    },\n    wc_sessionPing: {\n      req: {\n        ttl: K,\n        prompt: !1,\n        tag: 1114\n      },\n      res: {\n        ttl: K,\n        prompt: !1,\n        tag: 1115\n      }\n    },\n    wc_sessionAuthenticate: {\n      req: {\n        ttl: We,\n        prompt: !0,\n        tag: 1116\n      },\n      res: {\n        ttl: We,\n        prompt: !1,\n        tag: 1117\n      },\n      reject: {\n        ttl: C,\n        prompt: !1,\n        tag: 1118\n      },\n      autoReject: {\n        ttl: C,\n        prompt: !1,\n        tag: 1119\n      }\n    }\n  },\n  _e = {\n    min: C,\n    max: Be\n  },\n  $ = {\n    idle: \"IDLE\",\n    active: \"ACTIVE\"\n  },\n  Ue = {\n    eth_sendTransaction: {\n      key: \"\"\n    },\n    eth_sendRawTransaction: {\n      key: \"\"\n    },\n    wallet_sendCalls: {\n      key: \"\"\n    },\n    solana_signTransaction: {\n      key: \"signature\"\n    },\n    solana_signAllTransactions: {\n      key: \"transactions\"\n    },\n    solana_signAndSendTransaction: {\n      key: \"signature\"\n    }\n  },\n  ut = \"request\",\n  gt = [\"wc_sessionPropose\", \"wc_sessionRequest\", \"wc_authRequest\", \"wc_sessionAuthenticate\"],\n  yt = \"wc\",\n  Ss = 1.5,\n  wt = \"auth\",\n  mt = \"authKeys\",\n  _t = \"pairingTopics\",\n  Et = \"requests\",\n  ae = `${yt}@${1.5}:${wt}:`,\n  ce = `${ae}:PUB_KEY`;\nvar Rs = Object.defineProperty,\n  vs = Object.defineProperties,\n  Is = Object.getOwnPropertyDescriptors,\n  ft = Object.getOwnPropertySymbols,\n  Ts = Object.prototype.hasOwnProperty,\n  qs = Object.prototype.propertyIsEnumerable,\n  Ke = (S, n, e) => n in S ? Rs(S, n, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : S[n] = e,\n  v = (S, n) => {\n    for (var e in n || (n = {})) Ts.call(n, e) && Ke(S, e, n[e]);\n    if (ft) for (var e of ft(n)) qs.call(n, e) && Ke(S, e, n[e]);\n    return S;\n  },\n  b = (S, n) => vs(S, Is(n)),\n  c = (S, n, e) => Ke(S, typeof n != \"symbol\" ? n + \"\" : n, e);\nclass Ps extends Dt {\n  constructor(n) {\n    super(n), c(this, \"name\", dt), c(this, \"events\", new ls()), c(this, \"initialized\", !1), c(this, \"requestQueue\", {\n      state: $.idle,\n      queue: []\n    }), c(this, \"sessionRequestQueue\", {\n      state: $.idle,\n      queue: []\n    }), c(this, \"requestQueueDelay\", Ze), c(this, \"expectedPairingMethodMap\", new Map()), c(this, \"recentlyDeletedMap\", new Map()), c(this, \"recentlyDeletedLimit\", 200), c(this, \"relayMessageCache\", []), c(this, \"pendingSessions\", new Map()), c(this, \"init\", async () => {\n      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({\n        methods: Object.keys(N)\n      }), this.initialized = !0, setTimeout(async () => {\n        await this.processPendingMessageEvents(), this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();\n      }, Oe(this.requestQueueDelay)));\n    }), c(this, \"connect\", async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      const t = b(v({}, e), {\n        requiredNamespaces: e.requiredNamespaces || {},\n        optionalNamespaces: e.optionalNamespaces || {}\n      });\n      await this.isValidConnect(t);\n      const {\n        pairingTopic: s,\n        requiredNamespaces: i,\n        optionalNamespaces: r,\n        sessionProperties: o,\n        scopedProperties: a,\n        relays: l\n      } = t;\n      let p = s,\n        h,\n        u = !1;\n      try {\n        if (p) {\n          const T = this.client.core.pairing.pairings.get(p);\n          this.client.logger.warn(\"connect() with existing pairing topic is deprecated and will be removed in the next major release.\"), u = T.active;\n        }\n      } catch (T) {\n        throw this.client.logger.error(`connect() -> pairing.get(${p}) failed`), T;\n      }\n      if (!p || !u) {\n        const {\n          topic: T,\n          uri: U\n        } = await this.client.core.pairing.create();\n        p = T, h = U;\n      }\n      if (!p) {\n        const {\n          message: T\n        } = y(\"NO_MATCHING_KEY\", `connect() pairing topic: ${p}`);\n        throw new Error(T);\n      }\n      const d = await this.client.core.crypto.generateKeyPair(),\n        w = N.wc_sessionPropose.req.ttl || C,\n        m = V(w),\n        f = b(v(v({\n          requiredNamespaces: i,\n          optionalNamespaces: r,\n          relays: l ?? [{\n            protocol: qt\n          }],\n          proposer: {\n            publicKey: d,\n            metadata: this.client.metadata\n          },\n          expiryTimestamp: m,\n          pairingTopic: p\n        }, o && {\n          sessionProperties: o\n        }), a && {\n          scopedProperties: a\n        }), {\n          id: G()\n        }),\n        _ = R(\"session_connect\", f.id),\n        {\n          reject: g,\n          resolve: A,\n          done: D\n        } = ee(w, $e),\n        I = ({\n          id: T\n        }) => {\n          T === f.id && (this.client.events.off(\"proposal_expire\", I), this.pendingSessions.delete(f.id), this.events.emit(_, {\n            error: {\n              message: $e,\n              code: 0\n            }\n          }));\n        };\n      return this.client.events.on(\"proposal_expire\", I), this.events.once(_, ({\n        error: T,\n        session: U\n      }) => {\n        this.client.events.off(\"proposal_expire\", I), T ? g(T) : U && A(U);\n      }), await this.sendRequest({\n        topic: p,\n        method: \"wc_sessionPropose\",\n        params: f,\n        throwOnFailedPublish: !0,\n        clientRpcId: f.id\n      }), await this.setProposal(f.id, f), {\n        uri: h,\n        approval: D\n      };\n    }), c(this, \"pair\", async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      try {\n        return await this.client.core.pairing.pair(e);\n      } catch (t) {\n        throw this.client.logger.error(\"pair() failed\"), t;\n      }\n    }), c(this, \"approve\", async e => {\n      var t, s, i;\n      const r = this.client.core.eventClient.createEvent({\n        properties: {\n          topic: (t = e?.id) == null ? void 0 : t.toString(),\n          trace: [k.session_approve_started]\n        }\n      });\n      try {\n        this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      } catch (q) {\n        throw r.setError(H.no_internet_connection), q;\n      }\n      try {\n        await this.isValidProposalId(e?.id);\n      } catch (q) {\n        throw this.client.logger.error(`approve() -> proposal.get(${e?.id}) failed`), r.setError(H.proposal_not_found), q;\n      }\n      try {\n        await this.isValidApprove(e);\n      } catch (q) {\n        throw this.client.logger.error(\"approve() -> isValidApprove() failed\"), r.setError(H.session_approve_namespace_validation_failure), q;\n      }\n      const {\n          id: o,\n          relayProtocol: a,\n          namespaces: l,\n          sessionProperties: p,\n          scopedProperties: h,\n          sessionConfig: u\n        } = e,\n        d = this.client.proposal.get(o);\n      this.client.core.eventClient.deleteEvent({\n        eventId: r.eventId\n      });\n      const {\n        pairingTopic: w,\n        proposer: m,\n        requiredNamespaces: f,\n        optionalNamespaces: _\n      } = d;\n      let g = (s = this.client.core.eventClient) == null ? void 0 : s.getEvent({\n        topic: w\n      });\n      g || (g = (i = this.client.core.eventClient) == null ? void 0 : i.createEvent({\n        type: k.session_approve_started,\n        properties: {\n          topic: w,\n          trace: [k.session_approve_started, k.session_namespaces_validation_success]\n        }\n      }));\n      const A = await this.client.core.crypto.generateKeyPair(),\n        D = m.publicKey,\n        I = await this.client.core.crypto.generateSharedKey(A, D),\n        T = v(v(v({\n          relay: {\n            protocol: a ?? \"irn\"\n          },\n          namespaces: l,\n          controller: {\n            publicKey: A,\n            metadata: this.client.metadata\n          },\n          expiry: V(J)\n        }, p && {\n          sessionProperties: p\n        }), h && {\n          scopedProperties: h\n        }), u && {\n          sessionConfig: u\n        }),\n        U = P.relay;\n      g.addTrace(k.subscribing_session_topic);\n      try {\n        await this.client.core.relayer.subscribe(I, {\n          transportType: U\n        });\n      } catch (q) {\n        throw g.setError(H.subscribe_session_topic_failure), q;\n      }\n      g.addTrace(k.subscribe_session_topic_success);\n      const fe = b(v({}, T), {\n        topic: I,\n        requiredNamespaces: f,\n        optionalNamespaces: _,\n        pairingTopic: w,\n        acknowledged: !1,\n        self: T.controller,\n        peer: {\n          publicKey: m.publicKey,\n          metadata: m.metadata\n        },\n        controller: A,\n        transportType: P.relay\n      });\n      await this.client.session.set(I, fe), g.addTrace(k.store_session);\n      try {\n        g.addTrace(k.publishing_session_settle), await this.sendRequest({\n          topic: I,\n          method: \"wc_sessionSettle\",\n          params: T,\n          throwOnFailedPublish: !0\n        }).catch(q => {\n          throw g?.setError(H.session_settle_publish_failure), q;\n        }), g.addTrace(k.session_settle_publish_success), g.addTrace(k.publishing_session_approve), await this.sendResult({\n          id: o,\n          topic: w,\n          result: {\n            relay: {\n              protocol: a ?? \"irn\"\n            },\n            responderPublicKey: A\n          },\n          throwOnFailedPublish: !0\n        }).catch(q => {\n          throw g?.setError(H.session_approve_publish_failure), q;\n        }), g.addTrace(k.session_approve_publish_success);\n      } catch (q) {\n        throw this.client.logger.error(q), this.client.session.delete(I, O(\"USER_DISCONNECTED\")), await this.client.core.relayer.unsubscribe(I), q;\n      }\n      return this.client.core.eventClient.deleteEvent({\n        eventId: g.eventId\n      }), await this.client.core.pairing.updateMetadata({\n        topic: w,\n        metadata: m.metadata\n      }), await this.client.proposal.delete(o, O(\"USER_DISCONNECTED\")), await this.client.core.pairing.activate({\n        topic: w\n      }), await this.setExpiry(I, V(J)), {\n        topic: I,\n        acknowledged: () => Promise.resolve(this.client.session.get(I))\n      };\n    }), c(this, \"reject\", async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      try {\n        await this.isValidReject(e);\n      } catch (r) {\n        throw this.client.logger.error(\"reject() -> isValidReject() failed\"), r;\n      }\n      const {\n        id: t,\n        reason: s\n      } = e;\n      let i;\n      try {\n        i = this.client.proposal.get(t).pairingTopic;\n      } catch (r) {\n        throw this.client.logger.error(`reject() -> proposal.get(${t}) failed`), r;\n      }\n      i && (await this.sendError({\n        id: t,\n        topic: i,\n        error: s,\n        rpcOpts: N.wc_sessionPropose.reject\n      }), await this.client.proposal.delete(t, O(\"USER_DISCONNECTED\")));\n    }), c(this, \"update\", async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      try {\n        await this.isValidUpdate(e);\n      } catch (h) {\n        throw this.client.logger.error(\"update() -> isValidUpdate() failed\"), h;\n      }\n      const {\n          topic: t,\n          namespaces: s\n        } = e,\n        {\n          done: i,\n          resolve: r,\n          reject: o\n        } = ee(),\n        a = G(),\n        l = ge().toString(),\n        p = this.client.session.get(t).namespaces;\n      return this.events.once(R(\"session_update\", a), ({\n        error: h\n      }) => {\n        h ? o(h) : r();\n      }), await this.client.session.update(t, {\n        namespaces: s\n      }), await this.sendRequest({\n        topic: t,\n        method: \"wc_sessionUpdate\",\n        params: {\n          namespaces: s\n        },\n        throwOnFailedPublish: !0,\n        clientRpcId: a,\n        relayRpcId: l\n      }).catch(h => {\n        this.client.logger.error(h), this.client.session.update(t, {\n          namespaces: p\n        }), o(h);\n      }), {\n        acknowledged: i\n      };\n    }), c(this, \"extend\", async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      try {\n        await this.isValidExtend(e);\n      } catch (a) {\n        throw this.client.logger.error(\"extend() -> isValidExtend() failed\"), a;\n      }\n      const {\n          topic: t\n        } = e,\n        s = G(),\n        {\n          done: i,\n          resolve: r,\n          reject: o\n        } = ee();\n      return this.events.once(R(\"session_extend\", s), ({\n        error: a\n      }) => {\n        a ? o(a) : r();\n      }), await this.setExpiry(t, V(J)), this.sendRequest({\n        topic: t,\n        method: \"wc_sessionExtend\",\n        params: {},\n        clientRpcId: s,\n        throwOnFailedPublish: !0\n      }).catch(a => {\n        o(a);\n      }), {\n        acknowledged: i\n      };\n    }), c(this, \"request\", async e => {\n      this.isInitialized();\n      try {\n        await this.isValidRequest(e);\n      } catch (_) {\n        throw this.client.logger.error(\"request() -> isValidRequest() failed\"), _;\n      }\n      const {\n          chainId: t,\n          request: s,\n          topic: i,\n          expiry: r = N.wc_sessionRequest.req.ttl\n        } = e,\n        o = this.client.session.get(i);\n      o?.transportType === P.relay && (await this.confirmOnlineStateOrThrow());\n      const a = G(),\n        l = ge().toString(),\n        {\n          done: p,\n          resolve: h,\n          reject: u\n        } = ee(r, \"Request expired. Please try again.\");\n      this.events.once(R(\"session_request\", a), ({\n        error: _,\n        result: g\n      }) => {\n        _ ? u(_) : h(g);\n      });\n      const d = \"wc_sessionRequest\",\n        w = this.getAppLinkIfEnabled(o.peer.metadata, o.transportType);\n      if (w) return await this.sendRequest({\n        clientRpcId: a,\n        relayRpcId: l,\n        topic: i,\n        method: d,\n        params: {\n          request: b(v({}, s), {\n            expiryTimestamp: V(r)\n          }),\n          chainId: t\n        },\n        expiry: r,\n        throwOnFailedPublish: !0,\n        appLink: w\n      }).catch(_ => u(_)), this.client.events.emit(\"session_request_sent\", {\n        topic: i,\n        request: s,\n        chainId: t,\n        id: a\n      }), await p();\n      const m = {\n          request: b(v({}, s), {\n            expiryTimestamp: V(r)\n          }),\n          chainId: t\n        },\n        f = this.shouldSetTVF(d, m);\n      return await Promise.all([new Promise(async _ => {\n        await this.sendRequest(v({\n          clientRpcId: a,\n          relayRpcId: l,\n          topic: i,\n          method: d,\n          params: m,\n          expiry: r,\n          throwOnFailedPublish: !0\n        }, f && {\n          tvf: this.getTVFParams(a, m)\n        })).catch(g => u(g)), this.client.events.emit(\"session_request_sent\", {\n          topic: i,\n          request: s,\n          chainId: t,\n          id: a\n        }), _();\n      }), new Promise(async _ => {\n        var g;\n        if (!((g = o.sessionConfig) != null && g.disableDeepLink)) {\n          const A = await Ut(this.client.core.storage, Me);\n          await Kt({\n            id: a,\n            topic: i,\n            wcDeepLink: A\n          });\n        }\n        _();\n      }), p()]).then(_ => _[2]);\n    }), c(this, \"respond\", async e => {\n      this.isInitialized(), await this.isValidRespond(e);\n      const {\n          topic: t,\n          response: s\n        } = e,\n        {\n          id: i\n        } = s,\n        r = this.client.session.get(t);\n      r.transportType === P.relay && (await this.confirmOnlineStateOrThrow());\n      const o = this.getAppLinkIfEnabled(r.peer.metadata, r.transportType);\n      j(s) ? await this.sendResult({\n        id: i,\n        topic: t,\n        result: s.result,\n        throwOnFailedPublish: !0,\n        appLink: o\n      }) : F(s) && (await this.sendError({\n        id: i,\n        topic: t,\n        error: s.error,\n        appLink: o\n      })), this.cleanupAfterResponse(e);\n    }), c(this, \"ping\", async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      try {\n        await this.isValidPing(e);\n      } catch (s) {\n        throw this.client.logger.error(\"ping() -> isValidPing() failed\"), s;\n      }\n      const {\n        topic: t\n      } = e;\n      if (this.client.session.keys.includes(t)) {\n        const s = G(),\n          i = ge().toString(),\n          {\n            done: r,\n            resolve: o,\n            reject: a\n          } = ee();\n        this.events.once(R(\"session_ping\", s), ({\n          error: l\n        }) => {\n          l ? a(l) : o();\n        }), await Promise.all([this.sendRequest({\n          topic: t,\n          method: \"wc_sessionPing\",\n          params: {},\n          throwOnFailedPublish: !0,\n          clientRpcId: s,\n          relayRpcId: i\n        }), r()]);\n      } else this.client.core.pairing.pairings.keys.includes(t) && (this.client.logger.warn(\"ping() on pairing topic is deprecated and will be removed in the next major release.\"), await this.client.core.pairing.ping({\n        topic: t\n      }));\n    }), c(this, \"emit\", async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(e);\n      const {\n          topic: t,\n          event: s,\n          chainId: i\n        } = e,\n        r = ge().toString(),\n        o = G();\n      await this.sendRequest({\n        topic: t,\n        method: \"wc_sessionEvent\",\n        params: {\n          event: s,\n          chainId: i\n        },\n        throwOnFailedPublish: !0,\n        relayRpcId: r,\n        clientRpcId: o\n      });\n    }), c(this, \"disconnect\", async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(e);\n      const {\n        topic: t\n      } = e;\n      if (this.client.session.keys.includes(t)) await this.sendRequest({\n        topic: t,\n        method: \"wc_sessionDelete\",\n        params: O(\"USER_DISCONNECTED\"),\n        throwOnFailedPublish: !0\n      }), await this.deleteSession({\n        topic: t,\n        emitEvent: !1\n      });else if (this.client.core.pairing.pairings.keys.includes(t)) await this.client.core.pairing.disconnect({\n        topic: t\n      });else {\n        const {\n          message: s\n        } = y(\"MISMATCHED_TOPIC\", `Session or pairing topic not found: ${t}`);\n        throw new Error(s);\n      }\n    }), c(this, \"find\", e => (this.isInitialized(), this.client.session.getAll().filter(t => Gt(t, e)))), c(this, \"getPendingSessionRequests\", () => this.client.pendingRequest.getAll()), c(this, \"authenticate\", async (e, t) => {\n      var s;\n      this.isInitialized(), this.isValidAuthenticate(e);\n      const i = t && this.client.core.linkModeSupportedApps.includes(t) && ((s = this.client.metadata.redirect) == null ? void 0 : s.linkMode),\n        r = i ? P.link_mode : P.relay;\n      r === P.relay && (await this.confirmOnlineStateOrThrow());\n      const {\n          chains: o,\n          statement: a = \"\",\n          uri: l,\n          domain: p,\n          nonce: h,\n          type: u,\n          exp: d,\n          nbf: w,\n          methods: m = [],\n          expiry: f\n        } = e,\n        _ = [...(e.resources || [])],\n        {\n          topic: g,\n          uri: A\n        } = await this.client.core.pairing.create({\n          methods: [\"wc_sessionAuthenticate\"],\n          transportType: r\n        });\n      this.client.logger.info({\n        message: \"Generated new pairing\",\n        pairing: {\n          topic: g,\n          uri: A\n        }\n      });\n      const D = await this.client.core.crypto.generateKeyPair(),\n        I = be(D);\n      if (await Promise.all([this.client.auth.authKeys.set(ce, {\n        responseTopic: I,\n        publicKey: D\n      }), this.client.auth.pairingTopics.set(I, {\n        topic: I,\n        pairingTopic: g\n      })]), await this.client.core.relayer.subscribe(I, {\n        transportType: r\n      }), this.client.logger.info(`sending request to new pairing topic: ${g}`), m.length > 0) {\n        const {\n          namespace: x\n        } = Ae(o[0]);\n        let L = jt(x, \"request\", m);\n        xe(_) && (L = Ft(L, _.pop())), _.push(L);\n      }\n      const T = f && f > N.wc_sessionAuthenticate.req.ttl ? f : N.wc_sessionAuthenticate.req.ttl,\n        U = {\n          authPayload: {\n            type: u ?? \"caip122\",\n            chains: o,\n            statement: a,\n            aud: l,\n            domain: p,\n            version: \"1\",\n            nonce: h,\n            iat: new Date().toISOString(),\n            exp: d,\n            nbf: w,\n            resources: _\n          },\n          requester: {\n            publicKey: D,\n            metadata: this.client.metadata\n          },\n          expiryTimestamp: V(T)\n        },\n        fe = {\n          eip155: {\n            chains: o,\n            methods: [...new Set([\"personal_sign\", ...m])],\n            events: [\"chainChanged\", \"accountsChanged\"]\n          }\n        },\n        q = {\n          requiredNamespaces: {},\n          optionalNamespaces: fe,\n          relays: [{\n            protocol: \"irn\"\n          }],\n          pairingTopic: g,\n          proposer: {\n            publicKey: D,\n            metadata: this.client.metadata\n          },\n          expiryTimestamp: V(N.wc_sessionPropose.req.ttl),\n          id: G()\n        },\n        {\n          done: Rt,\n          resolve: je,\n          reject: Se\n        } = ee(T, \"Request expired\"),\n        te = G(),\n        le = R(\"session_connect\", q.id),\n        Re = R(\"session_request\", te),\n        pe = async ({\n          error: x,\n          session: L\n        }) => {\n          this.events.off(Re, ve), x ? Se(x) : L && je({\n            session: L\n          });\n        },\n        ve = async x => {\n          var L, Fe, Qe;\n          if (await this.deletePendingAuthRequest(te, {\n            message: \"fulfilled\",\n            code: 0\n          }), x.error) {\n            const ie = O(\"WC_METHOD_UNSUPPORTED\", \"wc_sessionAuthenticate\");\n            return x.error.code === ie.code ? void 0 : (this.events.off(le, pe), Se(x.error.message));\n          }\n          await this.deleteProposal(q.id), this.events.off(le, pe);\n          const {\n              cacaos: He,\n              responder: Q\n            } = x.result,\n            Te = [],\n            ze = [];\n          for (const ie of He) {\n            (await et({\n              cacao: ie,\n              projectId: this.client.core.projectId\n            })) || (this.client.logger.error(ie, \"Signature verification failed\"), Se(O(\"SESSION_SETTLEMENT_FAILED\", \"Signature verification failed\")));\n            const {\n                p: qe\n              } = ie,\n              Pe = xe(qe.resources),\n              Ye = [tt(qe.iss)],\n              vt = st(qe.iss);\n            if (Pe) {\n              const Ne = it(Pe),\n                It = rt(Pe);\n              Te.push(...Ne), Ye.push(...It);\n            }\n            for (const Ne of Ye) ze.push(`${Ne}:${vt}`);\n          }\n          const se = await this.client.core.crypto.generateSharedKey(D, Q.publicKey);\n          let he;\n          Te.length > 0 && (he = {\n            topic: se,\n            acknowledged: !0,\n            self: {\n              publicKey: D,\n              metadata: this.client.metadata\n            },\n            peer: Q,\n            controller: Q.publicKey,\n            expiry: V(J),\n            requiredNamespaces: {},\n            optionalNamespaces: {},\n            relay: {\n              protocol: \"irn\"\n            },\n            pairingTopic: g,\n            namespaces: nt([...new Set(Te)], [...new Set(ze)]),\n            transportType: r\n          }, await this.client.core.relayer.subscribe(se, {\n            transportType: r\n          }), await this.client.session.set(se, he), g && (await this.client.core.pairing.updateMetadata({\n            topic: g,\n            metadata: Q.metadata\n          })), he = this.client.session.get(se)), (L = this.client.metadata.redirect) != null && L.linkMode && (Fe = Q.metadata.redirect) != null && Fe.linkMode && (Qe = Q.metadata.redirect) != null && Qe.universal && t && (this.client.core.addLinkModeSupportedApp(Q.metadata.redirect.universal), this.client.session.update(se, {\n            transportType: P.link_mode\n          })), je({\n            auths: He,\n            session: he\n          });\n        };\n      this.events.once(le, pe), this.events.once(Re, ve);\n      let Ie;\n      try {\n        if (i) {\n          const x = ye(\"wc_sessionAuthenticate\", U, te);\n          this.client.core.history.set(g, x);\n          const L = await this.client.core.crypto.encode(\"\", x, {\n            type: Qt,\n            encoding: ne\n          });\n          Ie = ue(t, g, L);\n        } else await Promise.all([this.sendRequest({\n          topic: g,\n          method: \"wc_sessionAuthenticate\",\n          params: U,\n          expiry: e.expiry,\n          throwOnFailedPublish: !0,\n          clientRpcId: te\n        }), this.sendRequest({\n          topic: g,\n          method: \"wc_sessionPropose\",\n          params: q,\n          expiry: N.wc_sessionPropose.req.ttl,\n          throwOnFailedPublish: !0,\n          clientRpcId: q.id\n        })]);\n      } catch (x) {\n        throw this.events.off(le, pe), this.events.off(Re, ve), x;\n      }\n      return await this.setProposal(q.id, q), await this.setAuthRequest(te, {\n        request: b(v({}, U), {\n          verifyContext: {}\n        }),\n        pairingTopic: g,\n        transportType: r\n      }), {\n        uri: Ie ?? A,\n        response: Rt\n      };\n    }), c(this, \"approveSessionAuthenticate\", async e => {\n      const {\n          id: t,\n          auths: s\n        } = e,\n        i = this.client.core.eventClient.createEvent({\n          properties: {\n            topic: t.toString(),\n            trace: [z.authenticated_session_approve_started]\n          }\n        });\n      try {\n        this.isInitialized();\n      } catch (f) {\n        throw i.setError(re.no_internet_connection), f;\n      }\n      const r = this.getPendingAuthRequest(t);\n      if (!r) throw i.setError(re.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${t}`);\n      const o = r.transportType || P.relay;\n      o === P.relay && (await this.confirmOnlineStateOrThrow());\n      const a = r.requester.publicKey,\n        l = await this.client.core.crypto.generateKeyPair(),\n        p = be(a),\n        h = {\n          type: Ve,\n          receiverPublicKey: a,\n          senderPublicKey: l\n        },\n        u = [],\n        d = [];\n      for (const f of s) {\n        if (!(await et({\n          cacao: f,\n          projectId: this.client.core.projectId\n        }))) {\n          i.setError(re.invalid_cacao);\n          const I = O(\"SESSION_SETTLEMENT_FAILED\", \"Signature verification failed\");\n          throw await this.sendError({\n            id: t,\n            topic: p,\n            error: I,\n            encodeOpts: h\n          }), new Error(I.message);\n        }\n        i.addTrace(z.cacaos_verified);\n        const {\n            p: _\n          } = f,\n          g = xe(_.resources),\n          A = [tt(_.iss)],\n          D = st(_.iss);\n        if (g) {\n          const I = it(g),\n            T = rt(g);\n          u.push(...I), A.push(...T);\n        }\n        for (const I of A) d.push(`${I}:${D}`);\n      }\n      const w = await this.client.core.crypto.generateSharedKey(l, a);\n      i.addTrace(z.create_authenticated_session_topic);\n      let m;\n      if (u?.length > 0) {\n        m = {\n          topic: w,\n          acknowledged: !0,\n          self: {\n            publicKey: l,\n            metadata: this.client.metadata\n          },\n          peer: {\n            publicKey: a,\n            metadata: r.requester.metadata\n          },\n          controller: a,\n          expiry: V(J),\n          authentication: s,\n          requiredNamespaces: {},\n          optionalNamespaces: {},\n          relay: {\n            protocol: \"irn\"\n          },\n          pairingTopic: r.pairingTopic,\n          namespaces: nt([...new Set(u)], [...new Set(d)]),\n          transportType: o\n        }, i.addTrace(z.subscribing_authenticated_session_topic);\n        try {\n          await this.client.core.relayer.subscribe(w, {\n            transportType: o\n          });\n        } catch (f) {\n          throw i.setError(re.subscribe_authenticated_session_topic_failure), f;\n        }\n        i.addTrace(z.subscribe_authenticated_session_topic_success), await this.client.session.set(w, m), i.addTrace(z.store_authenticated_session), await this.client.core.pairing.updateMetadata({\n          topic: r.pairingTopic,\n          metadata: r.requester.metadata\n        });\n      }\n      i.addTrace(z.publishing_authenticated_session_approve);\n      try {\n        await this.sendResult({\n          topic: p,\n          id: t,\n          result: {\n            cacaos: s,\n            responder: {\n              publicKey: l,\n              metadata: this.client.metadata\n            }\n          },\n          encodeOpts: h,\n          throwOnFailedPublish: !0,\n          appLink: this.getAppLinkIfEnabled(r.requester.metadata, o)\n        });\n      } catch (f) {\n        throw i.setError(re.authenticated_session_approve_publish_failure), f;\n      }\n      return await this.client.auth.requests.delete(t, {\n        message: \"fulfilled\",\n        code: 0\n      }), await this.client.core.pairing.activate({\n        topic: r.pairingTopic\n      }), this.client.core.eventClient.deleteEvent({\n        eventId: i.eventId\n      }), {\n        session: m\n      };\n    }), c(this, \"rejectSessionAuthenticate\", async e => {\n      this.isInitialized();\n      const {\n          id: t,\n          reason: s\n        } = e,\n        i = this.getPendingAuthRequest(t);\n      if (!i) throw new Error(`Could not find pending auth request with id ${t}`);\n      i.transportType === P.relay && (await this.confirmOnlineStateOrThrow());\n      const r = i.requester.publicKey,\n        o = await this.client.core.crypto.generateKeyPair(),\n        a = be(r),\n        l = {\n          type: Ve,\n          receiverPublicKey: r,\n          senderPublicKey: o\n        };\n      await this.sendError({\n        id: t,\n        topic: a,\n        error: s,\n        encodeOpts: l,\n        rpcOpts: N.wc_sessionAuthenticate.reject,\n        appLink: this.getAppLinkIfEnabled(i.requester.metadata, i.transportType)\n      }), await this.client.auth.requests.delete(t, {\n        message: \"rejected\",\n        code: 0\n      }), await this.client.proposal.delete(t, O(\"USER_DISCONNECTED\"));\n    }), c(this, \"formatAuthMessage\", e => {\n      this.isInitialized();\n      const {\n        request: t,\n        iss: s\n      } = e;\n      return Ht(t, s);\n    }), c(this, \"processRelayMessageCache\", () => {\n      setTimeout(async () => {\n        if (this.relayMessageCache.length !== 0) for (; this.relayMessageCache.length > 0;) try {\n          const e = this.relayMessageCache.shift();\n          e && (await this.onRelayMessage(e));\n        } catch (e) {\n          this.client.logger.error(e);\n        }\n      }, 50);\n    }), c(this, \"cleanupDuplicatePairings\", async e => {\n      if (e.pairingTopic) try {\n        const t = this.client.core.pairing.pairings.get(e.pairingTopic),\n          s = this.client.core.pairing.pairings.getAll().filter(i => {\n            var r, o;\n            return ((r = i.peerMetadata) == null ? void 0 : r.url) && ((o = i.peerMetadata) == null ? void 0 : o.url) === e.peer.metadata.url && i.topic && i.topic !== t.topic;\n          });\n        if (s.length === 0) return;\n        this.client.logger.info(`Cleaning up ${s.length} duplicate pairing(s)`), await Promise.all(s.map(i => this.client.core.pairing.disconnect({\n          topic: i.topic\n        }))), this.client.logger.info(\"Duplicate pairings clean up finished\");\n      } catch (t) {\n        this.client.logger.error(t);\n      }\n    }), c(this, \"deleteSession\", async e => {\n      var t;\n      const {\n          topic: s,\n          expirerHasDeleted: i = !1,\n          emitEvent: r = !0,\n          id: o = 0\n        } = e,\n        {\n          self: a\n        } = this.client.session.get(s);\n      await this.client.core.relayer.unsubscribe(s), await this.client.session.delete(s, O(\"USER_DISCONNECTED\")), this.addToRecentlyDeleted(s, \"session\"), this.client.core.crypto.keychain.has(a.publicKey) && (await this.client.core.crypto.deleteKeyPair(a.publicKey)), this.client.core.crypto.keychain.has(s) && (await this.client.core.crypto.deleteSymKey(s)), i || this.client.core.expirer.del(s), this.client.core.storage.removeItem(Me).catch(l => this.client.logger.warn(l)), this.getPendingSessionRequests().forEach(l => {\n        l.topic === s && this.deletePendingSessionRequest(l.id, O(\"USER_DISCONNECTED\"));\n      }), s === ((t = this.sessionRequestQueue.queue[0]) == null ? void 0 : t.topic) && (this.sessionRequestQueue.state = $.idle), r && this.client.events.emit(\"session_delete\", {\n        id: o,\n        topic: s\n      });\n    }), c(this, \"deleteProposal\", async (e, t) => {\n      if (t) try {\n        const s = this.client.proposal.get(e),\n          i = this.client.core.eventClient.getEvent({\n            topic: s.pairingTopic\n          });\n        i?.setError(H.proposal_expired);\n      } catch {}\n      await Promise.all([this.client.proposal.delete(e, O(\"USER_DISCONNECTED\")), t ? Promise.resolve() : this.client.core.expirer.del(e)]), this.addToRecentlyDeleted(e, \"proposal\");\n    }), c(this, \"deletePendingSessionRequest\", async (e, t, s = !1) => {\n      await Promise.all([this.client.pendingRequest.delete(e, t), s ? Promise.resolve() : this.client.core.expirer.del(e)]), this.addToRecentlyDeleted(e, \"request\"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter(i => i.id !== e), s && (this.sessionRequestQueue.state = $.idle, this.client.events.emit(\"session_request_expire\", {\n        id: e\n      }));\n    }), c(this, \"deletePendingAuthRequest\", async (e, t, s = !1) => {\n      await Promise.all([this.client.auth.requests.delete(e, t), s ? Promise.resolve() : this.client.core.expirer.del(e)]);\n    }), c(this, \"setExpiry\", async (e, t) => {\n      this.client.session.keys.includes(e) && (this.client.core.expirer.set(e, t), await this.client.session.update(e, {\n        expiry: t\n      }));\n    }), c(this, \"setProposal\", async (e, t) => {\n      this.client.core.expirer.set(e, V(N.wc_sessionPropose.req.ttl)), await this.client.proposal.set(e, t);\n    }), c(this, \"setAuthRequest\", async (e, t) => {\n      const {\n        request: s,\n        pairingTopic: i,\n        transportType: r = P.relay\n      } = t;\n      this.client.core.expirer.set(e, s.expiryTimestamp), await this.client.auth.requests.set(e, {\n        authPayload: s.authPayload,\n        requester: s.requester,\n        expiryTimestamp: s.expiryTimestamp,\n        id: e,\n        pairingTopic: i,\n        verifyContext: s.verifyContext,\n        transportType: r\n      });\n    }), c(this, \"setPendingSessionRequest\", async e => {\n      const {\n          id: t,\n          topic: s,\n          params: i,\n          verifyContext: r\n        } = e,\n        o = i.request.expiryTimestamp || V(N.wc_sessionRequest.req.ttl);\n      this.client.core.expirer.set(t, o), await this.client.pendingRequest.set(t, {\n        id: t,\n        topic: s,\n        params: i,\n        verifyContext: r\n      });\n    }), c(this, \"sendRequest\", async e => {\n      const {\n          topic: t,\n          method: s,\n          params: i,\n          expiry: r,\n          relayRpcId: o,\n          clientRpcId: a,\n          throwOnFailedPublish: l,\n          appLink: p,\n          tvf: h\n        } = e,\n        u = ye(s, i, a);\n      let d;\n      const w = !!p;\n      try {\n        const _ = w ? ne : de;\n        d = await this.client.core.crypto.encode(t, u, {\n          encoding: _\n        });\n      } catch (_) {\n        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${t} failed`), _;\n      }\n      let m;\n      if (gt.includes(s)) {\n        const _ = W(JSON.stringify(u)),\n          g = W(d);\n        m = await this.client.core.verify.register({\n          id: g,\n          decryptedId: _\n        });\n      }\n      const f = N[s].req;\n      if (f.attestation = m, r && (f.ttl = r), o && (f.id = o), this.client.core.history.set(t, u), w) {\n        const _ = ue(p, t, d);\n        await global.Linking.openURL(_, this.client.name);\n      } else {\n        const _ = N[s].req;\n        r && (_.ttl = r), o && (_.id = o), _.tvf = b(v({}, h), {\n          correlationId: u.id\n        }), l ? (_.internal = b(v({}, _.internal), {\n          throwOnFailedPublish: !0\n        }), await this.client.core.relayer.publish(t, d, _)) : this.client.core.relayer.publish(t, d, _).catch(g => this.client.logger.error(g));\n      }\n      return u.id;\n    }), c(this, \"sendResult\", async e => {\n      const {\n          id: t,\n          topic: s,\n          result: i,\n          throwOnFailedPublish: r,\n          encodeOpts: o,\n          appLink: a\n        } = e,\n        l = us(t, i);\n      let p;\n      const h = a && typeof (global == null ? void 0 : global.Linking) < \"u\";\n      try {\n        const w = h ? ne : de;\n        p = await this.client.core.crypto.encode(s, l, b(v({}, o || {}), {\n          encoding: w\n        }));\n      } catch (w) {\n        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s} failed`), w;\n      }\n      let u, d;\n      try {\n        u = await this.client.core.history.get(s, t);\n        const w = u.request;\n        try {\n          this.shouldSetTVF(w.method, w.params) && (d = this.getTVFParams(t, w.params, i));\n        } catch (m) {\n          this.client.logger.warn(\"sendResult() -> getTVFParams() failed\", m);\n        }\n      } catch (w) {\n        throw this.client.logger.error(`sendResult() -> history.get(${s}, ${t}) failed`), w;\n      }\n      if (h) {\n        const w = ue(a, s, p);\n        await global.Linking.openURL(w, this.client.name);\n      } else {\n        const w = u.request.method,\n          m = N[w].res;\n        m.tvf = b(v({}, d), {\n          correlationId: t\n        }), r ? (m.internal = b(v({}, m.internal), {\n          throwOnFailedPublish: !0\n        }), await this.client.core.relayer.publish(s, p, m)) : this.client.core.relayer.publish(s, p, m).catch(f => this.client.logger.error(f));\n      }\n      await this.client.core.history.resolve(l);\n    }), c(this, \"sendError\", async e => {\n      const {\n          id: t,\n          topic: s,\n          error: i,\n          encodeOpts: r,\n          rpcOpts: o,\n          appLink: a\n        } = e,\n        l = gs(t, i);\n      let p;\n      const h = a && typeof (global == null ? void 0 : global.Linking) < \"u\";\n      try {\n        const d = h ? ne : de;\n        p = await this.client.core.crypto.encode(s, l, b(v({}, r || {}), {\n          encoding: d\n        }));\n      } catch (d) {\n        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s} failed`), d;\n      }\n      let u;\n      try {\n        u = await this.client.core.history.get(s, t);\n      } catch (d) {\n        throw this.client.logger.error(`sendError() -> history.get(${s}, ${t}) failed`), d;\n      }\n      if (h) {\n        const d = ue(a, s, p);\n        await global.Linking.openURL(d, this.client.name);\n      } else {\n        const d = u.request.method,\n          w = o || N[d].res;\n        this.client.core.relayer.publish(s, p, w);\n      }\n      await this.client.core.history.resolve(l);\n    }), c(this, \"cleanup\", async () => {\n      const e = [],\n        t = [];\n      this.client.session.getAll().forEach(s => {\n        let i = !1;\n        Z(s.expiry) && (i = !0), this.client.core.crypto.keychain.has(s.topic) || (i = !0), i && e.push(s.topic);\n      }), this.client.proposal.getAll().forEach(s => {\n        Z(s.expiryTimestamp) && t.push(s.id);\n      }), await Promise.all([...e.map(s => this.deleteSession({\n        topic: s\n      })), ...t.map(s => this.deleteProposal(s))]);\n    }), c(this, \"onProviderMessageEvent\", async e => {\n      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(e) : await this.onRelayMessage(e);\n    }), c(this, \"onRelayEventRequest\", async e => {\n      this.requestQueue.queue.push(e), await this.processRequestsQueue();\n    }), c(this, \"processRequestsQueue\", async () => {\n      if (this.requestQueue.state === $.active) {\n        this.client.logger.info(\"Request queue already active, skipping...\");\n        return;\n      }\n      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0;) {\n        this.requestQueue.state = $.active;\n        const e = this.requestQueue.queue.shift();\n        if (e) try {\n          await this.processRequest(e);\n        } catch (t) {\n          this.client.logger.warn(t);\n        }\n      }\n      this.requestQueue.state = $.idle;\n    }), c(this, \"processRequest\", async e => {\n      const {\n          topic: t,\n          payload: s,\n          attestation: i,\n          transportType: r,\n          encryptedId: o\n        } = e,\n        a = s.method;\n      if (!this.shouldIgnorePairingRequest({\n        topic: t,\n        requestMethod: a\n      })) switch (a) {\n        case \"wc_sessionPropose\":\n          return await this.onSessionProposeRequest({\n            topic: t,\n            payload: s,\n            attestation: i,\n            encryptedId: o\n          });\n        case \"wc_sessionSettle\":\n          return await this.onSessionSettleRequest(t, s);\n        case \"wc_sessionUpdate\":\n          return await this.onSessionUpdateRequest(t, s);\n        case \"wc_sessionExtend\":\n          return await this.onSessionExtendRequest(t, s);\n        case \"wc_sessionPing\":\n          return await this.onSessionPingRequest(t, s);\n        case \"wc_sessionDelete\":\n          return await this.onSessionDeleteRequest(t, s);\n        case \"wc_sessionRequest\":\n          return await this.onSessionRequest({\n            topic: t,\n            payload: s,\n            attestation: i,\n            encryptedId: o,\n            transportType: r\n          });\n        case \"wc_sessionEvent\":\n          return await this.onSessionEventRequest(t, s);\n        case \"wc_sessionAuthenticate\":\n          return await this.onSessionAuthenticateRequest({\n            topic: t,\n            payload: s,\n            attestation: i,\n            encryptedId: o,\n            transportType: r\n          });\n        default:\n          return this.client.logger.info(`Unsupported request method ${a}`);\n      }\n    }), c(this, \"onRelayEventResponse\", async e => {\n      const {\n          topic: t,\n          payload: s,\n          transportType: i\n        } = e,\n        r = (await this.client.core.history.get(t, s.id)).request.method;\n      switch (r) {\n        case \"wc_sessionPropose\":\n          return this.onSessionProposeResponse(t, s, i);\n        case \"wc_sessionSettle\":\n          return this.onSessionSettleResponse(t, s);\n        case \"wc_sessionUpdate\":\n          return this.onSessionUpdateResponse(t, s);\n        case \"wc_sessionExtend\":\n          return this.onSessionExtendResponse(t, s);\n        case \"wc_sessionPing\":\n          return this.onSessionPingResponse(t, s);\n        case \"wc_sessionRequest\":\n          return this.onSessionRequestResponse(t, s);\n        case \"wc_sessionAuthenticate\":\n          return this.onSessionAuthenticateResponse(t, s);\n        default:\n          return this.client.logger.info(`Unsupported response method ${r}`);\n      }\n    }), c(this, \"onRelayEventUnknownPayload\", e => {\n      const {\n          topic: t\n        } = e,\n        {\n          message: s\n        } = y(\"MISSING_OR_INVALID\", `Decoded payload on topic ${t} is not identifiable as a JSON-RPC request or a response.`);\n      throw new Error(s);\n    }), c(this, \"shouldIgnorePairingRequest\", e => {\n      const {\n          topic: t,\n          requestMethod: s\n        } = e,\n        i = this.expectedPairingMethodMap.get(t);\n      return !i || i.includes(s) ? !1 : !!(i.includes(\"wc_sessionAuthenticate\") && this.client.events.listenerCount(\"session_authenticate\") > 0);\n    }), c(this, \"onSessionProposeRequest\", async e => {\n      const {\n          topic: t,\n          payload: s,\n          attestation: i,\n          encryptedId: r\n        } = e,\n        {\n          params: o,\n          id: a\n        } = s;\n      try {\n        const l = this.client.core.eventClient.getEvent({\n          topic: t\n        });\n        this.client.events.listenerCount(\"session_proposal\") === 0 && (console.warn(\"No listener for session_proposal event\"), l?.setError(Pt.proposal_listener_not_found)), this.isValidConnect(v({}, s.params));\n        const p = o.expiryTimestamp || V(N.wc_sessionPropose.req.ttl),\n          h = v({\n            id: a,\n            pairingTopic: t,\n            expiryTimestamp: p\n          }, o);\n        await this.setProposal(a, h);\n        const u = await this.getVerifyContext({\n          attestationId: i,\n          hash: W(JSON.stringify(s)),\n          encryptedId: r,\n          metadata: h.proposer.metadata\n        });\n        l?.addTrace(Nt.emit_session_proposal), this.client.events.emit(\"session_proposal\", {\n          id: a,\n          params: h,\n          verifyContext: u\n        });\n      } catch (l) {\n        await this.sendError({\n          id: a,\n          topic: t,\n          error: l,\n          rpcOpts: N.wc_sessionPropose.autoReject\n        }), this.client.logger.error(l);\n      }\n    }), c(this, \"onSessionProposeResponse\", async (e, t, s) => {\n      const {\n        id: i\n      } = t;\n      if (j(t)) {\n        const {\n          result: r\n        } = t;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          result: r\n        });\n        const o = this.client.proposal.get(i);\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          proposal: o\n        });\n        const a = o.proposer.publicKey;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          selfPublicKey: a\n        });\n        const l = r.responderPublicKey;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          peerPublicKey: l\n        });\n        const p = await this.client.core.crypto.generateSharedKey(a, l);\n        this.pendingSessions.set(i, {\n          sessionTopic: p,\n          pairingTopic: e,\n          proposalId: i,\n          publicKey: a\n        });\n        const h = await this.client.core.relayer.subscribe(p, {\n          transportType: s\n        });\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          subscriptionId: h\n        }), await this.client.core.pairing.activate({\n          topic: e\n        });\n      } else if (F(t)) {\n        await this.client.proposal.delete(i, O(\"USER_DISCONNECTED\"));\n        const r = R(\"session_connect\", i);\n        if (this.events.listenerCount(r) === 0) throw new Error(`emitting ${r} without any listeners, 954`);\n        this.events.emit(r, {\n          error: t.error\n        });\n      }\n    }), c(this, \"onSessionSettleRequest\", async (e, t) => {\n      const {\n        id: s,\n        params: i\n      } = t;\n      try {\n        this.isValidSessionSettleRequest(i);\n        const {\n            relay: r,\n            controller: o,\n            expiry: a,\n            namespaces: l,\n            sessionProperties: p,\n            scopedProperties: h,\n            sessionConfig: u\n          } = t.params,\n          d = [...this.pendingSessions.values()].find(f => f.sessionTopic === e);\n        if (!d) return this.client.logger.error(`Pending session not found for topic ${e}`);\n        const w = this.client.proposal.get(d.proposalId),\n          m = b(v(v(v({\n            topic: e,\n            relay: r,\n            expiry: a,\n            namespaces: l,\n            acknowledged: !0,\n            pairingTopic: d.pairingTopic,\n            requiredNamespaces: w.requiredNamespaces,\n            optionalNamespaces: w.optionalNamespaces,\n            controller: o.publicKey,\n            self: {\n              publicKey: d.publicKey,\n              metadata: this.client.metadata\n            },\n            peer: {\n              publicKey: o.publicKey,\n              metadata: o.metadata\n            }\n          }, p && {\n            sessionProperties: p\n          }), h && {\n            scopedProperties: h\n          }), u && {\n            sessionConfig: u\n          }), {\n            transportType: P.relay\n          });\n        await this.client.session.set(m.topic, m), await this.setExpiry(m.topic, m.expiry), await this.client.core.pairing.updateMetadata({\n          topic: d.pairingTopic,\n          metadata: m.peer.metadata\n        }), this.client.events.emit(\"session_connect\", {\n          session: m\n        }), this.events.emit(R(\"session_connect\", d.proposalId), {\n          session: m\n        }), this.pendingSessions.delete(d.proposalId), this.deleteProposal(d.proposalId, !1), this.cleanupDuplicatePairings(m), await this.sendResult({\n          id: t.id,\n          topic: e,\n          result: !0,\n          throwOnFailedPublish: !0\n        });\n      } catch (r) {\n        await this.sendError({\n          id: s,\n          topic: e,\n          error: r\n        }), this.client.logger.error(r);\n      }\n    }), c(this, \"onSessionSettleResponse\", async (e, t) => {\n      const {\n        id: s\n      } = t;\n      j(t) ? (await this.client.session.update(e, {\n        acknowledged: !0\n      }), this.events.emit(R(\"session_approve\", s), {})) : F(t) && (await this.client.session.delete(e, O(\"USER_DISCONNECTED\")), this.events.emit(R(\"session_approve\", s), {\n        error: t.error\n      }));\n    }), c(this, \"onSessionUpdateRequest\", async (e, t) => {\n      const {\n        params: s,\n        id: i\n      } = t;\n      try {\n        const r = `${e}_session_update`,\n          o = oe.get(r);\n        if (o && this.isRequestOutOfSync(o, i)) {\n          this.client.logger.warn(`Discarding out of sync request - ${i}`), this.sendError({\n            id: i,\n            topic: e,\n            error: O(\"INVALID_UPDATE_REQUEST\")\n          });\n          return;\n        }\n        this.isValidUpdate(v({\n          topic: e\n        }, s));\n        try {\n          oe.set(r, i), await this.client.session.update(e, {\n            namespaces: s.namespaces\n          }), await this.sendResult({\n            id: i,\n            topic: e,\n            result: !0,\n            throwOnFailedPublish: !0\n          });\n        } catch (a) {\n          throw oe.delete(r), a;\n        }\n        this.client.events.emit(\"session_update\", {\n          id: i,\n          topic: e,\n          params: s\n        });\n      } catch (r) {\n        await this.sendError({\n          id: i,\n          topic: e,\n          error: r\n        }), this.client.logger.error(r);\n      }\n    }), c(this, \"isRequestOutOfSync\", (e, t) => t.toString().slice(0, -3) < e.toString().slice(0, -3)), c(this, \"onSessionUpdateResponse\", (e, t) => {\n      const {\n          id: s\n        } = t,\n        i = R(\"session_update\", s);\n      if (this.events.listenerCount(i) === 0) throw new Error(`emitting ${i} without any listeners`);\n      j(t) ? this.events.emit(R(\"session_update\", s), {}) : F(t) && this.events.emit(R(\"session_update\", s), {\n        error: t.error\n      });\n    }), c(this, \"onSessionExtendRequest\", async (e, t) => {\n      const {\n        id: s\n      } = t;\n      try {\n        this.isValidExtend({\n          topic: e\n        }), await this.setExpiry(e, V(J)), await this.sendResult({\n          id: s,\n          topic: e,\n          result: !0,\n          throwOnFailedPublish: !0\n        }), this.client.events.emit(\"session_extend\", {\n          id: s,\n          topic: e\n        });\n      } catch (i) {\n        await this.sendError({\n          id: s,\n          topic: e,\n          error: i\n        }), this.client.logger.error(i);\n      }\n    }), c(this, \"onSessionExtendResponse\", (e, t) => {\n      const {\n          id: s\n        } = t,\n        i = R(\"session_extend\", s);\n      if (this.events.listenerCount(i) === 0) throw new Error(`emitting ${i} without any listeners`);\n      j(t) ? this.events.emit(R(\"session_extend\", s), {}) : F(t) && this.events.emit(R(\"session_extend\", s), {\n        error: t.error\n      });\n    }), c(this, \"onSessionPingRequest\", async (e, t) => {\n      const {\n        id: s\n      } = t;\n      try {\n        this.isValidPing({\n          topic: e\n        }), await this.sendResult({\n          id: s,\n          topic: e,\n          result: !0,\n          throwOnFailedPublish: !0\n        }), this.client.events.emit(\"session_ping\", {\n          id: s,\n          topic: e\n        });\n      } catch (i) {\n        await this.sendError({\n          id: s,\n          topic: e,\n          error: i\n        }), this.client.logger.error(i);\n      }\n    }), c(this, \"onSessionPingResponse\", (e, t) => {\n      const {\n          id: s\n        } = t,\n        i = R(\"session_ping\", s);\n      setTimeout(() => {\n        if (this.events.listenerCount(i) === 0) throw new Error(`emitting ${i} without any listeners 2176`);\n        j(t) ? this.events.emit(R(\"session_ping\", s), {}) : F(t) && this.events.emit(R(\"session_ping\", s), {\n          error: t.error\n        });\n      }, 500);\n    }), c(this, \"onSessionDeleteRequest\", async (e, t) => {\n      const {\n        id: s\n      } = t;\n      try {\n        this.isValidDisconnect({\n          topic: e,\n          reason: t.params\n        }), Promise.all([new Promise(i => {\n          this.client.core.relayer.once(Xe.publish, async () => {\n            i(await this.deleteSession({\n              topic: e,\n              id: s\n            }));\n          });\n        }), this.sendResult({\n          id: s,\n          topic: e,\n          result: !0,\n          throwOnFailedPublish: !0\n        }), this.cleanupPendingSentRequestsForTopic({\n          topic: e,\n          error: O(\"USER_DISCONNECTED\")\n        })]).catch(i => this.client.logger.error(i));\n      } catch (i) {\n        this.client.logger.error(i);\n      }\n    }), c(this, \"onSessionRequest\", async e => {\n      var t, s, i;\n      const {\n          topic: r,\n          payload: o,\n          attestation: a,\n          encryptedId: l,\n          transportType: p\n        } = e,\n        {\n          id: h,\n          params: u\n        } = o;\n      try {\n        await this.isValidRequest(v({\n          topic: r\n        }, u));\n        const d = this.client.session.get(r),\n          w = await this.getVerifyContext({\n            attestationId: a,\n            hash: W(JSON.stringify(ye(\"wc_sessionRequest\", u, h))),\n            encryptedId: l,\n            metadata: d.peer.metadata,\n            transportType: p\n          }),\n          m = {\n            id: h,\n            topic: r,\n            params: u,\n            verifyContext: w\n          };\n        await this.setPendingSessionRequest(m), p === P.link_mode && (t = d.peer.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp((s = d.peer.metadata.redirect) == null ? void 0 : s.universal), (i = this.client.signConfig) != null && i.disableRequestQueue ? this.emitSessionRequest(m) : (this.addSessionRequestToSessionRequestQueue(m), this.processSessionRequestQueue());\n      } catch (d) {\n        await this.sendError({\n          id: h,\n          topic: r,\n          error: d\n        }), this.client.logger.error(d);\n      }\n    }), c(this, \"onSessionRequestResponse\", (e, t) => {\n      const {\n          id: s\n        } = t,\n        i = R(\"session_request\", s);\n      if (this.events.listenerCount(i) === 0) throw new Error(`emitting ${i} without any listeners`);\n      j(t) ? this.events.emit(R(\"session_request\", s), {\n        result: t.result\n      }) : F(t) && this.events.emit(R(\"session_request\", s), {\n        error: t.error\n      });\n    }), c(this, \"onSessionEventRequest\", async (e, t) => {\n      const {\n        id: s,\n        params: i\n      } = t;\n      try {\n        const r = `${e}_session_event_${i.event.name}`,\n          o = oe.get(r);\n        if (o && this.isRequestOutOfSync(o, s)) {\n          this.client.logger.info(`Discarding out of sync request - ${s}`);\n          return;\n        }\n        this.isValidEmit(v({\n          topic: e\n        }, i)), this.client.events.emit(\"session_event\", {\n          id: s,\n          topic: e,\n          params: i\n        }), oe.set(r, s);\n      } catch (r) {\n        await this.sendError({\n          id: s,\n          topic: e,\n          error: r\n        }), this.client.logger.error(r);\n      }\n    }), c(this, \"onSessionAuthenticateResponse\", (e, t) => {\n      const {\n        id: s\n      } = t;\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionAuthenticateResponse\",\n        topic: e,\n        payload: t\n      }), j(t) ? this.events.emit(R(\"session_request\", s), {\n        result: t.result\n      }) : F(t) && this.events.emit(R(\"session_request\", s), {\n        error: t.error\n      });\n    }), c(this, \"onSessionAuthenticateRequest\", async e => {\n      var t;\n      const {\n        topic: s,\n        payload: i,\n        attestation: r,\n        encryptedId: o,\n        transportType: a\n      } = e;\n      try {\n        const {\n            requester: l,\n            authPayload: p,\n            expiryTimestamp: h\n          } = i.params,\n          u = await this.getVerifyContext({\n            attestationId: r,\n            hash: W(JSON.stringify(i)),\n            encryptedId: o,\n            metadata: l.metadata,\n            transportType: a\n          }),\n          d = {\n            requester: l,\n            pairingTopic: s,\n            id: i.id,\n            authPayload: p,\n            verifyContext: u,\n            expiryTimestamp: h\n          };\n        await this.setAuthRequest(i.id, {\n          request: d,\n          pairingTopic: s,\n          transportType: a\n        }), a === P.link_mode && (t = l.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp(l.metadata.redirect.universal), this.client.events.emit(\"session_authenticate\", {\n          topic: s,\n          params: i.params,\n          id: i.id,\n          verifyContext: u\n        });\n      } catch (l) {\n        this.client.logger.error(l);\n        const p = i.params.requester.publicKey,\n          h = await this.client.core.crypto.generateKeyPair(),\n          u = this.getAppLinkIfEnabled(i.params.requester.metadata, a),\n          d = {\n            type: Ve,\n            receiverPublicKey: p,\n            senderPublicKey: h\n          };\n        await this.sendError({\n          id: i.id,\n          topic: s,\n          error: l,\n          encodeOpts: d,\n          rpcOpts: N.wc_sessionAuthenticate.autoReject,\n          appLink: u\n        });\n      }\n    }), c(this, \"addSessionRequestToSessionRequestQueue\", e => {\n      this.sessionRequestQueue.queue.push(e);\n    }), c(this, \"cleanupAfterResponse\", e => {\n      this.deletePendingSessionRequest(e.response.id, {\n        message: \"fulfilled\",\n        code: 0\n      }), setTimeout(() => {\n        this.sessionRequestQueue.state = $.idle, this.processSessionRequestQueue();\n      }, Oe(this.requestQueueDelay));\n    }), c(this, \"cleanupPendingSentRequestsForTopic\", ({\n      topic: e,\n      error: t\n    }) => {\n      const s = this.client.core.history.pending;\n      s.length > 0 && s.filter(i => i.topic === e && i.request.method === \"wc_sessionRequest\").forEach(i => {\n        const r = i.request.id,\n          o = R(\"session_request\", r);\n        if (this.events.listenerCount(o) === 0) throw new Error(`emitting ${o} without any listeners`);\n        this.events.emit(R(\"session_request\", i.request.id), {\n          error: t\n        });\n      });\n    }), c(this, \"processSessionRequestQueue\", () => {\n      if (this.sessionRequestQueue.state === $.active) {\n        this.client.logger.info(\"session request queue is already active.\");\n        return;\n      }\n      const e = this.sessionRequestQueue.queue[0];\n      if (!e) {\n        this.client.logger.info(\"session request queue is empty.\");\n        return;\n      }\n      try {\n        this.sessionRequestQueue.state = $.active, this.emitSessionRequest(e);\n      } catch (t) {\n        this.client.logger.error(t);\n      }\n    }), c(this, \"emitSessionRequest\", e => {\n      this.client.events.emit(\"session_request\", e);\n    }), c(this, \"onPairingCreated\", e => {\n      if (e.methods && this.expectedPairingMethodMap.set(e.topic, e.methods), e.active) return;\n      const t = this.client.proposal.getAll().find(s => s.pairingTopic === e.topic);\n      t && this.onSessionProposeRequest({\n        topic: e.topic,\n        payload: ye(\"wc_sessionPropose\", b(v({}, t), {\n          requiredNamespaces: t.requiredNamespaces,\n          optionalNamespaces: t.optionalNamespaces,\n          relays: t.relays,\n          proposer: t.proposer,\n          sessionProperties: t.sessionProperties,\n          scopedProperties: t.scopedProperties\n        }), t.id)\n      });\n    }), c(this, \"isValidConnect\", async e => {\n      if (!M(e)) {\n        const {\n          message: l\n        } = y(\"MISSING_OR_INVALID\", `connect() params: ${JSON.stringify(e)}`);\n        throw new Error(l);\n      }\n      const {\n        pairingTopic: t,\n        requiredNamespaces: s,\n        optionalNamespaces: i,\n        sessionProperties: r,\n        scopedProperties: o,\n        relays: a\n      } = e;\n      if (X(t) || (await this.isValidPairingTopic(t)), !zt(a, !0)) {\n        const {\n          message: l\n        } = y(\"MISSING_OR_INVALID\", `connect() relays: ${a}`);\n        throw new Error(l);\n      }\n      if (!X(s) && ot(s) !== 0 && this.validateNamespaces(s, \"requiredNamespaces\"), !X(i) && ot(i) !== 0 && this.validateNamespaces(i, \"optionalNamespaces\"), X(r) || this.validateSessionProps(r, \"sessionProperties\"), !X(o)) {\n        this.validateSessionProps(o, \"scopedProperties\");\n        const l = Object.keys(s || {}).concat(Object.keys(i || {}));\n        if (!Object.keys(o).every(p => l.includes(p))) throw new Error(`Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(o)}, required/optional namespaces: ${JSON.stringify(l)}`);\n      }\n    }), c(this, \"validateNamespaces\", (e, t) => {\n      const s = Yt(e, \"connect()\", t);\n      if (s) throw new Error(s.message);\n    }), c(this, \"isValidApprove\", async e => {\n      if (!M(e)) throw new Error(y(\"MISSING_OR_INVALID\", `approve() params: ${e}`).message);\n      const {\n        id: t,\n        namespaces: s,\n        relayProtocol: i,\n        sessionProperties: r,\n        scopedProperties: o\n      } = e;\n      this.checkRecentlyDeleted(t), await this.isValidProposalId(t);\n      const a = this.client.proposal.get(t),\n        l = Ce(s, \"approve()\");\n      if (l) throw new Error(l.message);\n      const p = at(a.requiredNamespaces, s, \"approve()\");\n      if (p) throw new Error(p.message);\n      if (!Y(i, !0)) {\n        const {\n          message: h\n        } = y(\"MISSING_OR_INVALID\", `approve() relayProtocol: ${i}`);\n        throw new Error(h);\n      }\n      if (X(r) || this.validateSessionProps(r, \"sessionProperties\"), !X(o)) {\n        this.validateSessionProps(o, \"scopedProperties\");\n        const h = new Set(Object.keys(s));\n        if (!Object.keys(o).every(u => h.has(u))) throw new Error(`Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(o)}, approved namespaces: ${Array.from(h).join(\", \")}`);\n      }\n    }), c(this, \"isValidReject\", async e => {\n      if (!M(e)) {\n        const {\n          message: i\n        } = y(\"MISSING_OR_INVALID\", `reject() params: ${e}`);\n        throw new Error(i);\n      }\n      const {\n        id: t,\n        reason: s\n      } = e;\n      if (this.checkRecentlyDeleted(t), await this.isValidProposalId(t), !Xt(s)) {\n        const {\n          message: i\n        } = y(\"MISSING_OR_INVALID\", `reject() reason: ${JSON.stringify(s)}`);\n        throw new Error(i);\n      }\n    }), c(this, \"isValidSessionSettleRequest\", e => {\n      if (!M(e)) {\n        const {\n          message: l\n        } = y(\"MISSING_OR_INVALID\", `onSessionSettleRequest() params: ${e}`);\n        throw new Error(l);\n      }\n      const {\n        relay: t,\n        controller: s,\n        namespaces: i,\n        expiry: r\n      } = e;\n      if (!Jt(t)) {\n        const {\n          message: l\n        } = y(\"MISSING_OR_INVALID\", \"onSessionSettleRequest() relay protocol should be a string\");\n        throw new Error(l);\n      }\n      const o = Bt(s, \"onSessionSettleRequest()\");\n      if (o) throw new Error(o.message);\n      const a = Ce(i, \"onSessionSettleRequest()\");\n      if (a) throw new Error(a.message);\n      if (Z(r)) {\n        const {\n          message: l\n        } = y(\"EXPIRED\", \"onSessionSettleRequest()\");\n        throw new Error(l);\n      }\n    }), c(this, \"isValidUpdate\", async e => {\n      if (!M(e)) {\n        const {\n          message: a\n        } = y(\"MISSING_OR_INVALID\", `update() params: ${e}`);\n        throw new Error(a);\n      }\n      const {\n        topic: t,\n        namespaces: s\n      } = e;\n      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);\n      const i = this.client.session.get(t),\n        r = Ce(s, \"update()\");\n      if (r) throw new Error(r.message);\n      const o = at(i.requiredNamespaces, s, \"update()\");\n      if (o) throw new Error(o.message);\n    }), c(this, \"isValidExtend\", async e => {\n      if (!M(e)) {\n        const {\n          message: s\n        } = y(\"MISSING_OR_INVALID\", `extend() params: ${e}`);\n        throw new Error(s);\n      }\n      const {\n        topic: t\n      } = e;\n      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);\n    }), c(this, \"isValidRequest\", async e => {\n      if (!M(e)) {\n        const {\n          message: a\n        } = y(\"MISSING_OR_INVALID\", `request() params: ${e}`);\n        throw new Error(a);\n      }\n      const {\n        topic: t,\n        request: s,\n        chainId: i,\n        expiry: r\n      } = e;\n      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);\n      const {\n        namespaces: o\n      } = this.client.session.get(t);\n      if (!ct(o, i)) {\n        const {\n          message: a\n        } = y(\"MISSING_OR_INVALID\", `request() chainId: ${i}`);\n        throw new Error(a);\n      }\n      if (!Wt(s)) {\n        const {\n          message: a\n        } = y(\"MISSING_OR_INVALID\", `request() ${JSON.stringify(s)}`);\n        throw new Error(a);\n      }\n      if (!Zt(o, i, s.method)) {\n        const {\n          message: a\n        } = y(\"MISSING_OR_INVALID\", `request() method: ${s.method}`);\n        throw new Error(a);\n      }\n      if (r && !es(r, _e)) {\n        const {\n          message: a\n        } = y(\"MISSING_OR_INVALID\", `request() expiry: ${r}. Expiry must be a number (in seconds) between ${_e.min} and ${_e.max}`);\n        throw new Error(a);\n      }\n    }), c(this, \"isValidRespond\", async e => {\n      var t;\n      if (!M(e)) {\n        const {\n          message: r\n        } = y(\"MISSING_OR_INVALID\", `respond() params: ${e}`);\n        throw new Error(r);\n      }\n      const {\n        topic: s,\n        response: i\n      } = e;\n      try {\n        await this.isValidSessionTopic(s);\n      } catch (r) {\n        throw (t = e?.response) != null && t.id && this.cleanupAfterResponse(e), r;\n      }\n      if (!ts(i)) {\n        const {\n          message: r\n        } = y(\"MISSING_OR_INVALID\", `respond() response: ${JSON.stringify(i)}`);\n        throw new Error(r);\n      }\n    }), c(this, \"isValidPing\", async e => {\n      if (!M(e)) {\n        const {\n          message: s\n        } = y(\"MISSING_OR_INVALID\", `ping() params: ${e}`);\n        throw new Error(s);\n      }\n      const {\n        topic: t\n      } = e;\n      await this.isValidSessionOrPairingTopic(t);\n    }), c(this, \"isValidEmit\", async e => {\n      if (!M(e)) {\n        const {\n          message: o\n        } = y(\"MISSING_OR_INVALID\", `emit() params: ${e}`);\n        throw new Error(o);\n      }\n      const {\n        topic: t,\n        event: s,\n        chainId: i\n      } = e;\n      await this.isValidSessionTopic(t);\n      const {\n        namespaces: r\n      } = this.client.session.get(t);\n      if (!ct(r, i)) {\n        const {\n          message: o\n        } = y(\"MISSING_OR_INVALID\", `emit() chainId: ${i}`);\n        throw new Error(o);\n      }\n      if (!ss(s)) {\n        const {\n          message: o\n        } = y(\"MISSING_OR_INVALID\", `emit() event: ${JSON.stringify(s)}`);\n        throw new Error(o);\n      }\n      if (!is(r, i, s.name)) {\n        const {\n          message: o\n        } = y(\"MISSING_OR_INVALID\", `emit() event: ${JSON.stringify(s)}`);\n        throw new Error(o);\n      }\n    }), c(this, \"isValidDisconnect\", async e => {\n      if (!M(e)) {\n        const {\n          message: s\n        } = y(\"MISSING_OR_INVALID\", `disconnect() params: ${e}`);\n        throw new Error(s);\n      }\n      const {\n        topic: t\n      } = e;\n      await this.isValidSessionOrPairingTopic(t);\n    }), c(this, \"isValidAuthenticate\", e => {\n      const {\n        chains: t,\n        uri: s,\n        domain: i,\n        nonce: r\n      } = e;\n      if (!Array.isArray(t) || t.length === 0) throw new Error(\"chains is required and must be a non-empty array\");\n      if (!Y(s, !1)) throw new Error(\"uri is required parameter\");\n      if (!Y(i, !1)) throw new Error(\"domain is required parameter\");\n      if (!Y(r, !1)) throw new Error(\"nonce is required parameter\");\n      if ([...new Set(t.map(a => Ae(a).namespace))].length > 1) throw new Error(\"Multi-namespace requests are not supported. Please request single namespace only.\");\n      const {\n        namespace: o\n      } = Ae(t[0]);\n      if (o !== \"eip155\") throw new Error(\"Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.\");\n    }), c(this, \"getVerifyContext\", async e => {\n      const {\n          attestationId: t,\n          hash: s,\n          encryptedId: i,\n          metadata: r,\n          transportType: o\n        } = e,\n        a = {\n          verified: {\n            verifyUrl: r.verifyUrl || Ot,\n            validation: \"UNKNOWN\",\n            origin: r.url || \"\"\n          }\n        };\n      try {\n        if (o === P.link_mode) {\n          const p = this.getAppLinkIfEnabled(r, o);\n          return a.verified.validation = p && new URL(p).origin === new URL(r.url).origin ? \"VALID\" : \"INVALID\", a;\n        }\n        const l = await this.client.core.verify.resolve({\n          attestationId: t,\n          hash: s,\n          encryptedId: i,\n          verifyUrl: r.verifyUrl\n        });\n        l && (a.verified.origin = l.origin, a.verified.isScam = l.isScam, a.verified.validation = l.origin === new URL(r.url).origin ? \"VALID\" : \"INVALID\");\n      } catch (l) {\n        this.client.logger.warn(l);\n      }\n      return this.client.logger.debug(`Verify context: ${JSON.stringify(a)}`), a;\n    }), c(this, \"validateSessionProps\", (e, t) => {\n      Object.values(e).forEach((s, i) => {\n        if (s == null) {\n          const {\n            message: r\n          } = y(\"MISSING_OR_INVALID\", `${t} must contain an existing value for each key. Received: ${s} for key ${Object.keys(e)[i]}`);\n          throw new Error(r);\n        }\n      });\n    }), c(this, \"getPendingAuthRequest\", e => {\n      const t = this.client.auth.requests.get(e);\n      return typeof t == \"object\" ? t : void 0;\n    }), c(this, \"addToRecentlyDeleted\", (e, t) => {\n      if (this.recentlyDeletedMap.set(e, t), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {\n        let s = 0;\n        const i = this.recentlyDeletedLimit / 2;\n        for (const r of this.recentlyDeletedMap.keys()) {\n          if (s++ >= i) break;\n          this.recentlyDeletedMap.delete(r);\n        }\n      }\n    }), c(this, \"checkRecentlyDeleted\", e => {\n      const t = this.recentlyDeletedMap.get(e);\n      if (t) {\n        const {\n          message: s\n        } = y(\"MISSING_OR_INVALID\", `Record was recently deleted - ${t}: ${e}`);\n        throw new Error(s);\n      }\n    }), c(this, \"isLinkModeEnabled\", (e, t) => {\n      var s, i, r, o, a, l, p, h, u;\n      return !e || t !== P.link_mode ? !1 : ((i = (s = this.client.metadata) == null ? void 0 : s.redirect) == null ? void 0 : i.linkMode) === !0 && ((o = (r = this.client.metadata) == null ? void 0 : r.redirect) == null ? void 0 : o.universal) !== void 0 && ((l = (a = this.client.metadata) == null ? void 0 : a.redirect) == null ? void 0 : l.universal) !== \"\" && ((p = e?.redirect) == null ? void 0 : p.universal) !== void 0 && ((h = e?.redirect) == null ? void 0 : h.universal) !== \"\" && ((u = e?.redirect) == null ? void 0 : u.linkMode) === !0 && this.client.core.linkModeSupportedApps.includes(e.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < \"u\";\n    }), c(this, \"getAppLinkIfEnabled\", (e, t) => {\n      var s;\n      return this.isLinkModeEnabled(e, t) ? (s = e?.redirect) == null ? void 0 : s.universal : void 0;\n    }), c(this, \"handleLinkModeMessage\", ({\n      url: e\n    }) => {\n      if (!e || !e.includes(\"wc_ev\") || !e.includes(\"topic\")) return;\n      const t = lt(e, \"topic\") || \"\",\n        s = decodeURIComponent(lt(e, \"wc_ev\") || \"\"),\n        i = this.client.session.keys.includes(t);\n      i && this.client.session.update(t, {\n        transportType: P.link_mode\n      }), this.client.core.dispatchEnvelope({\n        topic: t,\n        message: s,\n        sessionExists: i\n      });\n    }), c(this, \"registerLinkModeListeners\", async () => {\n      var e;\n      if (rs() || ns() && (e = this.client.metadata.redirect) != null && e.linkMode) {\n        const t = global == null ? void 0 : global.Linking;\n        if (typeof t < \"u\") {\n          t.addEventListener(\"url\", this.handleLinkModeMessage, this.client.name);\n          const s = await t.getInitialURL();\n          s && setTimeout(() => {\n            this.handleLinkModeMessage({\n              url: s\n            });\n          }, 50);\n        }\n      }\n    }), c(this, \"shouldSetTVF\", (e, t) => {\n      if (!t || e !== \"wc_sessionRequest\") return !1;\n      const {\n        request: s\n      } = t;\n      return Object.keys(Ue).includes(s.method);\n    }), c(this, \"getTVFParams\", (e, t, s) => {\n      var i, r;\n      try {\n        const o = t.request.method,\n          a = this.extractTxHashesFromResult(o, s);\n        return b(v({\n          correlationId: e,\n          rpcMethods: [o],\n          chainId: t.chainId\n        }, this.isValidContractData(t.request.params) && {\n          contractAddresses: [(r = (i = t.request.params) == null ? void 0 : i[0]) == null ? void 0 : r.to]\n        }), {\n          txHashes: a\n        });\n      } catch (o) {\n        this.client.logger.warn(\"Error getting TVF params\", o);\n      }\n      return {};\n    }), c(this, \"isValidContractData\", e => {\n      var t;\n      if (!e) return !1;\n      try {\n        const s = e?.data || ((t = e?.[0]) == null ? void 0 : t.data);\n        if (!s.startsWith(\"0x\")) return !1;\n        const i = s.slice(2);\n        return /^[0-9a-fA-F]*$/.test(i) ? i.length % 2 === 0 : !1;\n      } catch {}\n      return !1;\n    }), c(this, \"extractTxHashesFromResult\", (e, t) => {\n      try {\n        const s = Ue[e];\n        if (typeof t == \"string\") return [t];\n        const i = t[s.key];\n        if (os(i)) return e === \"solana_signAllTransactions\" ? i.map(r => as(r)) : i;\n        if (typeof i == \"string\") return [i];\n      } catch (s) {\n        this.client.logger.warn(\"Error extracting tx hashes from result\", s);\n      }\n      return [];\n    });\n  }\n  async processPendingMessageEvents() {\n    try {\n      const n = this.client.session.keys,\n        e = this.client.core.relayer.messages.getWithoutAck(n);\n      for (const [t, s] of Object.entries(e)) for (const i of s) try {\n        await this.onProviderMessageEvent({\n          topic: t,\n          message: i,\n          publishedAt: Date.now()\n        });\n      } catch {\n        this.client.logger.warn(`Error processing pending message event for topic: ${t}, message: ${i}`);\n      }\n    } catch (n) {\n      this.client.logger.warn(\"processPendingMessageEvents failed\", n);\n    }\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: n\n      } = y(\"NOT_INITIALIZED\", this.name);\n      throw new Error(n);\n    }\n  }\n  async confirmOnlineStateOrThrow() {\n    await this.client.core.relayer.confirmOnlineStateOrThrow();\n  }\n  registerRelayerEvents() {\n    this.client.core.relayer.on(Xe.message, n => {\n      this.onProviderMessageEvent(n);\n    });\n  }\n  async onRelayMessage(n) {\n    const {\n        topic: e,\n        message: t,\n        attestation: s,\n        transportType: i\n      } = n,\n      {\n        publicKey: r\n      } = this.client.auth.authKeys.keys.includes(ce) ? this.client.auth.authKeys.get(ce) : {\n        responseTopic: void 0,\n        publicKey: void 0\n      };\n    try {\n      const o = await this.client.core.crypto.decode(e, t, {\n        receiverPublicKey: r,\n        encoding: i === P.link_mode ? ne : de\n      });\n      hs(o) ? (this.client.core.history.set(e, o), await this.onRelayEventRequest({\n        topic: e,\n        payload: o,\n        attestation: s,\n        transportType: i,\n        encryptedId: W(t)\n      })) : ds(o) ? (await this.client.core.history.resolve(o), await this.onRelayEventResponse({\n        topic: e,\n        payload: o,\n        transportType: i\n      }), this.client.core.history.delete(e, o.id)) : await this.onRelayEventUnknownPayload({\n        topic: e,\n        payload: o,\n        transportType: i\n      }), await this.client.core.relayer.messages.ack(e, t);\n    } catch (o) {\n      this.client.logger.error(o);\n    }\n  }\n  registerExpirerEvents() {\n    this.client.core.expirer.on(Tt.expired, async n => {\n      const {\n        topic: e,\n        id: t\n      } = Mt(n.target);\n      if (t && this.client.pendingRequest.keys.includes(t)) return await this.deletePendingSessionRequest(t, y(\"EXPIRED\"), !0);\n      if (t && this.client.auth.requests.keys.includes(t)) return await this.deletePendingAuthRequest(t, y(\"EXPIRED\"), !0);\n      e ? this.client.session.keys.includes(e) && (await this.deleteSession({\n        topic: e,\n        expirerHasDeleted: !0\n      }), this.client.events.emit(\"session_expire\", {\n        topic: e\n      })) : t && (await this.deleteProposal(t, !0), this.client.events.emit(\"proposal_expire\", {\n        id: t\n      }));\n    });\n  }\n  registerPairingEvents() {\n    this.client.core.pairing.events.on(Je.create, n => this.onPairingCreated(n)), this.client.core.pairing.events.on(Je.delete, n => {\n      this.addToRecentlyDeleted(n.topic, \"pairing\");\n    });\n  }\n  isValidPairingTopic(n) {\n    if (!Y(n, !1)) {\n      const {\n        message: e\n      } = y(\"MISSING_OR_INVALID\", `pairing topic should be a string: ${n}`);\n      throw new Error(e);\n    }\n    if (!this.client.core.pairing.pairings.keys.includes(n)) {\n      const {\n        message: e\n      } = y(\"NO_MATCHING_KEY\", `pairing topic doesn't exist: ${n}`);\n      throw new Error(e);\n    }\n    if (Z(this.client.core.pairing.pairings.get(n).expiry)) {\n      const {\n        message: e\n      } = y(\"EXPIRED\", `pairing topic: ${n}`);\n      throw new Error(e);\n    }\n  }\n  async isValidSessionTopic(n) {\n    if (!Y(n, !1)) {\n      const {\n        message: e\n      } = y(\"MISSING_OR_INVALID\", `session topic should be a string: ${n}`);\n      throw new Error(e);\n    }\n    if (this.checkRecentlyDeleted(n), !this.client.session.keys.includes(n)) {\n      const {\n        message: e\n      } = y(\"NO_MATCHING_KEY\", `session topic doesn't exist: ${n}`);\n      throw new Error(e);\n    }\n    if (Z(this.client.session.get(n).expiry)) {\n      await this.deleteSession({\n        topic: n\n      });\n      const {\n        message: e\n      } = y(\"EXPIRED\", `session topic: ${n}`);\n      throw new Error(e);\n    }\n    if (!this.client.core.crypto.keychain.has(n)) {\n      const {\n        message: e\n      } = y(\"MISSING_OR_INVALID\", `session topic does not exist in keychain: ${n}`);\n      throw await this.deleteSession({\n        topic: n\n      }), new Error(e);\n    }\n  }\n  async isValidSessionOrPairingTopic(n) {\n    if (this.checkRecentlyDeleted(n), this.client.session.keys.includes(n)) await this.isValidSessionTopic(n);else if (this.client.core.pairing.pairings.keys.includes(n)) this.isValidPairingTopic(n);else if (Y(n, !1)) {\n      const {\n        message: e\n      } = y(\"NO_MATCHING_KEY\", `session or pairing topic doesn't exist: ${n}`);\n      throw new Error(e);\n    } else {\n      const {\n        message: e\n      } = y(\"MISSING_OR_INVALID\", `session or pairing topic should be a string: ${n}`);\n      throw new Error(e);\n    }\n  }\n  async isValidProposalId(n) {\n    if (!$t(n)) {\n      const {\n        message: e\n      } = y(\"MISSING_OR_INVALID\", `proposal id should be a number: ${n}`);\n      throw new Error(e);\n    }\n    if (!this.client.proposal.keys.includes(n)) {\n      const {\n        message: e\n      } = y(\"NO_MATCHING_KEY\", `proposal id doesn't exist: ${n}`);\n      throw new Error(e);\n    }\n    if (Z(this.client.proposal.get(n).expiryTimestamp)) {\n      await this.deleteProposal(n);\n      const {\n        message: e\n      } = y(\"EXPIRED\", `proposal id: ${n}`);\n      throw new Error(e);\n    }\n  }\n}\nclass Ns extends B {\n  constructor(n, e) {\n    super(n, e, pt, we), this.core = n, this.logger = e;\n  }\n}\nclass St extends B {\n  constructor(n, e) {\n    super(n, e, ht, we), this.core = n, this.logger = e;\n  }\n}\nclass Os extends B {\n  constructor(n, e) {\n    super(n, e, ut, we, t => t.id), this.core = n, this.logger = e;\n  }\n}\nclass bs extends B {\n  constructor(n, e) {\n    super(n, e, mt, ae, () => ce), this.core = n, this.logger = e;\n  }\n}\nclass As extends B {\n  constructor(n, e) {\n    super(n, e, _t, ae), this.core = n, this.logger = e;\n  }\n}\nclass xs extends B {\n  constructor(n, e) {\n    super(n, e, Et, ae, t => t.id), this.core = n, this.logger = e;\n  }\n}\nvar Cs = Object.defineProperty,\n  Vs = (S, n, e) => n in S ? Cs(S, n, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : S[n] = e,\n  Ge = (S, n, e) => Vs(S, typeof n != \"symbol\" ? n + \"\" : n, e);\nclass Ds {\n  constructor(n, e) {\n    this.core = n, this.logger = e, Ge(this, \"authKeys\"), Ge(this, \"pairingTopics\"), Ge(this, \"requests\"), this.authKeys = new bs(this.core, this.logger), this.pairingTopics = new As(this.core, this.logger), this.requests = new xs(this.core, this.logger);\n  }\n  async init() {\n    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();\n  }\n}\nvar Ls = Object.defineProperty,\n  ks = (S, n, e) => n in S ? Ls(S, n, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : S[n] = e,\n  E = (S, n, e) => ks(S, typeof n != \"symbol\" ? n + \"\" : n, e);\nclass Ee extends Lt {\n  constructor(n) {\n    super(n), E(this, \"protocol\", De), E(this, \"version\", Le), E(this, \"name\", me.name), E(this, \"metadata\"), E(this, \"core\"), E(this, \"logger\"), E(this, \"events\", new ps()), E(this, \"engine\"), E(this, \"session\"), E(this, \"proposal\"), E(this, \"pendingRequest\"), E(this, \"auth\"), E(this, \"signConfig\"), E(this, \"on\", (t, s) => this.events.on(t, s)), E(this, \"once\", (t, s) => this.events.once(t, s)), E(this, \"off\", (t, s) => this.events.off(t, s)), E(this, \"removeListener\", (t, s) => this.events.removeListener(t, s)), E(this, \"removeAllListeners\", t => this.events.removeAllListeners(t)), E(this, \"connect\", async t => {\n      try {\n        return await this.engine.connect(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), E(this, \"pair\", async t => {\n      try {\n        return await this.engine.pair(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), E(this, \"approve\", async t => {\n      try {\n        return await this.engine.approve(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), E(this, \"reject\", async t => {\n      try {\n        return await this.engine.reject(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), E(this, \"update\", async t => {\n      try {\n        return await this.engine.update(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), E(this, \"extend\", async t => {\n      try {\n        return await this.engine.extend(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), E(this, \"request\", async t => {\n      try {\n        return await this.engine.request(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), E(this, \"respond\", async t => {\n      try {\n        return await this.engine.respond(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), E(this, \"ping\", async t => {\n      try {\n        return await this.engine.ping(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), E(this, \"emit\", async t => {\n      try {\n        return await this.engine.emit(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), E(this, \"disconnect\", async t => {\n      try {\n        return await this.engine.disconnect(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), E(this, \"find\", t => {\n      try {\n        return this.engine.find(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), E(this, \"getPendingSessionRequests\", () => {\n      try {\n        return this.engine.getPendingSessionRequests();\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }), E(this, \"authenticate\", async (t, s) => {\n      try {\n        return await this.engine.authenticate(t, s);\n      } catch (i) {\n        throw this.logger.error(i.message), i;\n      }\n    }), E(this, \"formatAuthMessage\", t => {\n      try {\n        return this.engine.formatAuthMessage(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), E(this, \"approveSessionAuthenticate\", async t => {\n      try {\n        return await this.engine.approveSessionAuthenticate(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), E(this, \"rejectSessionAuthenticate\", async t => {\n      try {\n        return await this.engine.rejectSessionAuthenticate(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), this.name = n?.name || me.name, this.metadata = n?.metadata || cs(), this.signConfig = n?.signConfig;\n    const e = typeof n?.logger < \"u\" && typeof n?.logger != \"string\" ? n.logger : At(xt({\n      level: n?.logger || me.logger\n    }));\n    this.core = n?.core || new bt(n), this.logger = Ct(e, this.name), this.session = new St(this.core, this.logger), this.proposal = new Ns(this.core, this.logger), this.pendingRequest = new Os(this.core, this.logger), this.engine = new Ps(this), this.auth = new Ds(this.core, this.logger);\n  }\n  static async init(n) {\n    const e = new Ee(n);\n    return await e.initialize(), e;\n  }\n  get context() {\n    return Vt(this.logger);\n  }\n  get pairing() {\n    return this.core.pairing.pairings;\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\");\n    try {\n      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info(\"SignClient Initialization Success\"), setTimeout(() => {\n        this.engine.processRelayMessageCache();\n      }, Oe(Ze));\n    } catch (n) {\n      throw this.logger.info(\"SignClient Initialization Failure\"), this.logger.error(n.message), n;\n    }\n  }\n}\nconst Ms = St,\n  $s = Ee;\nexport { wt as AUTH_CONTEXT, mt as AUTH_KEYS_CONTEXT, _t as AUTH_PAIRING_TOPIC_CONTEXT, yt as AUTH_PROTOCOL, ce as AUTH_PUBLIC_KEY_NAME, Et as AUTH_REQUEST_CONTEXT, ae as AUTH_STORAGE_PREFIX, Ss as AUTH_VERSION, dt as ENGINE_CONTEXT, $ as ENGINE_QUEUE_STATES, N as ENGINE_RPC_OPTS, _s as HISTORY_CONTEXT, ms as HISTORY_EVENTS, Es as HISTORY_STORAGE_VERSION, gt as METHODS_TO_VERIFY, pt as PROPOSAL_CONTEXT, fs as PROPOSAL_EXPIRY, $e as PROPOSAL_EXPIRY_MESSAGE, ut as REQUEST_CONTEXT, ht as SESSION_CONTEXT, J as SESSION_EXPIRY, _e as SESSION_REQUEST_EXPIRY_BOUNDARIES, ke as SIGN_CLIENT_CONTEXT, me as SIGN_CLIENT_DEFAULT, ys as SIGN_CLIENT_EVENTS, De as SIGN_CLIENT_PROTOCOL, ws as SIGN_CLIENT_STORAGE_OPTIONS, we as SIGN_CLIENT_STORAGE_PREFIX, Le as SIGN_CLIENT_VERSION, Ms as SessionStore, $s as SignClient, Ue as TVF_METHODS, Me as WALLETCONNECT_DEEPLINK_CHOICE, Ee as default };\n//# sourceMappingURL=index.es.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}