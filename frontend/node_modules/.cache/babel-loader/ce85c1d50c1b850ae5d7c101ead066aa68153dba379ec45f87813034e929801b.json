{"ast":null,"code":"import { WalletConnectionError, isVersionedTransaction } from '@solana/wallet-adapter-base';\nimport { PublicKey, Transaction, VersionedTransaction } from '@solana/web3.js';\nimport { UniversalProvider } from '@walletconnect/universal-provider';\nimport { parseAccountId } from '@walletconnect/utils';\nimport { createAppKit } from '@reown/appkit/core';\nimport { solana, solanaDevnet, solanaTestnet } from '@reown/appkit/networks';\nimport base58 from 'bs58';\nimport { WalletConnectRPCMethods } from './constants.js';\nimport { ClientNotInitializedError } from './errors/ClientNotInitializedError.js';\nimport { WalletConnectFeatureNotSupportedError } from './errors/WalletConnectNotSupportedError.js';\nimport { getConnectParams, getDefaultChainFromSession } from './utils.js';\nimport { QRCodeModalError } from './errors/QRCodeModalError.js';\nexport class WalletConnectWallet {\n  _UniversalProvider;\n  _session;\n  _modal;\n  _projectId;\n  _network;\n  _ConnectQueueResolver;\n  constructor(config) {\n    this.initClient(config.options);\n    this._network = config.network;\n    if (!config.options.projectId) {\n      throw Error('WalletConnect Adapter: Project ID is undefined');\n    }\n    this._projectId = config.options.projectId;\n  }\n  async connect() {\n    if (!this._UniversalProvider) {\n      await new Promise(res => {\n        this._ConnectQueueResolver = res;\n      });\n    }\n    if (!this._UniversalProvider) {\n      throw new Error(\"WalletConnect Adapter - Universal Provider was undefined while calling 'connect()'\");\n    }\n    if (this._UniversalProvider.session) {\n      this._session = this._UniversalProvider.session;\n      const defaultNetwork = getDefaultChainFromSession(this._session, this._network);\n      this._network = defaultNetwork;\n      this._UniversalProvider.setDefaultChain(defaultNetwork);\n      return {\n        publicKey: this.publicKey\n      };\n    }\n    await this.initModal();\n    const params = getConnectParams(this._network);\n    this._modal?.open();\n    // Create an abort controller to handle modal close\n    const controller = new AbortController();\n    const signal = controller.signal;\n    this._modal?.subscribeState(state => {\n      if (!state.open) {\n        controller.abort(new QRCodeModalError());\n      }\n    });\n    try {\n      const session = await Promise.race([this._UniversalProvider?.connect(params), new Promise((_, reject) => {\n        signal.addEventListener('abort', () => {\n          reject(signal.reason);\n        });\n      })]);\n      this._modal?.close();\n      this._session = session;\n      if (!session) {\n        throw new WalletConnectionError();\n      }\n      const defaultNetwork = getDefaultChainFromSession(session, this._network);\n      this._network = defaultNetwork;\n      this._UniversalProvider?.setDefaultChain(defaultNetwork);\n      return {\n        publicKey: this.publicKey\n      };\n    } catch (error) {\n      this._modal?.close();\n      throw error;\n    }\n  }\n  async disconnect() {\n    if (this._UniversalProvider?.session) {\n      await this.initModal();\n      if (!this._modal) {\n        throw Error('WalletConnect Adapter -Modal is undefined: unable to disconnect');\n      }\n      await this.client.disconnect();\n      // await this._modal.disconnect()\n      this._session = undefined;\n    } else {\n      throw new ClientNotInitializedError();\n    }\n  }\n  get client() {\n    if (this._UniversalProvider) {\n      return this._UniversalProvider;\n    }\n    throw new ClientNotInitializedError();\n  }\n  get session() {\n    if (!this._session) {\n      throw new ClientNotInitializedError();\n    }\n    return this._session;\n  }\n  get publicKey() {\n    if (this._UniversalProvider?.session && this._session) {\n      const {\n        address\n      } = parseAccountId(this._session?.namespaces['solana']?.accounts[0] ?? '');\n      return new PublicKey(address);\n    }\n    throw new ClientNotInitializedError();\n  }\n  async signTransaction(transaction) {\n    this.checkIfWalletSupportsMethod(WalletConnectRPCMethods.signTransaction);\n    const isVersioned = isVersionedTransaction(transaction);\n    const legacyTransaction = isVersioned ? {} : transaction;\n    const {\n      signature,\n      transaction: signedSerializedTransaction\n    } = await this.client.client.request({\n      chainId: this._network,\n      topic: this.session.topic,\n      request: {\n        method: WalletConnectRPCMethods.signTransaction,\n        params: {\n          /*\n           * Passing ...legacyTransaction is deprecated.\n           * All new clients should rely on the `transaction` parameter.\n           * The future versions will stop passing ...legacyTransaction.\n           */\n          ...legacyTransaction,\n          // New base64-encoded serialized transaction request parameter\n          transaction: this.serialize(transaction)\n        }\n      }\n    });\n    if (signedSerializedTransaction) {\n      return this.deserialize(signedSerializedTransaction, isVersioned);\n    }\n    transaction.addSignature(this.publicKey, Buffer.from(base58.decode(signature)));\n    return transaction;\n  }\n  async signMessage(message) {\n    this.checkIfWalletSupportsMethod(WalletConnectRPCMethods.signMessage);\n    const {\n      signature\n    } = await this.client.client.request({\n      // The network does not change the output of message signing, but this is a required parameter for SignClient\n      chainId: this._network,\n      topic: this.session.topic,\n      request: {\n        method: WalletConnectRPCMethods.signMessage,\n        params: {\n          pubkey: this.publicKey.toString(),\n          message: base58.encode(message)\n        }\n      }\n    });\n    return base58.decode(signature);\n  }\n  async signAndSendTransaction(transaction) {\n    this.checkIfWalletSupportsMethod(WalletConnectRPCMethods.signAndSendTransaction);\n    const {\n      signature\n    } = await this.client.client.request({\n      chainId: this._network,\n      topic: this.session.topic,\n      request: {\n        method: WalletConnectRPCMethods.signAndSendTransaction,\n        params: {\n          transaction: this.serialize(transaction)\n        }\n      }\n    });\n    return signature;\n  }\n  async signAllTransactions(transactions) {\n    try {\n      this.checkIfWalletSupportsMethod(WalletConnectRPCMethods.signAllTransactions);\n      const serializedTransactions = transactions.map(transaction => this.serialize(transaction));\n      const {\n        transactions: serializedSignedTransactions\n      } = await this.client.client.request({\n        chainId: this._network,\n        topic: this.session.topic,\n        request: {\n          method: WalletConnectRPCMethods.signAllTransactions,\n          params: {\n            transactions: serializedTransactions\n          }\n        }\n      });\n      return transactions.map((transaction, index) => {\n        if (isVersionedTransaction(transaction)) {\n          return this.deserialize(serializedSignedTransactions[index] ?? '', true);\n        }\n        return this.deserialize(serializedSignedTransactions[index] ?? '');\n      });\n    } catch (error) {\n      if (error instanceof WalletConnectFeatureNotSupportedError) {\n        const promises = transactions.map(transaction => this.signTransaction(transaction));\n        const signedTransactions = await Promise.all(promises);\n        return signedTransactions;\n      }\n      throw error;\n    }\n  }\n  async initClient(options) {\n    const provider = await UniversalProvider.init(options);\n    this._UniversalProvider = provider;\n    if (this._ConnectQueueResolver) {\n      this._ConnectQueueResolver(true);\n    }\n  }\n  async initModal() {\n    if (this._modal) {\n      return;\n    }\n    if (!this._UniversalProvider) {\n      throw new Error('WalletConnect Adapter - cannot init modal when Universal Provider is undefined');\n    }\n    this._modal = createAppKit({\n      projectId: this._projectId,\n      universalProvider: this._UniversalProvider,\n      networks: [solana, solanaDevnet, solanaTestnet],\n      manualWCControl: true\n    });\n  }\n  serialize(transaction) {\n    return Buffer.from(transaction.serialize({\n      verifySignatures: false\n    })).toString('base64');\n  }\n  deserialize(serializedTransaction, versioned = false) {\n    if (versioned) {\n      return VersionedTransaction.deserialize(Buffer.from(serializedTransaction, 'base64'));\n    }\n    return Transaction.from(Buffer.from(serializedTransaction, 'base64'));\n  }\n  checkIfWalletSupportsMethod(method) {\n    if (!this.session.namespaces['solana']?.methods.includes(method)) {\n      throw new WalletConnectFeatureNotSupportedError(method);\n    }\n  }\n}","map":{"version":3,"names":["WalletConnectionError","isVersionedTransaction","PublicKey","Transaction","VersionedTransaction","UniversalProvider","parseAccountId","createAppKit","solana","solanaDevnet","solanaTestnet","base58","WalletConnectRPCMethods","ClientNotInitializedError","WalletConnectFeatureNotSupportedError","getConnectParams","getDefaultChainFromSession","QRCodeModalError","WalletConnectWallet","_UniversalProvider","_session","_modal","_projectId","_network","_ConnectQueueResolver","constructor","config","initClient","options","network","projectId","Error","connect","Promise","res","session","defaultNetwork","setDefaultChain","publicKey","initModal","params","open","controller","AbortController","signal","subscribeState","state","abort","race","_","reject","addEventListener","reason","close","error","disconnect","client","undefined","address","namespaces","accounts","signTransaction","transaction","checkIfWalletSupportsMethod","isVersioned","legacyTransaction","signature","signedSerializedTransaction","request","chainId","topic","method","serialize","deserialize","addSignature","Buffer","from","decode","signMessage","message","pubkey","toString","encode","signAndSendTransaction","signAllTransactions","transactions","serializedTransactions","map","serializedSignedTransactions","index","promises","signedTransactions","all","provider","init","universalProvider","networks","manualWCControl","verifySignatures","serializedTransaction","versioned","methods","includes"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\solana-adapter\\src\\core.ts"],"sourcesContent":["import { WalletConnectionError, isVersionedTransaction } from '@solana/wallet-adapter-base'\nimport { PublicKey, Transaction, VersionedTransaction } from '@solana/web3.js'\nimport type { SessionTypes, SignClientTypes } from '@walletconnect/types'\nimport { UniversalProvider } from '@walletconnect/universal-provider'\nimport { parseAccountId } from '@walletconnect/utils'\nimport { createAppKit } from '@reown/appkit/core'\nimport { solana, solanaDevnet, solanaTestnet } from '@reown/appkit/networks'\n\nimport base58 from 'bs58'\n\nimport type { AppKit } from '@reown/appkit/core'\n\n\nimport { WalletConnectRPCMethods } from './constants.js'\nimport type { WalletConnectChainID } from './constants.js'\nimport { ClientNotInitializedError } from './errors/ClientNotInitializedError.js'\nimport { WalletConnectFeatureNotSupportedError } from './errors/WalletConnectNotSupportedError.js'\nimport type {\n  UniversalProviderType,\n  WalletConnectWalletAdapterConfig,\n  WalletConnectWalletInit\n} from './types.js'\nimport { getConnectParams, getDefaultChainFromSession } from './utils.js'\nimport { QRCodeModalError } from './errors/QRCodeModalError.js'\n\nexport class WalletConnectWallet {\n  private _UniversalProvider: UniversalProviderType | undefined\n  private _session: SessionTypes.Struct | undefined\n  private _modal: AppKit | undefined\n  private _projectId: string\n  private _network: WalletConnectChainID\n  private _ConnectQueueResolver: ((value: unknown) => void) | undefined\n\n  constructor(config: WalletConnectWalletAdapterConfig) {\n    this.initClient(config.options)\n    this._network = config.network\n\n    if (!config.options.projectId) {\n      throw Error('WalletConnect Adapter: Project ID is undefined')\n    }\n    this._projectId = config.options.projectId\n  }\n\n  async connect(): Promise<WalletConnectWalletInit> {\n    if (!this._UniversalProvider) {\n      await new Promise(res => {\n        this._ConnectQueueResolver = res\n      })\n    }\n    if (!this._UniversalProvider) {\n      throw new Error(\n        \"WalletConnect Adapter - Universal Provider was undefined while calling 'connect()'\"\n      )\n    }\n\n    if (this._UniversalProvider.session) {\n      this._session = this._UniversalProvider.session\n      const defaultNetwork = getDefaultChainFromSession(\n        this._session,\n        this._network\n      ) as WalletConnectChainID\n      this._network = defaultNetwork\n      this._UniversalProvider.setDefaultChain(defaultNetwork)\n\n      return {\n        publicKey: this.publicKey\n      }\n    }\n    await this.initModal()\n    const params = getConnectParams(this._network)\n    this._modal?.open()\n\n    // Create an abort controller to handle modal close\n    const controller = new AbortController()\n    const signal = controller.signal\n\n    this._modal?.subscribeState((state) => {\n      if (!state.open) {\n        controller.abort(new QRCodeModalError())\n      }\n    })\n    \n    try {\n      const session = await Promise.race([\n        this._UniversalProvider?.connect(params),\n        new Promise<never>((_, reject) => {\n          signal.addEventListener('abort', () => {\n            reject(signal.reason)\n          })\n        })\n      ])\n      this._modal?.close()\n      this._session = session\n      if (!session) {\n        throw new WalletConnectionError()\n      }\n      const defaultNetwork = getDefaultChainFromSession(\n        session,\n        this._network\n      ) as WalletConnectChainID\n      this._network = defaultNetwork\n      this._UniversalProvider?.setDefaultChain(defaultNetwork)\n\n      return { publicKey: this.publicKey }\n    } catch (error) {\n      this._modal?.close()\n      throw error\n    }\n  }\n\n  async disconnect() {\n    if (this._UniversalProvider?.session) {\n      await this.initModal()\n      if (!this._modal) {\n        throw Error('WalletConnect Adapter -Modal is undefined: unable to disconnect')\n      }\n      await this.client.disconnect()\n      // await this._modal.disconnect()\n      this._session = undefined\n    } else {\n      throw new ClientNotInitializedError()\n    }\n\n  }\n\n  get client(): UniversalProviderType {\n    if (this._UniversalProvider) {\n      return this._UniversalProvider\n    }\n    throw new ClientNotInitializedError()\n  }\n\n  get session(): SessionTypes.Struct {\n    if (!this._session) {\n      throw new ClientNotInitializedError()\n    }\n\n    return this._session\n  }\n\n  get publicKey(): PublicKey {\n    if (this._UniversalProvider?.session && this._session) {\n      const { address } = parseAccountId(this._session?.namespaces['solana']?.accounts[0] ?? '')\n\n      return new PublicKey(address)\n    }\n    throw new ClientNotInitializedError()\n  }\n\n  async signTransaction<T extends Transaction | VersionedTransaction>(transaction: T): Promise<T> {\n    this.checkIfWalletSupportsMethod(WalletConnectRPCMethods.signTransaction)\n\n    const isVersioned = isVersionedTransaction(transaction)\n\n    const legacyTransaction = isVersioned ? {} : transaction\n\n    const { signature, transaction: signedSerializedTransaction } =\n      await this.client.client.request<{\n        signature: string\n        transaction?: string\n      }>({\n        chainId: this._network,\n        topic: this.session.topic,\n        request: {\n          method: WalletConnectRPCMethods.signTransaction,\n          params: {\n            /*\n             * Passing ...legacyTransaction is deprecated.\n             * All new clients should rely on the `transaction` parameter.\n             * The future versions will stop passing ...legacyTransaction.\n             */\n            ...legacyTransaction,\n            // New base64-encoded serialized transaction request parameter\n            transaction: this.serialize(transaction)\n          }\n        }\n      })\n\n    if (signedSerializedTransaction) {\n      return this.deserialize(signedSerializedTransaction, isVersioned) as T\n    }\n\n    transaction.addSignature(this.publicKey, Buffer.from(base58.decode(signature)))\n\n    return transaction\n  }\n\n  async signMessage(message: Uint8Array): Promise<Uint8Array> {\n    this.checkIfWalletSupportsMethod(WalletConnectRPCMethods.signMessage)\n\n    const { signature } = await this.client.client.request<{\n      signature: string\n    }>({\n      // The network does not change the output of message signing, but this is a required parameter for SignClient\n      chainId: this._network,\n      topic: this.session.topic,\n      request: {\n        method: WalletConnectRPCMethods.signMessage,\n        params: {\n          pubkey: this.publicKey.toString(),\n          message: base58.encode(message)\n        }\n      }\n    })\n\n    return base58.decode(signature)\n  }\n\n  async signAndSendTransaction<T extends Transaction | VersionedTransaction>(\n    transaction: T\n  ): Promise<string> {\n    this.checkIfWalletSupportsMethod(WalletConnectRPCMethods.signAndSendTransaction)\n\n    const { signature } = await this.client.client.request<{\n      signature: string\n    }>({\n      chainId: this._network,\n      topic: this.session.topic,\n      request: {\n        method: WalletConnectRPCMethods.signAndSendTransaction,\n        params: { transaction: this.serialize(transaction) }\n      }\n    })\n\n    return signature\n  }\n\n  async signAllTransactions<T extends Transaction | VersionedTransaction>(\n    transactions: T[]\n  ): Promise<T[]> {\n    try {\n      this.checkIfWalletSupportsMethod(WalletConnectRPCMethods.signAllTransactions)\n\n      const serializedTransactions = transactions.map(transaction => this.serialize(transaction))\n\n      const { transactions: serializedSignedTransactions } = await this.client.client.request<{\n        transactions: string[]\n      }>({\n        chainId: this._network,\n        topic: this.session.topic,\n        request: {\n          method: WalletConnectRPCMethods.signAllTransactions,\n          params: { transactions: serializedTransactions }\n        }\n      })\n\n      return transactions.map((transaction, index) => {\n        if (isVersionedTransaction(transaction)) {\n          return this.deserialize(serializedSignedTransactions[index] ?? '', true)\n        }\n\n        return this.deserialize(serializedSignedTransactions[index] ?? '')\n      }) as T[]\n    } catch (error) {\n      if (error instanceof WalletConnectFeatureNotSupportedError) {\n        const promises = transactions.map(transaction => this.signTransaction(transaction))\n        const signedTransactions = await Promise.all(promises)\n\n        return signedTransactions\n      }\n\n      throw error\n    }\n  }\n\n  async initClient(options: SignClientTypes.Options) {\n    const provider = await UniversalProvider.init(options)\n    this._UniversalProvider = provider\n    if (this._ConnectQueueResolver) {\n      this._ConnectQueueResolver(true)\n    }\n  }\n\n  async initModal() {\n    if (this._modal) {\n      return\n    }\n    if (!this._UniversalProvider) {\n      throw new Error(\n        'WalletConnect Adapter - cannot init modal when Universal Provider is undefined'\n      )\n    }\n\n\n    this._modal = createAppKit({\n      projectId: this._projectId,\n      universalProvider: this._UniversalProvider,\n      networks: [solana, solanaDevnet, solanaTestnet],\n      manualWCControl: true\n    })\n  }\n\n  private serialize(transaction: Transaction | VersionedTransaction): string {\n    return Buffer.from(transaction.serialize({ verifySignatures: false })).toString('base64')\n  }\n\n  private deserialize(\n    serializedTransaction: string,\n    versioned = false\n  ): Transaction | VersionedTransaction {\n    if (versioned) {\n      return VersionedTransaction.deserialize(Buffer.from(serializedTransaction, 'base64'))\n    }\n\n    return Transaction.from(Buffer.from(serializedTransaction, 'base64'))\n  }\n\n  private checkIfWalletSupportsMethod(method: WalletConnectRPCMethods) {\n    if (!this.session.namespaces['solana']?.methods.includes(method)) {\n      throw new WalletConnectFeatureNotSupportedError(method)\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}