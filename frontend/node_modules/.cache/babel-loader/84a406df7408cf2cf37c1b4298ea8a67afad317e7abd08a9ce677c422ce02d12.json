{"ast":null,"code":"import { TransportError } from \"@ledgerhq/errors\";\nconst Tag = 0x05;\nfunction asUInt16BE(value) {\n  const b = Buffer.alloc(2);\n  b.writeUInt16BE(value, 0);\n  return b;\n}\nconst initialAcc = {\n  data: Buffer.alloc(0),\n  dataLength: 0,\n  sequence: 0\n};\n/**\n * Object to handle HID frames (encoding and decoding)\n *\n * @param channel\n * @param packetSize The HID protocol packet size in bytes (usually 64)\n */\nconst createHIDframing = (channel, packetSize) => {\n  return {\n    /**\n     * Frames/encodes an APDU message into HID USB packets/frames\n     *\n     * @param apdu The APDU message to send, in a Buffer containing [cla, ins, p1, p2, data length, data(if not empty)]\n     * @returns an array of HID USB frames ready to be sent\n     */\n    makeBlocks(apdu) {\n      // Encodes the APDU length in 2 bytes before the APDU itself.\n      // The length is measured as the number of bytes.\n      // As the size of the APDU `data` should have been added in 1 byte just before `data`,\n      // the minimum size of an APDU is 5 bytes.\n      let data = Buffer.concat([asUInt16BE(apdu.length), apdu]);\n      const blockSize = packetSize - 5;\n      const nbBlocks = Math.ceil(data.length / blockSize);\n      // Fills data with 0-padding\n      data = Buffer.concat([data, Buffer.alloc(nbBlocks * blockSize - data.length + 1).fill(0)]);\n      const blocks = [];\n      for (let i = 0; i < nbBlocks; i++) {\n        const head = Buffer.alloc(5);\n        head.writeUInt16BE(channel, 0);\n        head.writeUInt8(Tag, 2);\n        head.writeUInt16BE(i, 3);\n        // `slice` and not `subarray`: this might not be a Node Buffer, but probably only a Uint8Array\n        const chunk = data.slice(i * blockSize, (i + 1) * blockSize);\n        blocks.push(Buffer.concat([head, chunk]));\n      }\n      return blocks;\n    },\n    /**\n     * Reduces HID USB packets/frames to one response.\n     *\n     * @param acc The value resulting from (accumulating) the previous call of reduceResponse.\n     *   On first call initialized to `initialAcc`. The accumulator enables handling multi-frames messages.\n     * @param chunk Current chunk to reduce into accumulator\n     * @returns An accumulator value updated with the current chunk\n     */\n    reduceResponse(acc, chunk) {\n      let {\n        data,\n        dataLength,\n        sequence\n      } = acc || initialAcc;\n      if (chunk.readUInt16BE(0) !== channel) {\n        throw new TransportError(\"Invalid channel\", \"InvalidChannel\");\n      }\n      if (chunk.readUInt8(2) !== Tag) {\n        throw new TransportError(\"Invalid tag\", \"InvalidTag\");\n      }\n      if (chunk.readUInt16BE(3) !== sequence) {\n        throw new TransportError(\"Invalid sequence\", \"InvalidSequence\");\n      }\n      // Gets the total length of the response from the 1st frame\n      if (!acc) {\n        dataLength = chunk.readUInt16BE(5);\n      }\n      sequence++;\n      // The total length on the 1st frame takes 2 more bytes\n      const chunkData = chunk.slice(acc ? 5 : 7);\n      data = Buffer.concat([data, chunkData]);\n      // Removes any 0 padding\n      if (data.length > dataLength) {\n        data = data.slice(0, dataLength);\n      }\n      return {\n        data,\n        dataLength,\n        sequence\n      };\n    },\n    /**\n     * Returns the response message that has been reduced from the HID USB frames\n     *\n     * @param acc The accumulator\n     * @returns A Buffer containing the cleaned response message, or null if no response message, or undefined if the\n     *   accumulator is incorrect (message length is not valid)\n     */\n    getReducedResult(acc) {\n      if (acc && acc.dataLength === acc.data.length) {\n        return acc.data;\n      }\n    }\n  };\n};\nexport default createHIDframing;","map":{"version":3,"names":["TransportError","Tag","asUInt16BE","value","b","Buffer","alloc","writeUInt16BE","initialAcc","data","dataLength","sequence","createHIDframing","channel","packetSize","makeBlocks","apdu","concat","length","blockSize","nbBlocks","Math","ceil","fill","blocks","i","head","writeUInt8","chunk","slice","push","reduceResponse","acc","readUInt16BE","readUInt8","chunkData","getReducedResult"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@ledgerhq\\devices\\src\\hid-framing.ts"],"sourcesContent":["import { TransportError } from \"@ledgerhq/errors\";\n\n// Represents a response message from the device being reduced from HID USB frames/packets\nexport type ResponseAcc =\n  | {\n      data: Buffer;\n      dataLength: number;\n      // The current frame id/number\n      sequence: number;\n    }\n  | null\n  | undefined;\n\nconst Tag = 0x05;\n\nfunction asUInt16BE(value) {\n  const b = Buffer.alloc(2);\n  b.writeUInt16BE(value, 0);\n  return b;\n}\n\nconst initialAcc = {\n  data: Buffer.alloc(0),\n  dataLength: 0,\n  sequence: 0,\n};\n\n/**\n * Object to handle HID frames (encoding and decoding)\n *\n * @param channel\n * @param packetSize The HID protocol packet size in bytes (usually 64)\n */\nconst createHIDframing = (channel: number, packetSize: number) => {\n  return {\n    /**\n     * Frames/encodes an APDU message into HID USB packets/frames\n     *\n     * @param apdu The APDU message to send, in a Buffer containing [cla, ins, p1, p2, data length, data(if not empty)]\n     * @returns an array of HID USB frames ready to be sent\n     */\n    makeBlocks(apdu: Buffer): Buffer[] {\n      // Encodes the APDU length in 2 bytes before the APDU itself.\n      // The length is measured as the number of bytes.\n      // As the size of the APDU `data` should have been added in 1 byte just before `data`,\n      // the minimum size of an APDU is 5 bytes.\n      let data = Buffer.concat([asUInt16BE(apdu.length), apdu]);\n\n      const blockSize = packetSize - 5;\n      const nbBlocks = Math.ceil(data.length / blockSize);\n\n      // Fills data with 0-padding\n      data = Buffer.concat([data, Buffer.alloc(nbBlocks * blockSize - data.length + 1).fill(0)]);\n\n      const blocks: Buffer[] = [];\n\n      for (let i = 0; i < nbBlocks; i++) {\n        const head = Buffer.alloc(5);\n        head.writeUInt16BE(channel, 0);\n        head.writeUInt8(Tag, 2);\n        head.writeUInt16BE(i, 3);\n\n        // `slice` and not `subarray`: this might not be a Node Buffer, but probably only a Uint8Array\n        const chunk = data.slice(i * blockSize, (i + 1) * blockSize);\n\n        blocks.push(Buffer.concat([head, chunk]));\n      }\n\n      return blocks;\n    },\n\n    /**\n     * Reduces HID USB packets/frames to one response.\n     *\n     * @param acc The value resulting from (accumulating) the previous call of reduceResponse.\n     *   On first call initialized to `initialAcc`. The accumulator enables handling multi-frames messages.\n     * @param chunk Current chunk to reduce into accumulator\n     * @returns An accumulator value updated with the current chunk\n     */\n    reduceResponse(acc: ResponseAcc, chunk: Buffer): ResponseAcc {\n      let { data, dataLength, sequence } = acc || initialAcc;\n\n      if (chunk.readUInt16BE(0) !== channel) {\n        throw new TransportError(\"Invalid channel\", \"InvalidChannel\");\n      }\n\n      if (chunk.readUInt8(2) !== Tag) {\n        throw new TransportError(\"Invalid tag\", \"InvalidTag\");\n      }\n\n      if (chunk.readUInt16BE(3) !== sequence) {\n        throw new TransportError(\"Invalid sequence\", \"InvalidSequence\");\n      }\n\n      // Gets the total length of the response from the 1st frame\n      if (!acc) {\n        dataLength = chunk.readUInt16BE(5);\n      }\n\n      sequence++;\n      // The total length on the 1st frame takes 2 more bytes\n      const chunkData = chunk.slice(acc ? 5 : 7);\n      data = Buffer.concat([data, chunkData]);\n\n      // Removes any 0 padding\n      if (data.length > dataLength) {\n        data = data.slice(0, dataLength);\n      }\n\n      return {\n        data,\n        dataLength,\n        sequence,\n      };\n    },\n\n    /**\n     * Returns the response message that has been reduced from the HID USB frames\n     *\n     * @param acc The accumulator\n     * @returns A Buffer containing the cleaned response message, or null if no response message, or undefined if the\n     *   accumulator is incorrect (message length is not valid)\n     */\n    getReducedResult(acc: ResponseAcc): Buffer | null | undefined {\n      if (acc && acc.dataLength === acc.data.length) {\n        return acc.data;\n      }\n    },\n  };\n};\n\nexport default createHIDframing;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}