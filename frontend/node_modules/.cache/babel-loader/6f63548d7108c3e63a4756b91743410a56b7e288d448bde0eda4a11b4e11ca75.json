{"ast":null,"code":"import loglevel from 'loglevel';\nimport { ObliviousSet } from 'oblivious-set';\nimport { io } from 'socket.io-client';\nimport { getPublic, sign } from '@toruslabs/eccrypto';\nimport { keccak256, encryptData, decryptData } from '@toruslabs/metadata-helpers';\n\n// import Bowser from 'bowser';\n\n/**\n * returns true if the given object is a promise\n */\nfunction isPromise(obj) {\n  if (obj && typeof obj.then === 'function') {\n    return true;\n  } else {\n    return false;\n  }\n}\nPromise.resolve(false);\nPromise.resolve(true);\nconst PROMISE_RESOLVED_VOID = Promise.resolve();\nfunction sleep(time, resolveWith) {\n  if (!time) time = 0;\n  return new Promise(res => setTimeout(() => res(resolveWith), time));\n}\nfunction randomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\n/**\n * https://stackoverflow.com/a/8084248\n */\nfunction randomToken() {\n  return Math.random().toString(36).substring(2);\n}\nlet lastMs = 0;\n\n/**\n * returns the current time in micro-seconds,\n * WARNING: This is a pseudo-function\n * Performance.now is not reliable in webworkers, so we just make sure to never return the same time.\n * This is enough in browsers, and this function will not be used in nodejs.\n * The main reason for this hack is to ensure that BroadcastChannel behaves equal to production when it is used in fast-running unit tests.\n */\nfunction microSeconds$5() {\n  let ret = Date.now() * 1000; // milliseconds to microseconds\n  if (ret <= lastMs) {\n    ret = lastMs + 1;\n  }\n  lastMs = ret;\n  return ret;\n}\n\n// the problem is only in iframes. we should default to server in case of iframes.\n// storage scoping is present in all browsers now\n// Safari and other browsers support native Broadcast channel now. It's in LS.\n// test here: https://pubkey.github.io/broadcast-channel/e2e.html?methodType=native\n// https://caniuse.com/broadcastchannel\n// export function are3PCSupported() {\n//     if (typeof navigator === 'undefined') return false;\n//     const browserInfo = Bowser.parse(navigator.userAgent);\n//     log.info(JSON.stringify(browserInfo), 'current browser info');\n\n//     let thirdPartyCookieSupport = true;\n//     // brave\n//     if (navigator.brave) {\n//         thirdPartyCookieSupport = false;\n//     }\n//     // All webkit & gecko engine instances use itp (intelligent tracking prevention -\n//     // https://webkit.org/tracking-prevention/#intelligent-tracking-prevention-itp)\n//     if (browserInfo.engine.name === Bowser.ENGINE_MAP.WebKit || browserInfo.engine.name === Bowser.ENGINE_MAP.Gecko) {\n//         thirdPartyCookieSupport = false;\n//     }\n\n//     return thirdPartyCookieSupport;\n// }\n\nconst log = loglevel.getLogger('broadcast-channel');\nlog.setLevel('error');\nconst microSeconds$4 = microSeconds$5;\nconst type$4 = 'native';\nfunction create$4(channelName) {\n  const state = {\n    time: microSeconds$5(),\n    messagesCallback: null,\n    bc: new BroadcastChannel(channelName),\n    subFns: [] // subscriberFunctions\n  };\n  state.bc.onmessage = msg => {\n    if (state.messagesCallback) {\n      state.messagesCallback(msg.data);\n    }\n  };\n  return state;\n}\nfunction close$4(channelState) {\n  channelState.bc.close();\n  channelState.subFns = [];\n}\nfunction postMessage$4(channelState, messageJson) {\n  try {\n    channelState.bc.postMessage(messageJson, false);\n    return PROMISE_RESOLVED_VOID;\n  } catch (err) {\n    return Promise.reject(err);\n  }\n}\nfunction onMessage$4(channelState, fn) {\n  channelState.messagesCallback = fn;\n}\nfunction canBeUsed$4() {\n  /**\n   * in the electron-renderer, isNode will be true even if we are in browser-context\n   * so we also check if window is undefined\n   */\n  if (typeof window === 'undefined') return false;\n  if (typeof BroadcastChannel === 'function') {\n    if (BroadcastChannel._pubkey) {\n      throw new Error('BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill');\n    }\n    return true;\n  } else return false;\n}\nfunction averageResponseTime$4() {\n  return 150;\n}\nvar NativeMethod = {\n  create: create$4,\n  close: close$4,\n  onMessage: onMessage$4,\n  postMessage: postMessage$4,\n  canBeUsed: canBeUsed$4,\n  type: type$4,\n  averageResponseTime: averageResponseTime$4,\n  microSeconds: microSeconds$4\n};\nfunction fillOptionsWithDefaults() {\n  let originalOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const options = JSON.parse(JSON.stringify(originalOptions));\n\n  // main\n  if (typeof options.webWorkerSupport === 'undefined') options.webWorkerSupport = true;\n\n  // indexed-db\n  if (!options.idb) options.idb = {};\n  //  after this time the messages get deleted\n  if (!options.idb.ttl) options.idb.ttl = 1000 * 45;\n  if (!options.idb.fallbackInterval) options.idb.fallbackInterval = 150;\n  //  handles abrupt db onclose events.\n  if (originalOptions.idb && typeof originalOptions.idb.onclose === 'function') options.idb.onclose = originalOptions.idb.onclose;\n\n  // localstorage\n  if (!options.localstorage) options.localstorage = {};\n  if (!options.localstorage.removeTimeout) options.localstorage.removeTimeout = 1000 * 60;\n\n  // server\n  if (!options.server) options.server = {};\n  if (!options.server.url) options.server.url = 'https://session.web3auth.io';\n  if (!options.server.removeTimeout) options.server.removeTimeout = 1000 * 60 * 5; // 5 minutes\n\n  // custom methods\n  if (originalOptions.methods) options.methods = originalOptions.methods;\n  return options;\n}\n\n/**\n * this method uses indexeddb to store the messages\n * There is currently no observerAPI for idb\n * @link https://github.com/w3c/IndexedDB/issues/51\n *\n * When working on this, ensure to use these performance optimizations:\n * @link https://rxdb.info/slow-indexeddb.html\n */\n\nconst microSeconds$3 = microSeconds$5;\nconst DB_PREFIX = 'pubkey.broadcast-channel-0-';\nconst OBJECT_STORE_ID = 'messages';\n\n/**\n * Use relaxed durability for faster performance on all transactions.\n * @link https://nolanlawson.com/2021/08/22/speeding-up-indexeddb-reads-and-writes/\n */\nconst TRANSACTION_SETTINGS = {\n  durability: 'relaxed'\n};\nconst type$3 = 'idb';\nfunction getIdb() {\n  if (typeof indexedDB !== 'undefined') return indexedDB;\n  if (typeof window !== 'undefined') {\n    if (typeof window.mozIndexedDB !== 'undefined') return window.mozIndexedDB;\n    if (typeof window.webkitIndexedDB !== 'undefined') return window.webkitIndexedDB;\n    if (typeof window.msIndexedDB !== 'undefined') return window.msIndexedDB;\n  }\n  return false;\n}\n\n/**\n * If possible, we should explicitly commit IndexedDB transactions\n * for better performance.\n * @link https://nolanlawson.com/2021/08/22/speeding-up-indexeddb-reads-and-writes/\n */\nfunction commitIndexedDBTransaction(tx) {\n  if (tx.commit) {\n    tx.commit();\n  }\n}\nfunction createDatabase(channelName) {\n  const IndexedDB = getIdb();\n\n  // create table\n  const dbName = DB_PREFIX + channelName;\n\n  /**\n   * All IndexedDB databases are opened without version\n   * because it is a bit faster, especially on firefox\n   * @link http://nparashuram.com/IndexedDB/perf/#Open%20Database%20with%20version\n   */\n  const openRequest = IndexedDB.open(dbName);\n  openRequest.onupgradeneeded = ev => {\n    const db = ev.target.result;\n    db.createObjectStore(OBJECT_STORE_ID, {\n      keyPath: 'id',\n      autoIncrement: true\n    });\n  };\n  const dbPromise = new Promise((res, rej) => {\n    openRequest.onerror = ev => rej(ev);\n    openRequest.onsuccess = () => {\n      res(openRequest.result);\n    };\n  });\n  return dbPromise;\n}\n\n/**\n * writes the new message to the database\n * so other readers can find it\n */\nfunction writeMessage(db, readerUuid, messageJson) {\n  const time = Date.now();\n  const writeObject = {\n    uuid: readerUuid,\n    time,\n    data: messageJson\n  };\n  const tx = db.transaction([OBJECT_STORE_ID], 'readwrite', TRANSACTION_SETTINGS);\n  return new Promise((res, rej) => {\n    tx.oncomplete = () => res();\n    tx.onerror = ev => rej(ev);\n    const objectStore = tx.objectStore(OBJECT_STORE_ID);\n    objectStore.add(writeObject);\n    commitIndexedDBTransaction(tx);\n  });\n}\nfunction getAllMessages(db) {\n  const tx = db.transaction(OBJECT_STORE_ID, 'readonly', TRANSACTION_SETTINGS);\n  const objectStore = tx.objectStore(OBJECT_STORE_ID);\n  const ret = [];\n  return new Promise(res => {\n    objectStore.openCursor().onsuccess = ev => {\n      const cursor = ev.target.result;\n      if (cursor) {\n        ret.push(cursor.value);\n        //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n        cursor.continue();\n      } else {\n        commitIndexedDBTransaction(tx);\n        res(ret);\n      }\n    };\n  });\n}\nfunction getMessagesHigherThan(db, lastCursorId) {\n  const tx = db.transaction(OBJECT_STORE_ID, 'readonly', TRANSACTION_SETTINGS);\n  const objectStore = tx.objectStore(OBJECT_STORE_ID);\n  const ret = [];\n  let keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);\n\n  /**\n   * Optimization shortcut,\n   * if getAll() can be used, do not use a cursor.\n   * @link https://rxdb.info/slow-indexeddb.html\n   */\n  if (objectStore.getAll) {\n    const getAllRequest = objectStore.getAll(keyRangeValue);\n    return new Promise((res, rej) => {\n      getAllRequest.onerror = err => rej(err);\n      getAllRequest.onsuccess = function (e) {\n        res(e.target.result);\n      };\n    });\n  }\n  function openCursor() {\n    // Occasionally Safari will fail on IDBKeyRange.bound, this\n    // catches that error, having it open the cursor to the first\n    // item. When it gets data it will advance to the desired key.\n    try {\n      keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);\n      return objectStore.openCursor(keyRangeValue);\n    } catch (e) {\n      return objectStore.openCursor();\n    }\n  }\n  return new Promise((res, rej) => {\n    const openCursorRequest = openCursor();\n    openCursorRequest.onerror = err => rej(err);\n    openCursorRequest.onsuccess = ev => {\n      const cursor = ev.target.result;\n      if (cursor) {\n        if (cursor.value.id < lastCursorId + 1) {\n          cursor.continue(lastCursorId + 1);\n        } else {\n          ret.push(cursor.value);\n          cursor.continue();\n        }\n      } else {\n        commitIndexedDBTransaction(tx);\n        res(ret);\n      }\n    };\n  });\n}\nfunction removeMessagesById(db, ids) {\n  const tx = db.transaction([OBJECT_STORE_ID], 'readwrite', TRANSACTION_SETTINGS);\n  const objectStore = tx.objectStore(OBJECT_STORE_ID);\n  return Promise.all(ids.map(id => {\n    const deleteRequest = objectStore.delete(id);\n    return new Promise(res => {\n      deleteRequest.onsuccess = () => res();\n    });\n  }));\n}\nfunction getOldMessages(db, ttl) {\n  const olderThen = Date.now() - ttl;\n  const tx = db.transaction(OBJECT_STORE_ID, 'readonly', TRANSACTION_SETTINGS);\n  const objectStore = tx.objectStore(OBJECT_STORE_ID);\n  const ret = [];\n  return new Promise(res => {\n    objectStore.openCursor().onsuccess = ev => {\n      const cursor = ev.target.result;\n      if (cursor) {\n        const msgObk = cursor.value;\n        if (msgObk.time < olderThen) {\n          ret.push(msgObk);\n          //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n          cursor.continue();\n        } else {\n          // no more old messages,\n          commitIndexedDBTransaction(tx);\n          res(ret);\n          return;\n        }\n      } else {\n        res(ret);\n      }\n    };\n  });\n}\nfunction cleanOldMessages(db, ttl) {\n  return getOldMessages(db, ttl).then(tooOld => {\n    return removeMessagesById(db, tooOld.map(msg => msg.id));\n  });\n}\nfunction create$3(channelName, options) {\n  options = fillOptionsWithDefaults(options);\n  return createDatabase(channelName).then(db => {\n    const state = {\n      closed: false,\n      lastCursorId: 0,\n      channelName,\n      options,\n      uuid: randomToken(),\n      /**\n       * emittedMessagesIds\n       * contains all messages that have been emitted before\n       * @type {ObliviousSet}\n       */\n      eMIs: new ObliviousSet(options.idb.ttl * 2),\n      // ensures we do not read messages in parrallel\n      writeBlockPromise: PROMISE_RESOLVED_VOID,\n      messagesCallback: null,\n      readQueuePromises: [],\n      db,\n      time: microSeconds$5()\n    };\n\n    /**\n     * Handle abrupt closes that do not originate from db.close().\n     * This could happen, for example, if the underlying storage is\n     * removed or if the user clears the database in the browser's\n     * history preferences.\n     */\n    db.onclose = function () {\n      state.closed = true;\n      if (options.idb.onclose) options.idb.onclose();\n    };\n\n    /**\n     * if service-workers are used,\n     * we have no 'storage'-event if they post a message,\n     * therefore we also have to set an interval\n     */\n    _readLoop(state);\n    return state;\n  });\n}\nfunction _readLoop(state) {\n  if (state.closed) return;\n  readNewMessages(state).then(() => sleep(state.options.idb.fallbackInterval)).then(() => _readLoop(state));\n}\nfunction _filterMessage(msgObj, state) {\n  if (msgObj.uuid === state.uuid) return false; // send by own\n  if (state.eMIs.has(msgObj.id)) return false; // already emitted\n  if (msgObj.data.time < state.messagesCallbackTime) return false; // older then onMessageCallback\n  return true;\n}\n\n/**\n * reads all new messages from the database and emits them\n */\nfunction readNewMessages(state) {\n  // channel already closed\n  if (state.closed) return PROMISE_RESOLVED_VOID;\n\n  // if no one is listening, we do not need to scan for new messages\n  if (!state.messagesCallback) return PROMISE_RESOLVED_VOID;\n  return getMessagesHigherThan(state.db, state.lastCursorId).then(newerMessages => {\n    const useMessages = newerMessages\n    /**\n     * there is a bug in iOS where the msgObj can be undefined some times\n     * so we filter them out\n     * @link https://github.com/pubkey/broadcast-channel/issues/19\n     */.filter(msgObj => !!msgObj).map(msgObj => {\n      if (msgObj.id > state.lastCursorId) {\n        state.lastCursorId = msgObj.id;\n      }\n      return msgObj;\n    }).filter(msgObj => _filterMessage(msgObj, state)).sort((msgObjA, msgObjB) => msgObjA.time - msgObjB.time); // sort by time\n    useMessages.forEach(msgObj => {\n      if (state.messagesCallback) {\n        state.eMIs.add(msgObj.id);\n        state.messagesCallback(msgObj.data);\n      }\n    });\n    return PROMISE_RESOLVED_VOID;\n  });\n}\nfunction close$3(channelState) {\n  channelState.closed = true;\n  channelState.db.close();\n}\nfunction postMessage$3(channelState, messageJson) {\n  channelState.writeBlockPromise = channelState.writeBlockPromise.then(() => writeMessage(channelState.db, channelState.uuid, messageJson)).then(() => {\n    if (randomInt(0, 10) === 0) {\n      /* await (do not await) */\n      cleanOldMessages(channelState.db, channelState.options.idb.ttl);\n    }\n  });\n  return channelState.writeBlockPromise;\n}\nfunction onMessage$3(channelState, fn, time) {\n  channelState.messagesCallbackTime = time;\n  channelState.messagesCallback = fn;\n  readNewMessages(channelState);\n}\nfunction canBeUsed$3() {\n  const idb = getIdb();\n  if (!idb) return false;\n  return true;\n}\nfunction averageResponseTime$3(options) {\n  return options.idb.fallbackInterval * 2;\n}\nvar IndexeDbMethod = {\n  getIdb,\n  createDatabase,\n  create: create$3,\n  close: close$3,\n  onMessage: onMessage$3,\n  postMessage: postMessage$3,\n  canBeUsed: canBeUsed$3,\n  type: type$3,\n  averageResponseTime: averageResponseTime$3,\n  microSeconds: microSeconds$3,\n  writeMessage,\n  getAllMessages,\n  cleanOldMessages,\n  getMessagesHigherThan,\n  getOldMessages\n};\n\n/**\n * A localStorage-only method which uses localstorage and its 'storage'-event\n * This does not work inside of webworkers because they have no access to locastorage\n * This is basically implemented to support IE9 or your grandmothers toaster.\n * @link https://caniuse.com/#feat=namevalue-storage\n * @link https://caniuse.com/#feat=indexeddb\n */\n\nconst microSeconds$2 = microSeconds$5;\nconst KEY_PREFIX$1 = 'pubkey.broadcastChannel-';\nconst type$2 = 'localstorage';\n\n/**\n * copied from crosstab\n * @link https://github.com/tejacques/crosstab/blob/master/src/crosstab.js#L32\n */\nfunction getLocalStorage() {\n  let localStorage;\n  if (typeof window === 'undefined') return null;\n  try {\n    localStorage = window.localStorage;\n    localStorage = window['ie8-eventlistener/storage'] || window.localStorage;\n  } catch (e) {\n    // New versions of Firefox throw a Security exception\n    // if cookies are disabled. See\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1028153\n  }\n  return localStorage;\n}\nfunction storageKey$1(channelName) {\n  return KEY_PREFIX$1 + channelName;\n}\n\n/**\n * writes the new message to the storage\n * and fires the storage-event so other readers can find it\n */\nfunction postMessage$2(channelState, messageJson) {\n  return new Promise(res => {\n    sleep().then(() => {\n      const key = storageKey$1(channelState.channelName);\n      const writeObj = {\n        token: randomToken(),\n        time: Date.now(),\n        data: messageJson,\n        uuid: channelState.uuid\n      };\n      const value = JSON.stringify(writeObj);\n      getLocalStorage().setItem(key, value);\n\n      /**\n       * StorageEvent does not fire the 'storage' event\n       * in the window that changes the state of the local storage.\n       * So we fire it manually\n       */\n      const ev = document.createEvent('Event');\n      ev.initEvent('storage', true, true);\n      ev.key = key;\n      ev.newValue = value;\n      window.dispatchEvent(ev);\n      res();\n    });\n  });\n}\nfunction addStorageEventListener(channelName, fn) {\n  const key = storageKey$1(channelName);\n  const listener = ev => {\n    if (ev.key === key) {\n      fn(JSON.parse(ev.newValue));\n    }\n  };\n  window.addEventListener('storage', listener);\n  return listener;\n}\nfunction removeStorageEventListener(listener) {\n  window.removeEventListener('storage', listener);\n}\nfunction create$2(channelName, options) {\n  options = fillOptionsWithDefaults(options);\n  if (!canBeUsed$2()) {\n    throw new Error('BroadcastChannel: localstorage cannot be used');\n  }\n  const uuid = randomToken();\n\n  /**\n   * eMIs\n   * contains all messages that have been emitted before\n   * @type {ObliviousSet}\n   */\n  const eMIs = new ObliviousSet(options.localstorage.removeTimeout);\n  const state = {\n    channelName,\n    uuid,\n    time: microSeconds$5(),\n    eMIs // emittedMessagesIds\n  };\n  state.listener = addStorageEventListener(channelName, msgObj => {\n    if (!state.messagesCallback) return; // no listener\n    if (msgObj.uuid === uuid) return; // own message\n    if (!msgObj.token || eMIs.has(msgObj.token)) return; // already emitted\n    if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return; // too old\n\n    eMIs.add(msgObj.token);\n    state.messagesCallback(msgObj.data);\n  });\n  return state;\n}\nfunction close$2(channelState) {\n  removeStorageEventListener(channelState.listener);\n}\nfunction onMessage$2(channelState, fn, time) {\n  channelState.messagesCallbackTime = time;\n  channelState.messagesCallback = fn;\n}\nfunction canBeUsed$2() {\n  const ls = getLocalStorage();\n  if (!ls) return false;\n  try {\n    const key = '__broadcastchannel_check';\n    ls.setItem(key, 'works');\n    ls.removeItem(key);\n  } catch (e) {\n    // Safari 10 in private mode will not allow write access to local\n    // storage and fail with a QuotaExceededError. See\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API#Private_Browsing_Incognito_modes\n    return false;\n  }\n  return true;\n}\nfunction averageResponseTime$2() {\n  const defaultTime = 120;\n  const userAgent = navigator.userAgent.toLowerCase();\n  if (userAgent.includes('safari') && !userAgent.includes('chrome')) {\n    // safari is much slower so this time is higher\n    return defaultTime * 2;\n  }\n  return defaultTime;\n}\nvar LocalstorageMethod = {\n  getLocalStorage,\n  create: create$2,\n  close: close$2,\n  onMessage: onMessage$2,\n  postMessage: postMessage$2,\n  canBeUsed: canBeUsed$2,\n  type: type$2,\n  averageResponseTime: averageResponseTime$2,\n  microSeconds: microSeconds$2,\n  storageKey: storageKey$1,\n  addStorageEventListener,\n  removeStorageEventListener\n};\n\n/**\n * A localStorage-only method which uses localstorage and its 'storage'-event\n * This does not work inside of webworkers because they have no access to locastorage\n * This is basically implemented to support IE9 or your grandmothers toaster.\n * @link https://caniuse.com/#feat=namevalue-storage\n * @link https://caniuse.com/#feat=indexeddb\n */\n\nconst microSeconds$1 = microSeconds$5;\nconst KEY_PREFIX = 'pubkey.broadcastChannel-';\nconst type$1 = 'server';\nlet SOCKET_CONN_INSTANCE = null;\n// used to decide to reconnect socket e.g. when socket connection is disconnected unexpectedly\nconst runningChannels = new Set();\nfunction storageKey(channelName) {\n  return KEY_PREFIX + channelName;\n}\n\n/**\n * writes the new message to the storage\n * and fires the storage-event so other readers can find it\n */\nfunction postMessage$1(channelState, messageJson) {\n  return new Promise((res, rej) => {\n    sleep().then(async () => {\n      const key = storageKey(channelState.channelName);\n      const channelEncPrivKey = keccak256(Buffer.from(key, 'utf8'));\n      const encData = await encryptData(channelEncPrivKey.toString('hex'), {\n        token: randomToken(),\n        time: Date.now(),\n        data: messageJson,\n        uuid: channelState.uuid\n      });\n      const body = {\n        sameOriginCheck: true,\n        sameIpCheck: true,\n        key: getPublic(channelEncPrivKey).toString('hex'),\n        data: encData,\n        signature: (await sign(channelEncPrivKey, keccak256(Buffer.from(encData, 'utf8')))).toString('hex')\n      };\n      if (channelState.timeout) body.timeout = channelState.timeout;\n      return fetch(channelState.serverUrl + '/channel/set', {\n        method: 'POST',\n        body: JSON.stringify(body),\n        headers: {\n          'Content-Type': 'application/json; charset=utf-8'\n        }\n      }).then(res).catch(rej);\n    });\n  });\n}\nfunction getSocketInstance(serverUrl) {\n  if (SOCKET_CONN_INSTANCE) {\n    return SOCKET_CONN_INSTANCE;\n  }\n  const SOCKET_CONN = io(serverUrl, {\n    transports: ['websocket', 'polling'],\n    // use WebSocket first, if available\n    withCredentials: true,\n    reconnectionDelayMax: 10000,\n    reconnectionAttempts: 10\n  });\n  SOCKET_CONN.on('connect_error', err => {\n    // revert to classic upgrade\n    SOCKET_CONN.io.opts.transports = ['polling', 'websocket'];\n    log.error('connect error', err);\n  });\n  SOCKET_CONN.on('connect', async () => {\n    const {\n      engine\n    } = SOCKET_CONN.io;\n    log.debug('initially connected to', engine.transport.name); // in most cases, prints \"polling\"\n    engine.once('upgrade', () => {\n      // called when the transport is upgraded (i.e. from HTTP long-polling to WebSocket)\n      log.debug('upgraded', engine.transport.name); // in most cases, prints \"websocket\"\n    });\n    engine.once('close', reason => {\n      // called when the underlying connection is closed\n      log.debug('connection closed', reason);\n    });\n  });\n  SOCKET_CONN.on('error', err => {\n    log.error('socket errored', err);\n    SOCKET_CONN.disconnect();\n  });\n  SOCKET_CONN_INSTANCE = SOCKET_CONN;\n  return SOCKET_CONN;\n}\nfunction setupSocketConnection(serverUrl, channelState, fn) {\n  const socketConn = getSocketInstance(serverUrl);\n  const key = storageKey(channelState.channelName);\n  const channelEncPrivKey = keccak256(Buffer.from(key, 'utf8'));\n  const channelPubKey = getPublic(channelEncPrivKey).toString('hex');\n  if (socketConn.connected) {\n    socketConn.emit('check_auth_status', channelPubKey, {\n      sameOriginCheck: true,\n      sameIpCheck: true\n    });\n  } else {\n    socketConn.once('connect', () => {\n      log.debug('connected with socket');\n      socketConn.emit('check_auth_status', channelPubKey, {\n        sameOriginCheck: true,\n        sameIpCheck: true\n      });\n    });\n  }\n  const reconnect = () => {\n    socketConn.once('connect', async () => {\n      if (runningChannels.has(channelState.channelName)) {\n        socketConn.emit('check_auth_status', channelPubKey, {\n          sameOriginCheck: true,\n          sameIpCheck: true\n        });\n      }\n    });\n  };\n  const visibilityListener = () => {\n    // if channel is closed, then remove the listener.\n    if (!socketConn || !runningChannels.has(channelState.channelName)) {\n      document.removeEventListener('visibilitychange', visibilityListener);\n      return;\n    }\n    // if not connected, then wait for connection and ping server for latest msg.\n    if (!socketConn.connected && document.visibilityState === 'visible') {\n      reconnect();\n    }\n  };\n  const listener = async ev => {\n    try {\n      const decData = await decryptData(channelEncPrivKey.toString('hex'), ev);\n      log.info(decData);\n      fn(decData);\n    } catch (error) {\n      log.error(error);\n    }\n  };\n  socketConn.on('disconnect', () => {\n    log.debug('socket disconnected');\n    if (runningChannels.has(channelState.channelName)) {\n      log.error('socket disconnected unexpectedly, reconnecting socket');\n      reconnect();\n    }\n  });\n  socketConn.on(`${channelPubKey}_success`, listener);\n  if (typeof document !== 'undefined') document.addEventListener('visibilitychange', visibilityListener);\n  return socketConn;\n}\nfunction create$1(channelName, options) {\n  options = fillOptionsWithDefaults(options);\n  const uuid = randomToken();\n\n  /**\n   * eMIs\n   * contains all messages that have been emitted before\n   * @type {ObliviousSet}\n   */\n  const eMIs = new ObliviousSet(options.server.removeTimeout);\n  const state = {\n    channelName,\n    uuid,\n    eMIs,\n    // emittedMessagesIds\n    serverUrl: options.server.url,\n    time: microSeconds$5()\n  };\n  if (options.server.timeout) state.timeout = options.server.timeout;\n  setupSocketConnection(options.server.url, state, msgObj => {\n    if (!state.messagesCallback) return; // no listener\n    if (msgObj.uuid === state.uuid) return; // own message\n    if (!msgObj.token || state.eMIs.has(msgObj.token)) return; // already emitted\n    // if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return; // too old\n\n    state.eMIs.add(msgObj.token);\n    state.messagesCallback(msgObj.data);\n  });\n  runningChannels.add(channelName);\n  return state;\n}\nfunction close$1(channelState) {\n  runningChannels.delete(channelState.channelName);\n  // give 2 sec for all msgs which are in transit to be consumed\n  // by receiver.\n  // window.setTimeout(() => {\n  //     removeStorageEventListener(channelState);\n  //     SOCKET_CONN_INSTANCE = null;\n  // }, 1000);\n}\nfunction onMessage$1(channelState, fn, time) {\n  channelState.messagesCallbackTime = time;\n  channelState.messagesCallback = fn;\n}\nfunction canBeUsed$1() {\n  return true;\n}\nfunction averageResponseTime$1() {\n  const defaultTime = 500;\n  // TODO: Maybe increase it based on operation\n  return defaultTime;\n}\nvar ServerMethod = {\n  create: create$1,\n  close: close$1,\n  onMessage: onMessage$1,\n  postMessage: postMessage$1,\n  canBeUsed: canBeUsed$1,\n  type: type$1,\n  averageResponseTime: averageResponseTime$1,\n  microSeconds: microSeconds$1\n};\nconst microSeconds = microSeconds$5;\nconst type = 'simulate';\nconst SIMULATE_CHANNELS = new Set();\nconst SIMULATE_DELAY_TIME = 5;\nfunction create(channelName) {\n  const state = {\n    time: microSeconds$5(),\n    name: channelName,\n    messagesCallback: null\n  };\n  SIMULATE_CHANNELS.add(state);\n  return state;\n}\nfunction close(channelState) {\n  SIMULATE_CHANNELS.delete(channelState);\n}\nfunction postMessage(channelState, messageJson) {\n  return new Promise(res => setTimeout(() => {\n    const channelArray = Array.from(SIMULATE_CHANNELS);\n    channelArray.forEach(channel => {\n      if (channel.name === channelState.name &&\n      // has same name\n      channel !== channelState &&\n      // not own channel\n      !!channel.messagesCallback &&\n      // has subscribers\n      channel.time < messageJson.time // channel not created after postMessage() call\n      ) {\n        channel.messagesCallback(messageJson);\n      }\n    });\n    res();\n  }, SIMULATE_DELAY_TIME));\n}\nfunction onMessage(channelState, fn) {\n  channelState.messagesCallback = fn;\n}\nfunction canBeUsed() {\n  return true;\n}\nfunction averageResponseTime() {\n  return SIMULATE_DELAY_TIME;\n}\nvar SimulateMethod = {\n  create,\n  close,\n  onMessage,\n  postMessage,\n  canBeUsed,\n  type,\n  averageResponseTime,\n  microSeconds\n};\n\n// order is important\nconst METHODS = [NativeMethod,\n// fastest\nIndexeDbMethod, LocalstorageMethod, ServerMethod];\nfunction chooseMethod(options) {\n  let chooseMethods = [].concat(options.methods, METHODS).filter(Boolean);\n\n  // directly chosen\n  if (options.type) {\n    if (options.type === 'simulate') {\n      // only use simulate-method if directly chosen\n      return SimulateMethod;\n    }\n    const ret = chooseMethods.find(m => m.type === options.type);\n    if (!ret) throw new Error('method-type ' + options.type + ' not found');else return ret;\n  }\n\n  /**\n   * if no webworker support is needed,\n   * remove idb from the list so that localstorage is been chosen\n   */\n  if (!options.webWorkerSupport) {\n    chooseMethods = chooseMethods.filter(m => m.type !== 'idb');\n  }\n  const useMethod = chooseMethods.find(method => method.canBeUsed(options));\n  if (!useMethod) throw new Error(`No useable method found in ${JSON.stringify(METHODS.map(m => m.type))}`);else return useMethod;\n}\n\n/**\n * Contains all open channels,\n * used in tests to ensure everything is closed.\n */\nconst OPEN_BROADCAST_CHANNELS = new Set();\nlet lastId = 0;\nconst BroadcastChannel$1 = function (name, options) {\n  // identifier of the channel to debug stuff\n  this.id = lastId++;\n  OPEN_BROADCAST_CHANNELS.add(this);\n  this.name = name;\n  if (ENFORCED_OPTIONS) {\n    options = ENFORCED_OPTIONS;\n  }\n  this.options = fillOptionsWithDefaults(options);\n  this.method = chooseMethod(this.options);\n\n  // isListening\n  this._iL = false;\n\n  /**\n   * _onMessageListener\n   * setting onmessage twice,\n   * will overwrite the first listener\n   */\n  this._onML = null;\n\n  /**\n   * _addEventListeners\n   */\n  this._addEL = {\n    message: [],\n    internal: []\n  };\n\n  /**\n   * Unsend message promises\n   * where the sending is still in progress\n   * @type {Set<Promise>}\n   */\n  this._uMP = new Set();\n\n  /**\n   * _beforeClose\n   * array of promises that will be awaited\n   * before the channel is closed\n   */\n  this._befC = [];\n\n  /**\n   * _preparePromise\n   */\n  this._prepP = null;\n  _prepareChannel(this);\n};\n\n// STATICS\n\n/**\n * used to identify if someone overwrites\n * window.BroadcastChannel with this\n * See methods/native.js\n */\nBroadcastChannel$1._pubkey = true;\n\n/**\n * if set, this method is enforced,\n * no mather what the options are\n */\nlet ENFORCED_OPTIONS;\nfunction enforceOptions(options) {\n  ENFORCED_OPTIONS = options;\n}\n\n// PROTOTYPE\nBroadcastChannel$1.prototype = {\n  postMessage(msg) {\n    if (this.closed) {\n      throw new Error('BroadcastChannel.postMessage(): ' + 'Cannot post message after channel has closed ' +\n      /**\n       * In the past when this error appeared, it was realy hard to debug.\n       * So now we log the msg together with the error so it at least\n       * gives some clue about where in your application this happens.\n       */\n      JSON.stringify(msg));\n    }\n    return _post(this, 'message', msg);\n  },\n  postInternal(msg) {\n    return _post(this, 'internal', msg);\n  },\n  set onmessage(fn) {\n    const time = this.method.microSeconds();\n    const listenObj = {\n      time,\n      fn\n    };\n    _removeListenerObject(this, 'message', this._onML);\n    if (fn && typeof fn === 'function') {\n      this._onML = listenObj;\n      _addListenerObject(this, 'message', listenObj);\n    } else {\n      this._onML = null;\n    }\n  },\n  addEventListener(type, fn) {\n    const time = this.method.microSeconds();\n    const listenObj = {\n      time,\n      fn\n    };\n    _addListenerObject(this, type, listenObj);\n  },\n  removeEventListener(type, fn) {\n    const obj = this._addEL[type].find(obj => obj.fn === fn);\n    _removeListenerObject(this, type, obj);\n  },\n  close() {\n    if (this.closed) {\n      return;\n    }\n    OPEN_BROADCAST_CHANNELS.delete(this);\n    this.closed = true;\n    const awaitPrepare = this._prepP ? this._prepP : PROMISE_RESOLVED_VOID;\n    this._onML = null;\n    this._addEL.message = [];\n    return awaitPrepare\n    // wait until all current sending are processed\n    .then(() => Promise.all(Array.from(this._uMP)))\n    // run before-close hooks\n    .then(() => Promise.all(this._befC.map(fn => fn())))\n    // close the channel\n    .then(() => this.method.close(this._state));\n  },\n  get type() {\n    return this.method.type;\n  },\n  get isClosed() {\n    return this.closed;\n  }\n};\n\n/**\n * Post a message over the channel\n * @returns {Promise} that resolved when the message sending is done\n */\nfunction _post(broadcastChannel, type, msg) {\n  const time = broadcastChannel.method.microSeconds();\n  const msgObj = {\n    time,\n    type,\n    data: msg\n  };\n  const awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : PROMISE_RESOLVED_VOID;\n  return awaitPrepare.then(() => {\n    const sendPromise = broadcastChannel.method.postMessage(broadcastChannel._state, msgObj);\n\n    // add/remove to unsend messages list\n    broadcastChannel._uMP.add(sendPromise);\n    sendPromise.catch().then(() => broadcastChannel._uMP.delete(sendPromise));\n    return sendPromise;\n  });\n}\nfunction _prepareChannel(channel) {\n  const maybePromise = channel.method.create(channel.name, channel.options);\n  if (isPromise(maybePromise)) {\n    channel._prepP = maybePromise;\n    maybePromise.then(s => {\n      // used in tests to simulate slow runtime\n      /*if (channel.options.prepareDelay) {\n           await new Promise(res => setTimeout(res, this.options.prepareDelay));\n      }*/\n      channel._state = s;\n    });\n  } else {\n    channel._state = maybePromise;\n  }\n}\nfunction _hasMessageListeners(channel) {\n  if (channel._addEL.message.length > 0) return true;\n  if (channel._addEL.internal.length > 0) return true;\n  return false;\n}\nfunction _addListenerObject(channel, type, obj) {\n  channel._addEL[type].push(obj);\n  _startListening(channel);\n}\nfunction _removeListenerObject(channel, type, obj) {\n  channel._addEL[type] = channel._addEL[type].filter(o => o !== obj);\n  _stopListening(channel);\n}\nfunction _startListening(channel) {\n  if (!channel._iL && _hasMessageListeners(channel)) {\n    // someone is listening, start subscribing\n\n    const listenerFn = msgObj => {\n      channel._addEL[msgObj.type].forEach(listenerObject => {\n        /**\n         * Getting the current time in JavaScript has no good precision.\n         * So instead of only listening to events that happend 'after' the listener\n         * was added, we also listen to events that happended 100ms before it.\n         * This ensures that when another process, like a WebWorker, sends events\n         * we do not miss them out because their timestamp is a bit off compared to the main process.\n         * Not doing this would make messages missing when we send data directly after subscribing and awaiting a response.\n         * @link https://johnresig.com/blog/accuracy-of-javascript-time/\n         */\n        // const hundredMsInMicro = 100 * 1000;\n        // const minMessageTime = listenerObject.time - hundredMsInMicro;\n\n        if (msgObj.time >= listenerObject.time) {\n          listenerObject.fn(msgObj.data);\n        } else if (channel.method.type === 'server') {\n          // server msg might lag based on connection.\n          listenerObject.fn(msgObj.data);\n        }\n      });\n    };\n    const time = channel.method.microSeconds();\n    if (channel._prepP) {\n      channel._prepP.then(() => {\n        channel._iL = true;\n        channel.method.onMessage(channel._state, listenerFn, time);\n      });\n    } else {\n      channel._iL = true;\n      channel.method.onMessage(channel._state, listenerFn, time);\n    }\n  }\n}\nfunction _stopListening(channel) {\n  if (channel._iL && !_hasMessageListeners(channel)) {\n    // noone is listening, stop subscribing\n    channel._iL = false;\n    const time = channel.method.microSeconds();\n    channel.method.onMessage(channel._state, null, time);\n  }\n}\nexport { BroadcastChannel$1 as BroadcastChannel, IndexeDbMethod as IndexedDbMethod, LocalstorageMethod as LocalStorageMethod, NativeMethod, OPEN_BROADCAST_CHANNELS, ServerMethod, chooseMethod, enforceOptions };","map":{"version":3,"names":["loglevel","ObliviousSet","io","getPublic","sign","keccak256","encryptData","decryptData","isPromise","obj","then","Promise","resolve","PROMISE_RESOLVED_VOID","sleep","time","resolveWith","res","setTimeout","randomInt","min","max","Math","floor","random","randomToken","toString","substring","lastMs","microSeconds$5","ret","Date","now","log","getLogger","setLevel","microSeconds$4","type$4","create$4","channelName","state","messagesCallback","bc","BroadcastChannel","subFns","onmessage","msg","data","close$4","channelState","close","postMessage$4","messageJson","postMessage","err","reject","onMessage$4","fn","canBeUsed$4","window","_pubkey","Error","averageResponseTime$4","NativeMethod","create","onMessage","canBeUsed","type","averageResponseTime","microSeconds","fillOptionsWithDefaults","originalOptions","arguments","length","undefined","options","JSON","parse","stringify","webWorkerSupport","idb","ttl","fallbackInterval","onclose","localstorage","removeTimeout","server","url","methods","microSeconds$3","DB_PREFIX","OBJECT_STORE_ID","TRANSACTION_SETTINGS","durability","type$3","getIdb","indexedDB","mozIndexedDB","webkitIndexedDB","msIndexedDB","commitIndexedDBTransaction","tx","commit","createDatabase","IndexedDB","dbName","openRequest","open","onupgradeneeded","ev","db","target","result","createObjectStore","keyPath","autoIncrement","dbPromise","rej","onerror","onsuccess","writeMessage","readerUuid","writeObject","uuid","transaction","oncomplete","objectStore","add","getAllMessages","openCursor","cursor","push","value","continue","getMessagesHigherThan","lastCursorId","keyRangeValue","IDBKeyRange","bound","Infinity","getAll","getAllRequest","e","openCursorRequest","id","removeMessagesById","ids","all","map","deleteRequest","delete","getOldMessages","olderThen","msgObk","cleanOldMessages","tooOld","create$3","closed","eMIs","writeBlockPromise","readQueuePromises","_readLoop","readNewMessages","_filterMessage","msgObj","has","messagesCallbackTime","newerMessages","useMessages","filter","sort","msgObjA","msgObjB","forEach","close$3","postMessage$3","onMessage$3","canBeUsed$3","averageResponseTime$3","IndexeDbMethod","microSeconds$2","KEY_PREFIX$1","type$2","getLocalStorage","localStorage","storageKey$1","postMessage$2","key","writeObj","token","setItem","document","createEvent","initEvent","newValue","dispatchEvent","addStorageEventListener","listener","addEventListener","removeStorageEventListener","removeEventListener","create$2","canBeUsed$2","close$2","onMessage$2","ls","removeItem","averageResponseTime$2","defaultTime","userAgent","navigator","toLowerCase","includes","LocalstorageMethod","storageKey","microSeconds$1","KEY_PREFIX","type$1","SOCKET_CONN_INSTANCE","runningChannels","Set","postMessage$1","channelEncPrivKey","Buffer","from","encData","body","sameOriginCheck","sameIpCheck","signature","timeout","fetch","serverUrl","method","headers","catch","getSocketInstance","SOCKET_CONN","transports","withCredentials","reconnectionDelayMax","reconnectionAttempts","on","opts","error","engine","debug","transport","name","once","reason","disconnect","setupSocketConnection","socketConn","channelPubKey","connected","emit","reconnect","visibilityListener","visibilityState","decData","info","create$1","close$1","onMessage$1","canBeUsed$1","averageResponseTime$1","ServerMethod","SIMULATE_CHANNELS","SIMULATE_DELAY_TIME","channelArray","Array","channel","SimulateMethod","METHODS","chooseMethod","chooseMethods","concat","Boolean","find","m","useMethod","OPEN_BROADCAST_CHANNELS","lastId","BroadcastChannel$1","ENFORCED_OPTIONS","_iL","_onML","_addEL","message","internal","_uMP","_befC","_prepP","_prepareChannel","enforceOptions","prototype","_post","postInternal","listenObj","_removeListenerObject","_addListenerObject","awaitPrepare","_state","isClosed","broadcastChannel","sendPromise","maybePromise","s","_hasMessageListeners","_startListening","o","_stopListening","listenerFn","listenerObject","IndexedDbMethod","LocalStorageMethod"],"sources":["C:/Users/yyash/Coding/solana-brkout/frontend/node_modules/@toruslabs/broadcast-channel/dist/broadcastChannel.esm.js"],"sourcesContent":["import loglevel from 'loglevel';\nimport { ObliviousSet } from 'oblivious-set';\nimport { io } from 'socket.io-client';\nimport { getPublic, sign } from '@toruslabs/eccrypto';\nimport { keccak256, encryptData, decryptData } from '@toruslabs/metadata-helpers';\n\n// import Bowser from 'bowser';\n\n/**\n * returns true if the given object is a promise\n */\nfunction isPromise(obj) {\n  if (obj && typeof obj.then === 'function') {\n    return true;\n  } else {\n    return false;\n  }\n}\nPromise.resolve(false);\nPromise.resolve(true);\nconst PROMISE_RESOLVED_VOID = Promise.resolve();\nfunction sleep(time, resolveWith) {\n  if (!time) time = 0;\n  return new Promise(res => setTimeout(() => res(resolveWith), time));\n}\nfunction randomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\n/**\n * https://stackoverflow.com/a/8084248\n */\nfunction randomToken() {\n  return Math.random().toString(36).substring(2);\n}\nlet lastMs = 0;\n\n/**\n * returns the current time in micro-seconds,\n * WARNING: This is a pseudo-function\n * Performance.now is not reliable in webworkers, so we just make sure to never return the same time.\n * This is enough in browsers, and this function will not be used in nodejs.\n * The main reason for this hack is to ensure that BroadcastChannel behaves equal to production when it is used in fast-running unit tests.\n */\nfunction microSeconds$5() {\n  let ret = Date.now() * 1000; // milliseconds to microseconds\n  if (ret <= lastMs) {\n    ret = lastMs + 1;\n  }\n  lastMs = ret;\n  return ret;\n}\n\n// the problem is only in iframes. we should default to server in case of iframes.\n// storage scoping is present in all browsers now\n// Safari and other browsers support native Broadcast channel now. It's in LS.\n// test here: https://pubkey.github.io/broadcast-channel/e2e.html?methodType=native\n// https://caniuse.com/broadcastchannel\n// export function are3PCSupported() {\n//     if (typeof navigator === 'undefined') return false;\n//     const browserInfo = Bowser.parse(navigator.userAgent);\n//     log.info(JSON.stringify(browserInfo), 'current browser info');\n\n//     let thirdPartyCookieSupport = true;\n//     // brave\n//     if (navigator.brave) {\n//         thirdPartyCookieSupport = false;\n//     }\n//     // All webkit & gecko engine instances use itp (intelligent tracking prevention -\n//     // https://webkit.org/tracking-prevention/#intelligent-tracking-prevention-itp)\n//     if (browserInfo.engine.name === Bowser.ENGINE_MAP.WebKit || browserInfo.engine.name === Bowser.ENGINE_MAP.Gecko) {\n//         thirdPartyCookieSupport = false;\n//     }\n\n//     return thirdPartyCookieSupport;\n// }\n\nconst log = loglevel.getLogger('broadcast-channel');\nlog.setLevel('error');\n\nconst microSeconds$4 = microSeconds$5;\nconst type$4 = 'native';\nfunction create$4(channelName) {\n  const state = {\n    time: microSeconds$5(),\n    messagesCallback: null,\n    bc: new BroadcastChannel(channelName),\n    subFns: [] // subscriberFunctions\n  };\n  state.bc.onmessage = msg => {\n    if (state.messagesCallback) {\n      state.messagesCallback(msg.data);\n    }\n  };\n  return state;\n}\nfunction close$4(channelState) {\n  channelState.bc.close();\n  channelState.subFns = [];\n}\nfunction postMessage$4(channelState, messageJson) {\n  try {\n    channelState.bc.postMessage(messageJson, false);\n    return PROMISE_RESOLVED_VOID;\n  } catch (err) {\n    return Promise.reject(err);\n  }\n}\nfunction onMessage$4(channelState, fn) {\n  channelState.messagesCallback = fn;\n}\nfunction canBeUsed$4() {\n  /**\n   * in the electron-renderer, isNode will be true even if we are in browser-context\n   * so we also check if window is undefined\n   */\n  if (typeof window === 'undefined') return false;\n  if (typeof BroadcastChannel === 'function') {\n    if (BroadcastChannel._pubkey) {\n      throw new Error('BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill');\n    }\n    return true;\n  } else return false;\n}\nfunction averageResponseTime$4() {\n  return 150;\n}\nvar NativeMethod = {\n  create: create$4,\n  close: close$4,\n  onMessage: onMessage$4,\n  postMessage: postMessage$4,\n  canBeUsed: canBeUsed$4,\n  type: type$4,\n  averageResponseTime: averageResponseTime$4,\n  microSeconds: microSeconds$4\n};\n\nfunction fillOptionsWithDefaults() {\n  let originalOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const options = JSON.parse(JSON.stringify(originalOptions));\n\n  // main\n  if (typeof options.webWorkerSupport === 'undefined') options.webWorkerSupport = true;\n\n  // indexed-db\n  if (!options.idb) options.idb = {};\n  //  after this time the messages get deleted\n  if (!options.idb.ttl) options.idb.ttl = 1000 * 45;\n  if (!options.idb.fallbackInterval) options.idb.fallbackInterval = 150;\n  //  handles abrupt db onclose events.\n  if (originalOptions.idb && typeof originalOptions.idb.onclose === 'function') options.idb.onclose = originalOptions.idb.onclose;\n\n  // localstorage\n  if (!options.localstorage) options.localstorage = {};\n  if (!options.localstorage.removeTimeout) options.localstorage.removeTimeout = 1000 * 60;\n\n  // server\n  if (!options.server) options.server = {};\n  if (!options.server.url) options.server.url = 'https://session.web3auth.io';\n  if (!options.server.removeTimeout) options.server.removeTimeout = 1000 * 60 * 5; // 5 minutes\n\n  // custom methods\n  if (originalOptions.methods) options.methods = originalOptions.methods;\n  return options;\n}\n\n/**\n * this method uses indexeddb to store the messages\n * There is currently no observerAPI for idb\n * @link https://github.com/w3c/IndexedDB/issues/51\n *\n * When working on this, ensure to use these performance optimizations:\n * @link https://rxdb.info/slow-indexeddb.html\n */\n\nconst microSeconds$3 = microSeconds$5;\nconst DB_PREFIX = 'pubkey.broadcast-channel-0-';\nconst OBJECT_STORE_ID = 'messages';\n\n/**\n * Use relaxed durability for faster performance on all transactions.\n * @link https://nolanlawson.com/2021/08/22/speeding-up-indexeddb-reads-and-writes/\n */\nconst TRANSACTION_SETTINGS = {\n  durability: 'relaxed'\n};\nconst type$3 = 'idb';\nfunction getIdb() {\n  if (typeof indexedDB !== 'undefined') return indexedDB;\n  if (typeof window !== 'undefined') {\n    if (typeof window.mozIndexedDB !== 'undefined') return window.mozIndexedDB;\n    if (typeof window.webkitIndexedDB !== 'undefined') return window.webkitIndexedDB;\n    if (typeof window.msIndexedDB !== 'undefined') return window.msIndexedDB;\n  }\n  return false;\n}\n\n/**\n * If possible, we should explicitly commit IndexedDB transactions\n * for better performance.\n * @link https://nolanlawson.com/2021/08/22/speeding-up-indexeddb-reads-and-writes/\n */\nfunction commitIndexedDBTransaction(tx) {\n  if (tx.commit) {\n    tx.commit();\n  }\n}\nfunction createDatabase(channelName) {\n  const IndexedDB = getIdb();\n\n  // create table\n  const dbName = DB_PREFIX + channelName;\n\n  /**\n   * All IndexedDB databases are opened without version\n   * because it is a bit faster, especially on firefox\n   * @link http://nparashuram.com/IndexedDB/perf/#Open%20Database%20with%20version\n   */\n  const openRequest = IndexedDB.open(dbName);\n  openRequest.onupgradeneeded = ev => {\n    const db = ev.target.result;\n    db.createObjectStore(OBJECT_STORE_ID, {\n      keyPath: 'id',\n      autoIncrement: true\n    });\n  };\n  const dbPromise = new Promise((res, rej) => {\n    openRequest.onerror = ev => rej(ev);\n    openRequest.onsuccess = () => {\n      res(openRequest.result);\n    };\n  });\n  return dbPromise;\n}\n\n/**\n * writes the new message to the database\n * so other readers can find it\n */\nfunction writeMessage(db, readerUuid, messageJson) {\n  const time = Date.now();\n  const writeObject = {\n    uuid: readerUuid,\n    time,\n    data: messageJson\n  };\n  const tx = db.transaction([OBJECT_STORE_ID], 'readwrite', TRANSACTION_SETTINGS);\n  return new Promise((res, rej) => {\n    tx.oncomplete = () => res();\n    tx.onerror = ev => rej(ev);\n    const objectStore = tx.objectStore(OBJECT_STORE_ID);\n    objectStore.add(writeObject);\n    commitIndexedDBTransaction(tx);\n  });\n}\nfunction getAllMessages(db) {\n  const tx = db.transaction(OBJECT_STORE_ID, 'readonly', TRANSACTION_SETTINGS);\n  const objectStore = tx.objectStore(OBJECT_STORE_ID);\n  const ret = [];\n  return new Promise(res => {\n    objectStore.openCursor().onsuccess = ev => {\n      const cursor = ev.target.result;\n      if (cursor) {\n        ret.push(cursor.value);\n        //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n        cursor.continue();\n      } else {\n        commitIndexedDBTransaction(tx);\n        res(ret);\n      }\n    };\n  });\n}\nfunction getMessagesHigherThan(db, lastCursorId) {\n  const tx = db.transaction(OBJECT_STORE_ID, 'readonly', TRANSACTION_SETTINGS);\n  const objectStore = tx.objectStore(OBJECT_STORE_ID);\n  const ret = [];\n  let keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);\n\n  /**\n   * Optimization shortcut,\n   * if getAll() can be used, do not use a cursor.\n   * @link https://rxdb.info/slow-indexeddb.html\n   */\n  if (objectStore.getAll) {\n    const getAllRequest = objectStore.getAll(keyRangeValue);\n    return new Promise((res, rej) => {\n      getAllRequest.onerror = err => rej(err);\n      getAllRequest.onsuccess = function (e) {\n        res(e.target.result);\n      };\n    });\n  }\n  function openCursor() {\n    // Occasionally Safari will fail on IDBKeyRange.bound, this\n    // catches that error, having it open the cursor to the first\n    // item. When it gets data it will advance to the desired key.\n    try {\n      keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);\n      return objectStore.openCursor(keyRangeValue);\n    } catch (e) {\n      return objectStore.openCursor();\n    }\n  }\n  return new Promise((res, rej) => {\n    const openCursorRequest = openCursor();\n    openCursorRequest.onerror = err => rej(err);\n    openCursorRequest.onsuccess = ev => {\n      const cursor = ev.target.result;\n      if (cursor) {\n        if (cursor.value.id < lastCursorId + 1) {\n          cursor.continue(lastCursorId + 1);\n        } else {\n          ret.push(cursor.value);\n          cursor.continue();\n        }\n      } else {\n        commitIndexedDBTransaction(tx);\n        res(ret);\n      }\n    };\n  });\n}\nfunction removeMessagesById(db, ids) {\n  const tx = db.transaction([OBJECT_STORE_ID], 'readwrite', TRANSACTION_SETTINGS);\n  const objectStore = tx.objectStore(OBJECT_STORE_ID);\n  return Promise.all(ids.map(id => {\n    const deleteRequest = objectStore.delete(id);\n    return new Promise(res => {\n      deleteRequest.onsuccess = () => res();\n    });\n  }));\n}\nfunction getOldMessages(db, ttl) {\n  const olderThen = Date.now() - ttl;\n  const tx = db.transaction(OBJECT_STORE_ID, 'readonly', TRANSACTION_SETTINGS);\n  const objectStore = tx.objectStore(OBJECT_STORE_ID);\n  const ret = [];\n  return new Promise(res => {\n    objectStore.openCursor().onsuccess = ev => {\n      const cursor = ev.target.result;\n      if (cursor) {\n        const msgObk = cursor.value;\n        if (msgObk.time < olderThen) {\n          ret.push(msgObk);\n          //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n          cursor.continue();\n        } else {\n          // no more old messages,\n          commitIndexedDBTransaction(tx);\n          res(ret);\n          return;\n        }\n      } else {\n        res(ret);\n      }\n    };\n  });\n}\nfunction cleanOldMessages(db, ttl) {\n  return getOldMessages(db, ttl).then(tooOld => {\n    return removeMessagesById(db, tooOld.map(msg => msg.id));\n  });\n}\nfunction create$3(channelName, options) {\n  options = fillOptionsWithDefaults(options);\n  return createDatabase(channelName).then(db => {\n    const state = {\n      closed: false,\n      lastCursorId: 0,\n      channelName,\n      options,\n      uuid: randomToken(),\n      /**\n       * emittedMessagesIds\n       * contains all messages that have been emitted before\n       * @type {ObliviousSet}\n       */\n      eMIs: new ObliviousSet(options.idb.ttl * 2),\n      // ensures we do not read messages in parrallel\n      writeBlockPromise: PROMISE_RESOLVED_VOID,\n      messagesCallback: null,\n      readQueuePromises: [],\n      db,\n      time: microSeconds$5()\n    };\n\n    /**\n     * Handle abrupt closes that do not originate from db.close().\n     * This could happen, for example, if the underlying storage is\n     * removed or if the user clears the database in the browser's\n     * history preferences.\n     */\n    db.onclose = function () {\n      state.closed = true;\n      if (options.idb.onclose) options.idb.onclose();\n    };\n\n    /**\n     * if service-workers are used,\n     * we have no 'storage'-event if they post a message,\n     * therefore we also have to set an interval\n     */\n    _readLoop(state);\n    return state;\n  });\n}\nfunction _readLoop(state) {\n  if (state.closed) return;\n  readNewMessages(state).then(() => sleep(state.options.idb.fallbackInterval)).then(() => _readLoop(state));\n}\nfunction _filterMessage(msgObj, state) {\n  if (msgObj.uuid === state.uuid) return false; // send by own\n  if (state.eMIs.has(msgObj.id)) return false; // already emitted\n  if (msgObj.data.time < state.messagesCallbackTime) return false; // older then onMessageCallback\n  return true;\n}\n\n/**\n * reads all new messages from the database and emits them\n */\nfunction readNewMessages(state) {\n  // channel already closed\n  if (state.closed) return PROMISE_RESOLVED_VOID;\n\n  // if no one is listening, we do not need to scan for new messages\n  if (!state.messagesCallback) return PROMISE_RESOLVED_VOID;\n  return getMessagesHigherThan(state.db, state.lastCursorId).then(newerMessages => {\n    const useMessages = newerMessages\n    /**\n     * there is a bug in iOS where the msgObj can be undefined some times\n     * so we filter them out\n     * @link https://github.com/pubkey/broadcast-channel/issues/19\n     */.filter(msgObj => !!msgObj).map(msgObj => {\n      if (msgObj.id > state.lastCursorId) {\n        state.lastCursorId = msgObj.id;\n      }\n      return msgObj;\n    }).filter(msgObj => _filterMessage(msgObj, state)).sort((msgObjA, msgObjB) => msgObjA.time - msgObjB.time); // sort by time\n    useMessages.forEach(msgObj => {\n      if (state.messagesCallback) {\n        state.eMIs.add(msgObj.id);\n        state.messagesCallback(msgObj.data);\n      }\n    });\n    return PROMISE_RESOLVED_VOID;\n  });\n}\nfunction close$3(channelState) {\n  channelState.closed = true;\n  channelState.db.close();\n}\nfunction postMessage$3(channelState, messageJson) {\n  channelState.writeBlockPromise = channelState.writeBlockPromise.then(() => writeMessage(channelState.db, channelState.uuid, messageJson)).then(() => {\n    if (randomInt(0, 10) === 0) {\n      /* await (do not await) */\n      cleanOldMessages(channelState.db, channelState.options.idb.ttl);\n    }\n  });\n  return channelState.writeBlockPromise;\n}\nfunction onMessage$3(channelState, fn, time) {\n  channelState.messagesCallbackTime = time;\n  channelState.messagesCallback = fn;\n  readNewMessages(channelState);\n}\nfunction canBeUsed$3() {\n  const idb = getIdb();\n  if (!idb) return false;\n  return true;\n}\nfunction averageResponseTime$3(options) {\n  return options.idb.fallbackInterval * 2;\n}\nvar IndexeDbMethod = {\n  getIdb,\n  createDatabase,\n  create: create$3,\n  close: close$3,\n  onMessage: onMessage$3,\n  postMessage: postMessage$3,\n  canBeUsed: canBeUsed$3,\n  type: type$3,\n  averageResponseTime: averageResponseTime$3,\n  microSeconds: microSeconds$3,\n  writeMessage,\n  getAllMessages,\n  cleanOldMessages,\n  getMessagesHigherThan,\n  getOldMessages\n};\n\n/**\n * A localStorage-only method which uses localstorage and its 'storage'-event\n * This does not work inside of webworkers because they have no access to locastorage\n * This is basically implemented to support IE9 or your grandmothers toaster.\n * @link https://caniuse.com/#feat=namevalue-storage\n * @link https://caniuse.com/#feat=indexeddb\n */\n\nconst microSeconds$2 = microSeconds$5;\nconst KEY_PREFIX$1 = 'pubkey.broadcastChannel-';\nconst type$2 = 'localstorage';\n\n/**\n * copied from crosstab\n * @link https://github.com/tejacques/crosstab/blob/master/src/crosstab.js#L32\n */\nfunction getLocalStorage() {\n  let localStorage;\n  if (typeof window === 'undefined') return null;\n  try {\n    localStorage = window.localStorage;\n    localStorage = window['ie8-eventlistener/storage'] || window.localStorage;\n  } catch (e) {\n    // New versions of Firefox throw a Security exception\n    // if cookies are disabled. See\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1028153\n  }\n  return localStorage;\n}\nfunction storageKey$1(channelName) {\n  return KEY_PREFIX$1 + channelName;\n}\n\n/**\n * writes the new message to the storage\n * and fires the storage-event so other readers can find it\n */\nfunction postMessage$2(channelState, messageJson) {\n  return new Promise(res => {\n    sleep().then(() => {\n      const key = storageKey$1(channelState.channelName);\n      const writeObj = {\n        token: randomToken(),\n        time: Date.now(),\n        data: messageJson,\n        uuid: channelState.uuid\n      };\n      const value = JSON.stringify(writeObj);\n      getLocalStorage().setItem(key, value);\n\n      /**\n       * StorageEvent does not fire the 'storage' event\n       * in the window that changes the state of the local storage.\n       * So we fire it manually\n       */\n      const ev = document.createEvent('Event');\n      ev.initEvent('storage', true, true);\n      ev.key = key;\n      ev.newValue = value;\n      window.dispatchEvent(ev);\n      res();\n    });\n  });\n}\nfunction addStorageEventListener(channelName, fn) {\n  const key = storageKey$1(channelName);\n  const listener = ev => {\n    if (ev.key === key) {\n      fn(JSON.parse(ev.newValue));\n    }\n  };\n  window.addEventListener('storage', listener);\n  return listener;\n}\nfunction removeStorageEventListener(listener) {\n  window.removeEventListener('storage', listener);\n}\nfunction create$2(channelName, options) {\n  options = fillOptionsWithDefaults(options);\n  if (!canBeUsed$2()) {\n    throw new Error('BroadcastChannel: localstorage cannot be used');\n  }\n  const uuid = randomToken();\n\n  /**\n   * eMIs\n   * contains all messages that have been emitted before\n   * @type {ObliviousSet}\n   */\n  const eMIs = new ObliviousSet(options.localstorage.removeTimeout);\n  const state = {\n    channelName,\n    uuid,\n    time: microSeconds$5(),\n    eMIs // emittedMessagesIds\n  };\n  state.listener = addStorageEventListener(channelName, msgObj => {\n    if (!state.messagesCallback) return; // no listener\n    if (msgObj.uuid === uuid) return; // own message\n    if (!msgObj.token || eMIs.has(msgObj.token)) return; // already emitted\n    if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return; // too old\n\n    eMIs.add(msgObj.token);\n    state.messagesCallback(msgObj.data);\n  });\n  return state;\n}\nfunction close$2(channelState) {\n  removeStorageEventListener(channelState.listener);\n}\nfunction onMessage$2(channelState, fn, time) {\n  channelState.messagesCallbackTime = time;\n  channelState.messagesCallback = fn;\n}\nfunction canBeUsed$2() {\n  const ls = getLocalStorage();\n  if (!ls) return false;\n  try {\n    const key = '__broadcastchannel_check';\n    ls.setItem(key, 'works');\n    ls.removeItem(key);\n  } catch (e) {\n    // Safari 10 in private mode will not allow write access to local\n    // storage and fail with a QuotaExceededError. See\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API#Private_Browsing_Incognito_modes\n    return false;\n  }\n  return true;\n}\nfunction averageResponseTime$2() {\n  const defaultTime = 120;\n  const userAgent = navigator.userAgent.toLowerCase();\n  if (userAgent.includes('safari') && !userAgent.includes('chrome')) {\n    // safari is much slower so this time is higher\n    return defaultTime * 2;\n  }\n  return defaultTime;\n}\nvar LocalstorageMethod = {\n  getLocalStorage,\n  create: create$2,\n  close: close$2,\n  onMessage: onMessage$2,\n  postMessage: postMessage$2,\n  canBeUsed: canBeUsed$2,\n  type: type$2,\n  averageResponseTime: averageResponseTime$2,\n  microSeconds: microSeconds$2,\n  storageKey: storageKey$1,\n  addStorageEventListener,\n  removeStorageEventListener\n};\n\n/**\n * A localStorage-only method which uses localstorage and its 'storage'-event\n * This does not work inside of webworkers because they have no access to locastorage\n * This is basically implemented to support IE9 or your grandmothers toaster.\n * @link https://caniuse.com/#feat=namevalue-storage\n * @link https://caniuse.com/#feat=indexeddb\n */\n\nconst microSeconds$1 = microSeconds$5;\nconst KEY_PREFIX = 'pubkey.broadcastChannel-';\nconst type$1 = 'server';\nlet SOCKET_CONN_INSTANCE = null;\n// used to decide to reconnect socket e.g. when socket connection is disconnected unexpectedly\nconst runningChannels = new Set();\nfunction storageKey(channelName) {\n  return KEY_PREFIX + channelName;\n}\n\n/**\n * writes the new message to the storage\n * and fires the storage-event so other readers can find it\n */\nfunction postMessage$1(channelState, messageJson) {\n  return new Promise((res, rej) => {\n    sleep().then(async () => {\n      const key = storageKey(channelState.channelName);\n      const channelEncPrivKey = keccak256(Buffer.from(key, 'utf8'));\n      const encData = await encryptData(channelEncPrivKey.toString('hex'), {\n        token: randomToken(),\n        time: Date.now(),\n        data: messageJson,\n        uuid: channelState.uuid\n      });\n      const body = {\n        sameOriginCheck: true,\n        sameIpCheck: true,\n        key: getPublic(channelEncPrivKey).toString('hex'),\n        data: encData,\n        signature: (await sign(channelEncPrivKey, keccak256(Buffer.from(encData, 'utf8')))).toString('hex')\n      };\n      if (channelState.timeout) body.timeout = channelState.timeout;\n      return fetch(channelState.serverUrl + '/channel/set', {\n        method: 'POST',\n        body: JSON.stringify(body),\n        headers: {\n          'Content-Type': 'application/json; charset=utf-8'\n        }\n      }).then(res).catch(rej);\n    });\n  });\n}\nfunction getSocketInstance(serverUrl) {\n  if (SOCKET_CONN_INSTANCE) {\n    return SOCKET_CONN_INSTANCE;\n  }\n  const SOCKET_CONN = io(serverUrl, {\n    transports: ['websocket', 'polling'],\n    // use WebSocket first, if available\n    withCredentials: true,\n    reconnectionDelayMax: 10000,\n    reconnectionAttempts: 10\n  });\n  SOCKET_CONN.on('connect_error', err => {\n    // revert to classic upgrade\n    SOCKET_CONN.io.opts.transports = ['polling', 'websocket'];\n    log.error('connect error', err);\n  });\n  SOCKET_CONN.on('connect', async () => {\n    const {\n      engine\n    } = SOCKET_CONN.io;\n    log.debug('initially connected to', engine.transport.name); // in most cases, prints \"polling\"\n    engine.once('upgrade', () => {\n      // called when the transport is upgraded (i.e. from HTTP long-polling to WebSocket)\n      log.debug('upgraded', engine.transport.name); // in most cases, prints \"websocket\"\n    });\n    engine.once('close', reason => {\n      // called when the underlying connection is closed\n      log.debug('connection closed', reason);\n    });\n  });\n  SOCKET_CONN.on('error', err => {\n    log.error('socket errored', err);\n    SOCKET_CONN.disconnect();\n  });\n  SOCKET_CONN_INSTANCE = SOCKET_CONN;\n  return SOCKET_CONN;\n}\nfunction setupSocketConnection(serverUrl, channelState, fn) {\n  const socketConn = getSocketInstance(serverUrl);\n  const key = storageKey(channelState.channelName);\n  const channelEncPrivKey = keccak256(Buffer.from(key, 'utf8'));\n  const channelPubKey = getPublic(channelEncPrivKey).toString('hex');\n  if (socketConn.connected) {\n    socketConn.emit('check_auth_status', channelPubKey, {\n      sameOriginCheck: true,\n      sameIpCheck: true\n    });\n  } else {\n    socketConn.once('connect', () => {\n      log.debug('connected with socket');\n      socketConn.emit('check_auth_status', channelPubKey, {\n        sameOriginCheck: true,\n        sameIpCheck: true\n      });\n    });\n  }\n  const reconnect = () => {\n    socketConn.once('connect', async () => {\n      if (runningChannels.has(channelState.channelName)) {\n        socketConn.emit('check_auth_status', channelPubKey, {\n          sameOriginCheck: true,\n          sameIpCheck: true\n        });\n      }\n    });\n  };\n  const visibilityListener = () => {\n    // if channel is closed, then remove the listener.\n    if (!socketConn || !runningChannels.has(channelState.channelName)) {\n      document.removeEventListener('visibilitychange', visibilityListener);\n      return;\n    }\n    // if not connected, then wait for connection and ping server for latest msg.\n    if (!socketConn.connected && document.visibilityState === 'visible') {\n      reconnect();\n    }\n  };\n  const listener = async ev => {\n    try {\n      const decData = await decryptData(channelEncPrivKey.toString('hex'), ev);\n      log.info(decData);\n      fn(decData);\n    } catch (error) {\n      log.error(error);\n    }\n  };\n  socketConn.on('disconnect', () => {\n    log.debug('socket disconnected');\n    if (runningChannels.has(channelState.channelName)) {\n      log.error('socket disconnected unexpectedly, reconnecting socket');\n      reconnect();\n    }\n  });\n  socketConn.on(`${channelPubKey}_success`, listener);\n  if (typeof document !== 'undefined') document.addEventListener('visibilitychange', visibilityListener);\n  return socketConn;\n}\nfunction create$1(channelName, options) {\n  options = fillOptionsWithDefaults(options);\n  const uuid = randomToken();\n\n  /**\n   * eMIs\n   * contains all messages that have been emitted before\n   * @type {ObliviousSet}\n   */\n  const eMIs = new ObliviousSet(options.server.removeTimeout);\n  const state = {\n    channelName,\n    uuid,\n    eMIs,\n    // emittedMessagesIds\n    serverUrl: options.server.url,\n    time: microSeconds$5()\n  };\n  if (options.server.timeout) state.timeout = options.server.timeout;\n  setupSocketConnection(options.server.url, state, msgObj => {\n    if (!state.messagesCallback) return; // no listener\n    if (msgObj.uuid === state.uuid) return; // own message\n    if (!msgObj.token || state.eMIs.has(msgObj.token)) return; // already emitted\n    // if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return; // too old\n\n    state.eMIs.add(msgObj.token);\n    state.messagesCallback(msgObj.data);\n  });\n  runningChannels.add(channelName);\n  return state;\n}\nfunction close$1(channelState) {\n  runningChannels.delete(channelState.channelName);\n  // give 2 sec for all msgs which are in transit to be consumed\n  // by receiver.\n  // window.setTimeout(() => {\n  //     removeStorageEventListener(channelState);\n  //     SOCKET_CONN_INSTANCE = null;\n  // }, 1000);\n}\nfunction onMessage$1(channelState, fn, time) {\n  channelState.messagesCallbackTime = time;\n  channelState.messagesCallback = fn;\n}\nfunction canBeUsed$1() {\n  return true;\n}\nfunction averageResponseTime$1() {\n  const defaultTime = 500;\n  // TODO: Maybe increase it based on operation\n  return defaultTime;\n}\nvar ServerMethod = {\n  create: create$1,\n  close: close$1,\n  onMessage: onMessage$1,\n  postMessage: postMessage$1,\n  canBeUsed: canBeUsed$1,\n  type: type$1,\n  averageResponseTime: averageResponseTime$1,\n  microSeconds: microSeconds$1\n};\n\nconst microSeconds = microSeconds$5;\nconst type = 'simulate';\nconst SIMULATE_CHANNELS = new Set();\nconst SIMULATE_DELAY_TIME = 5;\nfunction create(channelName) {\n  const state = {\n    time: microSeconds$5(),\n    name: channelName,\n    messagesCallback: null\n  };\n  SIMULATE_CHANNELS.add(state);\n  return state;\n}\nfunction close(channelState) {\n  SIMULATE_CHANNELS.delete(channelState);\n}\nfunction postMessage(channelState, messageJson) {\n  return new Promise(res => setTimeout(() => {\n    const channelArray = Array.from(SIMULATE_CHANNELS);\n    channelArray.forEach(channel => {\n      if (channel.name === channelState.name &&\n      // has same name\n      channel !== channelState &&\n      // not own channel\n      !!channel.messagesCallback &&\n      // has subscribers\n      channel.time < messageJson.time // channel not created after postMessage() call\n      ) {\n        channel.messagesCallback(messageJson);\n      }\n    });\n    res();\n  }, SIMULATE_DELAY_TIME));\n}\nfunction onMessage(channelState, fn) {\n  channelState.messagesCallback = fn;\n}\nfunction canBeUsed() {\n  return true;\n}\nfunction averageResponseTime() {\n  return SIMULATE_DELAY_TIME;\n}\nvar SimulateMethod = {\n  create,\n  close,\n  onMessage,\n  postMessage,\n  canBeUsed,\n  type,\n  averageResponseTime,\n  microSeconds\n};\n\n// order is important\nconst METHODS = [NativeMethod,\n// fastest\nIndexeDbMethod, LocalstorageMethod, ServerMethod];\nfunction chooseMethod(options) {\n  let chooseMethods = [].concat(options.methods, METHODS).filter(Boolean);\n\n  // directly chosen\n  if (options.type) {\n    if (options.type === 'simulate') {\n      // only use simulate-method if directly chosen\n      return SimulateMethod;\n    }\n    const ret = chooseMethods.find(m => m.type === options.type);\n    if (!ret) throw new Error('method-type ' + options.type + ' not found');else return ret;\n  }\n\n  /**\n   * if no webworker support is needed,\n   * remove idb from the list so that localstorage is been chosen\n   */\n  if (!options.webWorkerSupport) {\n    chooseMethods = chooseMethods.filter(m => m.type !== 'idb');\n  }\n  const useMethod = chooseMethods.find(method => method.canBeUsed(options));\n  if (!useMethod) throw new Error(`No useable method found in ${JSON.stringify(METHODS.map(m => m.type))}`);else return useMethod;\n}\n\n/**\n * Contains all open channels,\n * used in tests to ensure everything is closed.\n */\nconst OPEN_BROADCAST_CHANNELS = new Set();\nlet lastId = 0;\nconst BroadcastChannel$1 = function (name, options) {\n  // identifier of the channel to debug stuff\n  this.id = lastId++;\n  OPEN_BROADCAST_CHANNELS.add(this);\n  this.name = name;\n  if (ENFORCED_OPTIONS) {\n    options = ENFORCED_OPTIONS;\n  }\n  this.options = fillOptionsWithDefaults(options);\n  this.method = chooseMethod(this.options);\n\n  // isListening\n  this._iL = false;\n\n  /**\n   * _onMessageListener\n   * setting onmessage twice,\n   * will overwrite the first listener\n   */\n  this._onML = null;\n\n  /**\n   * _addEventListeners\n   */\n  this._addEL = {\n    message: [],\n    internal: []\n  };\n\n  /**\n   * Unsend message promises\n   * where the sending is still in progress\n   * @type {Set<Promise>}\n   */\n  this._uMP = new Set();\n\n  /**\n   * _beforeClose\n   * array of promises that will be awaited\n   * before the channel is closed\n   */\n  this._befC = [];\n\n  /**\n   * _preparePromise\n   */\n  this._prepP = null;\n  _prepareChannel(this);\n};\n\n// STATICS\n\n/**\n * used to identify if someone overwrites\n * window.BroadcastChannel with this\n * See methods/native.js\n */\nBroadcastChannel$1._pubkey = true;\n\n/**\n * if set, this method is enforced,\n * no mather what the options are\n */\nlet ENFORCED_OPTIONS;\nfunction enforceOptions(options) {\n  ENFORCED_OPTIONS = options;\n}\n\n// PROTOTYPE\nBroadcastChannel$1.prototype = {\n  postMessage(msg) {\n    if (this.closed) {\n      throw new Error('BroadcastChannel.postMessage(): ' + 'Cannot post message after channel has closed ' +\n      /**\n       * In the past when this error appeared, it was realy hard to debug.\n       * So now we log the msg together with the error so it at least\n       * gives some clue about where in your application this happens.\n       */\n      JSON.stringify(msg));\n    }\n    return _post(this, 'message', msg);\n  },\n  postInternal(msg) {\n    return _post(this, 'internal', msg);\n  },\n  set onmessage(fn) {\n    const time = this.method.microSeconds();\n    const listenObj = {\n      time,\n      fn\n    };\n    _removeListenerObject(this, 'message', this._onML);\n    if (fn && typeof fn === 'function') {\n      this._onML = listenObj;\n      _addListenerObject(this, 'message', listenObj);\n    } else {\n      this._onML = null;\n    }\n  },\n  addEventListener(type, fn) {\n    const time = this.method.microSeconds();\n    const listenObj = {\n      time,\n      fn\n    };\n    _addListenerObject(this, type, listenObj);\n  },\n  removeEventListener(type, fn) {\n    const obj = this._addEL[type].find(obj => obj.fn === fn);\n    _removeListenerObject(this, type, obj);\n  },\n  close() {\n    if (this.closed) {\n      return;\n    }\n    OPEN_BROADCAST_CHANNELS.delete(this);\n    this.closed = true;\n    const awaitPrepare = this._prepP ? this._prepP : PROMISE_RESOLVED_VOID;\n    this._onML = null;\n    this._addEL.message = [];\n    return awaitPrepare\n    // wait until all current sending are processed\n    .then(() => Promise.all(Array.from(this._uMP)))\n    // run before-close hooks\n    .then(() => Promise.all(this._befC.map(fn => fn())))\n    // close the channel\n    .then(() => this.method.close(this._state));\n  },\n  get type() {\n    return this.method.type;\n  },\n  get isClosed() {\n    return this.closed;\n  }\n};\n\n/**\n * Post a message over the channel\n * @returns {Promise} that resolved when the message sending is done\n */\nfunction _post(broadcastChannel, type, msg) {\n  const time = broadcastChannel.method.microSeconds();\n  const msgObj = {\n    time,\n    type,\n    data: msg\n  };\n  const awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : PROMISE_RESOLVED_VOID;\n  return awaitPrepare.then(() => {\n    const sendPromise = broadcastChannel.method.postMessage(broadcastChannel._state, msgObj);\n\n    // add/remove to unsend messages list\n    broadcastChannel._uMP.add(sendPromise);\n    sendPromise.catch().then(() => broadcastChannel._uMP.delete(sendPromise));\n    return sendPromise;\n  });\n}\nfunction _prepareChannel(channel) {\n  const maybePromise = channel.method.create(channel.name, channel.options);\n  if (isPromise(maybePromise)) {\n    channel._prepP = maybePromise;\n    maybePromise.then(s => {\n      // used in tests to simulate slow runtime\n      /*if (channel.options.prepareDelay) {\n           await new Promise(res => setTimeout(res, this.options.prepareDelay));\n      }*/\n      channel._state = s;\n    });\n  } else {\n    channel._state = maybePromise;\n  }\n}\nfunction _hasMessageListeners(channel) {\n  if (channel._addEL.message.length > 0) return true;\n  if (channel._addEL.internal.length > 0) return true;\n  return false;\n}\nfunction _addListenerObject(channel, type, obj) {\n  channel._addEL[type].push(obj);\n  _startListening(channel);\n}\nfunction _removeListenerObject(channel, type, obj) {\n  channel._addEL[type] = channel._addEL[type].filter(o => o !== obj);\n  _stopListening(channel);\n}\nfunction _startListening(channel) {\n  if (!channel._iL && _hasMessageListeners(channel)) {\n    // someone is listening, start subscribing\n\n    const listenerFn = msgObj => {\n      channel._addEL[msgObj.type].forEach(listenerObject => {\n        /**\n         * Getting the current time in JavaScript has no good precision.\n         * So instead of only listening to events that happend 'after' the listener\n         * was added, we also listen to events that happended 100ms before it.\n         * This ensures that when another process, like a WebWorker, sends events\n         * we do not miss them out because their timestamp is a bit off compared to the main process.\n         * Not doing this would make messages missing when we send data directly after subscribing and awaiting a response.\n         * @link https://johnresig.com/blog/accuracy-of-javascript-time/\n         */\n        // const hundredMsInMicro = 100 * 1000;\n        // const minMessageTime = listenerObject.time - hundredMsInMicro;\n\n        if (msgObj.time >= listenerObject.time) {\n          listenerObject.fn(msgObj.data);\n        } else if (channel.method.type === 'server') {\n          // server msg might lag based on connection.\n          listenerObject.fn(msgObj.data);\n        }\n      });\n    };\n    const time = channel.method.microSeconds();\n    if (channel._prepP) {\n      channel._prepP.then(() => {\n        channel._iL = true;\n        channel.method.onMessage(channel._state, listenerFn, time);\n      });\n    } else {\n      channel._iL = true;\n      channel.method.onMessage(channel._state, listenerFn, time);\n    }\n  }\n}\nfunction _stopListening(channel) {\n  if (channel._iL && !_hasMessageListeners(channel)) {\n    // noone is listening, stop subscribing\n    channel._iL = false;\n    const time = channel.method.microSeconds();\n    channel.method.onMessage(channel._state, null, time);\n  }\n}\n\nexport { BroadcastChannel$1 as BroadcastChannel, IndexeDbMethod as IndexedDbMethod, LocalstorageMethod as LocalStorageMethod, NativeMethod, OPEN_BROADCAST_CHANNELS, ServerMethod, chooseMethod, enforceOptions };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}