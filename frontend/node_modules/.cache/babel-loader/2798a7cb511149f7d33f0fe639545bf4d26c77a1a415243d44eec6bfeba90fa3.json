{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SetIncludes = SetIncludes;\nexports.SetIsSubset = SetIsSubset;\nexports.SetDistinct = SetDistinct;\nexports.SetIntersect = SetIntersect;\nexports.SetUnion = SetUnion;\nexports.SetComplement = SetComplement;\nexports.SetIntersectMany = SetIntersectMany;\nexports.SetUnionMany = SetUnionMany;\n/** Returns true if element right is in the set of left */\n// prettier-ignore\nfunction SetIncludes(T, S) {\n  return T.includes(S);\n}\n/** Returns true if left is a subset of right */\nfunction SetIsSubset(T, S) {\n  return T.every(L => SetIncludes(S, L));\n}\n/** Returns a distinct set of elements */\nfunction SetDistinct(T) {\n  return [...new Set(T)];\n}\n/** Returns the Intersect of the given sets */\nfunction SetIntersect(T, S) {\n  return T.filter(L => S.includes(L));\n}\n/** Returns the Union of the given sets */\nfunction SetUnion(T, S) {\n  return [...T, ...S];\n}\n/** Returns the Complement by omitting elements in T that are in S */\n// prettier-ignore\nfunction SetComplement(T, S) {\n  return T.filter(L => !S.includes(L));\n}\n// prettier-ignore\nfunction SetIntersectManyResolve(T, Init) {\n  return T.reduce((Acc, L) => {\n    return SetIntersect(Acc, L);\n  }, Init);\n}\n// prettier-ignore\nfunction SetIntersectMany(T) {\n  return T.length === 1 ? T[0]\n  // Use left to initialize the accumulator for resolve\n  : T.length > 1 ? SetIntersectManyResolve(T.slice(1), T[0]) : [];\n}\n/** Returns the Union of multiple sets */\nfunction SetUnionMany(T) {\n  const Acc = [];\n  for (const L of T) Acc.push(...L);\n  return Acc;\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}