{"ast":null,"code":"import { AbiItemAmbiguityError } from '../../errors/abi.js';\nimport { isHex } from '../../utils/data/isHex.js';\nimport { isAddress } from '../address/isAddress.js';\nimport { toEventSelector } from '../hash/toEventSelector.js';\nimport { toFunctionSelector } from '../hash/toFunctionSelector.js';\nexport function getAbiItem(parameters) {\n  const {\n    abi,\n    args = [],\n    name\n  } = parameters;\n  const isSelector = isHex(name, {\n    strict: false\n  });\n  const abiItems = abi.filter(abiItem => {\n    if (isSelector) {\n      if (abiItem.type === 'function') return toFunctionSelector(abiItem) === name;\n      if (abiItem.type === 'event') return toEventSelector(abiItem) === name;\n      return false;\n    }\n    return 'name' in abiItem && abiItem.name === name;\n  });\n  if (abiItems.length === 0) return undefined;\n  if (abiItems.length === 1) return abiItems[0];\n  let matchedAbiItem = undefined;\n  for (const abiItem of abiItems) {\n    if (!('inputs' in abiItem)) continue;\n    if (!args || args.length === 0) {\n      if (!abiItem.inputs || abiItem.inputs.length === 0) return abiItem;\n      continue;\n    }\n    if (!abiItem.inputs) continue;\n    if (abiItem.inputs.length === 0) continue;\n    if (abiItem.inputs.length !== args.length) continue;\n    const matched = args.every((arg, index) => {\n      const abiParameter = 'inputs' in abiItem && abiItem.inputs[index];\n      if (!abiParameter) return false;\n      return isArgOfType(arg, abiParameter);\n    });\n    if (matched) {\n      // Check for ambiguity against already matched parameters (e.g. `address` vs `bytes20`).\n      if (matchedAbiItem && 'inputs' in matchedAbiItem && matchedAbiItem.inputs) {\n        const ambiguousTypes = getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);\n        if (ambiguousTypes) throw new AbiItemAmbiguityError({\n          abiItem,\n          type: ambiguousTypes[0]\n        }, {\n          abiItem: matchedAbiItem,\n          type: ambiguousTypes[1]\n        });\n      }\n      matchedAbiItem = abiItem;\n    }\n  }\n  if (matchedAbiItem) return matchedAbiItem;\n  return abiItems[0];\n}\n/** @internal */\nexport function isArgOfType(arg, abiParameter) {\n  const argType = typeof arg;\n  const abiParameterType = abiParameter.type;\n  switch (abiParameterType) {\n    case 'address':\n      return isAddress(arg, {\n        strict: false\n      });\n    case 'bool':\n      return argType === 'boolean';\n    case 'function':\n      return argType === 'string';\n    case 'string':\n      return argType === 'string';\n    default:\n      {\n        if (abiParameterType === 'tuple' && 'components' in abiParameter) return Object.values(abiParameter.components).every((component, index) => {\n          return isArgOfType(Object.values(arg)[index], component);\n        });\n        // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n        // https://regexr.com/6v8hp\n        if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType)) return argType === 'number' || argType === 'bigint';\n        // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n        // https://regexr.com/6va55\n        if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType)) return argType === 'string' || arg instanceof Uint8Array;\n        // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays\n        // https://regexr.com/6va6i\n        if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n          return Array.isArray(arg) && arg.every(x => isArgOfType(x, {\n            ...abiParameter,\n            // Pop off `[]` or `[M]` from end of type\n            type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, '')\n          }));\n        }\n        return false;\n      }\n  }\n}\n/** @internal */\nexport function getAmbiguousTypes(sourceParameters, targetParameters, args) {\n  for (const parameterIndex in sourceParameters) {\n    const sourceParameter = sourceParameters[parameterIndex];\n    const targetParameter = targetParameters[parameterIndex];\n    if (sourceParameter.type === 'tuple' && targetParameter.type === 'tuple' && 'components' in sourceParameter && 'components' in targetParameter) return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);\n    const types = [sourceParameter.type, targetParameter.type];\n    const ambiguous = (() => {\n      if (types.includes('address') && types.includes('bytes20')) return true;\n      if (types.includes('address') && types.includes('string')) return isAddress(args[parameterIndex], {\n        strict: false\n      });\n      if (types.includes('address') && types.includes('bytes')) return isAddress(args[parameterIndex], {\n        strict: false\n      });\n      return false;\n    })();\n    if (ambiguous) return types;\n  }\n  return;\n}","map":{"version":3,"names":["AbiItemAmbiguityError","isHex","isAddress","toEventSelector","toFunctionSelector","getAbiItem","parameters","abi","args","name","isSelector","strict","abiItems","filter","abiItem","type","length","undefined","matchedAbiItem","inputs","matched","every","arg","index","abiParameter","isArgOfType","ambiguousTypes","getAmbiguousTypes","argType","abiParameterType","Object","values","components","component","test","Uint8Array","Array","isArray","x","replace","sourceParameters","targetParameters","parameterIndex","sourceParameter","targetParameter","types","ambiguous","includes"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@reown\\appkit\\node_modules\\@walletconnect\\utils\\node_modules\\viem\\utils\\abi\\getAbiItem.ts"],"sourcesContent":["import type { Abi, AbiParameter, Address } from 'abitype'\n\nimport {\n  AbiItemAmbiguityError,\n  type AbiItemAmbiguityErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  AbiItem,\n  AbiItemArgs,\n  AbiItemName,\n  ExtractAbiItemForArgs,\n  Widen,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { UnionEvaluate } from '../../types/utils.js'\nimport { type IsHexErrorType, isHex } from '../../utils/data/isHex.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport { toEventSelector } from '../hash/toEventSelector.js'\nimport {\n  type ToFunctionSelectorErrorType,\n  toFunctionSelector,\n} from '../hash/toFunctionSelector.js'\n\nexport type GetAbiItemParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  name extends AbiItemName<abi> = AbiItemName<abi>,\n  args extends AbiItemArgs<abi, name> | undefined = AbiItemArgs<abi, name>,\n  ///\n  allArgs = AbiItemArgs<abi, name>,\n  allNames = AbiItemName<abi>,\n> = {\n  abi: abi\n  name:\n    | allNames // show all options\n    | (name extends allNames ? name : never) // infer value\n    | Hex // function selector\n} & UnionEvaluate<\n  readonly [] extends allArgs\n    ? {\n        args?:\n          | allArgs // show all options\n          // infer value, widen inferred value of `args` conditionally to match `allArgs`\n          | (abi extends Abi\n              ? args extends allArgs\n                ? Widen<args>\n                : never\n              : never)\n          | undefined\n      }\n    : {\n        args?:\n          | allArgs // show all options\n          | (Widen<args> & (args extends allArgs ? unknown : never)) // infer value, widen inferred value of `args` match `allArgs` (e.g. avoid union `args: readonly [123n] | readonly [bigint]`)\n          | undefined\n      }\n>\n\nexport type GetAbiItemErrorType =\n  | IsArgOfTypeErrorType\n  | IsHexErrorType\n  | ToFunctionSelectorErrorType\n  | AbiItemAmbiguityErrorType\n  | ErrorType\n\nexport type GetAbiItemReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  name extends AbiItemName<abi> = AbiItemName<abi>,\n  args extends AbiItemArgs<abi, name> | undefined = AbiItemArgs<abi, name>,\n> = abi extends Abi\n  ? Abi extends abi\n    ? AbiItem | undefined\n    : ExtractAbiItemForArgs<\n        abi,\n        name,\n        args extends AbiItemArgs<abi, name> ? args : AbiItemArgs<abi, name>\n      >\n  : AbiItem | undefined\n\nexport function getAbiItem<\n  const abi extends Abi | readonly unknown[],\n  name extends AbiItemName<abi>,\n  const args extends AbiItemArgs<abi, name> | undefined = undefined,\n>(\n  parameters: GetAbiItemParameters<abi, name, args>,\n): GetAbiItemReturnType<abi, name, args> {\n  const { abi, args = [], name } = parameters as unknown as GetAbiItemParameters\n\n  const isSelector = isHex(name, { strict: false })\n  const abiItems = (abi as Abi).filter((abiItem) => {\n    if (isSelector) {\n      if (abiItem.type === 'function')\n        return toFunctionSelector(abiItem) === name\n      if (abiItem.type === 'event') return toEventSelector(abiItem) === name\n      return false\n    }\n    return 'name' in abiItem && abiItem.name === name\n  })\n\n  if (abiItems.length === 0)\n    return undefined as GetAbiItemReturnType<abi, name, args>\n  if (abiItems.length === 1)\n    return abiItems[0] as GetAbiItemReturnType<abi, name, args>\n\n  let matchedAbiItem: AbiItem | undefined = undefined\n  for (const abiItem of abiItems) {\n    if (!('inputs' in abiItem)) continue\n    if (!args || args.length === 0) {\n      if (!abiItem.inputs || abiItem.inputs.length === 0)\n        return abiItem as GetAbiItemReturnType<abi, name, args>\n      continue\n    }\n    if (!abiItem.inputs) continue\n    if (abiItem.inputs.length === 0) continue\n    if (abiItem.inputs.length !== args.length) continue\n    const matched = args.every((arg, index) => {\n      const abiParameter = 'inputs' in abiItem && abiItem.inputs![index]\n      if (!abiParameter) return false\n      return isArgOfType(arg, abiParameter)\n    })\n    if (matched) {\n      // Check for ambiguity against already matched parameters (e.g. `address` vs `bytes20`).\n      if (\n        matchedAbiItem &&\n        'inputs' in matchedAbiItem &&\n        matchedAbiItem.inputs\n      ) {\n        const ambiguousTypes = getAmbiguousTypes(\n          abiItem.inputs,\n          matchedAbiItem.inputs,\n          args as readonly unknown[],\n        )\n        if (ambiguousTypes)\n          throw new AbiItemAmbiguityError(\n            {\n              abiItem,\n              type: ambiguousTypes[0],\n            },\n            {\n              abiItem: matchedAbiItem,\n              type: ambiguousTypes[1],\n            },\n          )\n      }\n\n      matchedAbiItem = abiItem\n    }\n  }\n\n  if (matchedAbiItem)\n    return matchedAbiItem as GetAbiItemReturnType<abi, name, args>\n  return abiItems[0] as GetAbiItemReturnType<abi, name, args>\n}\n\ntype IsArgOfTypeErrorType = IsAddressErrorType | ErrorType\n\n/** @internal */\nexport function isArgOfType(arg: unknown, abiParameter: AbiParameter): boolean {\n  const argType = typeof arg\n  const abiParameterType = abiParameter.type\n  switch (abiParameterType) {\n    case 'address':\n      return isAddress(arg as Address, { strict: false })\n    case 'bool':\n      return argType === 'boolean'\n    case 'function':\n      return argType === 'string'\n    case 'string':\n      return argType === 'string'\n    default: {\n      if (abiParameterType === 'tuple' && 'components' in abiParameter)\n        return Object.values(abiParameter.components).every(\n          (component, index) => {\n            return isArgOfType(\n              Object.values(arg as unknown[] | Record<string, unknown>)[index],\n              component as AbiParameter,\n            )\n          },\n        )\n\n      // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n      // https://regexr.com/6v8hp\n      if (\n        /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(\n          abiParameterType,\n        )\n      )\n        return argType === 'number' || argType === 'bigint'\n\n      // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n      // https://regexr.com/6va55\n      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))\n        return argType === 'string' || arg instanceof Uint8Array\n\n      // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays\n      // https://regexr.com/6va6i\n      if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n        return (\n          Array.isArray(arg) &&\n          arg.every((x: unknown) =>\n            isArgOfType(x, {\n              ...abiParameter,\n              // Pop off `[]` or `[M]` from end of type\n              type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, ''),\n            } as AbiParameter),\n          )\n        )\n      }\n\n      return false\n    }\n  }\n}\n\n/** @internal */\nexport function getAmbiguousTypes(\n  sourceParameters: readonly AbiParameter[],\n  targetParameters: readonly AbiParameter[],\n  args: AbiItemArgs,\n): AbiParameter['type'][] | undefined {\n  for (const parameterIndex in sourceParameters) {\n    const sourceParameter = sourceParameters[parameterIndex]\n    const targetParameter = targetParameters[parameterIndex]\n\n    if (\n      sourceParameter.type === 'tuple' &&\n      targetParameter.type === 'tuple' &&\n      'components' in sourceParameter &&\n      'components' in targetParameter\n    )\n      return getAmbiguousTypes(\n        sourceParameter.components,\n        targetParameter.components,\n        (args as any)[parameterIndex],\n      )\n\n    const types = [sourceParameter.type, targetParameter.type]\n\n    const ambiguous = (() => {\n      if (types.includes('address') && types.includes('bytes20')) return true\n      if (types.includes('address') && types.includes('string'))\n        return isAddress(args[parameterIndex] as Address, { strict: false })\n      if (types.includes('address') && types.includes('bytes'))\n        return isAddress(args[parameterIndex] as Address, { strict: false })\n      return false\n    })()\n\n    if (ambiguous) return types\n  }\n\n  return\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}