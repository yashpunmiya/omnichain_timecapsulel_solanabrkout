{"ast":null,"code":"import * as AbiConstructor from 'ox/AbiConstructor';\nimport * as AbiFunction from 'ox/AbiFunction';\nimport { parseAccount } from '../../accounts/utils/parseAccount.js';\nimport { ethAddress, zeroAddress } from '../../constants/address.js';\nimport { deploylessCallViaBytecodeBytecode } from '../../constants/contracts.js';\nimport { BaseError } from '../../errors/base.js';\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js';\nimport { hexToBigInt } from '../../utils/index.js';\nimport { createAccessList } from './createAccessList.js';\nimport { simulateBlocks } from './simulateBlocks.js';\nconst getBalanceCode = '0x6080604052348015600e575f80fd5b5061016d8061001c5f395ff3fe608060405234801561000f575f80fd5b5060043610610029575f3560e01c8063f8b2cb4f1461002d575b5f80fd5b610047600480360381019061004291906100db565b61005d565b604051610054919061011e565b60405180910390f35b5f8173ffffffffffffffffffffffffffffffffffffffff16319050919050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6100aa82610081565b9050919050565b6100ba816100a0565b81146100c4575f80fd5b50565b5f813590506100d5816100b1565b92915050565b5f602082840312156100f0576100ef61007d565b5b5f6100fd848285016100c7565b91505092915050565b5f819050919050565b61011881610106565b82525050565b5f6020820190506101315f83018461010f565b9291505056fea26469706673582212203b9fe929fe995c7cf9887f0bdba8a36dd78e8b73f149b17d2d9ad7cd09d2dc6264736f6c634300081a0033';\n/**\n * Simulates execution of a batch of calls.\n *\n * @param client - Client to use\n * @param parameters - {@link SimulateCallsParameters}\n * @returns Results. {@link SimulateCallsReturnType}\n *\n * @example\n * ```ts\n * import { createPublicClient, http, parseEther } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { simulateCalls } from 'viem/actions'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const result = await simulateCalls(client, {\n *   account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',\n *   calls: [{\n *     {\n *       data: '0xdeadbeef',\n *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *     },\n *     {\n *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *       value: parseEther('1'),\n *     },\n *   ]\n * })\n * ```\n */\nexport async function simulateCalls(client, parameters) {\n  const {\n    blockNumber,\n    blockTag,\n    calls,\n    stateOverrides,\n    traceAssetChanges,\n    traceTransfers,\n    validation\n  } = parameters;\n  const account = parameters.account ? parseAccount(parameters.account) : undefined;\n  if (traceAssetChanges && !account) throw new BaseError('`account` is required when `traceAssetChanges` is true');\n  // Derive bytecode to extract ETH balance via a contract call.\n  const getBalanceData = account ? AbiConstructor.encode(AbiConstructor.from('constructor(bytes, bytes)'), {\n    bytecode: deploylessCallViaBytecodeBytecode,\n    args: [getBalanceCode, AbiFunction.encodeData(AbiFunction.from('function getBalance(address)'), [account.address])]\n  }) : undefined;\n  // Fetch ERC20/721 addresses that were \"touched\" from the calls.\n  const assetAddresses = traceAssetChanges ? await Promise.all(parameters.calls.map(async call => {\n    if (!call.data && !call.abi) return;\n    const {\n      accessList\n    } = await createAccessList(client, {\n      account: account.address,\n      ...call,\n      data: call.abi ? encodeFunctionData(call) : call.data\n    });\n    return accessList.map(({\n      address,\n      storageKeys\n    }) => storageKeys.length > 0 ? address : null);\n  })).then(x => x.flat().filter(Boolean)) : [];\n  const resultsStateOverrides = stateOverrides?.map(override => {\n    if (override.address === account?.address) return {\n      ...override,\n      nonce: 0\n    };\n    return override;\n  });\n  const blocks = await simulateBlocks(client, {\n    blockNumber,\n    blockTag: blockTag,\n    blocks: [...(traceAssetChanges ? [\n    // ETH pre balances\n    {\n      calls: [{\n        data: getBalanceData\n      }],\n      stateOverrides\n    },\n    // Asset pre balances\n    {\n      calls: assetAddresses.map((address, i) => ({\n        abi: [AbiFunction.from('function balanceOf(address) returns (uint256)')],\n        functionName: 'balanceOf',\n        args: [account.address],\n        to: address,\n        from: zeroAddress,\n        nonce: i\n      })),\n      stateOverrides: [{\n        address: zeroAddress,\n        nonce: 0\n      }]\n    }] : []), {\n      calls: [...calls, {}].map((call, index) => ({\n        ...call,\n        from: account?.address,\n        nonce: index\n      })),\n      stateOverrides: resultsStateOverrides\n    }, ...(traceAssetChanges ? [\n    // ETH post balances\n    {\n      calls: [{\n        data: getBalanceData\n      }]\n    },\n    // Asset post balances\n    {\n      calls: assetAddresses.map((address, i) => ({\n        abi: [AbiFunction.from('function balanceOf(address) returns (uint256)')],\n        functionName: 'balanceOf',\n        args: [account.address],\n        to: address,\n        from: zeroAddress,\n        nonce: i\n      })),\n      stateOverrides: [{\n        address: zeroAddress,\n        nonce: 0\n      }]\n    },\n    // Decimals\n    {\n      calls: assetAddresses.map((address, i) => ({\n        to: address,\n        abi: [AbiFunction.from('function decimals() returns (uint256)')],\n        functionName: 'decimals',\n        from: zeroAddress,\n        nonce: i\n      })),\n      stateOverrides: [{\n        address: zeroAddress,\n        nonce: 0\n      }]\n    },\n    // Token URI\n    {\n      calls: assetAddresses.map((address, i) => ({\n        to: address,\n        abi: [AbiFunction.from('function tokenURI(uint256) returns (string)')],\n        functionName: 'tokenURI',\n        args: [0n],\n        from: zeroAddress,\n        nonce: i\n      })),\n      stateOverrides: [{\n        address: zeroAddress,\n        nonce: 0\n      }]\n    },\n    // Symbols\n    {\n      calls: assetAddresses.map((address, i) => ({\n        to: address,\n        abi: [AbiFunction.from('function symbol() returns (string)')],\n        functionName: 'symbol',\n        from: zeroAddress,\n        nonce: i\n      })),\n      stateOverrides: [{\n        address: zeroAddress,\n        nonce: 0\n      }]\n    }] : [])],\n    traceTransfers,\n    validation\n  });\n  const block_results = traceAssetChanges ? blocks[2] : blocks[0];\n  const [block_ethPre, block_assetsPre,, block_ethPost, block_assetsPost, block_decimals, block_tokenURI, block_symbols] = traceAssetChanges ? blocks : [];\n  // Extract call results from the simulation.\n  const {\n    calls: block_calls,\n    ...block\n  } = block_results;\n  const results = block_calls.slice(0, -1) ?? [];\n  // Extract pre-execution ETH and asset balances.\n  const ethPre = block_ethPre?.calls ?? [];\n  const assetsPre = block_assetsPre?.calls ?? [];\n  const balancesPre = [...ethPre, ...assetsPre].map(call => call.status === 'success' ? hexToBigInt(call.data) : null);\n  // Extract post-execution ETH and asset balances.\n  const ethPost = block_ethPost?.calls ?? [];\n  const assetsPost = block_assetsPost?.calls ?? [];\n  const balancesPost = [...ethPost, ...assetsPost].map(call => call.status === 'success' ? hexToBigInt(call.data) : null);\n  // Extract asset symbols & decimals.\n  const decimals = (block_decimals?.calls ?? []).map(x => x.status === 'success' ? x.result : null);\n  const symbols = (block_symbols?.calls ?? []).map(x => x.status === 'success' ? x.result : null);\n  const tokenURI = (block_tokenURI?.calls ?? []).map(x => x.status === 'success' ? x.result : null);\n  const changes = [];\n  for (const [i, balancePost] of balancesPost.entries()) {\n    const balancePre = balancesPre[i];\n    if (typeof balancePost !== 'bigint') continue;\n    if (typeof balancePre !== 'bigint') continue;\n    const decimals_ = decimals[i - 1];\n    const symbol_ = symbols[i - 1];\n    const tokenURI_ = tokenURI[i - 1];\n    const token = (() => {\n      if (i === 0) return {\n        address: ethAddress,\n        decimals: 18,\n        symbol: 'ETH'\n      };\n      return {\n        address: assetAddresses[i - 1],\n        decimals: tokenURI_ || decimals_ ? Number(decimals_ ?? 1) : undefined,\n        symbol: symbol_ ?? undefined\n      };\n    })();\n    if (changes.some(change => change.token.address === token.address)) continue;\n    changes.push({\n      token,\n      value: {\n        pre: balancePre,\n        post: balancePost,\n        diff: balancePost - balancePre\n      }\n    });\n  }\n  return {\n    assetChanges: changes,\n    block,\n    results\n  };\n}\n//# sourceMappingURL=simulateCalls.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}