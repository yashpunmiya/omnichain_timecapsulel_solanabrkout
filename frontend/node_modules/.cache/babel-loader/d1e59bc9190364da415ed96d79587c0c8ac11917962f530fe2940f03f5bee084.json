{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n// Note, this module is not included in package exports so that it's private to\n// our first-party directives. If it ends up being useful, we can open it up and\n// export it.\n/**\n * Helper to iterate an AsyncIterable in its own closure.\n * @param iterable The iterable to iterate\n * @param callback The callback to call for each value. If the callback returns\n * `false`, the loop will be broken.\n */\nexport const forAwaitOf = async (iterable, callback) => {\n  for await (const v of iterable) {\n    if ((await callback(v)) === false) {\n      return;\n    }\n  }\n};\n/**\n * Holds a reference to an instance that can be disconnected and reconnected,\n * so that a closure over the ref (e.g. in a then function to a promise) does\n * not strongly hold a ref to the instance. Approximates a WeakRef but must\n * be manually connected & disconnected to the backing instance.\n */\nexport class PseudoWeakRef {\n  constructor(ref) {\n    this._ref = ref;\n  }\n  /**\n   * Disassociates the ref with the backing instance.\n   */\n  disconnect() {\n    this._ref = undefined;\n  }\n  /**\n   * Reassociates the ref with the backing instance.\n   */\n  reconnect(ref) {\n    this._ref = ref;\n  }\n  /**\n   * Retrieves the backing instance (will be undefined when disconnected)\n   */\n  deref() {\n    return this._ref;\n  }\n}\n/**\n * A helper to pause and resume waiting on a condition in an async function\n */\nexport class Pauser {\n  constructor() {\n    this._promise = undefined;\n    this._resolve = undefined;\n  }\n  /**\n   * When paused, returns a promise to be awaited; when unpaused, returns\n   * undefined. Note that in the microtask between the pauser being resumed\n   * an await of this promise resolving, the pauser could be paused again,\n   * hence callers should check the promise in a loop when awaiting.\n   * @returns A promise to be awaited when paused or undefined\n   */\n  get() {\n    return this._promise;\n  }\n  /**\n   * Creates a promise to be awaited\n   */\n  pause() {\n    this._promise ??= new Promise(resolve => this._resolve = resolve);\n  }\n  /**\n   * Resolves the promise which may be awaited\n   */\n  resume() {\n    this._resolve?.();\n    this._promise = this._resolve = undefined;\n  }\n}","map":{"version":3,"names":["forAwaitOf","iterable","callback","v","PseudoWeakRef","constructor","ref","_ref","disconnect","undefined","reconnect","deref","Pauser","_promise","_resolve","get","pause","Promise","resolve","resume"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\lit-html\\src\\directives\\private-async-helpers.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n// Note, this module is not included in package exports so that it's private to\n// our first-party directives. If it ends up being useful, we can open it up and\n// export it.\n\n/**\n * Helper to iterate an AsyncIterable in its own closure.\n * @param iterable The iterable to iterate\n * @param callback The callback to call for each value. If the callback returns\n * `false`, the loop will be broken.\n */\nexport const forAwaitOf = async <T>(\n  iterable: AsyncIterable<T>,\n  callback: (value: T) => Promise<boolean>\n) => {\n  for await (const v of iterable) {\n    if ((await callback(v)) === false) {\n      return;\n    }\n  }\n};\n\n/**\n * Holds a reference to an instance that can be disconnected and reconnected,\n * so that a closure over the ref (e.g. in a then function to a promise) does\n * not strongly hold a ref to the instance. Approximates a WeakRef but must\n * be manually connected & disconnected to the backing instance.\n */\nexport class PseudoWeakRef<T> {\n  private _ref?: T;\n  constructor(ref: T) {\n    this._ref = ref;\n  }\n  /**\n   * Disassociates the ref with the backing instance.\n   */\n  disconnect() {\n    this._ref = undefined;\n  }\n  /**\n   * Reassociates the ref with the backing instance.\n   */\n  reconnect(ref: T) {\n    this._ref = ref;\n  }\n  /**\n   * Retrieves the backing instance (will be undefined when disconnected)\n   */\n  deref() {\n    return this._ref;\n  }\n}\n\n/**\n * A helper to pause and resume waiting on a condition in an async function\n */\nexport class Pauser {\n  private _promise?: Promise<void> = undefined;\n  private _resolve?: () => void = undefined;\n  /**\n   * When paused, returns a promise to be awaited; when unpaused, returns\n   * undefined. Note that in the microtask between the pauser being resumed\n   * an await of this promise resolving, the pauser could be paused again,\n   * hence callers should check the promise in a loop when awaiting.\n   * @returns A promise to be awaited when paused or undefined\n   */\n  get() {\n    return this._promise;\n  }\n  /**\n   * Creates a promise to be awaited\n   */\n  pause() {\n    this._promise ??= new Promise((resolve) => (this._resolve = resolve));\n  }\n  /**\n   * Resolves the promise which may be awaited\n   */\n  resume() {\n    this._resolve?.();\n    this._promise = this._resolve = undefined;\n  }\n}\n"],"mappings":"AAAA;;;;;AAMA;AACA;AACA;AAEA;;;;;;AAMA,OAAO,MAAMA,UAAU,GAAG,MAAAA,CACxBC,QAA0B,EAC1BC,QAAwC,KACtC;EACF,WAAW,MAAMC,CAAC,IAAIF,QAAQ,EAAE;IAC9B,IAAI,CAAC,MAAMC,QAAQ,CAACC,CAAC,CAAC,MAAM,KAAK,EAAE;MACjC;IACF;EACF;AACF,CAAC;AAED;;;;;;AAMA,OAAM,MAAOC,aAAa;EAExBC,YAAYC,GAAM;IAChB,IAAI,CAACC,IAAI,GAAGD,GAAG;EACjB;EACA;;;EAGAE,UAAUA,CAAA;IACR,IAAI,CAACD,IAAI,GAAGE,SAAS;EACvB;EACA;;;EAGAC,SAASA,CAACJ,GAAM;IACd,IAAI,CAACC,IAAI,GAAGD,GAAG;EACjB;EACA;;;EAGAK,KAAKA,CAAA;IACH,OAAO,IAAI,CAACJ,IAAI;EAClB;;AAGF;;;AAGA,OAAM,MAAOK,MAAM;EAAnBP,YAAA;IACU,KAAAQ,QAAQ,GAAmBJ,SAAS;IACpC,KAAAK,QAAQ,GAAgBL,SAAS;EAwB3C;EAvBE;;;;;;;EAOAM,GAAGA,CAAA;IACD,OAAO,IAAI,CAACF,QAAQ;EACtB;EACA;;;EAGAG,KAAKA,CAAA;IACH,IAAI,CAACH,QAAQ,KAAK,IAAII,OAAO,CAAEC,OAAO,IAAM,IAAI,CAACJ,QAAQ,GAAGI,OAAQ,CAAC;EACvE;EACA;;;EAGAC,MAAMA,CAAA;IACJ,IAAI,CAACL,QAAQ,GAAE,CAAE;IACjB,IAAI,CAACD,QAAQ,GAAG,IAAI,CAACC,QAAQ,GAAGL,SAAS;EAC3C","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}