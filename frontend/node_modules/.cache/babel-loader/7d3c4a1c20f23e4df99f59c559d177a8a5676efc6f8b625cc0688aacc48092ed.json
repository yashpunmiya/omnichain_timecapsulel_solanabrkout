{"ast":null,"code":"import { RELAYER_EVENTS as Xe, TRANSPORT_TYPES as T, EXPIRER_EVENTS as qt, PAIRING_EVENTS as Je, RELAYER_DEFAULT_PROTOCOL as Tt, EVENT_CLIENT_SESSION_TRACES as M, EVENT_CLIENT_SESSION_ERRORS as H, EVENT_CLIENT_AUTHENTICATE_TRACES as z, EVENT_CLIENT_AUTHENTICATE_ERRORS as re, EVENT_CLIENT_PAIRING_ERRORS as Nt, EVENT_CLIENT_PAIRING_TRACES as Pt, VERIFY_SERVER as Ot, Store as J, Core as bt } from \"@walletconnect/core\";\nimport { pino as At, getDefaultLoggerOptions as Ct, generateChildLogger as xt, getLoggerContext as Vt } from \"@walletconnect/logger\";\nimport { IEngine as Dt, ISignClient as Lt } from \"@walletconnect/types\";\nimport { THIRTY_DAYS as Mt, SEVEN_DAYS as Be, FIVE_MINUTES as A, ONE_DAY as K, ONE_HOUR as We, ONE_SECOND as Ze, toMiliseconds as Oe } from \"@walletconnect/time\";\nimport { getInternalError as w, BASE64URL as ne, BASE64 as ue, hashMessage as B, parseExpirerTarget as kt, isValidString as U, isExpired as W, isValidId as $t, calcExpiry as C, engineEvent as f, createDelayedPromise as Z, getSdkError as O, getDeepLink as Kt, handleDeeplinkRedirect as Ut, isSessionCompatible as Gt, hashKey as be, parseChainId as Ae, createEncodedRecap as Ft, getRecapFromResources as Ce, mergeEncodedRecaps as jt, TYPE_2 as Qt, getLinkModeURL as ge, validateSignedCacao as et, getNamespacedDidChainId as tt, getDidAddress as st, getMethodsFromRecap as it, getChainsFromRecap as rt, buildNamespacesFromAuth as nt, formatMessage as Ht, MemoryStore as oe, isValidParams as k, isUndefined as ae, isValidRelays as zt, isValidObject as ot, isValidRequiredNamespaces as Yt, isValidNamespaces as xe, isConformingNamespaces as at, isValidErrorReason as Xt, isValidRelay as Jt, isValidController as Bt, isValidNamespacesChainId as ct, isValidRequest as Wt, isValidNamespacesRequest as Zt, isValidRequestExpiry as es, isValidResponse as ts, isValidEvent as ss, isValidNamespacesEvent as is, getSearchParamFromURL as lt, isTestRun as rs, isReactNative as ns, isValidArray as os, TYPE_1 as Ve, getAppMetadata as as } from \"@walletconnect/utils\";\nimport cs, { EventEmitter as ls } from \"events\";\nimport { isJsonRpcRequest as ps, isJsonRpcResponse as hs, payloadId as G, getBigIntRpcId as ye, isJsonRpcResult as F, isJsonRpcError as j, formatJsonRpcRequest as we, formatJsonRpcResult as ds, formatJsonRpcError as us } from \"@walletconnect/jsonrpc-utils\";\nconst De = \"wc\",\n  Le = 2,\n  Me = \"client\",\n  me = `${De}@${Le}:${Me}:`,\n  _e = {\n    name: Me,\n    logger: \"error\",\n    controller: !1,\n    relayUrl: \"wss://relay.walletconnect.org\"\n  },\n  gs = {\n    session_proposal: \"session_proposal\",\n    session_update: \"session_update\",\n    session_extend: \"session_extend\",\n    session_ping: \"session_ping\",\n    session_delete: \"session_delete\",\n    session_expire: \"session_expire\",\n    session_request: \"session_request\",\n    session_request_sent: \"session_request_sent\",\n    session_event: \"session_event\",\n    proposal_expire: \"proposal_expire\",\n    session_authenticate: \"session_authenticate\",\n    session_request_expire: \"session_request_expire\",\n    session_connect: \"session_connect\"\n  },\n  ys = {\n    database: \":memory:\"\n  },\n  ke = \"WALLETCONNECT_DEEPLINK_CHOICE\",\n  ws = {\n    created: \"history_created\",\n    updated: \"history_updated\",\n    deleted: \"history_deleted\",\n    sync: \"history_sync\"\n  },\n  ms = \"history\",\n  _s = \"0.3\",\n  pt = \"proposal\",\n  Es = Mt,\n  $e = \"Proposal expired\",\n  ht = \"session\",\n  Y = Be,\n  dt = \"engine\",\n  N = {\n    wc_sessionPropose: {\n      req: {\n        ttl: A,\n        prompt: !0,\n        tag: 1100\n      },\n      res: {\n        ttl: A,\n        prompt: !1,\n        tag: 1101\n      },\n      reject: {\n        ttl: A,\n        prompt: !1,\n        tag: 1120\n      },\n      autoReject: {\n        ttl: A,\n        prompt: !1,\n        tag: 1121\n      }\n    },\n    wc_sessionSettle: {\n      req: {\n        ttl: A,\n        prompt: !1,\n        tag: 1102\n      },\n      res: {\n        ttl: A,\n        prompt: !1,\n        tag: 1103\n      }\n    },\n    wc_sessionUpdate: {\n      req: {\n        ttl: K,\n        prompt: !1,\n        tag: 1104\n      },\n      res: {\n        ttl: K,\n        prompt: !1,\n        tag: 1105\n      }\n    },\n    wc_sessionExtend: {\n      req: {\n        ttl: K,\n        prompt: !1,\n        tag: 1106\n      },\n      res: {\n        ttl: K,\n        prompt: !1,\n        tag: 1107\n      }\n    },\n    wc_sessionRequest: {\n      req: {\n        ttl: A,\n        prompt: !0,\n        tag: 1108\n      },\n      res: {\n        ttl: A,\n        prompt: !1,\n        tag: 1109\n      }\n    },\n    wc_sessionEvent: {\n      req: {\n        ttl: A,\n        prompt: !0,\n        tag: 1110\n      },\n      res: {\n        ttl: A,\n        prompt: !1,\n        tag: 1111\n      }\n    },\n    wc_sessionDelete: {\n      req: {\n        ttl: K,\n        prompt: !1,\n        tag: 1112\n      },\n      res: {\n        ttl: K,\n        prompt: !1,\n        tag: 1113\n      }\n    },\n    wc_sessionPing: {\n      req: {\n        ttl: K,\n        prompt: !1,\n        tag: 1114\n      },\n      res: {\n        ttl: K,\n        prompt: !1,\n        tag: 1115\n      }\n    },\n    wc_sessionAuthenticate: {\n      req: {\n        ttl: We,\n        prompt: !0,\n        tag: 1116\n      },\n      res: {\n        ttl: We,\n        prompt: !1,\n        tag: 1117\n      },\n      reject: {\n        ttl: A,\n        prompt: !1,\n        tag: 1118\n      },\n      autoReject: {\n        ttl: A,\n        prompt: !1,\n        tag: 1119\n      }\n    }\n  },\n  Ee = {\n    min: A,\n    max: Be\n  },\n  $ = {\n    idle: \"IDLE\",\n    active: \"ACTIVE\"\n  },\n  Ke = {\n    eth_sendTransaction: {\n      key: \"\"\n    },\n    eth_sendRawTransaction: {\n      key: \"\"\n    },\n    wallet_sendCalls: {\n      key: \"\"\n    },\n    solana_signTransaction: {\n      key: \"signature\"\n    },\n    solana_signAllTransactions: {\n      key: \"transactions\"\n    },\n    solana_signAndSendTransaction: {\n      key: \"signature\"\n    }\n  },\n  ut = \"request\",\n  gt = [\"wc_sessionPropose\", \"wc_sessionRequest\", \"wc_authRequest\", \"wc_sessionAuthenticate\"],\n  yt = \"wc\",\n  Ss = 1.5,\n  wt = \"auth\",\n  mt = \"authKeys\",\n  _t = \"pairingTopics\",\n  Et = \"requests\",\n  ce = `${yt}@${1.5}:${wt}:`,\n  le = `${ce}:PUB_KEY`;\nvar Rs = Object.defineProperty,\n  fs = Object.defineProperties,\n  Is = Object.getOwnPropertyDescriptors,\n  St = Object.getOwnPropertySymbols,\n  vs = Object.prototype.hasOwnProperty,\n  qs = Object.prototype.propertyIsEnumerable,\n  Ue = (S, n, e) => n in S ? Rs(S, n, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : S[n] = e,\n  v = (S, n) => {\n    for (var e in n || (n = {})) vs.call(n, e) && Ue(S, e, n[e]);\n    if (St) for (var e of St(n)) qs.call(n, e) && Ue(S, e, n[e]);\n    return S;\n  },\n  x = (S, n) => fs(S, Is(n)),\n  c = (S, n, e) => Ue(S, typeof n != \"symbol\" ? n + \"\" : n, e);\nclass Ts extends Dt {\n  constructor(n) {\n    super(n), c(this, \"name\", dt), c(this, \"events\", new cs()), c(this, \"initialized\", !1), c(this, \"requestQueue\", {\n      state: $.idle,\n      queue: []\n    }), c(this, \"sessionRequestQueue\", {\n      state: $.idle,\n      queue: []\n    }), c(this, \"requestQueueDelay\", Ze), c(this, \"expectedPairingMethodMap\", new Map()), c(this, \"recentlyDeletedMap\", new Map()), c(this, \"recentlyDeletedLimit\", 200), c(this, \"relayMessageCache\", []), c(this, \"pendingSessions\", new Map()), c(this, \"init\", async () => {\n      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({\n        methods: Object.keys(N)\n      }), this.initialized = !0, setTimeout(() => {\n        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();\n      }, Oe(this.requestQueueDelay)));\n    }), c(this, \"connect\", async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      const t = x(v({}, e), {\n        requiredNamespaces: e.requiredNamespaces || {},\n        optionalNamespaces: e.optionalNamespaces || {}\n      });\n      await this.isValidConnect(t);\n      const {\n        pairingTopic: s,\n        requiredNamespaces: i,\n        optionalNamespaces: r,\n        sessionProperties: o,\n        relays: a\n      } = t;\n      let l = s,\n        u,\n        g = !1;\n      try {\n        if (l) {\n          const R = this.client.core.pairing.pairings.get(l);\n          this.client.logger.warn(\"connect() with existing pairing topic is deprecated and will be removed in the next major release.\"), g = R.active;\n        }\n      } catch (R) {\n        throw this.client.logger.error(`connect() -> pairing.get(${l}) failed`), R;\n      }\n      if (!l || !g) {\n        const {\n          topic: R,\n          uri: D\n        } = await this.client.core.pairing.create();\n        l = R, u = D;\n      }\n      if (!l) {\n        const {\n          message: R\n        } = w(\"NO_MATCHING_KEY\", `connect() pairing topic: ${l}`);\n        throw new Error(R);\n      }\n      const h = await this.client.core.crypto.generateKeyPair(),\n        d = N.wc_sessionPropose.req.ttl || A,\n        y = C(d),\n        m = x(v({\n          requiredNamespaces: i,\n          optionalNamespaces: r,\n          relays: a ?? [{\n            protocol: Tt\n          }],\n          proposer: {\n            publicKey: h,\n            metadata: this.client.metadata\n          },\n          expiryTimestamp: y,\n          pairingTopic: l\n        }, o && {\n          sessionProperties: o\n        }), {\n          id: G()\n        }),\n        I = f(\"session_connect\", m.id),\n        {\n          reject: p,\n          resolve: E,\n          done: V\n        } = Z(d, $e),\n        q = ({\n          id: R\n        }) => {\n          R === m.id && (this.client.events.off(\"proposal_expire\", q), this.pendingSessions.delete(m.id), this.events.emit(I, {\n            error: {\n              message: $e,\n              code: 0\n            }\n          }));\n        };\n      return this.client.events.on(\"proposal_expire\", q), this.events.once(I, ({\n        error: R,\n        session: D\n      }) => {\n        this.client.events.off(\"proposal_expire\", q), R ? p(R) : D && E(D);\n      }), await this.sendRequest({\n        topic: l,\n        method: \"wc_sessionPropose\",\n        params: m,\n        throwOnFailedPublish: !0,\n        clientRpcId: m.id\n      }), await this.setProposal(m.id, m), {\n        uri: u,\n        approval: V\n      };\n    }), c(this, \"pair\", async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      try {\n        return await this.client.core.pairing.pair(e);\n      } catch (t) {\n        throw this.client.logger.error(\"pair() failed\"), t;\n      }\n    }), c(this, \"approve\", async e => {\n      var t, s, i;\n      const r = this.client.core.eventClient.createEvent({\n        properties: {\n          topic: (t = e?.id) == null ? void 0 : t.toString(),\n          trace: [M.session_approve_started]\n        }\n      });\n      try {\n        this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      } catch (P) {\n        throw r.setError(H.no_internet_connection), P;\n      }\n      try {\n        await this.isValidProposalId(e?.id);\n      } catch (P) {\n        throw this.client.logger.error(`approve() -> proposal.get(${e?.id}) failed`), r.setError(H.proposal_not_found), P;\n      }\n      try {\n        await this.isValidApprove(e);\n      } catch (P) {\n        throw this.client.logger.error(\"approve() -> isValidApprove() failed\"), r.setError(H.session_approve_namespace_validation_failure), P;\n      }\n      const {\n          id: o,\n          relayProtocol: a,\n          namespaces: l,\n          sessionProperties: u,\n          sessionConfig: g\n        } = e,\n        h = this.client.proposal.get(o);\n      this.client.core.eventClient.deleteEvent({\n        eventId: r.eventId\n      });\n      const {\n        pairingTopic: d,\n        proposer: y,\n        requiredNamespaces: m,\n        optionalNamespaces: I\n      } = h;\n      let p = (s = this.client.core.eventClient) == null ? void 0 : s.getEvent({\n        topic: d\n      });\n      p || (p = (i = this.client.core.eventClient) == null ? void 0 : i.createEvent({\n        type: M.session_approve_started,\n        properties: {\n          topic: d,\n          trace: [M.session_approve_started, M.session_namespaces_validation_success]\n        }\n      }));\n      const E = await this.client.core.crypto.generateKeyPair(),\n        V = y.publicKey,\n        q = await this.client.core.crypto.generateSharedKey(E, V),\n        R = v(v({\n          relay: {\n            protocol: a ?? \"irn\"\n          },\n          namespaces: l,\n          controller: {\n            publicKey: E,\n            metadata: this.client.metadata\n          },\n          expiry: C(Y)\n        }, u && {\n          sessionProperties: u\n        }), g && {\n          sessionConfig: g\n        }),\n        D = T.relay;\n      p.addTrace(M.subscribing_session_topic);\n      try {\n        await this.client.core.relayer.subscribe(q, {\n          transportType: D\n        });\n      } catch (P) {\n        throw p.setError(H.subscribe_session_topic_failure), P;\n      }\n      p.addTrace(M.subscribe_session_topic_success);\n      const ee = x(v({}, R), {\n        topic: q,\n        requiredNamespaces: m,\n        optionalNamespaces: I,\n        pairingTopic: d,\n        acknowledged: !1,\n        self: R.controller,\n        peer: {\n          publicKey: y.publicKey,\n          metadata: y.metadata\n        },\n        controller: E,\n        transportType: T.relay\n      });\n      await this.client.session.set(q, ee), p.addTrace(M.store_session);\n      try {\n        p.addTrace(M.publishing_session_settle), await this.sendRequest({\n          topic: q,\n          method: \"wc_sessionSettle\",\n          params: R,\n          throwOnFailedPublish: !0\n        }).catch(P => {\n          throw p?.setError(H.session_settle_publish_failure), P;\n        }), p.addTrace(M.session_settle_publish_success), p.addTrace(M.publishing_session_approve), await this.sendResult({\n          id: o,\n          topic: d,\n          result: {\n            relay: {\n              protocol: a ?? \"irn\"\n            },\n            responderPublicKey: E\n          },\n          throwOnFailedPublish: !0\n        }).catch(P => {\n          throw p?.setError(H.session_approve_publish_failure), P;\n        }), p.addTrace(M.session_approve_publish_success);\n      } catch (P) {\n        throw this.client.logger.error(P), this.client.session.delete(q, O(\"USER_DISCONNECTED\")), await this.client.core.relayer.unsubscribe(q), P;\n      }\n      return this.client.core.eventClient.deleteEvent({\n        eventId: p.eventId\n      }), await this.client.core.pairing.updateMetadata({\n        topic: d,\n        metadata: y.metadata\n      }), await this.client.proposal.delete(o, O(\"USER_DISCONNECTED\")), await this.client.core.pairing.activate({\n        topic: d\n      }), await this.setExpiry(q, C(Y)), {\n        topic: q,\n        acknowledged: () => Promise.resolve(this.client.session.get(q))\n      };\n    }), c(this, \"reject\", async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      try {\n        await this.isValidReject(e);\n      } catch (r) {\n        throw this.client.logger.error(\"reject() -> isValidReject() failed\"), r;\n      }\n      const {\n        id: t,\n        reason: s\n      } = e;\n      let i;\n      try {\n        i = this.client.proposal.get(t).pairingTopic;\n      } catch (r) {\n        throw this.client.logger.error(`reject() -> proposal.get(${t}) failed`), r;\n      }\n      i && (await this.sendError({\n        id: t,\n        topic: i,\n        error: s,\n        rpcOpts: N.wc_sessionPropose.reject\n      }), await this.client.proposal.delete(t, O(\"USER_DISCONNECTED\")));\n    }), c(this, \"update\", async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      try {\n        await this.isValidUpdate(e);\n      } catch (g) {\n        throw this.client.logger.error(\"update() -> isValidUpdate() failed\"), g;\n      }\n      const {\n          topic: t,\n          namespaces: s\n        } = e,\n        {\n          done: i,\n          resolve: r,\n          reject: o\n        } = Z(),\n        a = G(),\n        l = ye().toString(),\n        u = this.client.session.get(t).namespaces;\n      return this.events.once(f(\"session_update\", a), ({\n        error: g\n      }) => {\n        g ? o(g) : r();\n      }), await this.client.session.update(t, {\n        namespaces: s\n      }), await this.sendRequest({\n        topic: t,\n        method: \"wc_sessionUpdate\",\n        params: {\n          namespaces: s\n        },\n        throwOnFailedPublish: !0,\n        clientRpcId: a,\n        relayRpcId: l\n      }).catch(g => {\n        this.client.logger.error(g), this.client.session.update(t, {\n          namespaces: u\n        }), o(g);\n      }), {\n        acknowledged: i\n      };\n    }), c(this, \"extend\", async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      try {\n        await this.isValidExtend(e);\n      } catch (a) {\n        throw this.client.logger.error(\"extend() -> isValidExtend() failed\"), a;\n      }\n      const {\n          topic: t\n        } = e,\n        s = G(),\n        {\n          done: i,\n          resolve: r,\n          reject: o\n        } = Z();\n      return this.events.once(f(\"session_extend\", s), ({\n        error: a\n      }) => {\n        a ? o(a) : r();\n      }), await this.setExpiry(t, C(Y)), this.sendRequest({\n        topic: t,\n        method: \"wc_sessionExtend\",\n        params: {},\n        clientRpcId: s,\n        throwOnFailedPublish: !0\n      }).catch(a => {\n        o(a);\n      }), {\n        acknowledged: i\n      };\n    }), c(this, \"request\", async e => {\n      this.isInitialized();\n      try {\n        await this.isValidRequest(e);\n      } catch (p) {\n        throw this.client.logger.error(\"request() -> isValidRequest() failed\"), p;\n      }\n      const {\n          chainId: t,\n          request: s,\n          topic: i,\n          expiry: r = N.wc_sessionRequest.req.ttl\n        } = e,\n        o = this.client.session.get(i);\n      o?.transportType === T.relay && (await this.confirmOnlineStateOrThrow());\n      const a = G(),\n        l = ye().toString(),\n        {\n          done: u,\n          resolve: g,\n          reject: h\n        } = Z(r, \"Request expired. Please try again.\");\n      this.events.once(f(\"session_request\", a), ({\n        error: p,\n        result: E\n      }) => {\n        p ? h(p) : g(E);\n      });\n      const d = \"wc_sessionRequest\",\n        y = this.getAppLinkIfEnabled(o.peer.metadata, o.transportType);\n      if (y) return await this.sendRequest({\n        clientRpcId: a,\n        relayRpcId: l,\n        topic: i,\n        method: d,\n        params: {\n          request: x(v({}, s), {\n            expiryTimestamp: C(r)\n          }),\n          chainId: t\n        },\n        expiry: r,\n        throwOnFailedPublish: !0,\n        appLink: y\n      }).catch(p => h(p)), this.client.events.emit(\"session_request_sent\", {\n        topic: i,\n        request: s,\n        chainId: t,\n        id: a\n      }), await u();\n      const m = {\n          request: x(v({}, s), {\n            expiryTimestamp: C(r)\n          }),\n          chainId: t\n        },\n        I = this.shouldSetTVF(d, m);\n      return await Promise.all([new Promise(async p => {\n        await this.sendRequest(v({\n          clientRpcId: a,\n          relayRpcId: l,\n          topic: i,\n          method: d,\n          params: m,\n          expiry: r,\n          throwOnFailedPublish: !0\n        }, I && {\n          tvf: this.getTVFParams(a, m)\n        })).catch(E => h(E)), this.client.events.emit(\"session_request_sent\", {\n          topic: i,\n          request: s,\n          chainId: t,\n          id: a\n        }), p();\n      }), new Promise(async p => {\n        var E;\n        if (!((E = o.sessionConfig) != null && E.disableDeepLink)) {\n          const V = await Kt(this.client.core.storage, ke);\n          await Ut({\n            id: a,\n            topic: i,\n            wcDeepLink: V\n          });\n        }\n        p();\n      }), u()]).then(p => p[2]);\n    }), c(this, \"respond\", async e => {\n      this.isInitialized(), await this.isValidRespond(e);\n      const {\n          topic: t,\n          response: s\n        } = e,\n        {\n          id: i\n        } = s,\n        r = this.client.session.get(t);\n      r.transportType === T.relay && (await this.confirmOnlineStateOrThrow());\n      const o = this.getAppLinkIfEnabled(r.peer.metadata, r.transportType);\n      F(s) ? await this.sendResult({\n        id: i,\n        topic: t,\n        result: s.result,\n        throwOnFailedPublish: !0,\n        appLink: o\n      }) : j(s) && (await this.sendError({\n        id: i,\n        topic: t,\n        error: s.error,\n        appLink: o\n      })), this.cleanupAfterResponse(e);\n    }), c(this, \"ping\", async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      try {\n        await this.isValidPing(e);\n      } catch (s) {\n        throw this.client.logger.error(\"ping() -> isValidPing() failed\"), s;\n      }\n      const {\n        topic: t\n      } = e;\n      if (this.client.session.keys.includes(t)) {\n        const s = G(),\n          i = ye().toString(),\n          {\n            done: r,\n            resolve: o,\n            reject: a\n          } = Z();\n        this.events.once(f(\"session_ping\", s), ({\n          error: l\n        }) => {\n          l ? a(l) : o();\n        }), await Promise.all([this.sendRequest({\n          topic: t,\n          method: \"wc_sessionPing\",\n          params: {},\n          throwOnFailedPublish: !0,\n          clientRpcId: s,\n          relayRpcId: i\n        }), r()]);\n      } else this.client.core.pairing.pairings.keys.includes(t) && (this.client.logger.warn(\"ping() on pairing topic is deprecated and will be removed in the next major release.\"), await this.client.core.pairing.ping({\n        topic: t\n      }));\n    }), c(this, \"emit\", async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(e);\n      const {\n          topic: t,\n          event: s,\n          chainId: i\n        } = e,\n        r = ye().toString(),\n        o = G();\n      await this.sendRequest({\n        topic: t,\n        method: \"wc_sessionEvent\",\n        params: {\n          event: s,\n          chainId: i\n        },\n        throwOnFailedPublish: !0,\n        relayRpcId: r,\n        clientRpcId: o\n      });\n    }), c(this, \"disconnect\", async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(e);\n      const {\n        topic: t\n      } = e;\n      if (this.client.session.keys.includes(t)) await this.sendRequest({\n        topic: t,\n        method: \"wc_sessionDelete\",\n        params: O(\"USER_DISCONNECTED\"),\n        throwOnFailedPublish: !0\n      }), await this.deleteSession({\n        topic: t,\n        emitEvent: !1\n      });else if (this.client.core.pairing.pairings.keys.includes(t)) await this.client.core.pairing.disconnect({\n        topic: t\n      });else {\n        const {\n          message: s\n        } = w(\"MISMATCHED_TOPIC\", `Session or pairing topic not found: ${t}`);\n        throw new Error(s);\n      }\n    }), c(this, \"find\", e => (this.isInitialized(), this.client.session.getAll().filter(t => Gt(t, e)))), c(this, \"getPendingSessionRequests\", () => this.client.pendingRequest.getAll()), c(this, \"authenticate\", async (e, t) => {\n      var s;\n      this.isInitialized(), this.isValidAuthenticate(e);\n      const i = t && this.client.core.linkModeSupportedApps.includes(t) && ((s = this.client.metadata.redirect) == null ? void 0 : s.linkMode),\n        r = i ? T.link_mode : T.relay;\n      r === T.relay && (await this.confirmOnlineStateOrThrow());\n      const {\n          chains: o,\n          statement: a = \"\",\n          uri: l,\n          domain: u,\n          nonce: g,\n          type: h,\n          exp: d,\n          nbf: y,\n          methods: m = [],\n          expiry: I\n        } = e,\n        p = [...(e.resources || [])],\n        {\n          topic: E,\n          uri: V\n        } = await this.client.core.pairing.create({\n          methods: [\"wc_sessionAuthenticate\"],\n          transportType: r\n        });\n      this.client.logger.info({\n        message: \"Generated new pairing\",\n        pairing: {\n          topic: E,\n          uri: V\n        }\n      });\n      const q = await this.client.core.crypto.generateKeyPair(),\n        R = be(q);\n      if (await Promise.all([this.client.auth.authKeys.set(le, {\n        responseTopic: R,\n        publicKey: q\n      }), this.client.auth.pairingTopics.set(R, {\n        topic: R,\n        pairingTopic: E\n      })]), await this.client.core.relayer.subscribe(R, {\n        transportType: r\n      }), this.client.logger.info(`sending request to new pairing topic: ${E}`), m.length > 0) {\n        const {\n          namespace: b\n        } = Ae(o[0]);\n        let L = Ft(b, \"request\", m);\n        Ce(p) && (L = jt(L, p.pop())), p.push(L);\n      }\n      const D = I && I > N.wc_sessionAuthenticate.req.ttl ? I : N.wc_sessionAuthenticate.req.ttl,\n        ee = {\n          authPayload: {\n            type: h ?? \"caip122\",\n            chains: o,\n            statement: a,\n            aud: l,\n            domain: u,\n            version: \"1\",\n            nonce: g,\n            iat: new Date().toISOString(),\n            exp: d,\n            nbf: y,\n            resources: p\n          },\n          requester: {\n            publicKey: q,\n            metadata: this.client.metadata\n          },\n          expiryTimestamp: C(D)\n        },\n        P = {\n          eip155: {\n            chains: o,\n            methods: [...new Set([\"personal_sign\", ...m])],\n            events: [\"chainChanged\", \"accountsChanged\"]\n          }\n        },\n        X = {\n          requiredNamespaces: {},\n          optionalNamespaces: P,\n          relays: [{\n            protocol: \"irn\"\n          }],\n          pairingTopic: E,\n          proposer: {\n            publicKey: q,\n            metadata: this.client.metadata\n          },\n          expiryTimestamp: C(N.wc_sessionPropose.req.ttl),\n          id: G()\n        },\n        {\n          done: ft,\n          resolve: Fe,\n          reject: Re\n        } = Z(D, \"Request expired\"),\n        te = G(),\n        pe = f(\"session_connect\", X.id),\n        fe = f(\"session_request\", te),\n        he = async ({\n          error: b,\n          session: L\n        }) => {\n          this.events.off(fe, Ie), b ? Re(b) : L && Fe({\n            session: L\n          });\n        },\n        Ie = async b => {\n          var L, je, Qe;\n          if (await this.deletePendingAuthRequest(te, {\n            message: \"fulfilled\",\n            code: 0\n          }), b.error) {\n            const ie = O(\"WC_METHOD_UNSUPPORTED\", \"wc_sessionAuthenticate\");\n            return b.error.code === ie.code ? void 0 : (this.events.off(pe, he), Re(b.error.message));\n          }\n          await this.deleteProposal(X.id), this.events.off(pe, he);\n          const {\n              cacaos: He,\n              responder: Q\n            } = b.result,\n            qe = [],\n            ze = [];\n          for (const ie of He) {\n            (await et({\n              cacao: ie,\n              projectId: this.client.core.projectId\n            })) || (this.client.logger.error(ie, \"Signature verification failed\"), Re(O(\"SESSION_SETTLEMENT_FAILED\", \"Signature verification failed\")));\n            const {\n                p: Te\n              } = ie,\n              Ne = Ce(Te.resources),\n              Ye = [tt(Te.iss)],\n              It = st(Te.iss);\n            if (Ne) {\n              const Pe = it(Ne),\n                vt = rt(Ne);\n              qe.push(...Pe), Ye.push(...vt);\n            }\n            for (const Pe of Ye) ze.push(`${Pe}:${It}`);\n          }\n          const se = await this.client.core.crypto.generateSharedKey(q, Q.publicKey);\n          let de;\n          qe.length > 0 && (de = {\n            topic: se,\n            acknowledged: !0,\n            self: {\n              publicKey: q,\n              metadata: this.client.metadata\n            },\n            peer: Q,\n            controller: Q.publicKey,\n            expiry: C(Y),\n            requiredNamespaces: {},\n            optionalNamespaces: {},\n            relay: {\n              protocol: \"irn\"\n            },\n            pairingTopic: E,\n            namespaces: nt([...new Set(qe)], [...new Set(ze)]),\n            transportType: r\n          }, await this.client.core.relayer.subscribe(se, {\n            transportType: r\n          }), await this.client.session.set(se, de), E && (await this.client.core.pairing.updateMetadata({\n            topic: E,\n            metadata: Q.metadata\n          })), de = this.client.session.get(se)), (L = this.client.metadata.redirect) != null && L.linkMode && (je = Q.metadata.redirect) != null && je.linkMode && (Qe = Q.metadata.redirect) != null && Qe.universal && t && (this.client.core.addLinkModeSupportedApp(Q.metadata.redirect.universal), this.client.session.update(se, {\n            transportType: T.link_mode\n          })), Fe({\n            auths: He,\n            session: de\n          });\n        };\n      this.events.once(pe, he), this.events.once(fe, Ie);\n      let ve;\n      try {\n        if (i) {\n          const b = we(\"wc_sessionAuthenticate\", ee, te);\n          this.client.core.history.set(E, b);\n          const L = await this.client.core.crypto.encode(\"\", b, {\n            type: Qt,\n            encoding: ne\n          });\n          ve = ge(t, E, L);\n        } else await Promise.all([this.sendRequest({\n          topic: E,\n          method: \"wc_sessionAuthenticate\",\n          params: ee,\n          expiry: e.expiry,\n          throwOnFailedPublish: !0,\n          clientRpcId: te\n        }), this.sendRequest({\n          topic: E,\n          method: \"wc_sessionPropose\",\n          params: X,\n          expiry: N.wc_sessionPropose.req.ttl,\n          throwOnFailedPublish: !0,\n          clientRpcId: X.id\n        })]);\n      } catch (b) {\n        throw this.events.off(pe, he), this.events.off(fe, Ie), b;\n      }\n      return await this.setProposal(X.id, X), await this.setAuthRequest(te, {\n        request: x(v({}, ee), {\n          verifyContext: {}\n        }),\n        pairingTopic: E,\n        transportType: r\n      }), {\n        uri: ve ?? V,\n        response: ft\n      };\n    }), c(this, \"approveSessionAuthenticate\", async e => {\n      const {\n          id: t,\n          auths: s\n        } = e,\n        i = this.client.core.eventClient.createEvent({\n          properties: {\n            topic: t.toString(),\n            trace: [z.authenticated_session_approve_started]\n          }\n        });\n      try {\n        this.isInitialized();\n      } catch (I) {\n        throw i.setError(re.no_internet_connection), I;\n      }\n      const r = this.getPendingAuthRequest(t);\n      if (!r) throw i.setError(re.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${t}`);\n      const o = r.transportType || T.relay;\n      o === T.relay && (await this.confirmOnlineStateOrThrow());\n      const a = r.requester.publicKey,\n        l = await this.client.core.crypto.generateKeyPair(),\n        u = be(a),\n        g = {\n          type: Ve,\n          receiverPublicKey: a,\n          senderPublicKey: l\n        },\n        h = [],\n        d = [];\n      for (const I of s) {\n        if (!(await et({\n          cacao: I,\n          projectId: this.client.core.projectId\n        }))) {\n          i.setError(re.invalid_cacao);\n          const R = O(\"SESSION_SETTLEMENT_FAILED\", \"Signature verification failed\");\n          throw await this.sendError({\n            id: t,\n            topic: u,\n            error: R,\n            encodeOpts: g\n          }), new Error(R.message);\n        }\n        i.addTrace(z.cacaos_verified);\n        const {\n            p\n          } = I,\n          E = Ce(p.resources),\n          V = [tt(p.iss)],\n          q = st(p.iss);\n        if (E) {\n          const R = it(E),\n            D = rt(E);\n          h.push(...R), V.push(...D);\n        }\n        for (const R of V) d.push(`${R}:${q}`);\n      }\n      const y = await this.client.core.crypto.generateSharedKey(l, a);\n      i.addTrace(z.create_authenticated_session_topic);\n      let m;\n      if (h?.length > 0) {\n        m = {\n          topic: y,\n          acknowledged: !0,\n          self: {\n            publicKey: l,\n            metadata: this.client.metadata\n          },\n          peer: {\n            publicKey: a,\n            metadata: r.requester.metadata\n          },\n          controller: a,\n          expiry: C(Y),\n          authentication: s,\n          requiredNamespaces: {},\n          optionalNamespaces: {},\n          relay: {\n            protocol: \"irn\"\n          },\n          pairingTopic: r.pairingTopic,\n          namespaces: nt([...new Set(h)], [...new Set(d)]),\n          transportType: o\n        }, i.addTrace(z.subscribing_authenticated_session_topic);\n        try {\n          await this.client.core.relayer.subscribe(y, {\n            transportType: o\n          });\n        } catch (I) {\n          throw i.setError(re.subscribe_authenticated_session_topic_failure), I;\n        }\n        i.addTrace(z.subscribe_authenticated_session_topic_success), await this.client.session.set(y, m), i.addTrace(z.store_authenticated_session), await this.client.core.pairing.updateMetadata({\n          topic: r.pairingTopic,\n          metadata: r.requester.metadata\n        });\n      }\n      i.addTrace(z.publishing_authenticated_session_approve);\n      try {\n        await this.sendResult({\n          topic: u,\n          id: t,\n          result: {\n            cacaos: s,\n            responder: {\n              publicKey: l,\n              metadata: this.client.metadata\n            }\n          },\n          encodeOpts: g,\n          throwOnFailedPublish: !0,\n          appLink: this.getAppLinkIfEnabled(r.requester.metadata, o)\n        });\n      } catch (I) {\n        throw i.setError(re.authenticated_session_approve_publish_failure), I;\n      }\n      return await this.client.auth.requests.delete(t, {\n        message: \"fulfilled\",\n        code: 0\n      }), await this.client.core.pairing.activate({\n        topic: r.pairingTopic\n      }), this.client.core.eventClient.deleteEvent({\n        eventId: i.eventId\n      }), {\n        session: m\n      };\n    }), c(this, \"rejectSessionAuthenticate\", async e => {\n      this.isInitialized();\n      const {\n          id: t,\n          reason: s\n        } = e,\n        i = this.getPendingAuthRequest(t);\n      if (!i) throw new Error(`Could not find pending auth request with id ${t}`);\n      i.transportType === T.relay && (await this.confirmOnlineStateOrThrow());\n      const r = i.requester.publicKey,\n        o = await this.client.core.crypto.generateKeyPair(),\n        a = be(r),\n        l = {\n          type: Ve,\n          receiverPublicKey: r,\n          senderPublicKey: o\n        };\n      await this.sendError({\n        id: t,\n        topic: a,\n        error: s,\n        encodeOpts: l,\n        rpcOpts: N.wc_sessionAuthenticate.reject,\n        appLink: this.getAppLinkIfEnabled(i.requester.metadata, i.transportType)\n      }), await this.client.auth.requests.delete(t, {\n        message: \"rejected\",\n        code: 0\n      }), await this.client.proposal.delete(t, O(\"USER_DISCONNECTED\"));\n    }), c(this, \"formatAuthMessage\", e => {\n      this.isInitialized();\n      const {\n        request: t,\n        iss: s\n      } = e;\n      return Ht(t, s);\n    }), c(this, \"processRelayMessageCache\", () => {\n      setTimeout(async () => {\n        if (this.relayMessageCache.length !== 0) for (; this.relayMessageCache.length > 0;) try {\n          const e = this.relayMessageCache.shift();\n          e && (await this.onRelayMessage(e));\n        } catch (e) {\n          this.client.logger.error(e);\n        }\n      }, 50);\n    }), c(this, \"cleanupDuplicatePairings\", async e => {\n      if (e.pairingTopic) try {\n        const t = this.client.core.pairing.pairings.get(e.pairingTopic),\n          s = this.client.core.pairing.pairings.getAll().filter(i => {\n            var r, o;\n            return ((r = i.peerMetadata) == null ? void 0 : r.url) && ((o = i.peerMetadata) == null ? void 0 : o.url) === e.peer.metadata.url && i.topic && i.topic !== t.topic;\n          });\n        if (s.length === 0) return;\n        this.client.logger.info(`Cleaning up ${s.length} duplicate pairing(s)`), await Promise.all(s.map(i => this.client.core.pairing.disconnect({\n          topic: i.topic\n        }))), this.client.logger.info(\"Duplicate pairings clean up finished\");\n      } catch (t) {\n        this.client.logger.error(t);\n      }\n    }), c(this, \"deleteSession\", async e => {\n      var t;\n      const {\n          topic: s,\n          expirerHasDeleted: i = !1,\n          emitEvent: r = !0,\n          id: o = 0\n        } = e,\n        {\n          self: a\n        } = this.client.session.get(s);\n      await this.client.core.relayer.unsubscribe(s), await this.client.session.delete(s, O(\"USER_DISCONNECTED\")), this.addToRecentlyDeleted(s, \"session\"), this.client.core.crypto.keychain.has(a.publicKey) && (await this.client.core.crypto.deleteKeyPair(a.publicKey)), this.client.core.crypto.keychain.has(s) && (await this.client.core.crypto.deleteSymKey(s)), i || this.client.core.expirer.del(s), this.client.core.storage.removeItem(ke).catch(l => this.client.logger.warn(l)), this.getPendingSessionRequests().forEach(l => {\n        l.topic === s && this.deletePendingSessionRequest(l.id, O(\"USER_DISCONNECTED\"));\n      }), s === ((t = this.sessionRequestQueue.queue[0]) == null ? void 0 : t.topic) && (this.sessionRequestQueue.state = $.idle), r && this.client.events.emit(\"session_delete\", {\n        id: o,\n        topic: s\n      });\n    }), c(this, \"deleteProposal\", async (e, t) => {\n      if (t) try {\n        const s = this.client.proposal.get(e),\n          i = this.client.core.eventClient.getEvent({\n            topic: s.pairingTopic\n          });\n        i?.setError(H.proposal_expired);\n      } catch {}\n      await Promise.all([this.client.proposal.delete(e, O(\"USER_DISCONNECTED\")), t ? Promise.resolve() : this.client.core.expirer.del(e)]), this.addToRecentlyDeleted(e, \"proposal\");\n    }), c(this, \"deletePendingSessionRequest\", async (e, t, s = !1) => {\n      await Promise.all([this.client.pendingRequest.delete(e, t), s ? Promise.resolve() : this.client.core.expirer.del(e)]), this.addToRecentlyDeleted(e, \"request\"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter(i => i.id !== e), s && (this.sessionRequestQueue.state = $.idle, this.client.events.emit(\"session_request_expire\", {\n        id: e\n      }));\n    }), c(this, \"deletePendingAuthRequest\", async (e, t, s = !1) => {\n      await Promise.all([this.client.auth.requests.delete(e, t), s ? Promise.resolve() : this.client.core.expirer.del(e)]);\n    }), c(this, \"setExpiry\", async (e, t) => {\n      this.client.session.keys.includes(e) && (this.client.core.expirer.set(e, t), await this.client.session.update(e, {\n        expiry: t\n      }));\n    }), c(this, \"setProposal\", async (e, t) => {\n      this.client.core.expirer.set(e, C(N.wc_sessionPropose.req.ttl)), await this.client.proposal.set(e, t);\n    }), c(this, \"setAuthRequest\", async (e, t) => {\n      const {\n        request: s,\n        pairingTopic: i,\n        transportType: r = T.relay\n      } = t;\n      this.client.core.expirer.set(e, s.expiryTimestamp), await this.client.auth.requests.set(e, {\n        authPayload: s.authPayload,\n        requester: s.requester,\n        expiryTimestamp: s.expiryTimestamp,\n        id: e,\n        pairingTopic: i,\n        verifyContext: s.verifyContext,\n        transportType: r\n      });\n    }), c(this, \"setPendingSessionRequest\", async e => {\n      const {\n          id: t,\n          topic: s,\n          params: i,\n          verifyContext: r\n        } = e,\n        o = i.request.expiryTimestamp || C(N.wc_sessionRequest.req.ttl);\n      this.client.core.expirer.set(t, o), await this.client.pendingRequest.set(t, {\n        id: t,\n        topic: s,\n        params: i,\n        verifyContext: r\n      });\n    }), c(this, \"sendRequest\", async e => {\n      const {\n          topic: t,\n          method: s,\n          params: i,\n          expiry: r,\n          relayRpcId: o,\n          clientRpcId: a,\n          throwOnFailedPublish: l,\n          appLink: u,\n          tvf: g\n        } = e,\n        h = we(s, i, a);\n      let d;\n      const y = !!u;\n      try {\n        const p = y ? ne : ue;\n        d = await this.client.core.crypto.encode(t, h, {\n          encoding: p\n        });\n      } catch (p) {\n        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${t} failed`), p;\n      }\n      let m;\n      if (gt.includes(s)) {\n        const p = B(JSON.stringify(h)),\n          E = B(d);\n        m = await this.client.core.verify.register({\n          id: E,\n          decryptedId: p\n        });\n      }\n      const I = N[s].req;\n      if (I.attestation = m, r && (I.ttl = r), o && (I.id = o), this.client.core.history.set(t, h), y) {\n        const p = ge(u, t, d);\n        await global.Linking.openURL(p, this.client.name);\n      } else {\n        const p = N[s].req;\n        r && (p.ttl = r), o && (p.id = o), p.tvf = x(v({}, g), {\n          correlationId: h.id\n        }), l ? (p.internal = x(v({}, p.internal), {\n          throwOnFailedPublish: !0\n        }), await this.client.core.relayer.publish(t, d, p)) : this.client.core.relayer.publish(t, d, p).catch(E => this.client.logger.error(E));\n      }\n      return h.id;\n    }), c(this, \"sendResult\", async e => {\n      const {\n          id: t,\n          topic: s,\n          result: i,\n          throwOnFailedPublish: r,\n          encodeOpts: o,\n          appLink: a\n        } = e,\n        l = ds(t, i);\n      let u;\n      const g = a && typeof (global == null ? void 0 : global.Linking) < \"u\";\n      try {\n        const y = g ? ne : ue;\n        u = await this.client.core.crypto.encode(s, l, x(v({}, o || {}), {\n          encoding: y\n        }));\n      } catch (y) {\n        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s} failed`), y;\n      }\n      let h, d;\n      try {\n        h = await this.client.core.history.get(s, t);\n        const y = h.request;\n        try {\n          this.shouldSetTVF(y.method, y.params) && (d = this.getTVFParams(t, y.params, i));\n        } catch (m) {\n          this.client.logger.warn(\"sendResult() -> getTVFParams() failed\", m);\n        }\n      } catch (y) {\n        throw this.client.logger.error(`sendResult() -> history.get(${s}, ${t}) failed`), y;\n      }\n      if (g) {\n        const y = ge(a, s, u);\n        await global.Linking.openURL(y, this.client.name);\n      } else {\n        const y = h.request.method,\n          m = N[y].res;\n        m.tvf = x(v({}, d), {\n          correlationId: t\n        }), r ? (m.internal = x(v({}, m.internal), {\n          throwOnFailedPublish: !0\n        }), await this.client.core.relayer.publish(s, u, m)) : this.client.core.relayer.publish(s, u, m).catch(I => this.client.logger.error(I));\n      }\n      await this.client.core.history.resolve(l);\n    }), c(this, \"sendError\", async e => {\n      const {\n          id: t,\n          topic: s,\n          error: i,\n          encodeOpts: r,\n          rpcOpts: o,\n          appLink: a\n        } = e,\n        l = us(t, i);\n      let u;\n      const g = a && typeof (global == null ? void 0 : global.Linking) < \"u\";\n      try {\n        const d = g ? ne : ue;\n        u = await this.client.core.crypto.encode(s, l, x(v({}, r || {}), {\n          encoding: d\n        }));\n      } catch (d) {\n        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s} failed`), d;\n      }\n      let h;\n      try {\n        h = await this.client.core.history.get(s, t);\n      } catch (d) {\n        throw this.client.logger.error(`sendError() -> history.get(${s}, ${t}) failed`), d;\n      }\n      if (g) {\n        const d = ge(a, s, u);\n        await global.Linking.openURL(d, this.client.name);\n      } else {\n        const d = h.request.method,\n          y = o || N[d].res;\n        this.client.core.relayer.publish(s, u, y);\n      }\n      await this.client.core.history.resolve(l);\n    }), c(this, \"cleanup\", async () => {\n      const e = [],\n        t = [];\n      this.client.session.getAll().forEach(s => {\n        let i = !1;\n        W(s.expiry) && (i = !0), this.client.core.crypto.keychain.has(s.topic) || (i = !0), i && e.push(s.topic);\n      }), this.client.proposal.getAll().forEach(s => {\n        W(s.expiryTimestamp) && t.push(s.id);\n      }), await Promise.all([...e.map(s => this.deleteSession({\n        topic: s\n      })), ...t.map(s => this.deleteProposal(s))]);\n    }), c(this, \"onRelayEventRequest\", async e => {\n      this.requestQueue.queue.push(e), await this.processRequestsQueue();\n    }), c(this, \"processRequestsQueue\", async () => {\n      if (this.requestQueue.state === $.active) {\n        this.client.logger.info(\"Request queue already active, skipping...\");\n        return;\n      }\n      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0;) {\n        this.requestQueue.state = $.active;\n        const e = this.requestQueue.queue.shift();\n        if (e) try {\n          await this.processRequest(e);\n        } catch (t) {\n          this.client.logger.warn(t);\n        }\n      }\n      this.requestQueue.state = $.idle;\n    }), c(this, \"processRequest\", async e => {\n      const {\n          topic: t,\n          payload: s,\n          attestation: i,\n          transportType: r,\n          encryptedId: o\n        } = e,\n        a = s.method;\n      if (!this.shouldIgnorePairingRequest({\n        topic: t,\n        requestMethod: a\n      })) switch (a) {\n        case \"wc_sessionPropose\":\n          return await this.onSessionProposeRequest({\n            topic: t,\n            payload: s,\n            attestation: i,\n            encryptedId: o\n          });\n        case \"wc_sessionSettle\":\n          return await this.onSessionSettleRequest(t, s);\n        case \"wc_sessionUpdate\":\n          return await this.onSessionUpdateRequest(t, s);\n        case \"wc_sessionExtend\":\n          return await this.onSessionExtendRequest(t, s);\n        case \"wc_sessionPing\":\n          return await this.onSessionPingRequest(t, s);\n        case \"wc_sessionDelete\":\n          return await this.onSessionDeleteRequest(t, s);\n        case \"wc_sessionRequest\":\n          return await this.onSessionRequest({\n            topic: t,\n            payload: s,\n            attestation: i,\n            encryptedId: o,\n            transportType: r\n          });\n        case \"wc_sessionEvent\":\n          return await this.onSessionEventRequest(t, s);\n        case \"wc_sessionAuthenticate\":\n          return await this.onSessionAuthenticateRequest({\n            topic: t,\n            payload: s,\n            attestation: i,\n            encryptedId: o,\n            transportType: r\n          });\n        default:\n          return this.client.logger.info(`Unsupported request method ${a}`);\n      }\n    }), c(this, \"onRelayEventResponse\", async e => {\n      const {\n          topic: t,\n          payload: s,\n          transportType: i\n        } = e,\n        r = (await this.client.core.history.get(t, s.id)).request.method;\n      switch (r) {\n        case \"wc_sessionPropose\":\n          return this.onSessionProposeResponse(t, s, i);\n        case \"wc_sessionSettle\":\n          return this.onSessionSettleResponse(t, s);\n        case \"wc_sessionUpdate\":\n          return this.onSessionUpdateResponse(t, s);\n        case \"wc_sessionExtend\":\n          return this.onSessionExtendResponse(t, s);\n        case \"wc_sessionPing\":\n          return this.onSessionPingResponse(t, s);\n        case \"wc_sessionRequest\":\n          return this.onSessionRequestResponse(t, s);\n        case \"wc_sessionAuthenticate\":\n          return this.onSessionAuthenticateResponse(t, s);\n        default:\n          return this.client.logger.info(`Unsupported response method ${r}`);\n      }\n    }), c(this, \"onRelayEventUnknownPayload\", e => {\n      const {\n          topic: t\n        } = e,\n        {\n          message: s\n        } = w(\"MISSING_OR_INVALID\", `Decoded payload on topic ${t} is not identifiable as a JSON-RPC request or a response.`);\n      throw new Error(s);\n    }), c(this, \"shouldIgnorePairingRequest\", e => {\n      const {\n          topic: t,\n          requestMethod: s\n        } = e,\n        i = this.expectedPairingMethodMap.get(t);\n      return !i || i.includes(s) ? !1 : !!(i.includes(\"wc_sessionAuthenticate\") && this.client.events.listenerCount(\"session_authenticate\") > 0);\n    }), c(this, \"onSessionProposeRequest\", async e => {\n      const {\n          topic: t,\n          payload: s,\n          attestation: i,\n          encryptedId: r\n        } = e,\n        {\n          params: o,\n          id: a\n        } = s;\n      try {\n        const l = this.client.core.eventClient.getEvent({\n          topic: t\n        });\n        this.client.events.listenerCount(\"session_proposal\") === 0 && (console.warn(\"No listener for session_proposal event\"), l?.setError(Nt.proposal_listener_not_found)), this.isValidConnect(v({}, s.params));\n        const u = o.expiryTimestamp || C(N.wc_sessionPropose.req.ttl),\n          g = v({\n            id: a,\n            pairingTopic: t,\n            expiryTimestamp: u\n          }, o);\n        await this.setProposal(a, g);\n        const h = await this.getVerifyContext({\n          attestationId: i,\n          hash: B(JSON.stringify(s)),\n          encryptedId: r,\n          metadata: g.proposer.metadata\n        });\n        l?.addTrace(Pt.emit_session_proposal), this.client.events.emit(\"session_proposal\", {\n          id: a,\n          params: g,\n          verifyContext: h\n        });\n      } catch (l) {\n        await this.sendError({\n          id: a,\n          topic: t,\n          error: l,\n          rpcOpts: N.wc_sessionPropose.autoReject\n        }), this.client.logger.error(l);\n      }\n    }), c(this, \"onSessionProposeResponse\", async (e, t, s) => {\n      const {\n        id: i\n      } = t;\n      if (F(t)) {\n        const {\n          result: r\n        } = t;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          result: r\n        });\n        const o = this.client.proposal.get(i);\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          proposal: o\n        });\n        const a = o.proposer.publicKey;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          selfPublicKey: a\n        });\n        const l = r.responderPublicKey;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          peerPublicKey: l\n        });\n        const u = await this.client.core.crypto.generateSharedKey(a, l);\n        this.pendingSessions.set(i, {\n          sessionTopic: u,\n          pairingTopic: e,\n          proposalId: i,\n          publicKey: a\n        });\n        const g = await this.client.core.relayer.subscribe(u, {\n          transportType: s\n        });\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          subscriptionId: g\n        }), await this.client.core.pairing.activate({\n          topic: e\n        });\n      } else if (j(t)) {\n        await this.client.proposal.delete(i, O(\"USER_DISCONNECTED\"));\n        const r = f(\"session_connect\", i);\n        if (this.events.listenerCount(r) === 0) throw new Error(`emitting ${r} without any listeners, 954`);\n        this.events.emit(r, {\n          error: t.error\n        });\n      }\n    }), c(this, \"onSessionSettleRequest\", async (e, t) => {\n      const {\n        id: s,\n        params: i\n      } = t;\n      try {\n        this.isValidSessionSettleRequest(i);\n        const {\n            relay: r,\n            controller: o,\n            expiry: a,\n            namespaces: l,\n            sessionProperties: u,\n            sessionConfig: g\n          } = t.params,\n          h = [...this.pendingSessions.values()].find(m => m.sessionTopic === e);\n        if (!h) return this.client.logger.error(`Pending session not found for topic ${e}`);\n        const d = this.client.proposal.get(h.proposalId),\n          y = x(v(v({\n            topic: e,\n            relay: r,\n            expiry: a,\n            namespaces: l,\n            acknowledged: !0,\n            pairingTopic: h.pairingTopic,\n            requiredNamespaces: d.requiredNamespaces,\n            optionalNamespaces: d.optionalNamespaces,\n            controller: o.publicKey,\n            self: {\n              publicKey: h.publicKey,\n              metadata: this.client.metadata\n            },\n            peer: {\n              publicKey: o.publicKey,\n              metadata: o.metadata\n            }\n          }, u && {\n            sessionProperties: u\n          }), g && {\n            sessionConfig: g\n          }), {\n            transportType: T.relay\n          });\n        await this.client.session.set(y.topic, y), await this.setExpiry(y.topic, y.expiry), await this.client.core.pairing.updateMetadata({\n          topic: h.pairingTopic,\n          metadata: y.peer.metadata\n        }), this.client.events.emit(\"session_connect\", {\n          session: y\n        }), this.events.emit(f(\"session_connect\", h.proposalId), {\n          session: y\n        }), this.pendingSessions.delete(h.proposalId), this.deleteProposal(h.proposalId, !1), this.cleanupDuplicatePairings(y), await this.sendResult({\n          id: t.id,\n          topic: e,\n          result: !0,\n          throwOnFailedPublish: !0\n        });\n      } catch (r) {\n        await this.sendError({\n          id: s,\n          topic: e,\n          error: r\n        }), this.client.logger.error(r);\n      }\n    }), c(this, \"onSessionSettleResponse\", async (e, t) => {\n      const {\n        id: s\n      } = t;\n      F(t) ? (await this.client.session.update(e, {\n        acknowledged: !0\n      }), this.events.emit(f(\"session_approve\", s), {})) : j(t) && (await this.client.session.delete(e, O(\"USER_DISCONNECTED\")), this.events.emit(f(\"session_approve\", s), {\n        error: t.error\n      }));\n    }), c(this, \"onSessionUpdateRequest\", async (e, t) => {\n      const {\n        params: s,\n        id: i\n      } = t;\n      try {\n        const r = `${e}_session_update`,\n          o = oe.get(r);\n        if (o && this.isRequestOutOfSync(o, i)) {\n          this.client.logger.warn(`Discarding out of sync request - ${i}`), this.sendError({\n            id: i,\n            topic: e,\n            error: O(\"INVALID_UPDATE_REQUEST\")\n          });\n          return;\n        }\n        this.isValidUpdate(v({\n          topic: e\n        }, s));\n        try {\n          oe.set(r, i), await this.client.session.update(e, {\n            namespaces: s.namespaces\n          }), await this.sendResult({\n            id: i,\n            topic: e,\n            result: !0,\n            throwOnFailedPublish: !0\n          });\n        } catch (a) {\n          throw oe.delete(r), a;\n        }\n        this.client.events.emit(\"session_update\", {\n          id: i,\n          topic: e,\n          params: s\n        });\n      } catch (r) {\n        await this.sendError({\n          id: i,\n          topic: e,\n          error: r\n        }), this.client.logger.error(r);\n      }\n    }), c(this, \"isRequestOutOfSync\", (e, t) => t.toString().slice(0, -3) < e.toString().slice(0, -3)), c(this, \"onSessionUpdateResponse\", (e, t) => {\n      const {\n          id: s\n        } = t,\n        i = f(\"session_update\", s);\n      if (this.events.listenerCount(i) === 0) throw new Error(`emitting ${i} without any listeners`);\n      F(t) ? this.events.emit(f(\"session_update\", s), {}) : j(t) && this.events.emit(f(\"session_update\", s), {\n        error: t.error\n      });\n    }), c(this, \"onSessionExtendRequest\", async (e, t) => {\n      const {\n        id: s\n      } = t;\n      try {\n        this.isValidExtend({\n          topic: e\n        }), await this.setExpiry(e, C(Y)), await this.sendResult({\n          id: s,\n          topic: e,\n          result: !0,\n          throwOnFailedPublish: !0\n        }), this.client.events.emit(\"session_extend\", {\n          id: s,\n          topic: e\n        });\n      } catch (i) {\n        await this.sendError({\n          id: s,\n          topic: e,\n          error: i\n        }), this.client.logger.error(i);\n      }\n    }), c(this, \"onSessionExtendResponse\", (e, t) => {\n      const {\n          id: s\n        } = t,\n        i = f(\"session_extend\", s);\n      if (this.events.listenerCount(i) === 0) throw new Error(`emitting ${i} without any listeners`);\n      F(t) ? this.events.emit(f(\"session_extend\", s), {}) : j(t) && this.events.emit(f(\"session_extend\", s), {\n        error: t.error\n      });\n    }), c(this, \"onSessionPingRequest\", async (e, t) => {\n      const {\n        id: s\n      } = t;\n      try {\n        this.isValidPing({\n          topic: e\n        }), await this.sendResult({\n          id: s,\n          topic: e,\n          result: !0,\n          throwOnFailedPublish: !0\n        }), this.client.events.emit(\"session_ping\", {\n          id: s,\n          topic: e\n        });\n      } catch (i) {\n        await this.sendError({\n          id: s,\n          topic: e,\n          error: i\n        }), this.client.logger.error(i);\n      }\n    }), c(this, \"onSessionPingResponse\", (e, t) => {\n      const {\n          id: s\n        } = t,\n        i = f(\"session_ping\", s);\n      if (this.events.listenerCount(i) === 0) throw new Error(`emitting ${i} without any listeners`);\n      setTimeout(() => {\n        F(t) ? this.events.emit(f(\"session_ping\", s), {}) : j(t) && this.events.emit(f(\"session_ping\", s), {\n          error: t.error\n        });\n      }, 500);\n    }), c(this, \"onSessionDeleteRequest\", async (e, t) => {\n      const {\n        id: s\n      } = t;\n      try {\n        this.isValidDisconnect({\n          topic: e,\n          reason: t.params\n        }), Promise.all([new Promise(i => {\n          this.client.core.relayer.once(Xe.publish, async () => {\n            i(await this.deleteSession({\n              topic: e,\n              id: s\n            }));\n          });\n        }), this.sendResult({\n          id: s,\n          topic: e,\n          result: !0,\n          throwOnFailedPublish: !0\n        }), this.cleanupPendingSentRequestsForTopic({\n          topic: e,\n          error: O(\"USER_DISCONNECTED\")\n        })]).catch(i => this.client.logger.error(i));\n      } catch (i) {\n        this.client.logger.error(i);\n      }\n    }), c(this, \"onSessionRequest\", async e => {\n      var t, s, i;\n      const {\n          topic: r,\n          payload: o,\n          attestation: a,\n          encryptedId: l,\n          transportType: u\n        } = e,\n        {\n          id: g,\n          params: h\n        } = o;\n      try {\n        await this.isValidRequest(v({\n          topic: r\n        }, h));\n        const d = this.client.session.get(r),\n          y = await this.getVerifyContext({\n            attestationId: a,\n            hash: B(JSON.stringify(we(\"wc_sessionRequest\", h, g))),\n            encryptedId: l,\n            metadata: d.peer.metadata,\n            transportType: u\n          }),\n          m = {\n            id: g,\n            topic: r,\n            params: h,\n            verifyContext: y\n          };\n        await this.setPendingSessionRequest(m), u === T.link_mode && (t = d.peer.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp((s = d.peer.metadata.redirect) == null ? void 0 : s.universal), (i = this.client.signConfig) != null && i.disableRequestQueue ? this.emitSessionRequest(m) : (this.addSessionRequestToSessionRequestQueue(m), this.processSessionRequestQueue());\n      } catch (d) {\n        await this.sendError({\n          id: g,\n          topic: r,\n          error: d\n        }), this.client.logger.error(d);\n      }\n    }), c(this, \"onSessionRequestResponse\", (e, t) => {\n      const {\n          id: s\n        } = t,\n        i = f(\"session_request\", s);\n      if (this.events.listenerCount(i) === 0) throw new Error(`emitting ${i} without any listeners`);\n      F(t) ? this.events.emit(f(\"session_request\", s), {\n        result: t.result\n      }) : j(t) && this.events.emit(f(\"session_request\", s), {\n        error: t.error\n      });\n    }), c(this, \"onSessionEventRequest\", async (e, t) => {\n      const {\n        id: s,\n        params: i\n      } = t;\n      try {\n        const r = `${e}_session_event_${i.event.name}`,\n          o = oe.get(r);\n        if (o && this.isRequestOutOfSync(o, s)) {\n          this.client.logger.info(`Discarding out of sync request - ${s}`);\n          return;\n        }\n        this.isValidEmit(v({\n          topic: e\n        }, i)), this.client.events.emit(\"session_event\", {\n          id: s,\n          topic: e,\n          params: i\n        }), oe.set(r, s);\n      } catch (r) {\n        await this.sendError({\n          id: s,\n          topic: e,\n          error: r\n        }), this.client.logger.error(r);\n      }\n    }), c(this, \"onSessionAuthenticateResponse\", (e, t) => {\n      const {\n        id: s\n      } = t;\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionAuthenticateResponse\",\n        topic: e,\n        payload: t\n      }), F(t) ? this.events.emit(f(\"session_request\", s), {\n        result: t.result\n      }) : j(t) && this.events.emit(f(\"session_request\", s), {\n        error: t.error\n      });\n    }), c(this, \"onSessionAuthenticateRequest\", async e => {\n      var t;\n      const {\n        topic: s,\n        payload: i,\n        attestation: r,\n        encryptedId: o,\n        transportType: a\n      } = e;\n      try {\n        const {\n            requester: l,\n            authPayload: u,\n            expiryTimestamp: g\n          } = i.params,\n          h = await this.getVerifyContext({\n            attestationId: r,\n            hash: B(JSON.stringify(i)),\n            encryptedId: o,\n            metadata: l.metadata,\n            transportType: a\n          }),\n          d = {\n            requester: l,\n            pairingTopic: s,\n            id: i.id,\n            authPayload: u,\n            verifyContext: h,\n            expiryTimestamp: g\n          };\n        await this.setAuthRequest(i.id, {\n          request: d,\n          pairingTopic: s,\n          transportType: a\n        }), a === T.link_mode && (t = l.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp(l.metadata.redirect.universal), this.client.events.emit(\"session_authenticate\", {\n          topic: s,\n          params: i.params,\n          id: i.id,\n          verifyContext: h\n        });\n      } catch (l) {\n        this.client.logger.error(l);\n        const u = i.params.requester.publicKey,\n          g = await this.client.core.crypto.generateKeyPair(),\n          h = this.getAppLinkIfEnabled(i.params.requester.metadata, a),\n          d = {\n            type: Ve,\n            receiverPublicKey: u,\n            senderPublicKey: g\n          };\n        await this.sendError({\n          id: i.id,\n          topic: s,\n          error: l,\n          encodeOpts: d,\n          rpcOpts: N.wc_sessionAuthenticate.autoReject,\n          appLink: h\n        });\n      }\n    }), c(this, \"addSessionRequestToSessionRequestQueue\", e => {\n      this.sessionRequestQueue.queue.push(e);\n    }), c(this, \"cleanupAfterResponse\", e => {\n      this.deletePendingSessionRequest(e.response.id, {\n        message: \"fulfilled\",\n        code: 0\n      }), setTimeout(() => {\n        this.sessionRequestQueue.state = $.idle, this.processSessionRequestQueue();\n      }, Oe(this.requestQueueDelay));\n    }), c(this, \"cleanupPendingSentRequestsForTopic\", ({\n      topic: e,\n      error: t\n    }) => {\n      const s = this.client.core.history.pending;\n      s.length > 0 && s.filter(i => i.topic === e && i.request.method === \"wc_sessionRequest\").forEach(i => {\n        const r = i.request.id,\n          o = f(\"session_request\", r);\n        if (this.events.listenerCount(o) === 0) throw new Error(`emitting ${o} without any listeners`);\n        this.events.emit(f(\"session_request\", i.request.id), {\n          error: t\n        });\n      });\n    }), c(this, \"processSessionRequestQueue\", () => {\n      if (this.sessionRequestQueue.state === $.active) {\n        this.client.logger.info(\"session request queue is already active.\");\n        return;\n      }\n      const e = this.sessionRequestQueue.queue[0];\n      if (!e) {\n        this.client.logger.info(\"session request queue is empty.\");\n        return;\n      }\n      try {\n        this.sessionRequestQueue.state = $.active, this.emitSessionRequest(e);\n      } catch (t) {\n        this.client.logger.error(t);\n      }\n    }), c(this, \"emitSessionRequest\", e => {\n      this.client.events.emit(\"session_request\", e);\n    }), c(this, \"onPairingCreated\", e => {\n      if (e.methods && this.expectedPairingMethodMap.set(e.topic, e.methods), e.active) return;\n      const t = this.client.proposal.getAll().find(s => s.pairingTopic === e.topic);\n      t && this.onSessionProposeRequest({\n        topic: e.topic,\n        payload: we(\"wc_sessionPropose\", {\n          requiredNamespaces: t.requiredNamespaces,\n          optionalNamespaces: t.optionalNamespaces,\n          relays: t.relays,\n          proposer: t.proposer,\n          sessionProperties: t.sessionProperties\n        }, t.id)\n      });\n    }), c(this, \"isValidConnect\", async e => {\n      if (!k(e)) {\n        const {\n          message: a\n        } = w(\"MISSING_OR_INVALID\", `connect() params: ${JSON.stringify(e)}`);\n        throw new Error(a);\n      }\n      const {\n        pairingTopic: t,\n        requiredNamespaces: s,\n        optionalNamespaces: i,\n        sessionProperties: r,\n        relays: o\n      } = e;\n      if (ae(t) || (await this.isValidPairingTopic(t)), !zt(o, !0)) {\n        const {\n          message: a\n        } = w(\"MISSING_OR_INVALID\", `connect() relays: ${o}`);\n        throw new Error(a);\n      }\n      !ae(s) && ot(s) !== 0 && this.validateNamespaces(s, \"requiredNamespaces\"), !ae(i) && ot(i) !== 0 && this.validateNamespaces(i, \"optionalNamespaces\"), ae(r) || this.validateSessionProps(r, \"sessionProperties\");\n    }), c(this, \"validateNamespaces\", (e, t) => {\n      const s = Yt(e, \"connect()\", t);\n      if (s) throw new Error(s.message);\n    }), c(this, \"isValidApprove\", async e => {\n      if (!k(e)) throw new Error(w(\"MISSING_OR_INVALID\", `approve() params: ${e}`).message);\n      const {\n        id: t,\n        namespaces: s,\n        relayProtocol: i,\n        sessionProperties: r\n      } = e;\n      this.checkRecentlyDeleted(t), await this.isValidProposalId(t);\n      const o = this.client.proposal.get(t),\n        a = xe(s, \"approve()\");\n      if (a) throw new Error(a.message);\n      const l = at(o.requiredNamespaces, s, \"approve()\");\n      if (l) throw new Error(l.message);\n      if (!U(i, !0)) {\n        const {\n          message: u\n        } = w(\"MISSING_OR_INVALID\", `approve() relayProtocol: ${i}`);\n        throw new Error(u);\n      }\n      ae(r) || this.validateSessionProps(r, \"sessionProperties\");\n    }), c(this, \"isValidReject\", async e => {\n      if (!k(e)) {\n        const {\n          message: i\n        } = w(\"MISSING_OR_INVALID\", `reject() params: ${e}`);\n        throw new Error(i);\n      }\n      const {\n        id: t,\n        reason: s\n      } = e;\n      if (this.checkRecentlyDeleted(t), await this.isValidProposalId(t), !Xt(s)) {\n        const {\n          message: i\n        } = w(\"MISSING_OR_INVALID\", `reject() reason: ${JSON.stringify(s)}`);\n        throw new Error(i);\n      }\n    }), c(this, \"isValidSessionSettleRequest\", e => {\n      if (!k(e)) {\n        const {\n          message: l\n        } = w(\"MISSING_OR_INVALID\", `onSessionSettleRequest() params: ${e}`);\n        throw new Error(l);\n      }\n      const {\n        relay: t,\n        controller: s,\n        namespaces: i,\n        expiry: r\n      } = e;\n      if (!Jt(t)) {\n        const {\n          message: l\n        } = w(\"MISSING_OR_INVALID\", \"onSessionSettleRequest() relay protocol should be a string\");\n        throw new Error(l);\n      }\n      const o = Bt(s, \"onSessionSettleRequest()\");\n      if (o) throw new Error(o.message);\n      const a = xe(i, \"onSessionSettleRequest()\");\n      if (a) throw new Error(a.message);\n      if (W(r)) {\n        const {\n          message: l\n        } = w(\"EXPIRED\", \"onSessionSettleRequest()\");\n        throw new Error(l);\n      }\n    }), c(this, \"isValidUpdate\", async e => {\n      if (!k(e)) {\n        const {\n          message: a\n        } = w(\"MISSING_OR_INVALID\", `update() params: ${e}`);\n        throw new Error(a);\n      }\n      const {\n        topic: t,\n        namespaces: s\n      } = e;\n      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);\n      const i = this.client.session.get(t),\n        r = xe(s, \"update()\");\n      if (r) throw new Error(r.message);\n      const o = at(i.requiredNamespaces, s, \"update()\");\n      if (o) throw new Error(o.message);\n    }), c(this, \"isValidExtend\", async e => {\n      if (!k(e)) {\n        const {\n          message: s\n        } = w(\"MISSING_OR_INVALID\", `extend() params: ${e}`);\n        throw new Error(s);\n      }\n      const {\n        topic: t\n      } = e;\n      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);\n    }), c(this, \"isValidRequest\", async e => {\n      if (!k(e)) {\n        const {\n          message: a\n        } = w(\"MISSING_OR_INVALID\", `request() params: ${e}`);\n        throw new Error(a);\n      }\n      const {\n        topic: t,\n        request: s,\n        chainId: i,\n        expiry: r\n      } = e;\n      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);\n      const {\n        namespaces: o\n      } = this.client.session.get(t);\n      if (!ct(o, i)) {\n        const {\n          message: a\n        } = w(\"MISSING_OR_INVALID\", `request() chainId: ${i}`);\n        throw new Error(a);\n      }\n      if (!Wt(s)) {\n        const {\n          message: a\n        } = w(\"MISSING_OR_INVALID\", `request() ${JSON.stringify(s)}`);\n        throw new Error(a);\n      }\n      if (!Zt(o, i, s.method)) {\n        const {\n          message: a\n        } = w(\"MISSING_OR_INVALID\", `request() method: ${s.method}`);\n        throw new Error(a);\n      }\n      if (r && !es(r, Ee)) {\n        const {\n          message: a\n        } = w(\"MISSING_OR_INVALID\", `request() expiry: ${r}. Expiry must be a number (in seconds) between ${Ee.min} and ${Ee.max}`);\n        throw new Error(a);\n      }\n    }), c(this, \"isValidRespond\", async e => {\n      var t;\n      if (!k(e)) {\n        const {\n          message: r\n        } = w(\"MISSING_OR_INVALID\", `respond() params: ${e}`);\n        throw new Error(r);\n      }\n      const {\n        topic: s,\n        response: i\n      } = e;\n      try {\n        await this.isValidSessionTopic(s);\n      } catch (r) {\n        throw (t = e?.response) != null && t.id && this.cleanupAfterResponse(e), r;\n      }\n      if (!ts(i)) {\n        const {\n          message: r\n        } = w(\"MISSING_OR_INVALID\", `respond() response: ${JSON.stringify(i)}`);\n        throw new Error(r);\n      }\n    }), c(this, \"isValidPing\", async e => {\n      if (!k(e)) {\n        const {\n          message: s\n        } = w(\"MISSING_OR_INVALID\", `ping() params: ${e}`);\n        throw new Error(s);\n      }\n      const {\n        topic: t\n      } = e;\n      await this.isValidSessionOrPairingTopic(t);\n    }), c(this, \"isValidEmit\", async e => {\n      if (!k(e)) {\n        const {\n          message: o\n        } = w(\"MISSING_OR_INVALID\", `emit() params: ${e}`);\n        throw new Error(o);\n      }\n      const {\n        topic: t,\n        event: s,\n        chainId: i\n      } = e;\n      await this.isValidSessionTopic(t);\n      const {\n        namespaces: r\n      } = this.client.session.get(t);\n      if (!ct(r, i)) {\n        const {\n          message: o\n        } = w(\"MISSING_OR_INVALID\", `emit() chainId: ${i}`);\n        throw new Error(o);\n      }\n      if (!ss(s)) {\n        const {\n          message: o\n        } = w(\"MISSING_OR_INVALID\", `emit() event: ${JSON.stringify(s)}`);\n        throw new Error(o);\n      }\n      if (!is(r, i, s.name)) {\n        const {\n          message: o\n        } = w(\"MISSING_OR_INVALID\", `emit() event: ${JSON.stringify(s)}`);\n        throw new Error(o);\n      }\n    }), c(this, \"isValidDisconnect\", async e => {\n      if (!k(e)) {\n        const {\n          message: s\n        } = w(\"MISSING_OR_INVALID\", `disconnect() params: ${e}`);\n        throw new Error(s);\n      }\n      const {\n        topic: t\n      } = e;\n      await this.isValidSessionOrPairingTopic(t);\n    }), c(this, \"isValidAuthenticate\", e => {\n      const {\n        chains: t,\n        uri: s,\n        domain: i,\n        nonce: r\n      } = e;\n      if (!Array.isArray(t) || t.length === 0) throw new Error(\"chains is required and must be a non-empty array\");\n      if (!U(s, !1)) throw new Error(\"uri is required parameter\");\n      if (!U(i, !1)) throw new Error(\"domain is required parameter\");\n      if (!U(r, !1)) throw new Error(\"nonce is required parameter\");\n      if ([...new Set(t.map(a => Ae(a).namespace))].length > 1) throw new Error(\"Multi-namespace requests are not supported. Please request single namespace only.\");\n      const {\n        namespace: o\n      } = Ae(t[0]);\n      if (o !== \"eip155\") throw new Error(\"Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.\");\n    }), c(this, \"getVerifyContext\", async e => {\n      const {\n          attestationId: t,\n          hash: s,\n          encryptedId: i,\n          metadata: r,\n          transportType: o\n        } = e,\n        a = {\n          verified: {\n            verifyUrl: r.verifyUrl || Ot,\n            validation: \"UNKNOWN\",\n            origin: r.url || \"\"\n          }\n        };\n      try {\n        if (o === T.link_mode) {\n          const u = this.getAppLinkIfEnabled(r, o);\n          return a.verified.validation = u && new URL(u).origin === new URL(r.url).origin ? \"VALID\" : \"INVALID\", a;\n        }\n        const l = await this.client.core.verify.resolve({\n          attestationId: t,\n          hash: s,\n          encryptedId: i,\n          verifyUrl: r.verifyUrl\n        });\n        l && (a.verified.origin = l.origin, a.verified.isScam = l.isScam, a.verified.validation = l.origin === new URL(r.url).origin ? \"VALID\" : \"INVALID\");\n      } catch (l) {\n        this.client.logger.warn(l);\n      }\n      return this.client.logger.debug(`Verify context: ${JSON.stringify(a)}`), a;\n    }), c(this, \"validateSessionProps\", (e, t) => {\n      Object.values(e).forEach(s => {\n        if (!U(s, !1)) {\n          const {\n            message: i\n          } = w(\"MISSING_OR_INVALID\", `${t} must be in Record<string, string> format. Received: ${JSON.stringify(s)}`);\n          throw new Error(i);\n        }\n      });\n    }), c(this, \"getPendingAuthRequest\", e => {\n      const t = this.client.auth.requests.get(e);\n      return typeof t == \"object\" ? t : void 0;\n    }), c(this, \"addToRecentlyDeleted\", (e, t) => {\n      if (this.recentlyDeletedMap.set(e, t), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {\n        let s = 0;\n        const i = this.recentlyDeletedLimit / 2;\n        for (const r of this.recentlyDeletedMap.keys()) {\n          if (s++ >= i) break;\n          this.recentlyDeletedMap.delete(r);\n        }\n      }\n    }), c(this, \"checkRecentlyDeleted\", e => {\n      const t = this.recentlyDeletedMap.get(e);\n      if (t) {\n        const {\n          message: s\n        } = w(\"MISSING_OR_INVALID\", `Record was recently deleted - ${t}: ${e}`);\n        throw new Error(s);\n      }\n    }), c(this, \"isLinkModeEnabled\", (e, t) => {\n      var s, i, r, o, a, l, u, g, h;\n      return !e || t !== T.link_mode ? !1 : ((i = (s = this.client.metadata) == null ? void 0 : s.redirect) == null ? void 0 : i.linkMode) === !0 && ((o = (r = this.client.metadata) == null ? void 0 : r.redirect) == null ? void 0 : o.universal) !== void 0 && ((l = (a = this.client.metadata) == null ? void 0 : a.redirect) == null ? void 0 : l.universal) !== \"\" && ((u = e?.redirect) == null ? void 0 : u.universal) !== void 0 && ((g = e?.redirect) == null ? void 0 : g.universal) !== \"\" && ((h = e?.redirect) == null ? void 0 : h.linkMode) === !0 && this.client.core.linkModeSupportedApps.includes(e.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < \"u\";\n    }), c(this, \"getAppLinkIfEnabled\", (e, t) => {\n      var s;\n      return this.isLinkModeEnabled(e, t) ? (s = e?.redirect) == null ? void 0 : s.universal : void 0;\n    }), c(this, \"handleLinkModeMessage\", ({\n      url: e\n    }) => {\n      if (!e || !e.includes(\"wc_ev\") || !e.includes(\"topic\")) return;\n      const t = lt(e, \"topic\") || \"\",\n        s = decodeURIComponent(lt(e, \"wc_ev\") || \"\"),\n        i = this.client.session.keys.includes(t);\n      i && this.client.session.update(t, {\n        transportType: T.link_mode\n      }), this.client.core.dispatchEnvelope({\n        topic: t,\n        message: s,\n        sessionExists: i\n      });\n    }), c(this, \"registerLinkModeListeners\", async () => {\n      var e;\n      if (rs() || ns() && (e = this.client.metadata.redirect) != null && e.linkMode) {\n        const t = global == null ? void 0 : global.Linking;\n        if (typeof t < \"u\") {\n          t.addEventListener(\"url\", this.handleLinkModeMessage, this.client.name);\n          const s = await t.getInitialURL();\n          s && setTimeout(() => {\n            this.handleLinkModeMessage({\n              url: s\n            });\n          }, 50);\n        }\n      }\n    }), c(this, \"shouldSetTVF\", (e, t) => {\n      if (!t || e !== \"wc_sessionRequest\") return !1;\n      const {\n        request: s\n      } = t;\n      return Object.keys(Ke).includes(s.method);\n    }), c(this, \"getTVFParams\", (e, t, s) => {\n      var i, r;\n      try {\n        const o = t.request.method,\n          a = this.extractTxHashesFromResult(o, s);\n        return x(v({\n          correlationId: e,\n          rpcMethods: [o],\n          chainId: t.chainId\n        }, this.isValidContractData(t.request.params) && {\n          contractAddresses: [(r = (i = t.request.params) == null ? void 0 : i[0]) == null ? void 0 : r.to]\n        }), {\n          txHashes: a\n        });\n      } catch (o) {\n        this.client.logger.warn(\"Error getting TVF params\", o);\n      }\n      return {};\n    }), c(this, \"isValidContractData\", e => {\n      var t;\n      if (!e) return !1;\n      try {\n        const s = e?.data || ((t = e?.[0]) == null ? void 0 : t.data);\n        if (!s.startsWith(\"0x\")) return !1;\n        const i = s.slice(2);\n        return /^[0-9a-fA-F]*$/.test(i) ? i.length % 2 === 0 : !1;\n      } catch {}\n      return !1;\n    }), c(this, \"extractTxHashesFromResult\", (e, t) => {\n      try {\n        const s = Ke[e];\n        if (typeof t == \"string\") return [t];\n        const i = t[s.key];\n        if (os(i)) return i;\n        if (typeof i == \"string\") return [i];\n      } catch (s) {\n        this.client.logger.warn(\"Error extracting tx hashes from result\", s);\n      }\n      return [];\n    });\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: n\n      } = w(\"NOT_INITIALIZED\", this.name);\n      throw new Error(n);\n    }\n  }\n  async confirmOnlineStateOrThrow() {\n    await this.client.core.relayer.confirmOnlineStateOrThrow();\n  }\n  registerRelayerEvents() {\n    this.client.core.relayer.on(Xe.message, n => {\n      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(n) : this.onRelayMessage(n);\n    });\n  }\n  async onRelayMessage(n) {\n    const {\n        topic: e,\n        message: t,\n        attestation: s,\n        transportType: i\n      } = n,\n      {\n        publicKey: r\n      } = this.client.auth.authKeys.keys.includes(le) ? this.client.auth.authKeys.get(le) : {\n        responseTopic: void 0,\n        publicKey: void 0\n      },\n      o = await this.client.core.crypto.decode(e, t, {\n        receiverPublicKey: r,\n        encoding: i === T.link_mode ? ne : ue\n      });\n    try {\n      ps(o) ? (this.client.core.history.set(e, o), this.onRelayEventRequest({\n        topic: e,\n        payload: o,\n        attestation: s,\n        transportType: i,\n        encryptedId: B(t)\n      })) : hs(o) ? (await this.client.core.history.resolve(o), await this.onRelayEventResponse({\n        topic: e,\n        payload: o,\n        transportType: i\n      }), this.client.core.history.delete(e, o.id)) : this.onRelayEventUnknownPayload({\n        topic: e,\n        payload: o,\n        transportType: i\n      });\n    } catch (a) {\n      this.client.logger.error(a);\n    }\n  }\n  registerExpirerEvents() {\n    this.client.core.expirer.on(qt.expired, async n => {\n      const {\n        topic: e,\n        id: t\n      } = kt(n.target);\n      if (t && this.client.pendingRequest.keys.includes(t)) return await this.deletePendingSessionRequest(t, w(\"EXPIRED\"), !0);\n      if (t && this.client.auth.requests.keys.includes(t)) return await this.deletePendingAuthRequest(t, w(\"EXPIRED\"), !0);\n      e ? this.client.session.keys.includes(e) && (await this.deleteSession({\n        topic: e,\n        expirerHasDeleted: !0\n      }), this.client.events.emit(\"session_expire\", {\n        topic: e\n      })) : t && (await this.deleteProposal(t, !0), this.client.events.emit(\"proposal_expire\", {\n        id: t\n      }));\n    });\n  }\n  registerPairingEvents() {\n    this.client.core.pairing.events.on(Je.create, n => this.onPairingCreated(n)), this.client.core.pairing.events.on(Je.delete, n => {\n      this.addToRecentlyDeleted(n.topic, \"pairing\");\n    });\n  }\n  isValidPairingTopic(n) {\n    if (!U(n, !1)) {\n      const {\n        message: e\n      } = w(\"MISSING_OR_INVALID\", `pairing topic should be a string: ${n}`);\n      throw new Error(e);\n    }\n    if (!this.client.core.pairing.pairings.keys.includes(n)) {\n      const {\n        message: e\n      } = w(\"NO_MATCHING_KEY\", `pairing topic doesn't exist: ${n}`);\n      throw new Error(e);\n    }\n    if (W(this.client.core.pairing.pairings.get(n).expiry)) {\n      const {\n        message: e\n      } = w(\"EXPIRED\", `pairing topic: ${n}`);\n      throw new Error(e);\n    }\n  }\n  async isValidSessionTopic(n) {\n    if (!U(n, !1)) {\n      const {\n        message: e\n      } = w(\"MISSING_OR_INVALID\", `session topic should be a string: ${n}`);\n      throw new Error(e);\n    }\n    if (this.checkRecentlyDeleted(n), !this.client.session.keys.includes(n)) {\n      const {\n        message: e\n      } = w(\"NO_MATCHING_KEY\", `session topic doesn't exist: ${n}`);\n      throw new Error(e);\n    }\n    if (W(this.client.session.get(n).expiry)) {\n      await this.deleteSession({\n        topic: n\n      });\n      const {\n        message: e\n      } = w(\"EXPIRED\", `session topic: ${n}`);\n      throw new Error(e);\n    }\n    if (!this.client.core.crypto.keychain.has(n)) {\n      const {\n        message: e\n      } = w(\"MISSING_OR_INVALID\", `session topic does not exist in keychain: ${n}`);\n      throw await this.deleteSession({\n        topic: n\n      }), new Error(e);\n    }\n  }\n  async isValidSessionOrPairingTopic(n) {\n    if (this.checkRecentlyDeleted(n), this.client.session.keys.includes(n)) await this.isValidSessionTopic(n);else if (this.client.core.pairing.pairings.keys.includes(n)) this.isValidPairingTopic(n);else if (U(n, !1)) {\n      const {\n        message: e\n      } = w(\"NO_MATCHING_KEY\", `session or pairing topic doesn't exist: ${n}`);\n      throw new Error(e);\n    } else {\n      const {\n        message: e\n      } = w(\"MISSING_OR_INVALID\", `session or pairing topic should be a string: ${n}`);\n      throw new Error(e);\n    }\n  }\n  async isValidProposalId(n) {\n    if (!$t(n)) {\n      const {\n        message: e\n      } = w(\"MISSING_OR_INVALID\", `proposal id should be a number: ${n}`);\n      throw new Error(e);\n    }\n    if (!this.client.proposal.keys.includes(n)) {\n      const {\n        message: e\n      } = w(\"NO_MATCHING_KEY\", `proposal id doesn't exist: ${n}`);\n      throw new Error(e);\n    }\n    if (W(this.client.proposal.get(n).expiryTimestamp)) {\n      await this.deleteProposal(n);\n      const {\n        message: e\n      } = w(\"EXPIRED\", `proposal id: ${n}`);\n      throw new Error(e);\n    }\n  }\n}\nclass Ns extends J {\n  constructor(n, e) {\n    super(n, e, pt, me), this.core = n, this.logger = e;\n  }\n}\nclass Rt extends J {\n  constructor(n, e) {\n    super(n, e, ht, me), this.core = n, this.logger = e;\n  }\n}\nclass Ps extends J {\n  constructor(n, e) {\n    super(n, e, ut, me, t => t.id), this.core = n, this.logger = e;\n  }\n}\nclass Os extends J {\n  constructor(n, e) {\n    super(n, e, mt, ce, () => le), this.core = n, this.logger = e;\n  }\n}\nclass bs extends J {\n  constructor(n, e) {\n    super(n, e, _t, ce), this.core = n, this.logger = e;\n  }\n}\nclass As extends J {\n  constructor(n, e) {\n    super(n, e, Et, ce, t => t.id), this.core = n, this.logger = e;\n  }\n}\nvar Cs = Object.defineProperty,\n  xs = (S, n, e) => n in S ? Cs(S, n, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : S[n] = e,\n  Ge = (S, n, e) => xs(S, typeof n != \"symbol\" ? n + \"\" : n, e);\nclass Vs {\n  constructor(n, e) {\n    this.core = n, this.logger = e, Ge(this, \"authKeys\"), Ge(this, \"pairingTopics\"), Ge(this, \"requests\"), this.authKeys = new Os(this.core, this.logger), this.pairingTopics = new bs(this.core, this.logger), this.requests = new As(this.core, this.logger);\n  }\n  async init() {\n    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();\n  }\n}\nvar Ds = Object.defineProperty,\n  Ls = (S, n, e) => n in S ? Ds(S, n, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : S[n] = e,\n  _ = (S, n, e) => Ls(S, typeof n != \"symbol\" ? n + \"\" : n, e);\nclass Se extends Lt {\n  constructor(n) {\n    super(n), _(this, \"protocol\", De), _(this, \"version\", Le), _(this, \"name\", _e.name), _(this, \"metadata\"), _(this, \"core\"), _(this, \"logger\"), _(this, \"events\", new ls()), _(this, \"engine\"), _(this, \"session\"), _(this, \"proposal\"), _(this, \"pendingRequest\"), _(this, \"auth\"), _(this, \"signConfig\"), _(this, \"on\", (t, s) => this.events.on(t, s)), _(this, \"once\", (t, s) => this.events.once(t, s)), _(this, \"off\", (t, s) => this.events.off(t, s)), _(this, \"removeListener\", (t, s) => this.events.removeListener(t, s)), _(this, \"removeAllListeners\", t => this.events.removeAllListeners(t)), _(this, \"connect\", async t => {\n      try {\n        return await this.engine.connect(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), _(this, \"pair\", async t => {\n      try {\n        return await this.engine.pair(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), _(this, \"approve\", async t => {\n      try {\n        return await this.engine.approve(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), _(this, \"reject\", async t => {\n      try {\n        return await this.engine.reject(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), _(this, \"update\", async t => {\n      try {\n        return await this.engine.update(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), _(this, \"extend\", async t => {\n      try {\n        return await this.engine.extend(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), _(this, \"request\", async t => {\n      try {\n        return await this.engine.request(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), _(this, \"respond\", async t => {\n      try {\n        return await this.engine.respond(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), _(this, \"ping\", async t => {\n      try {\n        return await this.engine.ping(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), _(this, \"emit\", async t => {\n      try {\n        return await this.engine.emit(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), _(this, \"disconnect\", async t => {\n      try {\n        return await this.engine.disconnect(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), _(this, \"find\", t => {\n      try {\n        return this.engine.find(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), _(this, \"getPendingSessionRequests\", () => {\n      try {\n        return this.engine.getPendingSessionRequests();\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }), _(this, \"authenticate\", async (t, s) => {\n      try {\n        return await this.engine.authenticate(t, s);\n      } catch (i) {\n        throw this.logger.error(i.message), i;\n      }\n    }), _(this, \"formatAuthMessage\", t => {\n      try {\n        return this.engine.formatAuthMessage(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), _(this, \"approveSessionAuthenticate\", async t => {\n      try {\n        return await this.engine.approveSessionAuthenticate(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), _(this, \"rejectSessionAuthenticate\", async t => {\n      try {\n        return await this.engine.rejectSessionAuthenticate(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), this.name = n?.name || _e.name, this.metadata = n?.metadata || as(), this.signConfig = n?.signConfig;\n    const e = typeof n?.logger < \"u\" && typeof n?.logger != \"string\" ? n.logger : At(Ct({\n      level: n?.logger || _e.logger\n    }));\n    this.core = n?.core || new bt(n), this.logger = xt(e, this.name), this.session = new Rt(this.core, this.logger), this.proposal = new Ns(this.core, this.logger), this.pendingRequest = new Ps(this.core, this.logger), this.engine = new Ts(this), this.auth = new Vs(this.core, this.logger);\n  }\n  static async init(n) {\n    const e = new Se(n);\n    return await e.initialize(), e;\n  }\n  get context() {\n    return Vt(this.logger);\n  }\n  get pairing() {\n    return this.core.pairing.pairings;\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\");\n    try {\n      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info(\"SignClient Initialization Success\"), setTimeout(() => {\n        this.engine.processRelayMessageCache();\n      }, Oe(Ze));\n    } catch (n) {\n      throw this.logger.info(\"SignClient Initialization Failure\"), this.logger.error(n.message), n;\n    }\n  }\n}\nconst Ms = Rt,\n  ks = Se;\nexport { wt as AUTH_CONTEXT, mt as AUTH_KEYS_CONTEXT, _t as AUTH_PAIRING_TOPIC_CONTEXT, yt as AUTH_PROTOCOL, le as AUTH_PUBLIC_KEY_NAME, Et as AUTH_REQUEST_CONTEXT, ce as AUTH_STORAGE_PREFIX, Ss as AUTH_VERSION, dt as ENGINE_CONTEXT, $ as ENGINE_QUEUE_STATES, N as ENGINE_RPC_OPTS, ms as HISTORY_CONTEXT, ws as HISTORY_EVENTS, _s as HISTORY_STORAGE_VERSION, gt as METHODS_TO_VERIFY, pt as PROPOSAL_CONTEXT, Es as PROPOSAL_EXPIRY, $e as PROPOSAL_EXPIRY_MESSAGE, ut as REQUEST_CONTEXT, ht as SESSION_CONTEXT, Y as SESSION_EXPIRY, Ee as SESSION_REQUEST_EXPIRY_BOUNDARIES, Me as SIGN_CLIENT_CONTEXT, _e as SIGN_CLIENT_DEFAULT, gs as SIGN_CLIENT_EVENTS, De as SIGN_CLIENT_PROTOCOL, ys as SIGN_CLIENT_STORAGE_OPTIONS, me as SIGN_CLIENT_STORAGE_PREFIX, Le as SIGN_CLIENT_VERSION, Ms as SessionStore, ks as SignClient, Ke as TVF_METHODS, ke as WALLETCONNECT_DEEPLINK_CHOICE, Se as default };\n//# sourceMappingURL=index.es.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}