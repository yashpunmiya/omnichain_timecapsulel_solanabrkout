{"ast":null,"code":"import { parseAccount } from '../../accounts/utils/parseAccount.js';\nimport { BaseError } from '../../errors/base.js';\nimport { recoverAuthorizationAddress } from '../../experimental/eip7702/utils/recoverAuthorizationAddress.js';\nimport { numberToHex } from '../../utils/encoding/toHex.js';\nimport { getEstimateGasError } from '../../utils/errors/getEstimateGasError.js';\nimport { extract } from '../../utils/formatters/extract.js';\nimport { formatTransactionRequest } from '../../utils/formatters/transactionRequest.js';\nimport { serializeStateOverride } from '../../utils/stateOverride.js';\nimport { assertRequest } from '../../utils/transaction/assertRequest.js';\nimport { prepareTransactionRequest } from '../wallet/prepareTransactionRequest.js';\nimport { getBalance } from './getBalance.js';\n/**\n * Estimates the gas necessary to complete a transaction without submitting it to the network.\n *\n * - Docs: https://viem.sh/docs/actions/public/estimateGas\n * - JSON-RPC Methods: [`eth_estimateGas`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_estimategas)\n *\n * @param client - Client to use\n * @param parameters - {@link EstimateGasParameters}\n * @returns The gas estimate (in wei). {@link EstimateGasReturnType}\n *\n * @example\n * import { createPublicClient, http, parseEther } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { estimateGas } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const gasEstimate = await estimateGas(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: parseEther('1'),\n * })\n */\nexport async function estimateGas(client, args) {\n  const {\n    account: account_ = client.account\n  } = args;\n  const account = account_ ? parseAccount(account_) : undefined;\n  try {\n    const {\n      accessList,\n      authorizationList,\n      blobs,\n      blobVersionedHashes,\n      blockNumber,\n      blockTag,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerBlobGas,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      value,\n      stateOverride,\n      ...rest\n    } = await prepareTransactionRequest(client, {\n      ...args,\n      parameters:\n      // Some RPC Providers do not compute versioned hashes from blobs. We will need\n      // to compute them.\n      account?.type === 'local' ? undefined : ['blobVersionedHashes']\n    });\n    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;\n    const block = blockNumberHex || blockTag;\n    const rpcStateOverride = serializeStateOverride(stateOverride);\n    const to = await (async () => {\n      // If `to` exists on the parameters, use that.\n      if (rest.to) return rest.to;\n      // If no `to` exists, and we are sending a EIP-7702 transaction, use the\n      // address of the first authorization in the list.\n      if (authorizationList && authorizationList.length > 0) return await recoverAuthorizationAddress({\n        authorization: authorizationList[0]\n      }).catch(() => {\n        throw new BaseError('`to` is required. Could not infer from `authorizationList`');\n      });\n      // Otherwise, we are sending a deployment transaction.\n      return undefined;\n    })();\n    assertRequest(args);\n    const chainFormat = client.chain?.formatters?.transactionRequest?.format;\n    const format = chainFormat || formatTransactionRequest;\n    const request = format({\n      // Pick out extra data that might exist on the chain's transaction request type.\n      ...extract(rest, {\n        format: chainFormat\n      }),\n      from: account?.address,\n      accessList,\n      authorizationList,\n      blobs,\n      blobVersionedHashes,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerBlobGas,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to,\n      value\n    });\n    function estimateGas_rpc(parameters) {\n      const {\n        block,\n        request,\n        rpcStateOverride\n      } = parameters;\n      return client.request({\n        method: 'eth_estimateGas',\n        params: rpcStateOverride ? [request, block ?? 'latest', rpcStateOverride] : block ? [request, block] : [request]\n      });\n    }\n    let estimate = BigInt(await estimateGas_rpc({\n      block,\n      request,\n      rpcStateOverride\n    }));\n    // TODO(7702): Remove this once https://github.com/ethereum/execution-apis/issues/561 is resolved.\n    //       Authorization list schema is not implemented on JSON-RPC spec yet, so we need to\n    //       manually estimate the gas.\n    if (authorizationList) {\n      const value = await getBalance(client, {\n        address: request.from\n      });\n      const estimates = await Promise.all(authorizationList.map(async authorization => {\n        const {\n          contractAddress\n        } = authorization;\n        const estimate = await estimateGas_rpc({\n          block,\n          request: {\n            authorizationList: undefined,\n            data,\n            from: account?.address,\n            to: contractAddress,\n            value: numberToHex(value)\n          },\n          rpcStateOverride\n        }).catch(() => 100000n);\n        return 2n * BigInt(estimate);\n      }));\n      estimate += estimates.reduce((acc, curr) => acc + curr, 0n);\n    }\n    return estimate;\n  } catch (err) {\n    throw getEstimateGasError(err, {\n      ...args,\n      account,\n      chain: client.chain\n    });\n  }\n}\n//# sourceMappingURL=estimateGas.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}