{"ast":null,"code":"// Implementation forked and adapted from https://github.com/MetaMask/eth-sig-util/blob/main/src/sign-typed-data.ts\nimport { encodeAbiParameters } from '../abi/encodeAbiParameters.js';\nimport { concat } from '../data/concat.js';\nimport { toHex } from '../encoding/toHex.js';\nimport { keccak256 } from '../hash/keccak256.js';\nimport { getTypesForEIP712Domain, validateTypedData } from '../typedData.js';\nexport function hashTypedData(parameters) {\n  const {\n    domain = {},\n    message,\n    primaryType\n  } = parameters;\n  const types = {\n    EIP712Domain: getTypesForEIP712Domain({\n      domain\n    }),\n    ...parameters.types\n  };\n  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n  // as we can't statically check this with TypeScript.\n  validateTypedData({\n    domain,\n    message,\n    primaryType,\n    types\n  });\n  const parts = ['0x1901'];\n  if (domain) parts.push(hashDomain({\n    domain,\n    types: types\n  }));\n  if (primaryType !== 'EIP712Domain') parts.push(hashStruct({\n    data: message,\n    primaryType,\n    types: types\n  }));\n  return keccak256(concat(parts));\n}\nexport function hashDomain({\n  domain,\n  types\n}) {\n  return hashStruct({\n    data: domain,\n    primaryType: 'EIP712Domain',\n    types\n  });\n}\nexport function hashStruct({\n  data,\n  primaryType,\n  types\n}) {\n  const encoded = encodeData({\n    data,\n    primaryType,\n    types\n  });\n  return keccak256(encoded);\n}\nfunction encodeData({\n  data,\n  primaryType,\n  types\n}) {\n  const encodedTypes = [{\n    type: 'bytes32'\n  }];\n  const encodedValues = [hashType({\n    primaryType,\n    types\n  })];\n  for (const field of types[primaryType]) {\n    const [type, value] = encodeField({\n      types,\n      name: field.name,\n      type: field.type,\n      value: data[field.name]\n    });\n    encodedTypes.push(type);\n    encodedValues.push(value);\n  }\n  return encodeAbiParameters(encodedTypes, encodedValues);\n}\nfunction hashType({\n  primaryType,\n  types\n}) {\n  const encodedHashType = toHex(encodeType({\n    primaryType,\n    types\n  }));\n  return keccak256(encodedHashType);\n}\nexport function encodeType({\n  primaryType,\n  types\n}) {\n  let result = '';\n  const unsortedDeps = findTypeDependencies({\n    primaryType,\n    types\n  });\n  unsortedDeps.delete(primaryType);\n  const deps = [primaryType, ...Array.from(unsortedDeps).sort()];\n  for (const type of deps) {\n    result += `${type}(${types[type].map(({\n      name,\n      type: t\n    }) => `${t} ${name}`).join(',')})`;\n  }\n  return result;\n}\nfunction findTypeDependencies({\n  primaryType: primaryType_,\n  types\n}, results = new Set()) {\n  const match = primaryType_.match(/^\\w*/u);\n  const primaryType = match?.[0];\n  if (results.has(primaryType) || types[primaryType] === undefined) {\n    return results;\n  }\n  results.add(primaryType);\n  for (const field of types[primaryType]) {\n    findTypeDependencies({\n      primaryType: field.type,\n      types\n    }, results);\n  }\n  return results;\n}\nfunction encodeField({\n  types,\n  name,\n  type,\n  value\n}) {\n  if (types[type] !== undefined) {\n    return [{\n      type: 'bytes32'\n    }, keccak256(encodeData({\n      data: value,\n      primaryType: type,\n      types\n    }))];\n  }\n  if (type === 'bytes') {\n    const prepend = value.length % 2 ? '0' : '';\n    value = `0x${prepend + value.slice(2)}`;\n    return [{\n      type: 'bytes32'\n    }, keccak256(value)];\n  }\n  if (type === 'string') return [{\n    type: 'bytes32'\n  }, keccak256(toHex(value))];\n  if (type.lastIndexOf(']') === type.length - 1) {\n    const parsedType = type.slice(0, type.lastIndexOf('['));\n    const typeValuePairs = value.map(item => encodeField({\n      name,\n      type: parsedType,\n      types,\n      value: item\n    }));\n    return [{\n      type: 'bytes32'\n    }, keccak256(encodeAbiParameters(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v)))];\n  }\n  return [{\n    type\n  }, value];\n}\n//# sourceMappingURL=hashTypedData.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}