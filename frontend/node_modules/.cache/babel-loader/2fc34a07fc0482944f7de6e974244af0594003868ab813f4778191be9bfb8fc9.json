{"ast":null,"code":"import { secp256k1 } from '@noble/curves/secp256k1';\nimport { hexToBigInt } from '../encoding/fromHex.js';\nimport { hexToBytes } from '../encoding/toBytes.js';\n/**\n * @description Converts a signature into hex format.\n *\n * @param signature The signature to convert.\n * @returns The signature in hex format.\n *\n * @example\n * serializeSignature({\n *   r: '0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf',\n *   s: '0x4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8',\n *   yParity: 1\n * })\n * // \"0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c\"\n */\nexport function serializeSignature({\n  r,\n  s,\n  to = 'hex',\n  v,\n  yParity\n}) {\n  const yParity_ = (() => {\n    if (yParity === 0 || yParity === 1) return yParity;\n    if (v && (v === 27n || v === 28n || v >= 35n)) return v % 2n === 0n ? 1 : 0;\n    throw new Error('Invalid `v` or `yParity` value');\n  })();\n  const signature = `0x${new secp256k1.Signature(hexToBigInt(r), hexToBigInt(s)).toCompactHex()}${yParity_ === 0 ? '1b' : '1c'}`;\n  if (to === 'hex') return signature;\n  return hexToBytes(signature);\n}\n//# sourceMappingURL=serializeSignature.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}