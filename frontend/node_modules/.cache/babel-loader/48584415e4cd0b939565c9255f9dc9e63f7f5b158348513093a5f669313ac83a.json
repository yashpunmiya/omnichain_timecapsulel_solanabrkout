{"ast":null,"code":"import * as Bytes from '../Bytes.js';\n/** @internal */\nexport function assertSize(bytes, size_) {\n  if (Bytes.size(bytes) > size_) throw new Bytes.SizeOverflowError({\n    givenSize: Bytes.size(bytes),\n    maxSize: size_\n  });\n}\n/** @internal */\nexport function assertStartOffset(value, start) {\n  if (typeof start === 'number' && start > 0 && start > Bytes.size(value) - 1) throw new Bytes.SliceOffsetOutOfBoundsError({\n    offset: start,\n    position: 'start',\n    size: Bytes.size(value)\n  });\n}\n/** @internal */\nexport function assertEndOffset(value, start, end) {\n  if (typeof start === 'number' && typeof end === 'number' && Bytes.size(value) !== end - start) {\n    throw new Bytes.SliceOffsetOutOfBoundsError({\n      offset: end,\n      position: 'end',\n      size: Bytes.size(value)\n    });\n  }\n}\n/** @internal */\nexport const charCodeMap = {\n  zero: 48,\n  nine: 57,\n  A: 65,\n  F: 70,\n  a: 97,\n  f: 102\n};\n/** @internal */\nexport function charCodeToBase16(char) {\n  if (char >= charCodeMap.zero && char <= charCodeMap.nine) return char - charCodeMap.zero;\n  if (char >= charCodeMap.A && char <= charCodeMap.F) return char - (charCodeMap.A - 10);\n  if (char >= charCodeMap.a && char <= charCodeMap.f) return char - (charCodeMap.a - 10);\n  return undefined;\n}\n/** @internal */\nexport function pad(bytes, options = {}) {\n  const {\n    dir,\n    size = 32\n  } = options;\n  if (size === 0) return bytes;\n  if (bytes.length > size) throw new Bytes.SizeExceedsPaddingSizeError({\n    size: bytes.length,\n    targetSize: size,\n    type: 'Bytes'\n  });\n  const paddedBytes = new Uint8Array(size);\n  for (let i = 0; i < size; i++) {\n    const padEnd = dir === 'right';\n    paddedBytes[padEnd ? i : size - i - 1] = bytes[padEnd ? i : bytes.length - i - 1];\n  }\n  return paddedBytes;\n}\n/** @internal */\nexport function trim(value, options = {}) {\n  const {\n    dir = 'left'\n  } = options;\n  let data = value;\n  let sliceLength = 0;\n  for (let i = 0; i < data.length - 1; i++) {\n    if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0') sliceLength++;else break;\n  }\n  data = dir === 'left' ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);\n  return data;\n}\n//# sourceMappingURL=bytes.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}