{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.chooseFragments = exports.shuffle = exports.chooseDegree = void 0;\nconst utils_1 = require(\"./utils\");\nconst xoshiro_1 = __importDefault(require(\"./xoshiro\"));\nconst alias_sampling_1 = __importDefault(require(\"@keystonehq/alias-sampling\"));\nconst chooseDegree = (seqLenth, rng) => {\n  const degreeProbabilities = [...new Array(seqLenth)].map((_, index) => 1 / (index + 1));\n  const degreeChooser = alias_sampling_1.default(degreeProbabilities, undefined, rng.nextDouble);\n  return degreeChooser.next() + 1;\n};\nexports.chooseDegree = chooseDegree;\nconst shuffle = (items, rng) => {\n  let remaining = [...items];\n  let result = [];\n  while (remaining.length > 0) {\n    let index = rng.nextInt(0, remaining.length - 1);\n    let item = remaining[index];\n    // remaining.erase(remaining.begin() + index);\n    remaining.splice(index, 1);\n    result.push(item);\n  }\n  return result;\n};\nexports.shuffle = shuffle;\nconst chooseFragments = (seqNum, seqLength, checksum) => {\n  // The first `seqLenth` parts are the \"pure\" fragments, not mixed with any\n  // others. This means that if you only generate the first `seqLenth` parts,\n  // then you have all the parts you need to decode the message.\n  if (seqNum <= seqLength) {\n    return [seqNum - 1];\n  } else {\n    const seed = Buffer.concat([utils_1.intToBytes(seqNum), utils_1.intToBytes(checksum)]);\n    const rng = new xoshiro_1.default(seed);\n    const degree = exports.chooseDegree(seqLength, rng);\n    const indexes = [...new Array(seqLength)].map((_, index) => index);\n    const shuffledIndexes = exports.shuffle(indexes, rng);\n    return shuffledIndexes.slice(0, degree);\n  }\n};\nexports.chooseFragments = chooseFragments;","map":{"version":3,"names":["utils_1","require","xoshiro_1","__importDefault","alias_sampling_1","chooseDegree","seqLenth","rng","degreeProbabilities","Array","map","_","index","degreeChooser","default","undefined","nextDouble","next","exports","shuffle","items","remaining","result","length","nextInt","item","splice","push","chooseFragments","seqNum","seqLength","checksum","seed","Buffer","concat","intToBytes","degree","indexes","shuffledIndexes","slice"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@ngraveio\\bc-ur\\src\\fountainUtils.ts"],"sourcesContent":["import { intToBytes } from \"./utils\";\nimport Xoshiro from \"./xoshiro\";\nimport randomSampler from \"@keystonehq/alias-sampling\";\n\nexport const chooseDegree = (seqLenth: number, rng: Xoshiro): number => {\n  const degreeProbabilities = [...new Array(seqLenth)].map((_, index) => 1 / (index + 1));\n  const degreeChooser = randomSampler(degreeProbabilities, undefined, rng.nextDouble as any);\n\n  return degreeChooser.next() + 1;\n}\n\n\nexport const shuffle = (items: any[], rng: Xoshiro): any[] => {\n  let remaining = [...items];\n  let result = [];\n\n  while (remaining.length > 0) {\n    let index = rng.nextInt(0, remaining.length - 1);\n    let item = remaining[index];\n    // remaining.erase(remaining.begin() + index);\n    remaining.splice(index, 1);\n    result.push(item);\n  }\n\n  return result;\n}\n\n\nexport const chooseFragments = (seqNum: number, seqLength: number, checksum: number): number[] => {\n  // The first `seqLenth` parts are the \"pure\" fragments, not mixed with any\n  // others. This means that if you only generate the first `seqLenth` parts,\n  // then you have all the parts you need to decode the message.\n  if (seqNum <= seqLength) {\n    return [seqNum - 1];\n  } else {\n    const seed = Buffer.concat([intToBytes(seqNum), intToBytes(checksum)]);\n    const rng = new Xoshiro(seed);\n    const degree = chooseDegree(seqLength, rng);\n    const indexes = [...new Array(seqLength)].map((_, index) => index);\n    const shuffledIndexes = shuffle(indexes, rng);\n\n    return shuffledIndexes.slice(0, degree);\n  }\n}"],"mappings":";;;;;;;;;;;AAAA,MAAAA,OAAA,GAAAC,OAAA;AACA,MAAAC,SAAA,GAAAC,eAAA,CAAAF,OAAA;AACA,MAAAG,gBAAA,GAAAD,eAAA,CAAAF,OAAA;AAEO,MAAMI,YAAY,GAAGA,CAACC,QAAgB,EAAEC,GAAY,KAAY;EACrE,MAAMC,mBAAmB,GAAG,CAAC,GAAG,IAAIC,KAAK,CAACH,QAAQ,CAAC,CAAC,CAACI,GAAG,CAAC,CAACC,CAAC,EAAEC,KAAK,KAAK,CAAC,IAAIA,KAAK,GAAG,CAAC,CAAC,CAAC;EACvF,MAAMC,aAAa,GAAGT,gBAAA,CAAAU,OAAa,CAACN,mBAAmB,EAAEO,SAAS,EAAER,GAAG,CAACS,UAAiB,CAAC;EAE1F,OAAOH,aAAa,CAACI,IAAI,EAAE,GAAG,CAAC;AACjC,CAAC;AALYC,OAAA,CAAAb,YAAY,GAAAA,YAAA;AAQlB,MAAMc,OAAO,GAAGA,CAACC,KAAY,EAAEb,GAAY,KAAW;EAC3D,IAAIc,SAAS,GAAG,CAAC,GAAGD,KAAK,CAAC;EAC1B,IAAIE,MAAM,GAAG,EAAE;EAEf,OAAOD,SAAS,CAACE,MAAM,GAAG,CAAC,EAAE;IAC3B,IAAIX,KAAK,GAAGL,GAAG,CAACiB,OAAO,CAAC,CAAC,EAAEH,SAAS,CAACE,MAAM,GAAG,CAAC,CAAC;IAChD,IAAIE,IAAI,GAAGJ,SAAS,CAACT,KAAK,CAAC;IAC3B;IACAS,SAAS,CAACK,MAAM,CAACd,KAAK,EAAE,CAAC,CAAC;IAC1BU,MAAM,CAACK,IAAI,CAACF,IAAI,CAAC;;EAGnB,OAAOH,MAAM;AACf,CAAC;AAbYJ,OAAA,CAAAC,OAAO,GAAAA,OAAA;AAgBb,MAAMS,eAAe,GAAGA,CAACC,MAAc,EAAEC,SAAiB,EAAEC,QAAgB,KAAc;EAC/F;EACA;EACA;EACA,IAAIF,MAAM,IAAIC,SAAS,EAAE;IACvB,OAAO,CAACD,MAAM,GAAG,CAAC,CAAC;GACpB,MAAM;IACL,MAAMG,IAAI,GAAGC,MAAM,CAACC,MAAM,CAAC,CAAClC,OAAA,CAAAmC,UAAU,CAACN,MAAM,CAAC,EAAE7B,OAAA,CAAAmC,UAAU,CAACJ,QAAQ,CAAC,CAAC,CAAC;IACtE,MAAMxB,GAAG,GAAG,IAAIL,SAAA,CAAAY,OAAO,CAACkB,IAAI,CAAC;IAC7B,MAAMI,MAAM,GAAGlB,OAAA,CAAAb,YAAY,CAACyB,SAAS,EAAEvB,GAAG,CAAC;IAC3C,MAAM8B,OAAO,GAAG,CAAC,GAAG,IAAI5B,KAAK,CAACqB,SAAS,CAAC,CAAC,CAACpB,GAAG,CAAC,CAACC,CAAC,EAAEC,KAAK,KAAKA,KAAK,CAAC;IAClE,MAAM0B,eAAe,GAAGpB,OAAA,CAAAC,OAAO,CAACkB,OAAO,EAAE9B,GAAG,CAAC;IAE7C,OAAO+B,eAAe,CAACC,KAAK,CAAC,CAAC,EAAEH,MAAM,CAAC;;AAE3C,CAAC;AAfYlB,OAAA,CAAAU,eAAe,GAAAA,eAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}