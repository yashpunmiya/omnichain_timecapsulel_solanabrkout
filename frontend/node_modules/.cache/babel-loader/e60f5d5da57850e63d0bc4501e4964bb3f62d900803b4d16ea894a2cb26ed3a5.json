{"ast":null,"code":"import { parseAbi } from 'abitype';\nimport { parseAccount } from '../../accounts/utils/parseAccount.js';\nimport { multicall3Abi } from '../../constants/abis.js';\nimport { aggregate3Signature } from '../../constants/contract.js';\nimport { deploylessCallViaBytecodeBytecode, deploylessCallViaFactoryBytecode } from '../../constants/contracts.js';\nimport { BaseError } from '../../errors/base.js';\nimport { ChainDoesNotSupportContract, ClientChainNotConfiguredError } from '../../errors/chain.js';\nimport { CounterfactualDeploymentFailedError, RawContractError } from '../../errors/contract.js';\nimport { decodeFunctionResult } from '../../utils/abi/decodeFunctionResult.js';\nimport { encodeDeployData } from '../../utils/abi/encodeDeployData.js';\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js';\nimport { getChainContractAddress } from '../../utils/chain/getChainContractAddress.js';\nimport { numberToHex } from '../../utils/encoding/toHex.js';\nimport { getCallError } from '../../utils/errors/getCallError.js';\nimport { extract } from '../../utils/formatters/extract.js';\nimport { formatTransactionRequest } from '../../utils/formatters/transactionRequest.js';\nimport { createBatchScheduler } from '../../utils/promise/createBatchScheduler.js';\nimport { serializeStateOverride } from '../../utils/stateOverride.js';\nimport { assertRequest } from '../../utils/transaction/assertRequest.js';\n/**\n * Executes a new message call immediately without submitting a transaction to the network.\n *\n * - Docs: https://viem.sh/docs/actions/public/call\n * - JSON-RPC Methods: [`eth_call`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_call)\n *\n * @param client - Client to use\n * @param parameters - {@link CallParameters}\n * @returns The call data. {@link CallReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { call } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const data = await call(client, {\n *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n *   data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * })\n */\nexport async function call(client, args) {\n  const {\n    account: account_ = client.account,\n    batch = Boolean(client.batch?.multicall),\n    blockNumber,\n    blockTag = 'latest',\n    accessList,\n    blobs,\n    code,\n    data: data_,\n    factory,\n    factoryData,\n    gas,\n    gasPrice,\n    maxFeePerBlobGas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    to,\n    value,\n    stateOverride,\n    ...rest\n  } = args;\n  const account = account_ ? parseAccount(account_) : undefined;\n  if (code && (factory || factoryData)) throw new BaseError('Cannot provide both `code` & `factory`/`factoryData` as parameters.');\n  if (code && to) throw new BaseError('Cannot provide both `code` & `to` as parameters.');\n  // Check if the call is deployless via bytecode.\n  const deploylessCallViaBytecode = code && data_;\n  // Check if the call is deployless via a factory.\n  const deploylessCallViaFactory = factory && factoryData && to && data_;\n  const deploylessCall = deploylessCallViaBytecode || deploylessCallViaFactory;\n  const data = (() => {\n    if (deploylessCallViaBytecode) return toDeploylessCallViaBytecodeData({\n      code,\n      data: data_\n    });\n    if (deploylessCallViaFactory) return toDeploylessCallViaFactoryData({\n      data: data_,\n      factory,\n      factoryData,\n      to\n    });\n    return data_;\n  })();\n  try {\n    assertRequest(args);\n    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;\n    const block = blockNumberHex || blockTag;\n    const rpcStateOverride = serializeStateOverride(stateOverride);\n    const chainFormat = client.chain?.formatters?.transactionRequest?.format;\n    const format = chainFormat || formatTransactionRequest;\n    const request = format({\n      // Pick out extra data that might exist on the chain's transaction request type.\n      ...extract(rest, {\n        format: chainFormat\n      }),\n      from: account?.address,\n      accessList,\n      blobs,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerBlobGas,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to: deploylessCall ? undefined : to,\n      value\n    });\n    if (batch && shouldPerformMulticall({\n      request\n    }) && !rpcStateOverride) {\n      try {\n        return await scheduleMulticall(client, {\n          ...request,\n          blockNumber,\n          blockTag\n        });\n      } catch (err) {\n        if (!(err instanceof ClientChainNotConfiguredError) && !(err instanceof ChainDoesNotSupportContract)) throw err;\n      }\n    }\n    const response = await client.request({\n      method: 'eth_call',\n      params: rpcStateOverride ? [request, block, rpcStateOverride] : [request, block]\n    });\n    if (response === '0x') return {\n      data: undefined\n    };\n    return {\n      data: response\n    };\n  } catch (err) {\n    const data = getRevertErrorData(err);\n    // Check for CCIP-Read offchain lookup signature.\n    const {\n      offchainLookup,\n      offchainLookupSignature\n    } = await import('../../utils/ccip.js');\n    if (client.ccipRead !== false && data?.slice(0, 10) === offchainLookupSignature && to) return {\n      data: await offchainLookup(client, {\n        data,\n        to\n      })\n    };\n    // Check for counterfactual deployment error.\n    if (deploylessCall && data?.slice(0, 10) === '0x101bb98d') throw new CounterfactualDeploymentFailedError({\n      factory\n    });\n    throw getCallError(err, {\n      ...args,\n      account,\n      chain: client.chain\n    });\n  }\n}\n// We only want to perform a scheduled multicall if:\n// - The request has calldata,\n// - The request has a target address,\n// - The target address is not already the aggregate3 signature,\n// - The request has no other properties (`nonce`, `gas`, etc cannot be sent with a multicall).\nfunction shouldPerformMulticall({\n  request\n}) {\n  const {\n    data,\n    to,\n    ...request_\n  } = request;\n  if (!data) return false;\n  if (data.startsWith(aggregate3Signature)) return false;\n  if (!to) return false;\n  if (Object.values(request_).filter(x => typeof x !== 'undefined').length > 0) return false;\n  return true;\n}\nasync function scheduleMulticall(client, args) {\n  const {\n    batchSize = 1024,\n    wait = 0\n  } = typeof client.batch?.multicall === 'object' ? client.batch.multicall : {};\n  const {\n    blockNumber,\n    blockTag = 'latest',\n    data,\n    multicallAddress: multicallAddress_,\n    to\n  } = args;\n  let multicallAddress = multicallAddress_;\n  if (!multicallAddress) {\n    if (!client.chain) throw new ClientChainNotConfiguredError();\n    multicallAddress = getChainContractAddress({\n      blockNumber,\n      chain: client.chain,\n      contract: 'multicall3'\n    });\n  }\n  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;\n  const block = blockNumberHex || blockTag;\n  const {\n    schedule\n  } = createBatchScheduler({\n    id: `${client.uid}.${block}`,\n    wait,\n    shouldSplitBatch(args) {\n      const size = args.reduce((size, {\n        data\n      }) => size + (data.length - 2), 0);\n      return size > batchSize * 2;\n    },\n    fn: async requests => {\n      const calls = requests.map(request => ({\n        allowFailure: true,\n        callData: request.data,\n        target: request.to\n      }));\n      const calldata = encodeFunctionData({\n        abi: multicall3Abi,\n        args: [calls],\n        functionName: 'aggregate3'\n      });\n      const data = await client.request({\n        method: 'eth_call',\n        params: [{\n          data: calldata,\n          to: multicallAddress\n        }, block]\n      });\n      return decodeFunctionResult({\n        abi: multicall3Abi,\n        args: [calls],\n        functionName: 'aggregate3',\n        data: data || '0x'\n      });\n    }\n  });\n  const [{\n    returnData,\n    success\n  }] = await schedule({\n    data,\n    to\n  });\n  if (!success) throw new RawContractError({\n    data: returnData\n  });\n  if (returnData === '0x') return {\n    data: undefined\n  };\n  return {\n    data: returnData\n  };\n}\nfunction toDeploylessCallViaBytecodeData(parameters) {\n  const {\n    code,\n    data\n  } = parameters;\n  return encodeDeployData({\n    abi: parseAbi(['constructor(bytes, bytes)']),\n    bytecode: deploylessCallViaBytecodeBytecode,\n    args: [code, data]\n  });\n}\nfunction toDeploylessCallViaFactoryData(parameters) {\n  const {\n    data,\n    factory,\n    factoryData,\n    to\n  } = parameters;\n  return encodeDeployData({\n    abi: parseAbi(['constructor(address, bytes, address, bytes)']),\n    bytecode: deploylessCallViaFactoryBytecode,\n    args: [to, data, factory, factoryData]\n  });\n}\n/** @internal */\nexport function getRevertErrorData(err) {\n  if (!(err instanceof BaseError)) return undefined;\n  const error = err.walk();\n  return typeof error?.data === 'object' ? error.data?.data : error.data;\n}\n//# sourceMappingURL=call.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}