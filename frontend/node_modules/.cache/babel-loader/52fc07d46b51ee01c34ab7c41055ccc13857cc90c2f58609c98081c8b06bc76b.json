{"ast":null,"code":"/**\n * Gets {@link parameterCache} cache key namespaced by {@link type}. This prevents parameters from being accessible to types that don't allow them (e.g. `string indexed foo` not allowed outside of `type: 'event'`).\n * @param param ABI parameter string\n * @param type ABI parameter type\n * @returns Cache key for {@link parameterCache}\n */\nexport function getParameterCacheKey(param, type, structs) {\n  let structKey = '';\n  if (structs) for (const struct of Object.entries(structs)) {\n    if (!struct) continue;\n    let propertyKey = '';\n    for (const property of struct[1]) {\n      propertyKey += `[${property.type}${property.name ? `:${property.name}` : ''}]`;\n    }\n    structKey += `(${struct[0]}{${propertyKey}})`;\n  }\n  if (type) return `${type}:${param}${structKey}`;\n  return param;\n}\n/**\n * Basic cache seeded with common ABI parameter strings.\n *\n * **Note: When seeding more parameters, make sure you benchmark performance. The current number is the ideal balance between performance and having an already existing cache.**\n */\nexport const parameterCache = new Map([\n// Unnamed\n['address', {\n  type: 'address'\n}], ['bool', {\n  type: 'bool'\n}], ['bytes', {\n  type: 'bytes'\n}], ['bytes32', {\n  type: 'bytes32'\n}], ['int', {\n  type: 'int256'\n}], ['int256', {\n  type: 'int256'\n}], ['string', {\n  type: 'string'\n}], ['uint', {\n  type: 'uint256'\n}], ['uint8', {\n  type: 'uint8'\n}], ['uint16', {\n  type: 'uint16'\n}], ['uint24', {\n  type: 'uint24'\n}], ['uint32', {\n  type: 'uint32'\n}], ['uint64', {\n  type: 'uint64'\n}], ['uint96', {\n  type: 'uint96'\n}], ['uint112', {\n  type: 'uint112'\n}], ['uint160', {\n  type: 'uint160'\n}], ['uint192', {\n  type: 'uint192'\n}], ['uint256', {\n  type: 'uint256'\n}],\n// Named\n['address owner', {\n  type: 'address',\n  name: 'owner'\n}], ['address to', {\n  type: 'address',\n  name: 'to'\n}], ['bool approved', {\n  type: 'bool',\n  name: 'approved'\n}], ['bytes _data', {\n  type: 'bytes',\n  name: '_data'\n}], ['bytes data', {\n  type: 'bytes',\n  name: 'data'\n}], ['bytes signature', {\n  type: 'bytes',\n  name: 'signature'\n}], ['bytes32 hash', {\n  type: 'bytes32',\n  name: 'hash'\n}], ['bytes32 r', {\n  type: 'bytes32',\n  name: 'r'\n}], ['bytes32 root', {\n  type: 'bytes32',\n  name: 'root'\n}], ['bytes32 s', {\n  type: 'bytes32',\n  name: 's'\n}], ['string name', {\n  type: 'string',\n  name: 'name'\n}], ['string symbol', {\n  type: 'string',\n  name: 'symbol'\n}], ['string tokenURI', {\n  type: 'string',\n  name: 'tokenURI'\n}], ['uint tokenId', {\n  type: 'uint256',\n  name: 'tokenId'\n}], ['uint8 v', {\n  type: 'uint8',\n  name: 'v'\n}], ['uint256 balance', {\n  type: 'uint256',\n  name: 'balance'\n}], ['uint256 tokenId', {\n  type: 'uint256',\n  name: 'tokenId'\n}], ['uint256 value', {\n  type: 'uint256',\n  name: 'value'\n}],\n// Indexed\n['event:address indexed from', {\n  type: 'address',\n  name: 'from',\n  indexed: true\n}], ['event:address indexed to', {\n  type: 'address',\n  name: 'to',\n  indexed: true\n}], ['event:uint indexed tokenId', {\n  type: 'uint256',\n  name: 'tokenId',\n  indexed: true\n}], ['event:uint256 indexed tokenId', {\n  type: 'uint256',\n  name: 'tokenId',\n  indexed: true\n}]]);\n//# sourceMappingURL=cache.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}