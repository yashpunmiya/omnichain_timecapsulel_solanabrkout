{"ast":null,"code":"'use strict';\n\nvar Buffer = require('safe-buffer').Buffer;\nvar Transform = require('stream').Transform;\nvar StringDecoder = require('string_decoder').StringDecoder;\nvar inherits = require('inherits');\nfunction CipherBase(hashMode) {\n  Transform.call(this);\n  this.hashMode = typeof hashMode === 'string';\n  if (this.hashMode) {\n    this[hashMode] = this._finalOrDigest;\n  } else {\n    this['final'] = this._finalOrDigest;\n  }\n  if (this._final) {\n    this.__final = this._final;\n    this._final = null;\n  }\n  this._decoder = null;\n  this._encoding = null;\n}\ninherits(CipherBase, Transform);\nvar useUint8Array = typeof Uint8Array !== 'undefined';\nvar useArrayBuffer = typeof ArrayBuffer !== 'undefined' && typeof Uint8Array !== 'undefined' && ArrayBuffer.isView && (Buffer.prototype instanceof Uint8Array || Buffer.TYPED_ARRAY_SUPPORT);\nfunction toBuffer(data, encoding) {\n  /*\n   * No need to do anything for exact instance\n   * This is only valid when safe-buffer.Buffer === buffer.Buffer, i.e. when Buffer.from/Buffer.alloc existed\n   */\n  if (data instanceof Buffer) {\n    return data;\n  }\n\n  // Convert strings to Buffer\n  if (typeof data === 'string') {\n    return Buffer.from(data, encoding);\n  }\n\n  /*\n   * Wrap any TypedArray instances and DataViews\n   * Makes sense only on engines with full TypedArray support -- let Buffer detect that\n   */\n  if (useArrayBuffer && ArrayBuffer.isView(data)) {\n    // Bug in Node.js <6.3.1, which treats this as out-of-bounds\n    if (data.byteLength === 0) {\n      return Buffer.alloc(0);\n    }\n    var res = Buffer.from(data.buffer, data.byteOffset, data.byteLength);\n    /*\n     * Recheck result size, as offset/length doesn't work on Node.js <5.10\n     * We just go to Uint8Array case if this fails\n     */\n    if (res.byteLength === data.byteLength) {\n      return res;\n    }\n  }\n\n  /*\n   * Uint8Array in engines where Buffer.from might not work with ArrayBuffer, just copy over\n   * Doesn't make sense with other TypedArray instances\n   */\n  if (useUint8Array && data instanceof Uint8Array) {\n    return Buffer.from(data);\n  }\n\n  /*\n   * Old Buffer polyfill on an engine that doesn't have TypedArray support\n   * Also, this is from a different Buffer polyfill implementation then we have, as instanceof check failed\n   * Convert to our current Buffer implementation\n   */\n  if (Buffer.isBuffer(data) && data.constructor && typeof data.constructor.isBuffer === 'function' && data.constructor.isBuffer(data)) {\n    return Buffer.from(data);\n  }\n  throw new TypeError('The \"data\" argument must be of type string or an instance of Buffer, TypedArray, or DataView.');\n}\nCipherBase.prototype.update = function (data, inputEnc, outputEnc) {\n  var bufferData = toBuffer(data, inputEnc); // asserts correct input type\n  var outData = this._update(bufferData);\n  if (this.hashMode) {\n    return this;\n  }\n  if (outputEnc) {\n    outData = this._toString(outData, outputEnc);\n  }\n  return outData;\n};\nCipherBase.prototype.setAutoPadding = function () {};\nCipherBase.prototype.getAuthTag = function () {\n  throw new Error('trying to get auth tag in unsupported state');\n};\nCipherBase.prototype.setAuthTag = function () {\n  throw new Error('trying to set auth tag in unsupported state');\n};\nCipherBase.prototype.setAAD = function () {\n  throw new Error('trying to set aad in unsupported state');\n};\nCipherBase.prototype._transform = function (data, _, next) {\n  var err;\n  try {\n    if (this.hashMode) {\n      this._update(data);\n    } else {\n      this.push(this._update(data));\n    }\n  } catch (e) {\n    err = e;\n  } finally {\n    next(err);\n  }\n};\nCipherBase.prototype._flush = function (done) {\n  var err;\n  try {\n    this.push(this.__final());\n  } catch (e) {\n    err = e;\n  }\n  done(err);\n};\nCipherBase.prototype._finalOrDigest = function (outputEnc) {\n  var outData = this.__final() || Buffer.alloc(0);\n  if (outputEnc) {\n    outData = this._toString(outData, outputEnc, true);\n  }\n  return outData;\n};\nCipherBase.prototype._toString = function (value, enc, fin) {\n  if (!this._decoder) {\n    this._decoder = new StringDecoder(enc);\n    this._encoding = enc;\n  }\n  if (this._encoding !== enc) {\n    throw new Error('canâ€™t switch encodings');\n  }\n  var out = this._decoder.write(value);\n  if (fin) {\n    out += this._decoder.end();\n  }\n  return out;\n};\nmodule.exports = CipherBase;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}