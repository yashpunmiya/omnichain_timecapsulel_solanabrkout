{"ast":null,"code":"import { readContract } from '../../../actions/public/readContract.js';\nimport { EnsAvatarInvalidMetadataError, EnsAvatarInvalidNftUriError, EnsAvatarUnsupportedNamespaceError, EnsAvatarUriResolutionError } from '../../../errors/ens.js';\nconst networkRegex = /(?<protocol>https?:\\/\\/[^\\/]*|ipfs:\\/|ipns:\\/|ar:\\/)?(?<root>\\/)?(?<subpath>ipfs\\/|ipns\\/)?(?<target>[\\w\\-.]+)(?<subtarget>\\/.*)?/;\nconst ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\\/(?<target>[\\w\\-.]+))?(?<subtarget>\\/.*)?$/;\nconst base64Regex = /^data:([a-zA-Z\\-/+]*);base64,([^\"].*)/;\nconst dataURIRegex = /^data:([a-zA-Z\\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;\n/** @internal */\nexport async function isImageUri(uri) {\n  try {\n    const res = await fetch(uri, {\n      method: 'HEAD'\n    });\n    // retrieve content type header to check if content is image\n    if (res.status === 200) {\n      const contentType = res.headers.get('content-type');\n      return contentType?.startsWith('image/');\n    }\n    return false;\n  } catch (error) {\n    // if error is not cors related then fail\n    if (typeof error === 'object' && typeof error.response !== 'undefined') {\n      return false;\n    }\n    // fail in NodeJS, since the error is not cors but any other network issue\n    // biome-ignore lint/suspicious/noPrototypeBuiltins:\n    if (!globalThis.hasOwnProperty('Image')) return false;\n    // in case of cors, use image api to validate if given url is an actual image\n    return new Promise(resolve => {\n      const img = new Image();\n      img.onload = () => {\n        resolve(true);\n      };\n      img.onerror = () => {\n        resolve(false);\n      };\n      img.src = uri;\n    });\n  }\n}\n/** @internal */\nexport function getGateway(custom, defaultGateway) {\n  if (!custom) return defaultGateway;\n  if (custom.endsWith('/')) return custom.slice(0, -1);\n  return custom;\n}\nexport function resolveAvatarUri({\n  uri,\n  gatewayUrls\n}) {\n  const isEncoded = base64Regex.test(uri);\n  if (isEncoded) return {\n    uri,\n    isOnChain: true,\n    isEncoded\n  };\n  const ipfsGateway = getGateway(gatewayUrls?.ipfs, 'https://ipfs.io');\n  const arweaveGateway = getGateway(gatewayUrls?.arweave, 'https://arweave.net');\n  const networkRegexMatch = uri.match(networkRegex);\n  const {\n    protocol,\n    subpath,\n    target,\n    subtarget = ''\n  } = networkRegexMatch?.groups || {};\n  const isIPNS = protocol === 'ipns:/' || subpath === 'ipns/';\n  const isIPFS = protocol === 'ipfs:/' || subpath === 'ipfs/' || ipfsHashRegex.test(uri);\n  if (uri.startsWith('http') && !isIPNS && !isIPFS) {\n    let replacedUri = uri;\n    if (gatewayUrls?.arweave) replacedUri = uri.replace(/https:\\/\\/arweave.net/g, gatewayUrls?.arweave);\n    return {\n      uri: replacedUri,\n      isOnChain: false,\n      isEncoded: false\n    };\n  }\n  if ((isIPNS || isIPFS) && target) {\n    return {\n      uri: `${ipfsGateway}/${isIPNS ? 'ipns' : 'ipfs'}/${target}${subtarget}`,\n      isOnChain: false,\n      isEncoded: false\n    };\n  }\n  if (protocol === 'ar:/' && target) {\n    return {\n      uri: `${arweaveGateway}/${target}${subtarget || ''}`,\n      isOnChain: false,\n      isEncoded: false\n    };\n  }\n  let parsedUri = uri.replace(dataURIRegex, '');\n  if (parsedUri.startsWith('<svg')) {\n    // if svg, base64 encode\n    parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`;\n  }\n  if (parsedUri.startsWith('data:') || parsedUri.startsWith('{')) {\n    return {\n      uri: parsedUri,\n      isOnChain: true,\n      isEncoded: false\n    };\n  }\n  throw new EnsAvatarUriResolutionError({\n    uri\n  });\n}\nexport function getJsonImage(data) {\n  // validation check for json data, must include one of theses properties\n  if (typeof data !== 'object' || !('image' in data) && !('image_url' in data) && !('image_data' in data)) {\n    throw new EnsAvatarInvalidMetadataError({\n      data\n    });\n  }\n  return data.image || data.image_url || data.image_data;\n}\nexport async function getMetadataAvatarUri({\n  gatewayUrls,\n  uri\n}) {\n  try {\n    const res = await fetch(uri).then(res => res.json());\n    const image = await parseAvatarUri({\n      gatewayUrls,\n      uri: getJsonImage(res)\n    });\n    return image;\n  } catch {\n    throw new EnsAvatarUriResolutionError({\n      uri\n    });\n  }\n}\nexport async function parseAvatarUri({\n  gatewayUrls,\n  uri\n}) {\n  const {\n    uri: resolvedURI,\n    isOnChain\n  } = resolveAvatarUri({\n    uri,\n    gatewayUrls\n  });\n  if (isOnChain) return resolvedURI;\n  // check if resolvedURI is an image, if it is return the url\n  const isImage = await isImageUri(resolvedURI);\n  if (isImage) return resolvedURI;\n  throw new EnsAvatarUriResolutionError({\n    uri\n  });\n}\nexport function parseNftUri(uri_) {\n  let uri = uri_;\n  // parse valid nft spec (CAIP-22/CAIP-29)\n  // @see: https://github.com/ChainAgnostic/CAIPs/tree/master/CAIPs\n  if (uri.startsWith('did:nft:')) {\n    // convert DID to CAIP\n    uri = uri.replace('did:nft:', '').replace(/_/g, '/');\n  }\n  const [reference, asset_namespace, tokenID] = uri.split('/');\n  const [eip_namespace, chainID] = reference.split(':');\n  const [erc_namespace, contractAddress] = asset_namespace.split(':');\n  if (!eip_namespace || eip_namespace.toLowerCase() !== 'eip155') throw new EnsAvatarInvalidNftUriError({\n    reason: 'Only EIP-155 supported'\n  });\n  if (!chainID) throw new EnsAvatarInvalidNftUriError({\n    reason: 'Chain ID not found'\n  });\n  if (!contractAddress) throw new EnsAvatarInvalidNftUriError({\n    reason: 'Contract address not found'\n  });\n  if (!tokenID) throw new EnsAvatarInvalidNftUriError({\n    reason: 'Token ID not found'\n  });\n  if (!erc_namespace) throw new EnsAvatarInvalidNftUriError({\n    reason: 'ERC namespace not found'\n  });\n  return {\n    chainID: Number.parseInt(chainID),\n    namespace: erc_namespace.toLowerCase(),\n    contractAddress: contractAddress,\n    tokenID\n  };\n}\nexport async function getNftTokenUri(client, {\n  nft\n}) {\n  if (nft.namespace === 'erc721') {\n    return readContract(client, {\n      address: nft.contractAddress,\n      abi: [{\n        name: 'tokenURI',\n        type: 'function',\n        stateMutability: 'view',\n        inputs: [{\n          name: 'tokenId',\n          type: 'uint256'\n        }],\n        outputs: [{\n          name: '',\n          type: 'string'\n        }]\n      }],\n      functionName: 'tokenURI',\n      args: [BigInt(nft.tokenID)]\n    });\n  }\n  if (nft.namespace === 'erc1155') {\n    return readContract(client, {\n      address: nft.contractAddress,\n      abi: [{\n        name: 'uri',\n        type: 'function',\n        stateMutability: 'view',\n        inputs: [{\n          name: '_id',\n          type: 'uint256'\n        }],\n        outputs: [{\n          name: '',\n          type: 'string'\n        }]\n      }],\n      functionName: 'uri',\n      args: [BigInt(nft.tokenID)]\n    });\n  }\n  throw new EnsAvatarUnsupportedNamespaceError({\n    namespace: nft.namespace\n  });\n}","map":{"version":3,"names":["readContract","EnsAvatarInvalidMetadataError","EnsAvatarInvalidNftUriError","EnsAvatarUnsupportedNamespaceError","EnsAvatarUriResolutionError","networkRegex","ipfsHashRegex","base64Regex","dataURIRegex","isImageUri","uri","res","fetch","method","status","contentType","headers","get","startsWith","error","response","globalThis","hasOwnProperty","Promise","resolve","img","Image","onload","onerror","src","getGateway","custom","defaultGateway","endsWith","slice","resolveAvatarUri","gatewayUrls","isEncoded","test","isOnChain","ipfsGateway","ipfs","arweaveGateway","arweave","networkRegexMatch","match","protocol","subpath","target","subtarget","groups","isIPNS","isIPFS","replacedUri","replace","parsedUri","btoa","getJsonImage","data","image","image_url","image_data","getMetadataAvatarUri","then","json","parseAvatarUri","resolvedURI","isImage","parseNftUri","uri_","reference","asset_namespace","tokenID","split","eip_namespace","chainID","erc_namespace","contractAddress","toLowerCase","reason","Number","parseInt","namespace","getNftTokenUri","client","nft","address","abi","name","type","stateMutability","inputs","outputs","functionName","args","BigInt"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@reown\\appkit\\node_modules\\@walletconnect\\utils\\node_modules\\viem\\utils\\ens\\avatar\\utils.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport {\n  type ReadContractErrorType,\n  readContract,\n} from '../../../actions/public/readContract.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport {\n  EnsAvatarInvalidMetadataError,\n  type EnsAvatarInvalidMetadataErrorType,\n  EnsAvatarInvalidNftUriError,\n  type EnsAvatarInvalidNftUriErrorType,\n  EnsAvatarUnsupportedNamespaceError,\n  type EnsAvatarUnsupportedNamespaceErrorType,\n  EnsAvatarUriResolutionError,\n  type EnsAvatarUriResolutionErrorType,\n} from '../../../errors/ens.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { AssetGatewayUrls } from '../../../types/ens.js'\n\ntype UriItem = {\n  uri: string\n  isOnChain: boolean\n  isEncoded: boolean\n}\n\nconst networkRegex =\n  /(?<protocol>https?:\\/\\/[^\\/]*|ipfs:\\/|ipns:\\/|ar:\\/)?(?<root>\\/)?(?<subpath>ipfs\\/|ipns\\/)?(?<target>[\\w\\-.]+)(?<subtarget>\\/.*)?/\nconst ipfsHashRegex =\n  /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\\/(?<target>[\\w\\-.]+))?(?<subtarget>\\/.*)?$/\nconst base64Regex = /^data:([a-zA-Z\\-/+]*);base64,([^\"].*)/\nconst dataURIRegex = /^data:([a-zA-Z\\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/\n\ntype IsImageUriErrorType = ErrorType\n\n/** @internal */\nexport async function isImageUri(uri: string) {\n  try {\n    const res = await fetch(uri, { method: 'HEAD' })\n    // retrieve content type header to check if content is image\n    if (res.status === 200) {\n      const contentType = res.headers.get('content-type')\n      return contentType?.startsWith('image/')\n    }\n    return false\n  } catch (error: any) {\n    // if error is not cors related then fail\n    if (typeof error === 'object' && typeof error.response !== 'undefined') {\n      return false\n    }\n    // fail in NodeJS, since the error is not cors but any other network issue\n    // biome-ignore lint/suspicious/noPrototypeBuiltins:\n    if (!globalThis.hasOwnProperty('Image')) return false\n    // in case of cors, use image api to validate if given url is an actual image\n    return new Promise((resolve) => {\n      const img = new Image()\n      img.onload = () => {\n        resolve(true)\n      }\n      img.onerror = () => {\n        resolve(false)\n      }\n      img.src = uri\n    })\n  }\n}\n\ntype GetGatewayErrorType = ErrorType\n\n/** @internal */\nexport function getGateway(custom: string | undefined, defaultGateway: string) {\n  if (!custom) return defaultGateway\n  if (custom.endsWith('/')) return custom.slice(0, -1)\n  return custom\n}\n\nexport type ResolveAvatarUriErrorType =\n  | GetGatewayErrorType\n  | EnsAvatarUriResolutionErrorType\n  | ErrorType\n\nexport function resolveAvatarUri({\n  uri,\n  gatewayUrls,\n}: {\n  uri: string\n  gatewayUrls?: AssetGatewayUrls | undefined\n}): UriItem {\n  const isEncoded = base64Regex.test(uri)\n  if (isEncoded) return { uri, isOnChain: true, isEncoded }\n\n  const ipfsGateway = getGateway(gatewayUrls?.ipfs, 'https://ipfs.io')\n  const arweaveGateway = getGateway(gatewayUrls?.arweave, 'https://arweave.net')\n\n  const networkRegexMatch = uri.match(networkRegex)\n  const {\n    protocol,\n    subpath,\n    target,\n    subtarget = '',\n  } = networkRegexMatch?.groups || {}\n\n  const isIPNS = protocol === 'ipns:/' || subpath === 'ipns/'\n  const isIPFS =\n    protocol === 'ipfs:/' || subpath === 'ipfs/' || ipfsHashRegex.test(uri)\n\n  if (uri.startsWith('http') && !isIPNS && !isIPFS) {\n    let replacedUri = uri\n    if (gatewayUrls?.arweave)\n      replacedUri = uri.replace(/https:\\/\\/arweave.net/g, gatewayUrls?.arweave)\n    return { uri: replacedUri, isOnChain: false, isEncoded: false }\n  }\n\n  if ((isIPNS || isIPFS) && target) {\n    return {\n      uri: `${ipfsGateway}/${isIPNS ? 'ipns' : 'ipfs'}/${target}${subtarget}`,\n      isOnChain: false,\n      isEncoded: false,\n    }\n  }\n\n  if (protocol === 'ar:/' && target) {\n    return {\n      uri: `${arweaveGateway}/${target}${subtarget || ''}`,\n      isOnChain: false,\n      isEncoded: false,\n    }\n  }\n\n  let parsedUri = uri.replace(dataURIRegex, '')\n  if (parsedUri.startsWith('<svg')) {\n    // if svg, base64 encode\n    parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`\n  }\n\n  if (parsedUri.startsWith('data:') || parsedUri.startsWith('{')) {\n    return {\n      uri: parsedUri,\n      isOnChain: true,\n      isEncoded: false,\n    }\n  }\n\n  throw new EnsAvatarUriResolutionError({ uri })\n}\n\nexport type GetJsonImageErrorType =\n  | EnsAvatarInvalidMetadataErrorType\n  | ErrorType\n\nexport function getJsonImage(data: any) {\n  // validation check for json data, must include one of theses properties\n  if (\n    typeof data !== 'object' ||\n    (!('image' in data) && !('image_url' in data) && !('image_data' in data))\n  ) {\n    throw new EnsAvatarInvalidMetadataError({ data })\n  }\n\n  return data.image || data.image_url || data.image_data\n}\n\nexport type GetMetadataAvatarUriErrorType =\n  | EnsAvatarUriResolutionErrorType\n  | ParseAvatarUriErrorType\n  | GetJsonImageErrorType\n  | ErrorType\n\nexport async function getMetadataAvatarUri({\n  gatewayUrls,\n  uri,\n}: {\n  gatewayUrls?: AssetGatewayUrls | undefined\n  uri: string\n}): Promise<string> {\n  try {\n    const res = await fetch(uri).then((res) => res.json())\n    const image = await parseAvatarUri({\n      gatewayUrls,\n      uri: getJsonImage(res),\n    })\n    return image\n  } catch {\n    throw new EnsAvatarUriResolutionError({ uri })\n  }\n}\n\nexport type ParseAvatarUriErrorType =\n  | ResolveAvatarUriErrorType\n  | IsImageUriErrorType\n  | EnsAvatarUriResolutionErrorType\n  | ErrorType\n\nexport async function parseAvatarUri({\n  gatewayUrls,\n  uri,\n}: {\n  gatewayUrls?: AssetGatewayUrls | undefined\n  uri: string\n}): Promise<string> {\n  const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls })\n  if (isOnChain) return resolvedURI\n\n  // check if resolvedURI is an image, if it is return the url\n  const isImage = await isImageUri(resolvedURI)\n  if (isImage) return resolvedURI\n\n  throw new EnsAvatarUriResolutionError({ uri })\n}\n\ntype ParsedNft = {\n  chainID: number\n  namespace: string\n  contractAddress: Address\n  tokenID: string\n}\n\nexport type ParseNftUriErrorType = EnsAvatarInvalidNftUriErrorType | ErrorType\n\nexport function parseNftUri(uri_: string): ParsedNft {\n  let uri = uri_\n  // parse valid nft spec (CAIP-22/CAIP-29)\n  // @see: https://github.com/ChainAgnostic/CAIPs/tree/master/CAIPs\n  if (uri.startsWith('did:nft:')) {\n    // convert DID to CAIP\n    uri = uri.replace('did:nft:', '').replace(/_/g, '/')\n  }\n\n  const [reference, asset_namespace, tokenID] = uri.split('/')\n  const [eip_namespace, chainID] = reference.split(':')\n  const [erc_namespace, contractAddress] = asset_namespace.split(':')\n\n  if (!eip_namespace || eip_namespace.toLowerCase() !== 'eip155')\n    throw new EnsAvatarInvalidNftUriError({ reason: 'Only EIP-155 supported' })\n  if (!chainID)\n    throw new EnsAvatarInvalidNftUriError({ reason: 'Chain ID not found' })\n  if (!contractAddress)\n    throw new EnsAvatarInvalidNftUriError({\n      reason: 'Contract address not found',\n    })\n  if (!tokenID)\n    throw new EnsAvatarInvalidNftUriError({ reason: 'Token ID not found' })\n  if (!erc_namespace)\n    throw new EnsAvatarInvalidNftUriError({ reason: 'ERC namespace not found' })\n\n  return {\n    chainID: Number.parseInt(chainID),\n    namespace: erc_namespace.toLowerCase(),\n    contractAddress: contractAddress as Address,\n    tokenID,\n  }\n}\n\nexport type GetNftTokenUriErrorType =\n  | ReadContractErrorType\n  | EnsAvatarUnsupportedNamespaceErrorType\n  | ErrorType\n\nexport async function getNftTokenUri<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  { nft }: { nft: ParsedNft },\n) {\n  if (nft.namespace === 'erc721') {\n    return readContract(client, {\n      address: nft.contractAddress,\n      abi: [\n        {\n          name: 'tokenURI',\n          type: 'function',\n          stateMutability: 'view',\n          inputs: [{ name: 'tokenId', type: 'uint256' }],\n          outputs: [{ name: '', type: 'string' }],\n        },\n      ],\n      functionName: 'tokenURI',\n      args: [BigInt(nft.tokenID)],\n    })\n  }\n  if (nft.namespace === 'erc1155') {\n    return readContract(client, {\n      address: nft.contractAddress,\n      abi: [\n        {\n          name: 'uri',\n          type: 'function',\n          stateMutability: 'view',\n          inputs: [{ name: '_id', type: 'uint256' }],\n          outputs: [{ name: '', type: 'string' }],\n        },\n      ],\n      functionName: 'uri',\n      args: [BigInt(nft.tokenID)],\n    })\n  }\n  throw new EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace })\n}\n"],"mappings":"AAEA,SAEEA,YAAY,QACP,yCAAyC;AAGhD,SACEC,6BAA6B,EAE7BC,2BAA2B,EAE3BC,kCAAkC,EAElCC,2BAA2B,QAEtB,wBAAwB;AAW/B,MAAMC,YAAY,GAChB,mIAAmI;AACrI,MAAMC,aAAa,GACjB,uJAAuJ;AACzJ,MAAMC,WAAW,GAAG,uCAAuC;AAC3D,MAAMC,YAAY,GAAG,6CAA6C;AAIlE;AACA,OAAO,eAAeC,UAAUA,CAACC,GAAW;EAC1C,IAAI;IACF,MAAMC,GAAG,GAAG,MAAMC,KAAK,CAACF,GAAG,EAAE;MAAEG,MAAM,EAAE;IAAM,CAAE,CAAC;IAChD;IACA,IAAIF,GAAG,CAACG,MAAM,KAAK,GAAG,EAAE;MACtB,MAAMC,WAAW,GAAGJ,GAAG,CAACK,OAAO,CAACC,GAAG,CAAC,cAAc,CAAC;MACnD,OAAOF,WAAW,EAAEG,UAAU,CAAC,QAAQ,CAAC;IAC1C;IACA,OAAO,KAAK;EACd,CAAC,CAAC,OAAOC,KAAU,EAAE;IACnB;IACA,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAI,OAAOA,KAAK,CAACC,QAAQ,KAAK,WAAW,EAAE;MACtE,OAAO,KAAK;IACd;IACA;IACA;IACA,IAAI,CAACC,UAAU,CAACC,cAAc,CAAC,OAAO,CAAC,EAAE,OAAO,KAAK;IACrD;IACA,OAAO,IAAIC,OAAO,CAAEC,OAAO,IAAI;MAC7B,MAAMC,GAAG,GAAG,IAAIC,KAAK,EAAE;MACvBD,GAAG,CAACE,MAAM,GAAG,MAAK;QAChBH,OAAO,CAAC,IAAI,CAAC;MACf,CAAC;MACDC,GAAG,CAACG,OAAO,GAAG,MAAK;QACjBJ,OAAO,CAAC,KAAK,CAAC;MAChB,CAAC;MACDC,GAAG,CAACI,GAAG,GAAGnB,GAAG;IACf,CAAC,CAAC;EACJ;AACF;AAIA;AACA,OAAM,SAAUoB,UAAUA,CAACC,MAA0B,EAAEC,cAAsB;EAC3E,IAAI,CAACD,MAAM,EAAE,OAAOC,cAAc;EAClC,IAAID,MAAM,CAACE,QAAQ,CAAC,GAAG,CAAC,EAAE,OAAOF,MAAM,CAACG,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;EACpD,OAAOH,MAAM;AACf;AAOA,OAAM,SAAUI,gBAAgBA,CAAC;EAC/BzB,GAAG;EACH0B;AAAW,CAIZ;EACC,MAAMC,SAAS,GAAG9B,WAAW,CAAC+B,IAAI,CAAC5B,GAAG,CAAC;EACvC,IAAI2B,SAAS,EAAE,OAAO;IAAE3B,GAAG;IAAE6B,SAAS,EAAE,IAAI;IAAEF;EAAS,CAAE;EAEzD,MAAMG,WAAW,GAAGV,UAAU,CAACM,WAAW,EAAEK,IAAI,EAAE,iBAAiB,CAAC;EACpE,MAAMC,cAAc,GAAGZ,UAAU,CAACM,WAAW,EAAEO,OAAO,EAAE,qBAAqB,CAAC;EAE9E,MAAMC,iBAAiB,GAAGlC,GAAG,CAACmC,KAAK,CAACxC,YAAY,CAAC;EACjD,MAAM;IACJyC,QAAQ;IACRC,OAAO;IACPC,MAAM;IACNC,SAAS,GAAG;EAAE,CACf,GAAGL,iBAAiB,EAAEM,MAAM,IAAI,EAAE;EAEnC,MAAMC,MAAM,GAAGL,QAAQ,KAAK,QAAQ,IAAIC,OAAO,KAAK,OAAO;EAC3D,MAAMK,MAAM,GACVN,QAAQ,KAAK,QAAQ,IAAIC,OAAO,KAAK,OAAO,IAAIzC,aAAa,CAACgC,IAAI,CAAC5B,GAAG,CAAC;EAEzE,IAAIA,GAAG,CAACQ,UAAU,CAAC,MAAM,CAAC,IAAI,CAACiC,MAAM,IAAI,CAACC,MAAM,EAAE;IAChD,IAAIC,WAAW,GAAG3C,GAAG;IACrB,IAAI0B,WAAW,EAAEO,OAAO,EACtBU,WAAW,GAAG3C,GAAG,CAAC4C,OAAO,CAAC,wBAAwB,EAAElB,WAAW,EAAEO,OAAO,CAAC;IAC3E,OAAO;MAAEjC,GAAG,EAAE2C,WAAW;MAAEd,SAAS,EAAE,KAAK;MAAEF,SAAS,EAAE;IAAK,CAAE;EACjE;EAEA,IAAI,CAACc,MAAM,IAAIC,MAAM,KAAKJ,MAAM,EAAE;IAChC,OAAO;MACLtC,GAAG,EAAE,GAAG8B,WAAW,IAAIW,MAAM,GAAG,MAAM,GAAG,MAAM,IAAIH,MAAM,GAAGC,SAAS,EAAE;MACvEV,SAAS,EAAE,KAAK;MAChBF,SAAS,EAAE;KACZ;EACH;EAEA,IAAIS,QAAQ,KAAK,MAAM,IAAIE,MAAM,EAAE;IACjC,OAAO;MACLtC,GAAG,EAAE,GAAGgC,cAAc,IAAIM,MAAM,GAAGC,SAAS,IAAI,EAAE,EAAE;MACpDV,SAAS,EAAE,KAAK;MAChBF,SAAS,EAAE;KACZ;EACH;EAEA,IAAIkB,SAAS,GAAG7C,GAAG,CAAC4C,OAAO,CAAC9C,YAAY,EAAE,EAAE,CAAC;EAC7C,IAAI+C,SAAS,CAACrC,UAAU,CAAC,MAAM,CAAC,EAAE;IAChC;IACAqC,SAAS,GAAG,6BAA6BC,IAAI,CAACD,SAAS,CAAC,EAAE;EAC5D;EAEA,IAAIA,SAAS,CAACrC,UAAU,CAAC,OAAO,CAAC,IAAIqC,SAAS,CAACrC,UAAU,CAAC,GAAG,CAAC,EAAE;IAC9D,OAAO;MACLR,GAAG,EAAE6C,SAAS;MACdhB,SAAS,EAAE,IAAI;MACfF,SAAS,EAAE;KACZ;EACH;EAEA,MAAM,IAAIjC,2BAA2B,CAAC;IAAEM;EAAG,CAAE,CAAC;AAChD;AAMA,OAAM,SAAU+C,YAAYA,CAACC,IAAS;EACpC;EACA,IACE,OAAOA,IAAI,KAAK,QAAQ,IACvB,EAAE,OAAO,IAAIA,IAAI,CAAC,IAAI,EAAE,WAAW,IAAIA,IAAI,CAAC,IAAI,EAAE,YAAY,IAAIA,IAAI,CAAE,EACzE;IACA,MAAM,IAAIzD,6BAA6B,CAAC;MAAEyD;IAAI,CAAE,CAAC;EACnD;EAEA,OAAOA,IAAI,CAACC,KAAK,IAAID,IAAI,CAACE,SAAS,IAAIF,IAAI,CAACG,UAAU;AACxD;AAQA,OAAO,eAAeC,oBAAoBA,CAAC;EACzC1B,WAAW;EACX1B;AAAG,CAIJ;EACC,IAAI;IACF,MAAMC,GAAG,GAAG,MAAMC,KAAK,CAACF,GAAG,CAAC,CAACqD,IAAI,CAAEpD,GAAG,IAAKA,GAAG,CAACqD,IAAI,EAAE,CAAC;IACtD,MAAML,KAAK,GAAG,MAAMM,cAAc,CAAC;MACjC7B,WAAW;MACX1B,GAAG,EAAE+C,YAAY,CAAC9C,GAAG;KACtB,CAAC;IACF,OAAOgD,KAAK;EACd,CAAC,CAAC,MAAM;IACN,MAAM,IAAIvD,2BAA2B,CAAC;MAAEM;IAAG,CAAE,CAAC;EAChD;AACF;AAQA,OAAO,eAAeuD,cAAcA,CAAC;EACnC7B,WAAW;EACX1B;AAAG,CAIJ;EACC,MAAM;IAAEA,GAAG,EAAEwD,WAAW;IAAE3B;EAAS,CAAE,GAAGJ,gBAAgB,CAAC;IAAEzB,GAAG;IAAE0B;EAAW,CAAE,CAAC;EAC9E,IAAIG,SAAS,EAAE,OAAO2B,WAAW;EAEjC;EACA,MAAMC,OAAO,GAAG,MAAM1D,UAAU,CAACyD,WAAW,CAAC;EAC7C,IAAIC,OAAO,EAAE,OAAOD,WAAW;EAE/B,MAAM,IAAI9D,2BAA2B,CAAC;IAAEM;EAAG,CAAE,CAAC;AAChD;AAWA,OAAM,SAAU0D,WAAWA,CAACC,IAAY;EACtC,IAAI3D,GAAG,GAAG2D,IAAI;EACd;EACA;EACA,IAAI3D,GAAG,CAACQ,UAAU,CAAC,UAAU,CAAC,EAAE;IAC9B;IACAR,GAAG,GAAGA,GAAG,CAAC4C,OAAO,CAAC,UAAU,EAAE,EAAE,CAAC,CAACA,OAAO,CAAC,IAAI,EAAE,GAAG,CAAC;EACtD;EAEA,MAAM,CAACgB,SAAS,EAAEC,eAAe,EAAEC,OAAO,CAAC,GAAG9D,GAAG,CAAC+D,KAAK,CAAC,GAAG,CAAC;EAC5D,MAAM,CAACC,aAAa,EAAEC,OAAO,CAAC,GAAGL,SAAS,CAACG,KAAK,CAAC,GAAG,CAAC;EACrD,MAAM,CAACG,aAAa,EAAEC,eAAe,CAAC,GAAGN,eAAe,CAACE,KAAK,CAAC,GAAG,CAAC;EAEnE,IAAI,CAACC,aAAa,IAAIA,aAAa,CAACI,WAAW,EAAE,KAAK,QAAQ,EAC5D,MAAM,IAAI5E,2BAA2B,CAAC;IAAE6E,MAAM,EAAE;EAAwB,CAAE,CAAC;EAC7E,IAAI,CAACJ,OAAO,EACV,MAAM,IAAIzE,2BAA2B,CAAC;IAAE6E,MAAM,EAAE;EAAoB,CAAE,CAAC;EACzE,IAAI,CAACF,eAAe,EAClB,MAAM,IAAI3E,2BAA2B,CAAC;IACpC6E,MAAM,EAAE;GACT,CAAC;EACJ,IAAI,CAACP,OAAO,EACV,MAAM,IAAItE,2BAA2B,CAAC;IAAE6E,MAAM,EAAE;EAAoB,CAAE,CAAC;EACzE,IAAI,CAACH,aAAa,EAChB,MAAM,IAAI1E,2BAA2B,CAAC;IAAE6E,MAAM,EAAE;EAAyB,CAAE,CAAC;EAE9E,OAAO;IACLJ,OAAO,EAAEK,MAAM,CAACC,QAAQ,CAACN,OAAO,CAAC;IACjCO,SAAS,EAAEN,aAAa,CAACE,WAAW,EAAE;IACtCD,eAAe,EAAEA,eAA0B;IAC3CL;GACD;AACH;AAOA,OAAO,eAAeW,cAAcA,CAClCC,MAAgC,EAChC;EAAEC;AAAG,CAAsB;EAE3B,IAAIA,GAAG,CAACH,SAAS,KAAK,QAAQ,EAAE;IAC9B,OAAOlF,YAAY,CAACoF,MAAM,EAAE;MAC1BE,OAAO,EAAED,GAAG,CAACR,eAAe;MAC5BU,GAAG,EAAE,CACH;QACEC,IAAI,EAAE,UAAU;QAChBC,IAAI,EAAE,UAAU;QAChBC,eAAe,EAAE,MAAM;QACvBC,MAAM,EAAE,CAAC;UAAEH,IAAI,EAAE,SAAS;UAAEC,IAAI,EAAE;QAAS,CAAE,CAAC;QAC9CG,OAAO,EAAE,CAAC;UAAEJ,IAAI,EAAE,EAAE;UAAEC,IAAI,EAAE;QAAQ,CAAE;OACvC,CACF;MACDI,YAAY,EAAE,UAAU;MACxBC,IAAI,EAAE,CAACC,MAAM,CAACV,GAAG,CAACb,OAAO,CAAC;KAC3B,CAAC;EACJ;EACA,IAAIa,GAAG,CAACH,SAAS,KAAK,SAAS,EAAE;IAC/B,OAAOlF,YAAY,CAACoF,MAAM,EAAE;MAC1BE,OAAO,EAAED,GAAG,CAACR,eAAe;MAC5BU,GAAG,EAAE,CACH;QACEC,IAAI,EAAE,KAAK;QACXC,IAAI,EAAE,UAAU;QAChBC,eAAe,EAAE,MAAM;QACvBC,MAAM,EAAE,CAAC;UAAEH,IAAI,EAAE,KAAK;UAAEC,IAAI,EAAE;QAAS,CAAE,CAAC;QAC1CG,OAAO,EAAE,CAAC;UAAEJ,IAAI,EAAE,EAAE;UAAEC,IAAI,EAAE;QAAQ,CAAE;OACvC,CACF;MACDI,YAAY,EAAE,KAAK;MACnBC,IAAI,EAAE,CAACC,MAAM,CAACV,GAAG,CAACb,OAAO,CAAC;KAC3B,CAAC;EACJ;EACA,MAAM,IAAIrE,kCAAkC,CAAC;IAAE+E,SAAS,EAAEG,GAAG,CAACH;EAAS,CAAE,CAAC;AAC5E","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}