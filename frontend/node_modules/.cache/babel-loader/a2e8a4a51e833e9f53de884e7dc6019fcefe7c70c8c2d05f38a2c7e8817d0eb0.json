{"ast":null,"code":"import { detect as Pr } from \"detect-browser\";\nimport { toMiliseconds as We, FIVE_MINUTES as jt, fromMiliseconds as Br } from \"@walletconnect/time\";\nimport { getDocument as ze, getNavigator as Ct, getLocation as kt } from \"@walletconnect/window-getters\";\nimport { getWindowMetadata as Lr } from \"@walletconnect/window-metadata\";\nimport { recoverAddress as jr } from \"viem\";\nimport Cr from \"bs58\";\nimport { decodeJWT as kr } from \"@walletconnect/relay-auth\";\nimport { toString as K, fromString as W, concat as Je } from \"uint8arrays\";\nimport { ec as Dr } from \"elliptic\";\nimport { RELAY_JSONRPC as Mr } from \"@walletconnect/relay-api\";\nconst Pe = \":\";\nfunction Ye(e) {\n  const [t, n] = e.split(Pe);\n  return {\n    namespace: t,\n    reference: n\n  };\n}\nfunction Dt(e) {\n  const {\n    namespace: t,\n    reference: n\n  } = e;\n  return [t, n].join(Pe);\n}\nfunction Xe(e) {\n  const [t, n, r] = e.split(Pe);\n  return {\n    namespace: t,\n    reference: n,\n    address: r\n  };\n}\nfunction Mt(e) {\n  const {\n    namespace: t,\n    reference: n,\n    address: r\n  } = e;\n  return [t, n, r].join(Pe);\n}\nfunction Ze(e, t) {\n  const n = [];\n  return e.forEach(r => {\n    const o = t(r);\n    n.includes(o) || n.push(o);\n  }), n;\n}\nfunction Vt(e) {\n  const {\n    address: t\n  } = Xe(e);\n  return t;\n}\nfunction Ht(e) {\n  const {\n    namespace: t,\n    reference: n\n  } = Xe(e);\n  return Dt({\n    namespace: t,\n    reference: n\n  });\n}\nfunction Vr(e, t) {\n  const {\n    namespace: n,\n    reference: r\n  } = Ye(t);\n  return Mt({\n    namespace: n,\n    reference: r,\n    address: e\n  });\n}\nfunction Hr(e) {\n  return Ze(e, Vt);\n}\nfunction Kt(e) {\n  return Ze(e, Ht);\n}\nfunction Kr(e, t = []) {\n  const n = [];\n  return Object.keys(e).forEach(r => {\n    if (t.length && !t.includes(r)) return;\n    const o = e[r];\n    n.push(...o.accounts);\n  }), n;\n}\nfunction Fr(e, t = []) {\n  const n = [];\n  return Object.keys(e).forEach(r => {\n    if (t.length && !t.includes(r)) return;\n    const o = e[r];\n    n.push(...Kt(o.accounts));\n  }), n;\n}\nfunction qr(e, t = []) {\n  const n = [];\n  return Object.keys(e).forEach(r => {\n    if (t.length && !t.includes(r)) return;\n    const o = e[r];\n    n.push(...Be(r, o));\n  }), n;\n}\nfunction Be(e, t) {\n  return e.includes(\":\") ? [e] : t.chains || [];\n}\nconst Ft = \"ReactNative\",\n  H = {\n    reactNative: \"react-native\",\n    node: \"node\",\n    browser: \"browser\",\n    unknown: \"unknown\"\n  },\n  Le = \" \",\n  Gr = \":\",\n  qt = \"/\",\n  Qe = 2,\n  Wr = 1e3,\n  Gt = \"js\";\nfunction et() {\n  return typeof process < \"u\" && typeof process.versions < \"u\" && typeof process.versions.node < \"u\";\n}\nfunction ne() {\n  return !ze() && !!Ct() && navigator.product === Ft;\n}\nfunction zr() {\n  return ne() && typeof global < \"u\" && typeof (global == null ? void 0 : global.Platform) < \"u\" && (global == null ? void 0 : global.Platform.OS) === \"android\";\n}\nfunction Jr() {\n  return ne() && typeof global < \"u\" && typeof (global == null ? void 0 : global.Platform) < \"u\" && (global == null ? void 0 : global.Platform.OS) === \"ios\";\n}\nfunction Ae() {\n  return !et() && !!Ct() && !!ze();\n}\nfunction ue() {\n  return ne() ? H.reactNative : et() ? H.node : Ae() ? H.browser : H.unknown;\n}\nfunction Yr() {\n  var e;\n  try {\n    return ne() && typeof global < \"u\" && typeof (global == null ? void 0 : global.Application) < \"u\" ? (e = global.Application) == null ? void 0 : e.applicationId : void 0;\n  } catch {\n    return;\n  }\n}\nfunction Wt(e, t) {\n  const n = new URLSearchParams(e);\n  for (const r of Object.keys(t).sort()) if (t.hasOwnProperty(r)) {\n    const o = t[r];\n    o !== void 0 && n.set(r, o);\n  }\n  return n.toString();\n}\nfunction Xr() {\n  return Lr() || {\n    name: \"\",\n    description: \"\",\n    url: \"\",\n    icons: [\"\"]\n  };\n}\nfunction Zr(e, t) {\n  var n;\n  const r = ue(),\n    o = {\n      protocol: e,\n      version: t,\n      env: r\n    };\n  return r === \"browser\" && (o.host = ((n = kt()) == null ? void 0 : n.host) || \"unknown\"), o;\n}\nfunction zt() {\n  if (ue() === H.reactNative && typeof global < \"u\" && typeof (global == null ? void 0 : global.Platform) < \"u\") {\n    const {\n      OS: n,\n      Version: r\n    } = global.Platform;\n    return [n, r].join(\"-\");\n  }\n  const e = Pr();\n  if (e === null) return \"unknown\";\n  const t = e.os ? e.os.replace(\" \", \"\").toLowerCase() : \"unknown\";\n  return e.type === \"browser\" ? [t, e.name, e.version].join(\"-\") : [t, e.version].join(\"-\");\n}\nfunction Jt() {\n  var e;\n  const t = ue();\n  return t === H.browser ? [t, ((e = kt()) == null ? void 0 : e.host) || \"unknown\"].join(\":\") : t;\n}\nfunction Yt(e, t, n) {\n  const r = zt(),\n    o = Jt();\n  return [[e, t].join(\"-\"), [Gt, n].join(\"-\"), r, o].join(\"/\");\n}\nfunction Qr({\n  protocol: e,\n  version: t,\n  relayUrl: n,\n  sdkVersion: r,\n  auth: o,\n  projectId: s,\n  useOnCloseEvent: i,\n  bundleId: c,\n  packageName: u\n}) {\n  const a = n.split(\"?\"),\n    l = Yt(e, t, r),\n    f = {\n      auth: o,\n      ua: l,\n      projectId: s,\n      useOnCloseEvent: i || void 0,\n      packageName: u || void 0,\n      bundleId: c || void 0\n    },\n    d = Wt(a[1] || \"\", f);\n  return a[0] + \"?\" + d;\n}\nfunction eo(e) {\n  let t = (e.match(/^[^:]+(?=:\\/\\/)/gi) || [])[0];\n  const n = typeof t < \"u\" ? e.split(\"://\")[1] : e;\n  return t = t === \"wss\" ? \"https\" : \"http\", [t, n].join(\"://\");\n}\nfunction to(e, t, n) {\n  if (!e[t] || typeof e[t] !== n) throw new Error(`Missing or invalid \"${t}\" param`);\n}\nfunction Xt(e, t = Qe) {\n  return Zt(e.split(qt), t);\n}\nfunction no(e) {\n  return Xt(e).join(Le);\n}\nfunction re(e, t) {\n  return e.filter(n => t.includes(n)).length === e.length;\n}\nfunction Zt(e, t = Qe) {\n  return e.slice(Math.max(e.length - t, 0));\n}\nfunction ro(e) {\n  return Object.fromEntries(e.entries());\n}\nfunction oo(e) {\n  return new Map(Object.entries(e));\n}\nfunction so(e, t) {\n  const n = {};\n  return Object.keys(e).forEach(r => {\n    n[r] = t(e[r]);\n  }), n;\n}\nconst io = e => e;\nfunction Qt(e) {\n  return e.trim().replace(/^\\w/, t => t.toUpperCase());\n}\nfunction co(e) {\n  return e.split(Le).map(t => Qt(t)).join(Le);\n}\nfunction ao(e = jt, t) {\n  const n = We(e || jt);\n  let r, o, s, i;\n  return {\n    resolve: c => {\n      s && r && (clearTimeout(s), r(c), i = Promise.resolve(c));\n    },\n    reject: c => {\n      s && o && (clearTimeout(s), o(c));\n    },\n    done: () => new Promise((c, u) => {\n      if (i) return c(i);\n      s = setTimeout(() => {\n        const a = new Error(t);\n        i = Promise.reject(a), u(a);\n      }, n), r = c, o = u;\n    })\n  };\n}\nfunction uo(e, t, n) {\n  return new Promise(async (r, o) => {\n    const s = setTimeout(() => o(new Error(n)), t);\n    try {\n      const i = await e;\n      r(i);\n    } catch (i) {\n      o(i);\n    }\n    clearTimeout(s);\n  });\n}\nfunction tt(e, t) {\n  if (typeof t == \"string\" && t.startsWith(`${e}:`)) return t;\n  if (e.toLowerCase() === \"topic\") {\n    if (typeof t != \"string\") throw new Error('Value must be \"string\" for expirer target type: topic');\n    return `topic:${t}`;\n  } else if (e.toLowerCase() === \"id\") {\n    if (typeof t != \"number\") throw new Error('Value must be \"number\" for expirer target type: id');\n    return `id:${t}`;\n  }\n  throw new Error(`Unknown expirer target type: ${e}`);\n}\nfunction fo(e) {\n  return tt(\"topic\", e);\n}\nfunction lo(e) {\n  return tt(\"id\", e);\n}\nfunction ho(e) {\n  const [t, n] = e.split(\":\"),\n    r = {\n      id: void 0,\n      topic: void 0\n    };\n  if (t === \"topic\" && typeof n == \"string\") r.topic = n;else if (t === \"id\" && Number.isInteger(Number(n))) r.id = Number(n);else throw new Error(`Invalid target, expected id:number or topic:string, got ${t}:${n}`);\n  return r;\n}\nfunction po(e, t) {\n  return Br((t || Date.now()) + We(e));\n}\nfunction go(e) {\n  return Date.now() >= We(e);\n}\nfunction yo(e, t) {\n  return `${e}${t ? `:${t}` : \"\"}`;\n}\nfunction Q(e = [], t = []) {\n  return [...new Set([...e, ...t])];\n}\nasync function mo({\n  id: e,\n  topic: t,\n  wcDeepLink: n\n}) {\n  var r;\n  try {\n    if (!n) return;\n    const o = typeof n == \"string\" ? JSON.parse(n) : n,\n      s = o?.href;\n    if (typeof s != \"string\") return;\n    const i = en(s, e, t),\n      c = ue();\n    if (c === H.browser) {\n      if (!((r = ze()) != null && r.hasFocus())) {\n        console.warn(\"Document does not have focus, skipping deeplink.\");\n        return;\n      }\n      tn(i);\n    } else c === H.reactNative && typeof (global == null ? void 0 : global.Linking) < \"u\" && (await global.Linking.openURL(i));\n  } catch (o) {\n    console.error(o);\n  }\n}\nfunction en(e, t, n) {\n  const r = `requestId=${t}&sessionTopic=${n}`;\n  e.endsWith(\"/\") && (e = e.slice(0, -1));\n  let o = `${e}`;\n  if (e.startsWith(\"https://t.me\")) {\n    const s = e.includes(\"?\") ? \"&startapp=\" : \"?startapp=\";\n    o = `${o}${s}${on(r, !0)}`;\n  } else o = `${o}/wc?${r}`;\n  return o;\n}\nfunction tn(e) {\n  let t = \"_self\";\n  rn() ? t = \"_top\" : (nn() || e.startsWith(\"https://\") || e.startsWith(\"http://\")) && (t = \"_blank\"), window.open(e, t, \"noreferrer noopener\");\n}\nasync function bo(e, t) {\n  let n = \"\";\n  try {\n    if (Ae() && (n = localStorage.getItem(t), n)) return n;\n    n = await e.getItem(t);\n  } catch (r) {\n    console.error(r);\n  }\n  return n;\n}\nfunction nt(e, t) {\n  return e.filter(n => t.includes(n));\n}\nfunction wo(e, t) {\n  if (!e.includes(t)) return null;\n  const n = e.split(/([&,?,=])/),\n    r = n.indexOf(t);\n  return n[r + 2];\n}\nfunction Eo() {\n  return typeof crypto < \"u\" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/gu, e => {\n    const t = Math.random() * 16 | 0;\n    return (e === \"x\" ? t : t & 3 | 8).toString(16);\n  });\n}\nfunction vo() {\n  return typeof process < \"u\" && process.env.IS_VITEST === \"true\";\n}\nfunction nn() {\n  return typeof window < \"u\" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto);\n}\nfunction rn() {\n  try {\n    return window.self !== window.top;\n  } catch {\n    return !1;\n  }\n}\nfunction on(e, t = !1) {\n  const n = Buffer.from(e).toString(\"base64\");\n  return t ? n.replace(/[=]/g, \"\") : n;\n}\nfunction rt(e) {\n  return Buffer.from(e, \"base64\").toString(\"utf-8\");\n}\nfunction xo(e) {\n  return new Promise(t => setTimeout(t, e));\n}\nfunction Ne(e) {\n  if (!Number.isSafeInteger(e) || e < 0) throw new Error(\"positive integer expected, got \" + e);\n}\nfunction Io(e) {\n  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === \"Uint8Array\";\n}\nfunction je(e, ...t) {\n  if (!Io(e)) throw new Error(\"Uint8Array expected\");\n  if (t.length > 0 && !t.includes(e.length)) throw new Error(\"Uint8Array expected of length \" + t + \", got length=\" + e.length);\n}\nfunction ot(e) {\n  if (typeof e != \"function\" || typeof e.create != \"function\") throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n  Ne(e.outputLen), Ne(e.blockLen);\n}\nfunction me(e, t = !0) {\n  if (e.destroyed) throw new Error(\"Hash instance has been destroyed\");\n  if (t && e.finished) throw new Error(\"Hash#digest() has already been called\");\n}\nfunction sn(e, t) {\n  je(e);\n  const n = t.outputLen;\n  if (e.length < n) throw new Error(\"digestInto() expects output buffer of length at least \" + n);\n}\nconst Ce = BigInt(2 ** 32 - 1),\n  cn = BigInt(32);\nfunction Oo(e, t = !1) {\n  return t ? {\n    h: Number(e & Ce),\n    l: Number(e >> cn & Ce)\n  } : {\n    h: Number(e >> cn & Ce) | 0,\n    l: Number(e & Ce) | 0\n  };\n}\nfunction Ao(e, t = !1) {\n  let n = new Uint32Array(e.length),\n    r = new Uint32Array(e.length);\n  for (let o = 0; o < e.length; o++) {\n    const {\n      h: s,\n      l: i\n    } = Oo(e[o], t);\n    [n[o], r[o]] = [s, i];\n  }\n  return [n, r];\n}\nconst No = (e, t, n) => e << n | t >>> 32 - n,\n  So = (e, t, n) => t << n | e >>> 32 - n,\n  Uo = (e, t, n) => t << n - 32 | e >>> 64 - n,\n  _o = (e, t, n) => e << n - 32 | t >>> 64 - n,\n  be = typeof globalThis == \"object\" && \"crypto\" in globalThis ? globalThis.crypto : void 0;\nfunction To(e) {\n  return new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4));\n}\nfunction st(e) {\n  return new DataView(e.buffer, e.byteOffset, e.byteLength);\n}\nfunction J(e, t) {\n  return e << 32 - t | e >>> t;\n}\nconst an = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;\nfunction $o(e) {\n  return e << 24 & 4278190080 | e << 8 & 16711680 | e >>> 8 & 65280 | e >>> 24 & 255;\n}\nfunction un(e) {\n  for (let t = 0; t < e.length; t++) e[t] = $o(e[t]);\n}\nfunction Ro(e) {\n  if (typeof e != \"string\") throw new Error(\"utf8ToBytes expected string, got \" + typeof e);\n  return new Uint8Array(new TextEncoder().encode(e));\n}\nfunction we(e) {\n  return typeof e == \"string\" && (e = Ro(e)), je(e), e;\n}\nclass it {\n  clone() {\n    return this._cloneInto();\n  }\n}\nfunction fn(e) {\n  const t = r => e().update(we(r)).digest(),\n    n = e();\n  return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = () => e(), t;\n}\nfunction Se(e = 32) {\n  if (be && typeof be.getRandomValues == \"function\") return be.getRandomValues(new Uint8Array(e));\n  if (be && typeof be.randomBytes == \"function\") return be.randomBytes(e);\n  throw new Error(\"crypto.getRandomValues must be defined\");\n}\nconst ln = [],\n  dn = [],\n  hn = [],\n  Po = BigInt(0),\n  Ue = BigInt(1),\n  Bo = BigInt(2),\n  Lo = BigInt(7),\n  jo = BigInt(256),\n  Co = BigInt(113);\nfor (let e = 0, t = Ue, n = 1, r = 0; e < 24; e++) {\n  [n, r] = [r, (2 * n + 3 * r) % 5], ln.push(2 * (5 * r + n)), dn.push((e + 1) * (e + 2) / 2 % 64);\n  let o = Po;\n  for (let s = 0; s < 7; s++) t = (t << Ue ^ (t >> Lo) * Co) % jo, t & Bo && (o ^= Ue << (Ue << BigInt(s)) - Ue);\n  hn.push(o);\n}\nconst [ko, Do] = Ao(hn, !0),\n  pn = (e, t, n) => n > 32 ? Uo(e, t, n) : No(e, t, n),\n  gn = (e, t, n) => n > 32 ? _o(e, t, n) : So(e, t, n);\nfunction Mo(e, t = 24) {\n  const n = new Uint32Array(10);\n  for (let r = 24 - t; r < 24; r++) {\n    for (let i = 0; i < 10; i++) n[i] = e[i] ^ e[i + 10] ^ e[i + 20] ^ e[i + 30] ^ e[i + 40];\n    for (let i = 0; i < 10; i += 2) {\n      const c = (i + 8) % 10,\n        u = (i + 2) % 10,\n        a = n[u],\n        l = n[u + 1],\n        f = pn(a, l, 1) ^ n[c],\n        d = gn(a, l, 1) ^ n[c + 1];\n      for (let g = 0; g < 50; g += 10) e[i + g] ^= f, e[i + g + 1] ^= d;\n    }\n    let o = e[2],\n      s = e[3];\n    for (let i = 0; i < 24; i++) {\n      const c = dn[i],\n        u = pn(o, s, c),\n        a = gn(o, s, c),\n        l = ln[i];\n      o = e[l], s = e[l + 1], e[l] = u, e[l + 1] = a;\n    }\n    for (let i = 0; i < 50; i += 10) {\n      for (let c = 0; c < 10; c++) n[c] = e[i + c];\n      for (let c = 0; c < 10; c++) e[i + c] ^= ~n[(c + 2) % 10] & n[(c + 4) % 10];\n    }\n    e[0] ^= ko[r], e[1] ^= Do[r];\n  }\n  n.fill(0);\n}\nclass Lt extends it {\n  constructor(t, n, r, o = !1, s = 24) {\n    if (super(), this.blockLen = t, this.suffix = n, this.outputLen = r, this.enableXOF = o, this.rounds = s, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, Ne(r), 0 >= this.blockLen || this.blockLen >= 200) throw new Error(\"Sha3 supports only keccak-f1600 function\");\n    this.state = new Uint8Array(200), this.state32 = To(this.state);\n  }\n  keccak() {\n    an || un(this.state32), Mo(this.state32, this.rounds), an || un(this.state32), this.posOut = 0, this.pos = 0;\n  }\n  update(t) {\n    me(this);\n    const {\n      blockLen: n,\n      state: r\n    } = this;\n    t = we(t);\n    const o = t.length;\n    for (let s = 0; s < o;) {\n      const i = Math.min(n - this.pos, o - s);\n      for (let c = 0; c < i; c++) r[this.pos++] ^= t[s++];\n      this.pos === n && this.keccak();\n    }\n    return this;\n  }\n  finish() {\n    if (this.finished) return;\n    this.finished = !0;\n    const {\n      state: t,\n      suffix: n,\n      pos: r,\n      blockLen: o\n    } = this;\n    t[r] ^= n, (n & 128) !== 0 && r === o - 1 && this.keccak(), t[o - 1] ^= 128, this.keccak();\n  }\n  writeInto(t) {\n    me(this, !1), je(t), this.finish();\n    const n = this.state,\n      {\n        blockLen: r\n      } = this;\n    for (let o = 0, s = t.length; o < s;) {\n      this.posOut >= r && this.keccak();\n      const i = Math.min(r - this.posOut, s - o);\n      t.set(n.subarray(this.posOut, this.posOut + i), o), this.posOut += i, o += i;\n    }\n    return t;\n  }\n  xofInto(t) {\n    if (!this.enableXOF) throw new Error(\"XOF is not possible for this instance\");\n    return this.writeInto(t);\n  }\n  xof(t) {\n    return Ne(t), this.xofInto(new Uint8Array(t));\n  }\n  digestInto(t) {\n    if (sn(t, this), this.finished) throw new Error(\"digest() was already called\");\n    return this.writeInto(t), this.destroy(), t;\n  }\n  digest() {\n    return this.digestInto(new Uint8Array(this.outputLen));\n  }\n  destroy() {\n    this.destroyed = !0, this.state.fill(0);\n  }\n  _cloneInto(t) {\n    const {\n      blockLen: n,\n      suffix: r,\n      outputLen: o,\n      rounds: s,\n      enableXOF: i\n    } = this;\n    return t || (t = new Lt(n, r, o, i, s)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = s, t.suffix = r, t.outputLen = o, t.enableXOF = i, t.destroyed = this.destroyed, t;\n  }\n}\nconst Vo = (e, t, n) => fn(() => new Lt(t, e, n)),\n  Ho = Vo(1, 136, 256 / 8),\n  Ko = \"https://rpc.walletconnect.org/v1\";\nfunction ct(e) {\n  const t = `\u0019Ethereum Signed Message:\n${e.length}`,\n    n = new TextEncoder().encode(t + e);\n  return \"0x\" + Buffer.from(Ho(n)).toString(\"hex\");\n}\nasync function yn(e, t, n, r, o, s) {\n  switch (n.t) {\n    case \"eip191\":\n      return await mn(e, t, n.s);\n    case \"eip1271\":\n      return await bn(e, t, n.s, r, o, s);\n    default:\n      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${n.t}`);\n  }\n}\nasync function mn(e, t, n) {\n  return (await jr({\n    hash: ct(t),\n    signature: n\n  })).toLowerCase() === e.toLowerCase();\n}\nasync function bn(e, t, n, r, o, s) {\n  const i = Ye(r);\n  if (!i.namespace || !i.reference) throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${r}`);\n  try {\n    const c = \"0x1626ba7e\",\n      u = \"0000000000000000000000000000000000000000000000000000000000000040\",\n      a = \"0000000000000000000000000000000000000000000000000000000000000041\",\n      l = n.substring(2),\n      f = ct(t).substring(2),\n      d = c + f + u + a + l,\n      g = await fetch(`${s || Ko}/?chainId=${r}&projectId=${o}`, {\n        method: \"POST\",\n        body: JSON.stringify({\n          id: Fo(),\n          jsonrpc: \"2.0\",\n          method: \"eth_call\",\n          params: [{\n            to: e,\n            data: d\n          }, \"latest\"]\n        })\n      }),\n      {\n        result: y\n      } = await g.json();\n    return y ? y.slice(0, c.length).toLowerCase() === c.toLowerCase() : !1;\n  } catch (c) {\n    return console.error(\"isValidEip1271Signature: \", c), !1;\n  }\n}\nfunction Fo() {\n  return Date.now() + Math.floor(Math.random() * 1e3);\n}\nfunction qo(e) {\n  const t = atob(e),\n    n = new Uint8Array(t.length);\n  for (let i = 0; i < t.length; i++) n[i] = t.charCodeAt(i);\n  const r = n[0];\n  if (r === 0) throw new Error(\"No signatures found\");\n  const o = 1 + r * 64;\n  if (n.length < o) throw new Error(\"Transaction data too short for claimed signature count\");\n  if (n.length < 100) throw new Error(\"Transaction too short\");\n  const s = Buffer.from(e, \"base64\").slice(1, 65);\n  return Cr.encode(s);\n}\nvar Go = Object.defineProperty,\n  Wo = Object.defineProperties,\n  zo = Object.getOwnPropertyDescriptors,\n  wn = Object.getOwnPropertySymbols,\n  Jo = Object.prototype.hasOwnProperty,\n  Yo = Object.prototype.propertyIsEnumerable,\n  En = (e, t, n) => t in e ? Go(e, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: n\n  }) : e[t] = n,\n  at = (e, t) => {\n    for (var n in t || (t = {})) Jo.call(t, n) && En(e, n, t[n]);\n    if (wn) for (var n of wn(t)) Yo.call(t, n) && En(e, n, t[n]);\n    return e;\n  },\n  vn = (e, t) => Wo(e, zo(t));\nconst Xo = \"did:pkh:\",\n  ke = e => e?.split(\":\"),\n  xn = e => {\n    const t = e && ke(e);\n    if (t) return e.includes(Xo) ? t[3] : t[1];\n  },\n  In = e => {\n    const t = e && ke(e);\n    if (t) return t[2] + \":\" + t[3];\n  },\n  ut = e => {\n    const t = e && ke(e);\n    if (t) return t.pop();\n  };\nasync function Zo(e) {\n  const {\n      cacao: t,\n      projectId: n\n    } = e,\n    {\n      s: r,\n      p: o\n    } = t,\n    s = On(o, o.iss),\n    i = ut(o.iss);\n  return await yn(i, s, r, In(o.iss), n);\n}\nconst On = (e, t) => {\n  const n = `${e.domain} wants you to sign in with your Ethereum account:`,\n    r = ut(t);\n  if (!e.aud && !e.uri) throw new Error(\"Either `aud` or `uri` is required to construct the message\");\n  let o = e.statement || void 0;\n  const s = `URI: ${e.aud || e.uri}`,\n    i = `Version: ${e.version}`,\n    c = `Chain ID: ${xn(t)}`,\n    u = `Nonce: ${e.nonce}`,\n    a = `Issued At: ${e.iat}`,\n    l = e.exp ? `Expiration Time: ${e.exp}` : void 0,\n    f = e.nbf ? `Not Before: ${e.nbf}` : void 0,\n    d = e.requestId ? `Request ID: ${e.requestId}` : void 0,\n    g = e.resources ? `Resources:${e.resources.map(h => `\n- ${h}`).join(\"\")}` : void 0,\n    y = Me(e.resources);\n  if (y) {\n    const h = oe(y);\n    o = dt(o, h);\n  }\n  return [n, r, \"\", o, \"\", s, i, c, u, a, l, f, d, g].filter(h => h != null).join(`\n`);\n};\nfunction Qo(e, t, n) {\n  return n.includes(\"did:pkh:\") || (n = `did:pkh:${n}`), {\n    h: {\n      t: \"caip122\"\n    },\n    p: {\n      iss: n,\n      domain: e.domain,\n      aud: e.aud,\n      version: e.version,\n      nonce: e.nonce,\n      iat: e.iat,\n      statement: e.statement,\n      requestId: e.requestId,\n      resources: e.resources,\n      nbf: e.nbf,\n      exp: e.exp\n    },\n    s: t\n  };\n}\nfunction es(e) {\n  var t;\n  const {\n      authPayload: n,\n      chains: r,\n      methods: o\n    } = e,\n    s = n.statement || \"\";\n  if (!(r != null && r.length)) return n;\n  const i = n.chains,\n    c = nt(i, r);\n  if (!(c != null && c.length)) throw new Error(\"No supported chains\");\n  const u = An(n.resources);\n  if (!u) return n;\n  Y(u);\n  const a = Nn(u, \"eip155\");\n  let l = n?.resources || [];\n  if (a != null && a.length) {\n    const f = Sn(a),\n      d = nt(f, o);\n    if (!(d != null && d.length)) throw new Error(`Supported methods don't satisfy the requested: ${JSON.stringify(f)}, supported: ${JSON.stringify(o)}`);\n    const g = ft(\"request\", d, {\n        chains: c\n      }),\n      y = $n(u, \"eip155\", g);\n    l = ((t = n?.resources) == null ? void 0 : t.slice(0, -1)) || [], l.push(De(y));\n  }\n  return vn(at({}, n), {\n    statement: Pn(s, Me(l)),\n    chains: c,\n    resources: n != null && n.resources || l.length > 0 ? l : void 0\n  });\n}\nfunction An(e) {\n  const t = Me(e);\n  if (t && lt(t)) return oe(t);\n}\nfunction ts(e, t) {\n  var n;\n  return (n = e?.att) == null ? void 0 : n.hasOwnProperty(t);\n}\nfunction Nn(e, t) {\n  var n, r;\n  return (n = e?.att) != null && n[t] ? Object.keys((r = e?.att) == null ? void 0 : r[t]) : [];\n}\nfunction ns(e) {\n  return e?.map(t => Object.keys(t)) || [];\n}\nfunction Sn(e) {\n  return e?.map(t => {\n    var n;\n    return (n = t.split(\"/\")) == null ? void 0 : n[1];\n  }) || [];\n}\nfunction Un(e) {\n  return Buffer.from(JSON.stringify(e)).toString(\"base64\");\n}\nfunction _n(e) {\n  return JSON.parse(Buffer.from(e, \"base64\").toString(\"utf-8\"));\n}\nfunction Y(e) {\n  if (!e) throw new Error(\"No recap provided, value is undefined\");\n  if (!e.att) throw new Error(\"No `att` property found\");\n  const t = Object.keys(e.att);\n  if (!(t != null && t.length)) throw new Error(\"No resources found in `att` property\");\n  t.forEach(n => {\n    const r = e.att[n];\n    if (Array.isArray(r)) throw new Error(`Resource must be an object: ${n}`);\n    if (typeof r != \"object\") throw new Error(`Resource must be an object: ${n}`);\n    if (!Object.keys(r).length) throw new Error(`Resource object is empty: ${n}`);\n    Object.keys(r).forEach(o => {\n      const s = r[o];\n      if (!Array.isArray(s)) throw new Error(`Ability limits ${o} must be an array of objects, found: ${s}`);\n      if (!s.length) throw new Error(`Value of ${o} is empty array, must be an array with objects`);\n      s.forEach(i => {\n        if (typeof i != \"object\") throw new Error(`Ability limits (${o}) must be an array of objects, found: ${i}`);\n      });\n    });\n  });\n}\nfunction Tn(e, t, n, r = {}) {\n  return n?.sort((o, s) => o.localeCompare(s)), {\n    att: {\n      [e]: ft(t, n, r)\n    }\n  };\n}\nfunction $n(e, t, n) {\n  var r;\n  e.att[t] = at({}, n);\n  const o = (r = Object.keys(e.att)) == null ? void 0 : r.sort((i, c) => i.localeCompare(c)),\n    s = {\n      att: {}\n    };\n  return o.reduce((i, c) => (i.att[c] = e.att[c], i), s);\n}\nfunction ft(e, t, n = {}) {\n  t = t?.sort((o, s) => o.localeCompare(s));\n  const r = t.map(o => ({\n    [`${e}/${o}`]: [n]\n  }));\n  return Object.assign({}, ...r);\n}\nfunction De(e) {\n  return Y(e), `urn:recap:${Un(e).replace(/=/g, \"\")}`;\n}\nfunction oe(e) {\n  const t = _n(e.replace(\"urn:recap:\", \"\"));\n  return Y(t), t;\n}\nfunction rs(e, t, n) {\n  const r = Tn(e, t, n);\n  return De(r);\n}\nfunction lt(e) {\n  return e && e.includes(\"urn:recap:\");\n}\nfunction os(e, t) {\n  const n = oe(e),\n    r = oe(t),\n    o = Rn(n, r);\n  return De(o);\n}\nfunction Rn(e, t) {\n  Y(e), Y(t);\n  const n = Object.keys(e.att).concat(Object.keys(t.att)).sort((o, s) => o.localeCompare(s)),\n    r = {\n      att: {}\n    };\n  return n.forEach(o => {\n    var s, i;\n    Object.keys(((s = e.att) == null ? void 0 : s[o]) || {}).concat(Object.keys(((i = t.att) == null ? void 0 : i[o]) || {})).sort((c, u) => c.localeCompare(u)).forEach(c => {\n      var u, a;\n      r.att[o] = vn(at({}, r.att[o]), {\n        [c]: ((u = e.att[o]) == null ? void 0 : u[c]) || ((a = t.att[o]) == null ? void 0 : a[c])\n      });\n    });\n  }), r;\n}\nfunction dt(e = \"\", t) {\n  Y(t);\n  const n = \"I further authorize the stated URI to perform the following actions on my behalf: \";\n  if (e.includes(n)) return e;\n  const r = [];\n  let o = 0;\n  Object.keys(t.att).forEach(c => {\n    const u = Object.keys(t.att[c]).map(f => ({\n      ability: f.split(\"/\")[0],\n      action: f.split(\"/\")[1]\n    }));\n    u.sort((f, d) => f.action.localeCompare(d.action));\n    const a = {};\n    u.forEach(f => {\n      a[f.ability] || (a[f.ability] = []), a[f.ability].push(f.action);\n    });\n    const l = Object.keys(a).map(f => (o++, `(${o}) '${f}': '${a[f].join(\"', '\")}' for '${c}'.`));\n    r.push(l.join(\", \").replace(\".,\", \".\"));\n  });\n  const s = r.join(\" \"),\n    i = `${n}${s}`;\n  return `${e ? e + \" \" : \"\"}${i}`;\n}\nfunction ss(e) {\n  var t;\n  const n = oe(e);\n  Y(n);\n  const r = (t = n.att) == null ? void 0 : t.eip155;\n  return r ? Object.keys(r).map(o => o.split(\"/\")[1]) : [];\n}\nfunction is(e) {\n  const t = oe(e);\n  Y(t);\n  const n = [];\n  return Object.values(t.att).forEach(r => {\n    Object.values(r).forEach(o => {\n      var s;\n      (s = o?.[0]) != null && s.chains && n.push(o[0].chains);\n    });\n  }), [...new Set(n.flat())];\n}\nfunction Pn(e, t) {\n  if (!t) return e;\n  const n = oe(t);\n  return Y(n), dt(e, n);\n}\nfunction Me(e) {\n  if (!e) return;\n  const t = e?.[e.length - 1];\n  return lt(t) ? t : void 0;\n}\nfunction ht(e) {\n  if (!Number.isSafeInteger(e) || e < 0) throw new Error(\"positive integer expected, got \" + e);\n}\nfunction Bn(e) {\n  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === \"Uint8Array\";\n}\nfunction F(e, ...t) {\n  if (!Bn(e)) throw new Error(\"Uint8Array expected\");\n  if (t.length > 0 && !t.includes(e.length)) throw new Error(\"Uint8Array expected of length \" + t + \", got length=\" + e.length);\n}\nfunction Ln(e, t = !0) {\n  if (e.destroyed) throw new Error(\"Hash instance has been destroyed\");\n  if (t && e.finished) throw new Error(\"Hash#digest() has already been called\");\n}\nfunction cs(e, t) {\n  F(e);\n  const n = t.outputLen;\n  if (e.length < n) throw new Error(\"digestInto() expects output buffer of length at least \" + n);\n}\nfunction jn(e) {\n  if (typeof e != \"boolean\") throw new Error(`boolean expected, not ${e}`);\n}\nconst se = e => new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)),\n  as = e => new DataView(e.buffer, e.byteOffset, e.byteLength),\n  us = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;\nif (!us) throw new Error(\"Non little-endian hardware is not supported\");\nfunction fs(e) {\n  if (typeof e != \"string\") throw new Error(\"string expected\");\n  return new Uint8Array(new TextEncoder().encode(e));\n}\nfunction pt(e) {\n  if (typeof e == \"string\") e = fs(e);else if (Bn(e)) e = gt(e);else throw new Error(\"Uint8Array expected, got \" + typeof e);\n  return e;\n}\nfunction ls(e, t) {\n  if (t == null || typeof t != \"object\") throw new Error(\"options must be defined\");\n  return Object.assign(e, t);\n}\nfunction ds(e, t) {\n  if (e.length !== t.length) return !1;\n  let n = 0;\n  for (let r = 0; r < e.length; r++) n |= e[r] ^ t[r];\n  return n === 0;\n}\nconst hs = (e, t) => {\n  function n(r, ...o) {\n    if (F(r), e.nonceLength !== void 0) {\n      const l = o[0];\n      if (!l) throw new Error(\"nonce / iv required\");\n      e.varSizeNonce ? F(l) : F(l, e.nonceLength);\n    }\n    const s = e.tagLength;\n    s && o[1] !== void 0 && F(o[1]);\n    const i = t(r, ...o),\n      c = (l, f) => {\n        if (f !== void 0) {\n          if (l !== 2) throw new Error(\"cipher output not supported\");\n          F(f);\n        }\n      };\n    let u = !1;\n    return {\n      encrypt(l, f) {\n        if (u) throw new Error(\"cannot encrypt() twice with same key + nonce\");\n        return u = !0, F(l), c(i.encrypt.length, f), i.encrypt(l, f);\n      },\n      decrypt(l, f) {\n        if (F(l), s && l.length < s) throw new Error(\"invalid ciphertext length: smaller than tagLength=\" + s);\n        return c(i.decrypt.length, f), i.decrypt(l, f);\n      }\n    };\n  }\n  return Object.assign(n, e), n;\n};\nfunction Cn(e, t, n = !0) {\n  if (t === void 0) return new Uint8Array(e);\n  if (t.length !== e) throw new Error(\"invalid output length, expected \" + e + \", got: \" + t.length);\n  if (n && !ps(t)) throw new Error(\"invalid output, must be aligned\");\n  return t;\n}\nfunction kn(e, t, n, r) {\n  if (typeof e.setBigUint64 == \"function\") return e.setBigUint64(t, n, r);\n  const o = BigInt(32),\n    s = BigInt(4294967295),\n    i = Number(n >> o & s),\n    c = Number(n & s),\n    u = r ? 4 : 0,\n    a = r ? 0 : 4;\n  e.setUint32(t + u, i, r), e.setUint32(t + a, c, r);\n}\nfunction ps(e) {\n  return e.byteOffset % 4 === 0;\n}\nfunction gt(e) {\n  return Uint8Array.from(e);\n}\nfunction Ee(...e) {\n  for (let t = 0; t < e.length; t++) e[t].fill(0);\n}\nconst Dn = e => Uint8Array.from(e.split(\"\").map(t => t.charCodeAt(0))),\n  gs = Dn(\"expand 16-byte k\"),\n  ys = Dn(\"expand 32-byte k\"),\n  ms = se(gs),\n  bs = se(ys);\nfunction x(e, t) {\n  return e << t | e >>> 32 - t;\n}\nfunction yt(e) {\n  return e.byteOffset % 4 === 0;\n}\nconst Ve = 64,\n  ws = 16,\n  Mn = 2 ** 32 - 1,\n  Vn = new Uint32Array();\nfunction Es(e, t, n, r, o, s, i, c) {\n  const u = o.length,\n    a = new Uint8Array(Ve),\n    l = se(a),\n    f = yt(o) && yt(s),\n    d = f ? se(o) : Vn,\n    g = f ? se(s) : Vn;\n  for (let y = 0; y < u; i++) {\n    if (e(t, n, r, l, i, c), i >= Mn) throw new Error(\"arx: counter overflow\");\n    const h = Math.min(Ve, u - y);\n    if (f && h === Ve) {\n      const m = y / 4;\n      if (y % 4 !== 0) throw new Error(\"arx: invalid block position\");\n      for (let L = 0, b; L < ws; L++) b = m + L, g[b] = d[b] ^ l[L];\n      y += Ve;\n      continue;\n    }\n    for (let m = 0, L; m < h; m++) L = y + m, s[L] = o[L] ^ a[m];\n    y += h;\n  }\n}\nfunction vs(e, t) {\n  const {\n    allowShortKeys: n,\n    extendNonceFn: r,\n    counterLength: o,\n    counterRight: s,\n    rounds: i\n  } = ls({\n    allowShortKeys: !1,\n    counterLength: 8,\n    counterRight: !1,\n    rounds: 20\n  }, t);\n  if (typeof e != \"function\") throw new Error(\"core must be a function\");\n  return ht(o), ht(i), jn(s), jn(n), (c, u, a, l, f = 0) => {\n    F(c), F(u), F(a);\n    const d = a.length;\n    if (l === void 0 && (l = new Uint8Array(d)), F(l), ht(f), f < 0 || f >= Mn) throw new Error(\"arx: counter overflow\");\n    if (l.length < d) throw new Error(`arx: output (${l.length}) is shorter than data (${d})`);\n    const g = [];\n    let y = c.length,\n      h,\n      m;\n    if (y === 32) g.push(h = gt(c)), m = bs;else if (y === 16 && n) h = new Uint8Array(32), h.set(c), h.set(c, 16), m = ms, g.push(h);else throw new Error(`arx: invalid 32-byte key, got length=${y}`);\n    yt(u) || g.push(u = gt(u));\n    const L = se(h);\n    if (r) {\n      if (u.length !== 24) throw new Error(\"arx: extended nonce must be 24 bytes\");\n      r(m, L, se(u.subarray(0, 16)), L), u = u.subarray(16);\n    }\n    const b = 16 - o;\n    if (b !== u.length) throw new Error(`arx: nonce must be ${b} or 16 bytes`);\n    if (b !== 12) {\n      const O = new Uint8Array(12);\n      O.set(u, s ? 0 : 12 - u.length), u = O, g.push(u);\n    }\n    const _ = se(u);\n    return Es(e, m, L, _, a, l, f, i), Ee(...g), l;\n  };\n}\nconst M = (e, t) => e[t++] & 255 | (e[t++] & 255) << 8;\nclass xs {\n  constructor(t) {\n    this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = !1, t = pt(t), F(t, 32);\n    const n = M(t, 0),\n      r = M(t, 2),\n      o = M(t, 4),\n      s = M(t, 6),\n      i = M(t, 8),\n      c = M(t, 10),\n      u = M(t, 12),\n      a = M(t, 14);\n    this.r[0] = n & 8191, this.r[1] = (n >>> 13 | r << 3) & 8191, this.r[2] = (r >>> 10 | o << 6) & 7939, this.r[3] = (o >>> 7 | s << 9) & 8191, this.r[4] = (s >>> 4 | i << 12) & 255, this.r[5] = i >>> 1 & 8190, this.r[6] = (i >>> 14 | c << 2) & 8191, this.r[7] = (c >>> 11 | u << 5) & 8065, this.r[8] = (u >>> 8 | a << 8) & 8191, this.r[9] = a >>> 5 & 127;\n    for (let l = 0; l < 8; l++) this.pad[l] = M(t, 16 + 2 * l);\n  }\n  process(t, n, r = !1) {\n    const o = r ? 0 : 2048,\n      {\n        h: s,\n        r: i\n      } = this,\n      c = i[0],\n      u = i[1],\n      a = i[2],\n      l = i[3],\n      f = i[4],\n      d = i[5],\n      g = i[6],\n      y = i[7],\n      h = i[8],\n      m = i[9],\n      L = M(t, n + 0),\n      b = M(t, n + 2),\n      _ = M(t, n + 4),\n      O = M(t, n + 6),\n      k = M(t, n + 8),\n      E = M(t, n + 10),\n      B = M(t, n + 12),\n      j = M(t, n + 14);\n    let v = s[0] + (L & 8191),\n      I = s[1] + ((L >>> 13 | b << 3) & 8191),\n      w = s[2] + ((b >>> 10 | _ << 6) & 8191),\n      R = s[3] + ((_ >>> 7 | O << 9) & 8191),\n      A = s[4] + ((O >>> 4 | k << 12) & 8191),\n      T = s[5] + (k >>> 1 & 8191),\n      N = s[6] + ((k >>> 14 | E << 2) & 8191),\n      S = s[7] + ((E >>> 11 | B << 5) & 8191),\n      U = s[8] + ((B >>> 8 | j << 8) & 8191),\n      $ = s[9] + (j >>> 5 | o),\n      p = 0,\n      C = p + v * c + I * (5 * m) + w * (5 * h) + R * (5 * y) + A * (5 * g);\n    p = C >>> 13, C &= 8191, C += T * (5 * d) + N * (5 * f) + S * (5 * l) + U * (5 * a) + $ * (5 * u), p += C >>> 13, C &= 8191;\n    let D = p + v * u + I * c + w * (5 * m) + R * (5 * h) + A * (5 * y);\n    p = D >>> 13, D &= 8191, D += T * (5 * g) + N * (5 * d) + S * (5 * f) + U * (5 * l) + $ * (5 * a), p += D >>> 13, D &= 8191;\n    let P = p + v * a + I * u + w * c + R * (5 * m) + A * (5 * h);\n    p = P >>> 13, P &= 8191, P += T * (5 * y) + N * (5 * g) + S * (5 * d) + U * (5 * f) + $ * (5 * l), p += P >>> 13, P &= 8191;\n    let G = p + v * l + I * a + w * u + R * c + A * (5 * m);\n    p = G >>> 13, G &= 8191, G += T * (5 * h) + N * (5 * y) + S * (5 * g) + U * (5 * d) + $ * (5 * f), p += G >>> 13, G &= 8191;\n    let X = p + v * f + I * l + w * a + R * u + A * c;\n    p = X >>> 13, X &= 8191, X += T * (5 * m) + N * (5 * h) + S * (5 * y) + U * (5 * g) + $ * (5 * d), p += X >>> 13, X &= 8191;\n    let Z = p + v * d + I * f + w * l + R * a + A * u;\n    p = Z >>> 13, Z &= 8191, Z += T * c + N * (5 * m) + S * (5 * h) + U * (5 * y) + $ * (5 * g), p += Z >>> 13, Z &= 8191;\n    let he = p + v * g + I * d + w * f + R * l + A * a;\n    p = he >>> 13, he &= 8191, he += T * u + N * c + S * (5 * m) + U * (5 * h) + $ * (5 * y), p += he >>> 13, he &= 8191;\n    let pe = p + v * y + I * g + w * d + R * f + A * l;\n    p = pe >>> 13, pe &= 8191, pe += T * a + N * u + S * c + U * (5 * m) + $ * (5 * h), p += pe >>> 13, pe &= 8191;\n    let ge = p + v * h + I * y + w * g + R * d + A * f;\n    p = ge >>> 13, ge &= 8191, ge += T * l + N * a + S * u + U * c + $ * (5 * m), p += ge >>> 13, ge &= 8191;\n    let ye = p + v * m + I * h + w * y + R * g + A * d;\n    p = ye >>> 13, ye &= 8191, ye += T * f + N * l + S * a + U * u + $ * c, p += ye >>> 13, ye &= 8191, p = (p << 2) + p | 0, p = p + C | 0, C = p & 8191, p = p >>> 13, D += p, s[0] = C, s[1] = D, s[2] = P, s[3] = G, s[4] = X, s[5] = Z, s[6] = he, s[7] = pe, s[8] = ge, s[9] = ye;\n  }\n  finalize() {\n    const {\n        h: t,\n        pad: n\n      } = this,\n      r = new Uint16Array(10);\n    let o = t[1] >>> 13;\n    t[1] &= 8191;\n    for (let c = 2; c < 10; c++) t[c] += o, o = t[c] >>> 13, t[c] &= 8191;\n    t[0] += o * 5, o = t[0] >>> 13, t[0] &= 8191, t[1] += o, o = t[1] >>> 13, t[1] &= 8191, t[2] += o, r[0] = t[0] + 5, o = r[0] >>> 13, r[0] &= 8191;\n    for (let c = 1; c < 10; c++) r[c] = t[c] + o, o = r[c] >>> 13, r[c] &= 8191;\n    r[9] -= 8192;\n    let s = (o ^ 1) - 1;\n    for (let c = 0; c < 10; c++) r[c] &= s;\n    s = ~s;\n    for (let c = 0; c < 10; c++) t[c] = t[c] & s | r[c];\n    t[0] = (t[0] | t[1] << 13) & 65535, t[1] = (t[1] >>> 3 | t[2] << 10) & 65535, t[2] = (t[2] >>> 6 | t[3] << 7) & 65535, t[3] = (t[3] >>> 9 | t[4] << 4) & 65535, t[4] = (t[4] >>> 12 | t[5] << 1 | t[6] << 14) & 65535, t[5] = (t[6] >>> 2 | t[7] << 11) & 65535, t[6] = (t[7] >>> 5 | t[8] << 8) & 65535, t[7] = (t[8] >>> 8 | t[9] << 5) & 65535;\n    let i = t[0] + n[0];\n    t[0] = i & 65535;\n    for (let c = 1; c < 8; c++) i = (t[c] + n[c] | 0) + (i >>> 16) | 0, t[c] = i & 65535;\n    Ee(r);\n  }\n  update(t) {\n    Ln(this);\n    const {\n      buffer: n,\n      blockLen: r\n    } = this;\n    t = pt(t);\n    const o = t.length;\n    for (let s = 0; s < o;) {\n      const i = Math.min(r - this.pos, o - s);\n      if (i === r) {\n        for (; r <= o - s; s += r) this.process(t, s);\n        continue;\n      }\n      n.set(t.subarray(s, s + i), this.pos), this.pos += i, s += i, this.pos === r && (this.process(n, 0, !1), this.pos = 0);\n    }\n    return this;\n  }\n  destroy() {\n    Ee(this.h, this.r, this.buffer, this.pad);\n  }\n  digestInto(t) {\n    Ln(this), cs(t, this), this.finished = !0;\n    const {\n      buffer: n,\n      h: r\n    } = this;\n    let {\n      pos: o\n    } = this;\n    if (o) {\n      for (n[o++] = 1; o < 16; o++) n[o] = 0;\n      this.process(n, 0, !0);\n    }\n    this.finalize();\n    let s = 0;\n    for (let i = 0; i < 8; i++) t[s++] = r[i] >>> 0, t[s++] = r[i] >>> 8;\n    return t;\n  }\n  digest() {\n    const {\n      buffer: t,\n      outputLen: n\n    } = this;\n    this.digestInto(t);\n    const r = t.slice(0, n);\n    return this.destroy(), r;\n  }\n}\nfunction Is(e) {\n  const t = (r, o) => e(o).update(pt(r)).digest(),\n    n = e(new Uint8Array(32));\n  return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = r => e(r), t;\n}\nconst Os = Is(e => new xs(e));\nfunction As(e, t, n, r, o, s = 20) {\n  let i = e[0],\n    c = e[1],\n    u = e[2],\n    a = e[3],\n    l = t[0],\n    f = t[1],\n    d = t[2],\n    g = t[3],\n    y = t[4],\n    h = t[5],\n    m = t[6],\n    L = t[7],\n    b = o,\n    _ = n[0],\n    O = n[1],\n    k = n[2],\n    E = i,\n    B = c,\n    j = u,\n    v = a,\n    I = l,\n    w = f,\n    R = d,\n    A = g,\n    T = y,\n    N = h,\n    S = m,\n    U = L,\n    $ = b,\n    p = _,\n    C = O,\n    D = k;\n  for (let G = 0; G < s; G += 2) E = E + I | 0, $ = x($ ^ E, 16), T = T + $ | 0, I = x(I ^ T, 12), E = E + I | 0, $ = x($ ^ E, 8), T = T + $ | 0, I = x(I ^ T, 7), B = B + w | 0, p = x(p ^ B, 16), N = N + p | 0, w = x(w ^ N, 12), B = B + w | 0, p = x(p ^ B, 8), N = N + p | 0, w = x(w ^ N, 7), j = j + R | 0, C = x(C ^ j, 16), S = S + C | 0, R = x(R ^ S, 12), j = j + R | 0, C = x(C ^ j, 8), S = S + C | 0, R = x(R ^ S, 7), v = v + A | 0, D = x(D ^ v, 16), U = U + D | 0, A = x(A ^ U, 12), v = v + A | 0, D = x(D ^ v, 8), U = U + D | 0, A = x(A ^ U, 7), E = E + w | 0, D = x(D ^ E, 16), S = S + D | 0, w = x(w ^ S, 12), E = E + w | 0, D = x(D ^ E, 8), S = S + D | 0, w = x(w ^ S, 7), B = B + R | 0, $ = x($ ^ B, 16), U = U + $ | 0, R = x(R ^ U, 12), B = B + R | 0, $ = x($ ^ B, 8), U = U + $ | 0, R = x(R ^ U, 7), j = j + A | 0, p = x(p ^ j, 16), T = T + p | 0, A = x(A ^ T, 12), j = j + A | 0, p = x(p ^ j, 8), T = T + p | 0, A = x(A ^ T, 7), v = v + I | 0, C = x(C ^ v, 16), N = N + C | 0, I = x(I ^ N, 12), v = v + I | 0, C = x(C ^ v, 8), N = N + C | 0, I = x(I ^ N, 7);\n  let P = 0;\n  r[P++] = i + E | 0, r[P++] = c + B | 0, r[P++] = u + j | 0, r[P++] = a + v | 0, r[P++] = l + I | 0, r[P++] = f + w | 0, r[P++] = d + R | 0, r[P++] = g + A | 0, r[P++] = y + T | 0, r[P++] = h + N | 0, r[P++] = m + S | 0, r[P++] = L + U | 0, r[P++] = b + $ | 0, r[P++] = _ + p | 0, r[P++] = O + C | 0, r[P++] = k + D | 0;\n}\nconst Ns = vs(As, {\n    counterRight: !1,\n    counterLength: 4,\n    allowShortKeys: !1\n  }),\n  Ss = new Uint8Array(16),\n  Hn = (e, t) => {\n    e.update(t);\n    const n = t.length % 16;\n    n && e.update(Ss.subarray(n));\n  },\n  Us = new Uint8Array(32);\nfunction Kn(e, t, n, r, o) {\n  const s = e(t, n, Us),\n    i = Os.create(s);\n  o && Hn(i, o), Hn(i, r);\n  const c = new Uint8Array(16),\n    u = as(c);\n  kn(u, 0, BigInt(o ? o.length : 0), !0), kn(u, 8, BigInt(r.length), !0), i.update(c);\n  const a = i.digest();\n  return Ee(s, c), a;\n}\nconst _s = e => (t, n, r) => ({\n    encrypt(s, i) {\n      const c = s.length;\n      i = Cn(c + 16, i, !1), i.set(s);\n      const u = i.subarray(0, -16);\n      e(t, n, u, u, 1);\n      const a = Kn(e, t, n, u, r);\n      return i.set(a, c), Ee(a), i;\n    },\n    decrypt(s, i) {\n      i = Cn(s.length - 16, i, !1);\n      const c = s.subarray(0, -16),\n        u = s.subarray(-16),\n        a = Kn(e, t, n, c, r);\n      if (!ds(u, a)) throw new Error(\"invalid tag\");\n      return i.set(s.subarray(0, -16)), e(t, n, i, i, 1), Ee(a), i;\n    }\n  }),\n  Fn = hs({\n    blockSize: 64,\n    nonceLength: 12,\n    tagLength: 16\n  }, _s(Ns));\nclass qn extends it {\n  constructor(t, n) {\n    super(), this.finished = !1, this.destroyed = !1, ot(t);\n    const r = we(n);\n    if (this.iHash = t.create(), typeof this.iHash.update != \"function\") throw new Error(\"Expected instance of class which extends utils.Hash\");\n    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;\n    const o = this.blockLen,\n      s = new Uint8Array(o);\n    s.set(r.length > o ? t.create().update(r).digest() : r);\n    for (let i = 0; i < s.length; i++) s[i] ^= 54;\n    this.iHash.update(s), this.oHash = t.create();\n    for (let i = 0; i < s.length; i++) s[i] ^= 106;\n    this.oHash.update(s), s.fill(0);\n  }\n  update(t) {\n    return me(this), this.iHash.update(t), this;\n  }\n  digestInto(t) {\n    me(this), je(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();\n  }\n  digest() {\n    const t = new Uint8Array(this.oHash.outputLen);\n    return this.digestInto(t), t;\n  }\n  _cloneInto(t) {\n    t || (t = Object.create(Object.getPrototypeOf(this), {}));\n    const {\n      oHash: n,\n      iHash: r,\n      finished: o,\n      destroyed: s,\n      blockLen: i,\n      outputLen: c\n    } = this;\n    return t = t, t.finished = o, t.destroyed = s, t.blockLen = i, t.outputLen = c, t.oHash = n._cloneInto(t.oHash), t.iHash = r._cloneInto(t.iHash), t;\n  }\n  destroy() {\n    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();\n  }\n}\nconst mt = (e, t, n) => new qn(e, t).update(n).digest();\nmt.create = (e, t) => new qn(e, t);\nfunction Ts(e, t, n) {\n  return ot(e), n === void 0 && (n = new Uint8Array(e.outputLen)), mt(e, we(n), we(t));\n}\nconst bt = new Uint8Array([0]),\n  Gn = new Uint8Array();\nfunction $s(e, t, n, r = 32) {\n  if (ot(e), Ne(r), r > 255 * e.outputLen) throw new Error(\"Length should be <= 255*HashLen\");\n  const o = Math.ceil(r / e.outputLen);\n  n === void 0 && (n = Gn);\n  const s = new Uint8Array(o * e.outputLen),\n    i = mt.create(e, t),\n    c = i._cloneInto(),\n    u = new Uint8Array(i.outputLen);\n  for (let a = 0; a < o; a++) bt[0] = a + 1, c.update(a === 0 ? Gn : u).update(n).update(bt).digestInto(u), s.set(u, e.outputLen * a), i._cloneInto(c);\n  return i.destroy(), c.destroy(), u.fill(0), bt.fill(0), s.slice(0, r);\n}\nconst Rs = (e, t, n, r, o) => $s(e, Ts(e, t, n), r, o);\nfunction Ps(e, t, n, r) {\n  if (typeof e.setBigUint64 == \"function\") return e.setBigUint64(t, n, r);\n  const o = BigInt(32),\n    s = BigInt(4294967295),\n    i = Number(n >> o & s),\n    c = Number(n & s),\n    u = r ? 4 : 0,\n    a = r ? 0 : 4;\n  e.setUint32(t + u, i, r), e.setUint32(t + a, c, r);\n}\nfunction Bs(e, t, n) {\n  return e & t ^ ~e & n;\n}\nfunction Ls(e, t, n) {\n  return e & t ^ e & n ^ t & n;\n}\nclass js extends it {\n  constructor(t, n, r, o) {\n    super(), this.blockLen = t, this.outputLen = n, this.padOffset = r, this.isLE = o, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = st(this.buffer);\n  }\n  update(t) {\n    me(this);\n    const {\n      view: n,\n      buffer: r,\n      blockLen: o\n    } = this;\n    t = we(t);\n    const s = t.length;\n    for (let i = 0; i < s;) {\n      const c = Math.min(o - this.pos, s - i);\n      if (c === o) {\n        const u = st(t);\n        for (; o <= s - i; i += o) this.process(u, i);\n        continue;\n      }\n      r.set(t.subarray(i, i + c), this.pos), this.pos += c, i += c, this.pos === o && (this.process(n, 0), this.pos = 0);\n    }\n    return this.length += t.length, this.roundClean(), this;\n  }\n  digestInto(t) {\n    me(this), sn(t, this), this.finished = !0;\n    const {\n      buffer: n,\n      view: r,\n      blockLen: o,\n      isLE: s\n    } = this;\n    let {\n      pos: i\n    } = this;\n    n[i++] = 128, this.buffer.subarray(i).fill(0), this.padOffset > o - i && (this.process(r, 0), i = 0);\n    for (let f = i; f < o; f++) n[f] = 0;\n    Ps(r, o - 8, BigInt(this.length * 8), s), this.process(r, 0);\n    const c = st(t),\n      u = this.outputLen;\n    if (u % 4) throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n    const a = u / 4,\n      l = this.get();\n    if (a > l.length) throw new Error(\"_sha2: outputLen bigger than state\");\n    for (let f = 0; f < a; f++) c.setUint32(4 * f, l[f], s);\n  }\n  digest() {\n    const {\n      buffer: t,\n      outputLen: n\n    } = this;\n    this.digestInto(t);\n    const r = t.slice(0, n);\n    return this.destroy(), r;\n  }\n  _cloneInto(t) {\n    t || (t = new this.constructor()), t.set(...this.get());\n    const {\n      blockLen: n,\n      buffer: r,\n      length: o,\n      finished: s,\n      destroyed: i,\n      pos: c\n    } = this;\n    return t.length = o, t.pos = c, t.finished = s, t.destroyed = i, o % n && t.buffer.set(r), t;\n  }\n}\nconst Cs = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]),\n  ie = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]),\n  ce = new Uint32Array(64);\nclass ks extends js {\n  constructor() {\n    super(64, 32, 8, !1), this.A = ie[0] | 0, this.B = ie[1] | 0, this.C = ie[2] | 0, this.D = ie[3] | 0, this.E = ie[4] | 0, this.F = ie[5] | 0, this.G = ie[6] | 0, this.H = ie[7] | 0;\n  }\n  get() {\n    const {\n      A: t,\n      B: n,\n      C: r,\n      D: o,\n      E: s,\n      F: i,\n      G: c,\n      H: u\n    } = this;\n    return [t, n, r, o, s, i, c, u];\n  }\n  set(t, n, r, o, s, i, c, u) {\n    this.A = t | 0, this.B = n | 0, this.C = r | 0, this.D = o | 0, this.E = s | 0, this.F = i | 0, this.G = c | 0, this.H = u | 0;\n  }\n  process(t, n) {\n    for (let f = 0; f < 16; f++, n += 4) ce[f] = t.getUint32(n, !1);\n    for (let f = 16; f < 64; f++) {\n      const d = ce[f - 15],\n        g = ce[f - 2],\n        y = J(d, 7) ^ J(d, 18) ^ d >>> 3,\n        h = J(g, 17) ^ J(g, 19) ^ g >>> 10;\n      ce[f] = h + ce[f - 7] + y + ce[f - 16] | 0;\n    }\n    let {\n      A: r,\n      B: o,\n      C: s,\n      D: i,\n      E: c,\n      F: u,\n      G: a,\n      H: l\n    } = this;\n    for (let f = 0; f < 64; f++) {\n      const d = J(c, 6) ^ J(c, 11) ^ J(c, 25),\n        g = l + d + Bs(c, u, a) + Cs[f] + ce[f] | 0,\n        h = (J(r, 2) ^ J(r, 13) ^ J(r, 22)) + Ls(r, o, s) | 0;\n      l = a, a = u, u = c, c = i + g | 0, i = s, s = o, o = r, r = g + h | 0;\n    }\n    r = r + this.A | 0, o = o + this.B | 0, s = s + this.C | 0, i = i + this.D | 0, c = c + this.E | 0, u = u + this.F | 0, a = a + this.G | 0, l = l + this.H | 0, this.set(r, o, s, i, c, u, a, l);\n  }\n  roundClean() {\n    ce.fill(0);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);\n  }\n}\nconst He = fn(() => new ks()); /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst Wn = BigInt(0);\nfunction wt(e) {\n  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === \"Uint8Array\";\n}\nfunction zn(e) {\n  if (!wt(e)) throw new Error(\"Uint8Array expected\");\n}\nconst Ds = Array.from({\n  length: 256\n}, (e, t) => t.toString(16).padStart(2, \"0\"));\nfunction Ms(e) {\n  zn(e);\n  let t = \"\";\n  for (let n = 0; n < e.length; n++) t += Ds[e[n]];\n  return t;\n}\nfunction Vs(e) {\n  if (typeof e != \"string\") throw new Error(\"hex string expected, got \" + typeof e);\n  return e === \"\" ? Wn : BigInt(\"0x\" + e);\n}\nconst ee = {\n  _0: 48,\n  _9: 57,\n  A: 65,\n  F: 70,\n  a: 97,\n  f: 102\n};\nfunction Jn(e) {\n  if (e >= ee._0 && e <= ee._9) return e - ee._0;\n  if (e >= ee.A && e <= ee.F) return e - (ee.A - 10);\n  if (e >= ee.a && e <= ee.f) return e - (ee.a - 10);\n}\nfunction Yn(e) {\n  if (typeof e != \"string\") throw new Error(\"hex string expected, got \" + typeof e);\n  const t = e.length,\n    n = t / 2;\n  if (t % 2) throw new Error(\"hex string expected, got unpadded hex of length \" + t);\n  const r = new Uint8Array(n);\n  for (let o = 0, s = 0; o < n; o++, s += 2) {\n    const i = Jn(e.charCodeAt(s)),\n      c = Jn(e.charCodeAt(s + 1));\n    if (i === void 0 || c === void 0) {\n      const u = e[s] + e[s + 1];\n      throw new Error('hex string expected, got non-hex character \"' + u + '\" at index ' + s);\n    }\n    r[o] = i * 16 + c;\n  }\n  return r;\n}\nfunction Xn(e) {\n  return zn(e), Vs(Ms(Uint8Array.from(e).reverse()));\n}\nfunction Hs(e, t) {\n  return Yn(e.toString(16).padStart(t * 2, \"0\"));\n}\nfunction Ks(e, t) {\n  return Hs(e, t).reverse();\n}\nfunction Zn(e, t, n) {\n  let r;\n  if (typeof t == \"string\") try {\n    r = Yn(t);\n  } catch (s) {\n    throw new Error(e + \" must be hex string or Uint8Array, cause: \" + s);\n  } else if (wt(t)) r = Uint8Array.from(t);else throw new Error(e + \" must be hex string or Uint8Array\");\n  const o = r.length;\n  if (typeof n == \"number\" && o !== n) throw new Error(e + \" of length \" + n + \" expected, got \" + o);\n  return r;\n}\nconst Et = e => typeof e == \"bigint\" && Wn <= e;\nfunction Fs(e, t, n) {\n  return Et(e) && Et(t) && Et(n) && t <= e && e < n;\n}\nfunction Qn(e, t, n, r) {\n  if (!Fs(t, n, r)) throw new Error(\"expected valid \" + e + \": \" + n + \" <= n < \" + r + \", got \" + t);\n}\nconst qs = {\n  bigint: e => typeof e == \"bigint\",\n  function: e => typeof e == \"function\",\n  boolean: e => typeof e == \"boolean\",\n  string: e => typeof e == \"string\",\n  stringOrUint8Array: e => typeof e == \"string\" || wt(e),\n  isSafeInteger: e => Number.isSafeInteger(e),\n  array: e => Array.isArray(e),\n  field: (e, t) => t.Fp.isValid(e),\n  hash: e => typeof e == \"function\" && Number.isSafeInteger(e.outputLen)\n};\nfunction Gs(e, t, n = {}) {\n  const r = (o, s, i) => {\n    const c = qs[s];\n    if (typeof c != \"function\") throw new Error(\"invalid validator function\");\n    const u = e[o];\n    if (!(i && u === void 0) && !c(u, e)) throw new Error(\"param \" + String(o) + \" is invalid. Expected \" + s + \", got \" + u);\n  };\n  for (const [o, s] of Object.entries(t)) r(o, s, !1);\n  for (const [o, s] of Object.entries(n)) r(o, s, !0);\n  return e;\n}\nconst ve = BigInt(0),\n  Ke = BigInt(1);\nfunction er(e, t) {\n  const n = e % t;\n  return n >= ve ? n : t + n;\n}\nfunction Ws(e, t, n) {\n  if (t < ve) throw new Error(\"invalid exponent, negatives unsupported\");\n  if (n <= ve) throw new Error(\"invalid modulus\");\n  if (n === Ke) return ve;\n  let r = Ke;\n  for (; t > ve;) t & Ke && (r = r * e % n), e = e * e % n, t >>= Ke;\n  return r;\n}\nfunction z(e, t, n) {\n  let r = e;\n  for (; t-- > ve;) r *= r, r %= n;\n  return r;\n}\nBigInt(0), BigInt(1), BigInt(0), BigInt(1), BigInt(2), BigInt(8);\nconst xe = BigInt(0),\n  vt = BigInt(1);\nfunction zs(e) {\n  return Gs(e, {\n    a: \"bigint\"\n  }, {\n    montgomeryBits: \"isSafeInteger\",\n    nByteLength: \"isSafeInteger\",\n    adjustScalarBytes: \"function\",\n    domain: \"function\",\n    powPminus2: \"function\",\n    Gu: \"bigint\"\n  }), Object.freeze({\n    ...e\n  });\n}\nfunction Js(e) {\n  const t = zs(e),\n    {\n      P: n\n    } = t,\n    r = b => er(b, n),\n    o = t.montgomeryBits,\n    s = Math.ceil(o / 8),\n    i = t.nByteLength,\n    c = t.adjustScalarBytes || (b => b),\n    u = t.powPminus2 || (b => Ws(b, n - BigInt(2), n));\n  function a(b, _, O) {\n    const k = r(b * (_ - O));\n    return _ = r(_ - k), O = r(O + k), [_, O];\n  }\n  const l = (t.a - BigInt(2)) / BigInt(4);\n  function f(b, _) {\n    Qn(\"u\", b, xe, n), Qn(\"scalar\", _, xe, n);\n    const O = _,\n      k = b;\n    let E = vt,\n      B = xe,\n      j = b,\n      v = vt,\n      I = xe,\n      w;\n    for (let A = BigInt(o - 1); A >= xe; A--) {\n      const T = O >> A & vt;\n      I ^= T, w = a(I, E, j), E = w[0], j = w[1], w = a(I, B, v), B = w[0], v = w[1], I = T;\n      const N = E + B,\n        S = r(N * N),\n        U = E - B,\n        $ = r(U * U),\n        p = S - $,\n        C = j + v,\n        D = j - v,\n        P = r(D * N),\n        G = r(C * U),\n        X = P + G,\n        Z = P - G;\n      j = r(X * X), v = r(k * r(Z * Z)), E = r(S * $), B = r(p * (S + r(l * p)));\n    }\n    w = a(I, E, j), E = w[0], j = w[1], w = a(I, B, v), B = w[0], v = w[1];\n    const R = u(B);\n    return r(E * R);\n  }\n  function d(b) {\n    return Ks(r(b), s);\n  }\n  function g(b) {\n    const _ = Zn(\"u coordinate\", b, s);\n    return i === 32 && (_[31] &= 127), Xn(_);\n  }\n  function y(b) {\n    const _ = Zn(\"scalar\", b),\n      O = _.length;\n    if (O !== s && O !== i) {\n      let k = \"\" + s + \" or \" + i;\n      throw new Error(\"invalid scalar, expected \" + k + \" bytes, got \" + O);\n    }\n    return Xn(c(_));\n  }\n  function h(b, _) {\n    const O = g(_),\n      k = y(b),\n      E = f(O, k);\n    if (E === xe) throw new Error(\"invalid private or public key received\");\n    return d(E);\n  }\n  const m = d(t.Gu);\n  function L(b) {\n    return h(b, m);\n  }\n  return {\n    scalarMult: h,\n    scalarMultBase: L,\n    getSharedSecret: (b, _) => h(b, _),\n    getPublicKey: b => L(b),\n    utils: {\n      randomPrivateKey: () => t.randomBytes(t.nByteLength)\n    },\n    GuBytes: m\n  };\n}\nconst xt = BigInt(\"57896044618658097711785492504343953926634992332820282019728792003956564819949\");\nBigInt(0);\nconst Ys = BigInt(1),\n  tr = BigInt(2),\n  Xs = BigInt(3),\n  Zs = BigInt(5);\nBigInt(8);\nfunction Qs(e) {\n  const t = BigInt(10),\n    n = BigInt(20),\n    r = BigInt(40),\n    o = BigInt(80),\n    s = xt,\n    c = e * e % s * e % s,\n    u = z(c, tr, s) * c % s,\n    a = z(u, Ys, s) * e % s,\n    l = z(a, Zs, s) * a % s,\n    f = z(l, t, s) * l % s,\n    d = z(f, n, s) * f % s,\n    g = z(d, r, s) * d % s,\n    y = z(g, o, s) * g % s,\n    h = z(y, o, s) * g % s,\n    m = z(h, t, s) * l % s;\n  return {\n    pow_p_5_8: z(m, tr, s) * e % s,\n    b2: c\n  };\n}\nfunction ei(e) {\n  return e[0] &= 248, e[31] &= 127, e[31] |= 64, e;\n}\nconst It = Js({\n    P: xt,\n    a: BigInt(486662),\n    montgomeryBits: 255,\n    nByteLength: 32,\n    Gu: BigInt(9),\n    powPminus2: e => {\n      const t = xt,\n        {\n          pow_p_5_8: n,\n          b2: r\n        } = Qs(e);\n      return er(z(n, Xs, t) * r, t);\n    },\n    adjustScalarBytes: ei,\n    randomBytes: Se\n  }),\n  Ot = \"base10\",\n  V = \"base16\",\n  At = \"base64pad\",\n  ti = \"base64url\",\n  Ie = \"utf8\",\n  Nt = 0,\n  Oe = 1,\n  _e = 2,\n  ni = 0,\n  nr = 1,\n  Te = 12,\n  St = 32;\nfunction ri() {\n  const e = It.utils.randomPrivateKey(),\n    t = It.getPublicKey(e);\n  return {\n    privateKey: K(e, V),\n    publicKey: K(t, V)\n  };\n}\nfunction oi() {\n  const e = Se(St);\n  return K(e, V);\n}\nfunction si(e, t) {\n  const n = It.getSharedSecret(W(e, V), W(t, V)),\n    r = Rs(He, n, void 0, void 0, St);\n  return K(r, V);\n}\nfunction ii(e) {\n  const t = He(W(e, V));\n  return K(t, V);\n}\nfunction ci(e) {\n  const t = He(W(e, Ie));\n  return K(t, V);\n}\nfunction Ut(e) {\n  return W(`${e}`, Ot);\n}\nfunction fe(e) {\n  return Number(K(e, Ot));\n}\nfunction ai(e) {\n  const t = Ut(typeof e.type < \"u\" ? e.type : Nt);\n  if (fe(t) === Oe && typeof e.senderPublicKey > \"u\") throw new Error(\"Missing sender public key for type 1 envelope\");\n  const n = typeof e.senderPublicKey < \"u\" ? W(e.senderPublicKey, V) : void 0,\n    r = typeof e.iv < \"u\" ? W(e.iv, V) : Se(Te),\n    o = W(e.symKey, V),\n    s = Fn(o, r).encrypt(W(e.message, Ie));\n  return _t({\n    type: t,\n    sealed: s,\n    iv: r,\n    senderPublicKey: n,\n    encoding: e.encoding\n  });\n}\nfunction ui(e) {\n  const t = W(e.symKey, V),\n    {\n      sealed: n,\n      iv: r\n    } = Fe(e),\n    o = Fn(t, r).decrypt(n);\n  if (o === null) throw new Error(\"Failed to decrypt\");\n  return K(o, Ie);\n}\nfunction fi(e, t) {\n  const n = Ut(_e),\n    r = Se(Te),\n    o = W(e, Ie);\n  return _t({\n    type: n,\n    sealed: o,\n    iv: r,\n    encoding: t\n  });\n}\nfunction li(e, t) {\n  const {\n    sealed: n\n  } = Fe({\n    encoded: e,\n    encoding: t\n  });\n  return K(n, Ie);\n}\nfunction _t(e) {\n  const {\n    encoding: t = At\n  } = e;\n  if (fe(e.type) === _e) return K(Je([e.type, e.sealed]), t);\n  if (fe(e.type) === Oe) {\n    if (typeof e.senderPublicKey > \"u\") throw new Error(\"Missing sender public key for type 1 envelope\");\n    return K(Je([e.type, e.senderPublicKey, e.iv, e.sealed]), t);\n  }\n  return K(Je([e.type, e.iv, e.sealed]), t);\n}\nfunction Fe(e) {\n  const {\n      encoded: t,\n      encoding: n = At\n    } = e,\n    r = W(t, n),\n    o = r.slice(ni, nr),\n    s = nr;\n  if (fe(o) === Oe) {\n    const a = s + St,\n      l = a + Te,\n      f = r.slice(s, a),\n      d = r.slice(a, l),\n      g = r.slice(l);\n    return {\n      type: o,\n      sealed: g,\n      iv: d,\n      senderPublicKey: f\n    };\n  }\n  if (fe(o) === _e) {\n    const a = r.slice(s),\n      l = Se(Te);\n    return {\n      type: o,\n      sealed: a,\n      iv: l\n    };\n  }\n  const i = s + Te,\n    c = r.slice(s, i),\n    u = r.slice(i);\n  return {\n    type: o,\n    sealed: u,\n    iv: c\n  };\n}\nfunction di(e, t) {\n  const n = Fe({\n    encoded: e,\n    encoding: t?.encoding\n  });\n  return rr({\n    type: fe(n.type),\n    senderPublicKey: typeof n.senderPublicKey < \"u\" ? K(n.senderPublicKey, V) : void 0,\n    receiverPublicKey: t?.receiverPublicKey\n  });\n}\nfunction rr(e) {\n  const t = e?.type || Nt;\n  if (t === Oe) {\n    if (typeof e?.senderPublicKey > \"u\") throw new Error(\"missing sender public key\");\n    if (typeof e?.receiverPublicKey > \"u\") throw new Error(\"missing receiver public key\");\n  }\n  return {\n    type: t,\n    senderPublicKey: e?.senderPublicKey,\n    receiverPublicKey: e?.receiverPublicKey\n  };\n}\nfunction hi(e) {\n  return e.type === Oe && typeof e.senderPublicKey == \"string\" && typeof e.receiverPublicKey == \"string\";\n}\nfunction pi(e) {\n  return e.type === _e;\n}\nfunction or(e) {\n  return new Dr(\"p256\").keyFromPublic({\n    x: Buffer.from(e.x, \"base64\").toString(\"hex\"),\n    y: Buffer.from(e.y, \"base64\").toString(\"hex\")\n  }, \"hex\");\n}\nfunction gi(e) {\n  let t = e.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  const n = t.length % 4;\n  return n > 0 && (t += \"=\".repeat(4 - n)), t;\n}\nfunction yi(e) {\n  return Buffer.from(gi(e), \"base64\");\n}\nfunction mi(e, t) {\n  const [n, r, o] = e.split(\".\"),\n    s = yi(o);\n  if (s.length !== 64) throw new Error(\"Invalid signature length\");\n  const i = s.slice(0, 32).toString(\"hex\"),\n    c = s.slice(32, 64).toString(\"hex\"),\n    u = `${n}.${r}`,\n    a = He(u),\n    l = or(t),\n    f = K(a, V);\n  if (!l.verify(f, {\n    r: i,\n    s: c\n  })) throw new Error(\"Invalid signature\");\n  return kr(e).payload;\n}\nconst sr = \"irn\";\nfunction bi(e) {\n  return e?.relay || {\n    protocol: sr\n  };\n}\nfunction wi(e) {\n  const t = Mr[e];\n  if (typeof t > \"u\") throw new Error(`Relay Protocol not supported: ${e}`);\n  return t;\n}\nfunction ir(e, t = \"-\") {\n  const n = {},\n    r = \"relay\" + t;\n  return Object.keys(e).forEach(o => {\n    if (o.startsWith(r)) {\n      const s = o.replace(r, \"\"),\n        i = e[o];\n      n[s] = i;\n    }\n  }), n;\n}\nfunction Ei(e) {\n  if (!e.includes(\"wc:\")) {\n    const a = rt(e);\n    a != null && a.includes(\"wc:\") && (e = a);\n  }\n  e = e.includes(\"wc://\") ? e.replace(\"wc://\", \"\") : e, e = e.includes(\"wc:\") ? e.replace(\"wc:\", \"\") : e;\n  const t = e.indexOf(\":\"),\n    n = e.indexOf(\"?\") !== -1 ? e.indexOf(\"?\") : void 0,\n    r = e.substring(0, t),\n    o = e.substring(t + 1, n).split(\"@\"),\n    s = typeof n < \"u\" ? e.substring(n) : \"\",\n    i = new URLSearchParams(s),\n    c = {};\n  i.forEach((a, l) => {\n    c[l] = a;\n  });\n  const u = typeof c.methods == \"string\" ? c.methods.split(\",\") : void 0;\n  return {\n    protocol: r,\n    topic: cr(o[0]),\n    version: parseInt(o[1], 10),\n    symKey: c.symKey,\n    relay: ir(c),\n    methods: u,\n    expiryTimestamp: c.expiryTimestamp ? parseInt(c.expiryTimestamp, 10) : void 0\n  };\n}\nfunction cr(e) {\n  return e.startsWith(\"//\") ? e.substring(2) : e;\n}\nfunction ar(e, t = \"-\") {\n  const n = \"relay\",\n    r = {};\n  return Object.keys(e).forEach(o => {\n    const s = o,\n      i = n + t + s;\n    e[s] && (r[i] = e[s]);\n  }), r;\n}\nfunction vi(e) {\n  const t = new URLSearchParams(),\n    n = ar(e.relay);\n  Object.keys(n).sort().forEach(o => {\n    t.set(o, n[o]);\n  }), t.set(\"symKey\", e.symKey), e.expiryTimestamp && t.set(\"expiryTimestamp\", e.expiryTimestamp.toString()), e.methods && t.set(\"methods\", e.methods.join(\",\"));\n  const r = t.toString();\n  return `${e.protocol}:${e.topic}@${e.version}?${r}`;\n}\nfunction xi(e, t, n) {\n  return `${e}?wc_ev=${n}&topic=${t}`;\n}\nvar Ii = Object.defineProperty,\n  Oi = Object.defineProperties,\n  Ai = Object.getOwnPropertyDescriptors,\n  ur = Object.getOwnPropertySymbols,\n  Ni = Object.prototype.hasOwnProperty,\n  Si = Object.prototype.propertyIsEnumerable,\n  fr = (e, t, n) => t in e ? Ii(e, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: n\n  }) : e[t] = n,\n  Ui = (e, t) => {\n    for (var n in t || (t = {})) Ni.call(t, n) && fr(e, n, t[n]);\n    if (ur) for (var n of ur(t)) Si.call(t, n) && fr(e, n, t[n]);\n    return e;\n  },\n  _i = (e, t) => Oi(e, Ai(t));\nfunction le(e) {\n  const t = [];\n  return e.forEach(n => {\n    const [r, o] = n.split(\":\");\n    t.push(`${r}:${o}`);\n  }), t;\n}\nfunction lr(e) {\n  const t = [];\n  return Object.values(e).forEach(n => {\n    t.push(...le(n.accounts));\n  }), t;\n}\nfunction dr(e, t) {\n  const n = [];\n  return Object.values(e).forEach(r => {\n    le(r.accounts).includes(t) && n.push(...r.methods);\n  }), n;\n}\nfunction hr(e, t) {\n  const n = [];\n  return Object.values(e).forEach(r => {\n    le(r.accounts).includes(t) && n.push(...r.events);\n  }), n;\n}\nfunction Ti(e, t) {\n  const n = Or(e, t);\n  if (n) throw new Error(n.message);\n  const r = {};\n  for (const [o, s] of Object.entries(e)) r[o] = {\n    methods: s.methods,\n    events: s.events,\n    chains: s.accounts.map(i => `${i.split(\":\")[0]}:${i.split(\":\")[1]}`)\n  };\n  return r;\n}\nfunction $i(e) {\n  const {\n      proposal: {\n        requiredNamespaces: t,\n        optionalNamespaces: n = {}\n      },\n      supportedNamespaces: r\n    } = e,\n    o = $t(t),\n    s = $t(n),\n    i = {};\n  Object.keys(r).forEach(a => {\n    const l = r[a].chains,\n      f = r[a].methods,\n      d = r[a].events,\n      g = r[a].accounts;\n    l.forEach(y => {\n      if (!g.some(h => h.includes(y))) throw new Error(`No accounts provided for chain ${y} in namespace ${a}`);\n    }), i[a] = {\n      chains: l,\n      methods: f,\n      events: d,\n      accounts: g\n    };\n  });\n  const c = Nr(t, i, \"approve()\");\n  if (c) throw new Error(c.message);\n  const u = {};\n  return !Object.keys(t).length && !Object.keys(n).length ? i : (Object.keys(o).forEach(a => {\n    const l = r[a].chains.filter(y => {\n        var h, m;\n        return (m = (h = o[a]) == null ? void 0 : h.chains) == null ? void 0 : m.includes(y);\n      }),\n      f = r[a].methods.filter(y => {\n        var h, m;\n        return (m = (h = o[a]) == null ? void 0 : h.methods) == null ? void 0 : m.includes(y);\n      }),\n      d = r[a].events.filter(y => {\n        var h, m;\n        return (m = (h = o[a]) == null ? void 0 : h.events) == null ? void 0 : m.includes(y);\n      }),\n      g = l.map(y => r[a].accounts.filter(h => h.includes(`${y}:`))).flat();\n    u[a] = {\n      chains: l,\n      methods: f,\n      events: d,\n      accounts: g\n    };\n  }), Object.keys(s).forEach(a => {\n    var l, f, d, g, y, h;\n    if (!r[a]) return;\n    const m = (f = (l = s[a]) == null ? void 0 : l.chains) == null ? void 0 : f.filter(O => r[a].chains.includes(O)),\n      L = r[a].methods.filter(O => {\n        var k, E;\n        return (E = (k = s[a]) == null ? void 0 : k.methods) == null ? void 0 : E.includes(O);\n      }),\n      b = r[a].events.filter(O => {\n        var k, E;\n        return (E = (k = s[a]) == null ? void 0 : k.events) == null ? void 0 : E.includes(O);\n      }),\n      _ = m?.map(O => r[a].accounts.filter(k => k.includes(`${O}:`))).flat();\n    u[a] = {\n      chains: Q((d = u[a]) == null ? void 0 : d.chains, m),\n      methods: Q((g = u[a]) == null ? void 0 : g.methods, L),\n      events: Q((y = u[a]) == null ? void 0 : y.events, b),\n      accounts: Q((h = u[a]) == null ? void 0 : h.accounts, _)\n    };\n  }), u);\n}\nfunction Tt(e) {\n  return e.includes(\":\");\n}\nfunction pr(e) {\n  return Tt(e) ? e.split(\":\")[0] : e;\n}\nfunction $t(e) {\n  var t, n, r;\n  const o = {};\n  if (!qe(e)) return o;\n  for (const [s, i] of Object.entries(e)) {\n    const c = Tt(s) ? [s] : i.chains,\n      u = i.methods || [],\n      a = i.events || [],\n      l = pr(s);\n    o[l] = _i(Ui({}, o[l]), {\n      chains: Q(c, (t = o[l]) == null ? void 0 : t.chains),\n      methods: Q(u, (n = o[l]) == null ? void 0 : n.methods),\n      events: Q(a, (r = o[l]) == null ? void 0 : r.events)\n    });\n  }\n  return o;\n}\nfunction gr(e) {\n  const t = {};\n  return e?.forEach(n => {\n    var r;\n    const [o, s] = n.split(\":\");\n    t[o] || (t[o] = {\n      accounts: [],\n      chains: [],\n      events: [],\n      methods: []\n    }), t[o].accounts.push(n), (r = t[o].chains) == null || r.push(`${o}:${s}`);\n  }), t;\n}\nfunction Ri(e, t) {\n  t = t.map(r => r.replace(\"did:pkh:\", \"\"));\n  const n = gr(t);\n  for (const [r, o] of Object.entries(n)) o.methods ? o.methods = Q(o.methods, e) : o.methods = e, o.events = [\"chainChanged\", \"accountsChanged\"];\n  return n;\n}\nconst yr = {\n    INVALID_METHOD: {\n      message: \"Invalid method.\",\n      code: 1001\n    },\n    INVALID_EVENT: {\n      message: \"Invalid event.\",\n      code: 1002\n    },\n    INVALID_UPDATE_REQUEST: {\n      message: \"Invalid update request.\",\n      code: 1003\n    },\n    INVALID_EXTEND_REQUEST: {\n      message: \"Invalid extend request.\",\n      code: 1004\n    },\n    INVALID_SESSION_SETTLE_REQUEST: {\n      message: \"Invalid session settle request.\",\n      code: 1005\n    },\n    UNAUTHORIZED_METHOD: {\n      message: \"Unauthorized method.\",\n      code: 3001\n    },\n    UNAUTHORIZED_EVENT: {\n      message: \"Unauthorized event.\",\n      code: 3002\n    },\n    UNAUTHORIZED_UPDATE_REQUEST: {\n      message: \"Unauthorized update request.\",\n      code: 3003\n    },\n    UNAUTHORIZED_EXTEND_REQUEST: {\n      message: \"Unauthorized extend request.\",\n      code: 3004\n    },\n    USER_REJECTED: {\n      message: \"User rejected.\",\n      code: 5e3\n    },\n    USER_REJECTED_CHAINS: {\n      message: \"User rejected chains.\",\n      code: 5001\n    },\n    USER_REJECTED_METHODS: {\n      message: \"User rejected methods.\",\n      code: 5002\n    },\n    USER_REJECTED_EVENTS: {\n      message: \"User rejected events.\",\n      code: 5003\n    },\n    UNSUPPORTED_CHAINS: {\n      message: \"Unsupported chains.\",\n      code: 5100\n    },\n    UNSUPPORTED_METHODS: {\n      message: \"Unsupported methods.\",\n      code: 5101\n    },\n    UNSUPPORTED_EVENTS: {\n      message: \"Unsupported events.\",\n      code: 5102\n    },\n    UNSUPPORTED_ACCOUNTS: {\n      message: \"Unsupported accounts.\",\n      code: 5103\n    },\n    UNSUPPORTED_NAMESPACE_KEY: {\n      message: \"Unsupported namespace key.\",\n      code: 5104\n    },\n    USER_DISCONNECTED: {\n      message: \"User disconnected.\",\n      code: 6e3\n    },\n    SESSION_SETTLEMENT_FAILED: {\n      message: \"Session settlement failed.\",\n      code: 7e3\n    },\n    WC_METHOD_UNSUPPORTED: {\n      message: \"Unsupported wc_ method.\",\n      code: 10001\n    }\n  },\n  mr = {\n    NOT_INITIALIZED: {\n      message: \"Not initialized.\",\n      code: 1\n    },\n    NO_MATCHING_KEY: {\n      message: \"No matching key.\",\n      code: 2\n    },\n    RESTORE_WILL_OVERRIDE: {\n      message: \"Restore will override.\",\n      code: 3\n    },\n    RESUBSCRIBED: {\n      message: \"Resubscribed.\",\n      code: 4\n    },\n    MISSING_OR_INVALID: {\n      message: \"Missing or invalid.\",\n      code: 5\n    },\n    EXPIRED: {\n      message: \"Expired.\",\n      code: 6\n    },\n    UNKNOWN_TYPE: {\n      message: \"Unknown type.\",\n      code: 7\n    },\n    MISMATCHED_TOPIC: {\n      message: \"Mismatched topic.\",\n      code: 8\n    },\n    NON_CONFORMING_NAMESPACES: {\n      message: \"Non conforming namespaces.\",\n      code: 9\n    }\n  };\nfunction te(e, t) {\n  const {\n    message: n,\n    code: r\n  } = mr[e];\n  return {\n    message: t ? `${n} ${t}` : n,\n    code: r\n  };\n}\nfunction de(e, t) {\n  const {\n    message: n,\n    code: r\n  } = yr[e];\n  return {\n    message: t ? `${n} ${t}` : n,\n    code: r\n  };\n}\nfunction $e(e, t) {\n  return Array.isArray(e) ? typeof t < \"u\" && e.length ? e.every(t) : !0 : !1;\n}\nfunction qe(e) {\n  return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length;\n}\nfunction ae(e) {\n  return typeof e > \"u\";\n}\nfunction q(e, t) {\n  return t && ae(e) ? !0 : typeof e == \"string\" && !!e.trim().length;\n}\nfunction Ge(e, t) {\n  return t && ae(e) ? !0 : typeof e == \"number\" && !isNaN(e);\n}\nfunction Pi(e, t) {\n  const {\n      requiredNamespaces: n\n    } = t,\n    r = Object.keys(e.namespaces),\n    o = Object.keys(n);\n  let s = !0;\n  return re(o, r) ? (r.forEach(i => {\n    const {\n        accounts: c,\n        methods: u,\n        events: a\n      } = e.namespaces[i],\n      l = le(c),\n      f = n[i];\n    (!re(Be(i, f), l) || !re(f.methods, u) || !re(f.events, a)) && (s = !1);\n  }), s) : !1;\n}\nfunction Re(e) {\n  return q(e, !1) && e.includes(\":\") ? e.split(\":\").length === 2 : !1;\n}\nfunction br(e) {\n  if (q(e, !1) && e.includes(\":\")) {\n    const t = e.split(\":\");\n    if (t.length === 3) {\n      const n = t[0] + \":\" + t[1];\n      return !!t[2] && Re(n);\n    }\n  }\n  return !1;\n}\nfunction Bi(e) {\n  function t(n) {\n    try {\n      return typeof new URL(n) < \"u\";\n    } catch {\n      return !1;\n    }\n  }\n  try {\n    if (q(e, !1)) {\n      if (t(e)) return !0;\n      const n = rt(e);\n      return t(n);\n    }\n  } catch {}\n  return !1;\n}\nfunction Li(e) {\n  var t;\n  return (t = e?.proposer) == null ? void 0 : t.publicKey;\n}\nfunction ji(e) {\n  return e?.topic;\n}\nfunction Ci(e, t) {\n  let n = null;\n  return q(e?.publicKey, !1) || (n = te(\"MISSING_OR_INVALID\", `${t} controller public key should be a string`)), n;\n}\nfunction Rt(e) {\n  let t = !0;\n  return $e(e) ? e.length && (t = e.every(n => q(n, !1))) : t = !1, t;\n}\nfunction wr(e, t, n) {\n  let r = null;\n  return $e(t) && t.length ? t.forEach(o => {\n    r || Re(o) || (r = de(\"UNSUPPORTED_CHAINS\", `${n}, chain ${o} should be a string and conform to \"namespace:chainId\" format`));\n  }) : Re(e) || (r = de(\"UNSUPPORTED_CHAINS\", `${n}, chains must be defined as \"namespace:chainId\" e.g. \"eip155:1\": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: [\"eip155:1\", \"eip155:5\"] }`)), r;\n}\nfunction Er(e, t, n) {\n  let r = null;\n  return Object.entries(e).forEach(([o, s]) => {\n    if (r) return;\n    const i = wr(o, Be(o, s), `${t} ${n}`);\n    i && (r = i);\n  }), r;\n}\nfunction vr(e, t) {\n  let n = null;\n  return $e(e) ? e.forEach(r => {\n    n || br(r) || (n = de(\"UNSUPPORTED_ACCOUNTS\", `${t}, account ${r} should be a string and conform to \"namespace:chainId:address\" format`));\n  }) : n = de(\"UNSUPPORTED_ACCOUNTS\", `${t}, accounts should be an array of strings conforming to \"namespace:chainId:address\" format`), n;\n}\nfunction xr(e, t) {\n  let n = null;\n  return Object.values(e).forEach(r => {\n    if (n) return;\n    const o = vr(r?.accounts, `${t} namespace`);\n    o && (n = o);\n  }), n;\n}\nfunction Ir(e, t) {\n  let n = null;\n  return Rt(e?.methods) ? Rt(e?.events) || (n = de(\"UNSUPPORTED_EVENTS\", `${t}, events should be an array of strings or empty array for no events`)) : n = de(\"UNSUPPORTED_METHODS\", `${t}, methods should be an array of strings or empty array for no methods`), n;\n}\nfunction Pt(e, t) {\n  let n = null;\n  return Object.values(e).forEach(r => {\n    if (n) return;\n    const o = Ir(r, `${t}, namespace`);\n    o && (n = o);\n  }), n;\n}\nfunction ki(e, t, n) {\n  let r = null;\n  if (e && qe(e)) {\n    const o = Pt(e, t);\n    o && (r = o);\n    const s = Er(e, t, n);\n    s && (r = s);\n  } else r = te(\"MISSING_OR_INVALID\", `${t}, ${n} should be an object with data`);\n  return r;\n}\nfunction Or(e, t) {\n  let n = null;\n  if (e && qe(e)) {\n    const r = Pt(e, t);\n    r && (n = r);\n    const o = xr(e, t);\n    o && (n = o);\n  } else n = te(\"MISSING_OR_INVALID\", `${t}, namespaces should be an object with data`);\n  return n;\n}\nfunction Ar(e) {\n  return q(e.protocol, !0);\n}\nfunction Di(e, t) {\n  let n = !1;\n  return t && !e ? n = !0 : e && $e(e) && e.length && e.forEach(r => {\n    n = Ar(r);\n  }), n;\n}\nfunction Mi(e) {\n  return typeof e == \"number\";\n}\nfunction Vi(e) {\n  return typeof e < \"u\" && typeof e !== null;\n}\nfunction Hi(e) {\n  return !(!e || typeof e != \"object\" || !e.code || !Ge(e.code, !1) || !e.message || !q(e.message, !1));\n}\nfunction Ki(e) {\n  return !(ae(e) || !q(e.method, !1));\n}\nfunction Fi(e) {\n  return !(ae(e) || ae(e.result) && ae(e.error) || !Ge(e.id, !1) || !q(e.jsonrpc, !1));\n}\nfunction qi(e) {\n  return !(ae(e) || !q(e.name, !1));\n}\nfunction Gi(e, t) {\n  return !(!Re(t) || !lr(e).includes(t));\n}\nfunction Wi(e, t, n) {\n  return q(n, !1) ? dr(e, t).includes(n) : !1;\n}\nfunction zi(e, t, n) {\n  return q(n, !1) ? hr(e, t).includes(n) : !1;\n}\nfunction Nr(e, t, n) {\n  let r = null;\n  const o = Ji(e),\n    s = Yi(t),\n    i = Object.keys(o),\n    c = Object.keys(s),\n    u = Sr(Object.keys(e)),\n    a = Sr(Object.keys(t)),\n    l = u.filter(f => !a.includes(f));\n  return l.length && (r = te(\"NON_CONFORMING_NAMESPACES\", `${n} namespaces keys don't satisfy requiredNamespaces.\n      Required: ${l.toString()}\n      Received: ${Object.keys(t).toString()}`)), re(i, c) || (r = te(\"NON_CONFORMING_NAMESPACES\", `${n} namespaces chains don't satisfy required namespaces.\n      Required: ${i.toString()}\n      Approved: ${c.toString()}`)), Object.keys(t).forEach(f => {\n    if (!f.includes(\":\") || r) return;\n    const d = le(t[f].accounts);\n    d.includes(f) || (r = te(\"NON_CONFORMING_NAMESPACES\", `${n} namespaces accounts don't satisfy namespace accounts for ${f}\n        Required: ${f}\n        Approved: ${d.toString()}`));\n  }), i.forEach(f => {\n    r || (re(o[f].methods, s[f].methods) ? re(o[f].events, s[f].events) || (r = te(\"NON_CONFORMING_NAMESPACES\", `${n} namespaces events don't satisfy namespace events for ${f}`)) : r = te(\"NON_CONFORMING_NAMESPACES\", `${n} namespaces methods don't satisfy namespace methods for ${f}`));\n  }), r;\n}\nfunction Ji(e) {\n  const t = {};\n  return Object.keys(e).forEach(n => {\n    var r;\n    n.includes(\":\") ? t[n] = e[n] : (r = e[n].chains) == null || r.forEach(o => {\n      t[o] = {\n        methods: e[n].methods,\n        events: e[n].events\n      };\n    });\n  }), t;\n}\nfunction Sr(e) {\n  return [...new Set(e.map(t => t.includes(\":\") ? t.split(\":\")[0] : t))];\n}\nfunction Yi(e) {\n  const t = {};\n  return Object.keys(e).forEach(n => {\n    if (n.includes(\":\")) t[n] = e[n];else {\n      const r = le(e[n].accounts);\n      r?.forEach(o => {\n        t[o] = {\n          accounts: e[n].accounts.filter(s => s.includes(`${o}:`)),\n          methods: e[n].methods,\n          events: e[n].events\n        };\n      });\n    }\n  }), t;\n}\nfunction Xi(e, t) {\n  return Ge(e, !1) && e <= t.max && e >= t.min;\n}\nfunction Zi() {\n  const e = ue();\n  return new Promise(t => {\n    switch (e) {\n      case H.browser:\n        t(Ur());\n        break;\n      case H.reactNative:\n        t(_r());\n        break;\n      case H.node:\n        t(Tr());\n        break;\n      default:\n        t(!0);\n    }\n  });\n}\nfunction Ur() {\n  return Ae() && navigator?.onLine;\n}\nasync function _r() {\n  if (ne() && typeof global < \"u\" && global != null && global.NetInfo) {\n    const e = await (global == null ? void 0 : global.NetInfo.fetch());\n    return e?.isConnected;\n  }\n  return !0;\n}\nfunction Tr() {\n  return !0;\n}\nfunction Qi(e) {\n  switch (ue()) {\n    case H.browser:\n      $r(e);\n      break;\n    case H.reactNative:\n      Rr(e);\n      break;\n    case H.node:\n      break;\n  }\n}\nfunction $r(e) {\n  !ne() && Ae() && (window.addEventListener(\"online\", () => e(!0)), window.addEventListener(\"offline\", () => e(!1)));\n}\nfunction Rr(e) {\n  ne() && typeof global < \"u\" && global != null && global.NetInfo && global?.NetInfo.addEventListener(t => e(t?.isConnected));\n}\nconst Bt = {};\nclass ec {\n  static get(t) {\n    return Bt[t];\n  }\n  static set(t, n) {\n    Bt[t] = n;\n  }\n  static delete(t) {\n    delete Bt[t];\n  }\n}\nexport { Ot as BASE10, V as BASE16, At as BASE64, ti as BASE64URL, Gr as COLON, Qe as DEFAULT_DEPTH, Le as EMPTY_SPACE, H as ENV_MAP, mr as INTERNAL_ERRORS, ec as MemoryStore, Wr as ONE_THOUSAND, Ft as REACT_NATIVE_PRODUCT, sr as RELAYER_DEFAULT_PROTOCOL, yr as SDK_ERRORS, Gt as SDK_TYPE, qt as SLASH, Nt as TYPE_0, Oe as TYPE_1, _e as TYPE_2, Ie as UTF8, $n as addResourceToRecap, Wt as appendToQueryString, to as assertType, ft as assignAbilityToActions, _n as base64Decode, Un as base64Encode, $i as buildApprovedNamespaces, Qo as buildAuthObject, Ri as buildNamespacesFromAuth, Pn as buildRecapStatement, po as calcExpiry, co as capitalize, Qt as capitalizeWord, ao as createDelayedPromise, rs as createEncodedRecap, uo as createExpiringPromise, Tn as createRecap, oe as decodeRecap, fe as decodeTypeByte, li as decodeTypeTwoEnvelope, ui as decrypt, si as deriveSymKey, Fe as deserialize, De as encodeRecap, Ut as encodeTypeByte, fi as encodeTypeTwoEnvelope, ai as encrypt, yo as engineEvent, io as enumify, qo as extractSolanaTransactionId, Mt as formatAccountId, Vr as formatAccountWithChain, Dt as formatChainId, en as formatDeeplinkUrl, tt as formatExpirerTarget, lo as formatIdTarget, On as formatMessage, no as formatMessageContext, ar as formatRelayParams, Qr as formatRelayRpcUrl, dt as formatStatementFromRecap, fo as formatTopicTarget, Yt as formatUA, vi as formatUri, rt as fromBase64, ri as generateKeyPair, oi as generateRandomBytes32, le as getAccountsChains, Kr as getAccountsFromNamespaces, Vt as getAddressFromAccount, Hr as getAddressesFromAccounts, Yr as getAppId, Xr as getAppMetadata, Ur as getBrowserOnlineStatus, Ht as getChainFromAccount, Kt as getChainsFromAccounts, Be as getChainsFromNamespace, Fr as getChainsFromNamespaces, is as getChainsFromRecap, qr as getChainsFromRequiredNamespaces, nt as getCommonValuesInArrays, or as getCryptoKeyFromKeyData, An as getDecodedRecapFromResources, bo as getDeepLink, ut as getDidAddress, ke as getDidAddressSegments, xn as getDidChainId, ue as getEnvironment, eo as getHttpUrl, te as getInternalError, Jt as getJavascriptID, zt as getJavascriptOS, Zt as getLastItems, xi as getLinkModeURL, ss as getMethodsFromRecap, In as getNamespacedDidChainId, lr as getNamespacesChains, hr as getNamespacesEventsForChainId, gr as getNamespacesFromAccounts, dr as getNamespacesMethodsForChainId, Tr as getNodeOnlineStatus, Sn as getReCapActions, _r as getReactNativeOnlineStatus, ns as getRecapAbilitiesFromResource, Me as getRecapFromResources, Nn as getRecapResource, Zr as getRelayClientMetadata, wi as getRelayProtocolApi, bi as getRelayProtocolName, Ti as getRequiredNamespacesFromNamespaces, de as getSdkError, wo as getSearchParamFromURL, Ze as getUniqueValues, mo as handleDeeplinkRedirect, re as hasOverlap, ct as hashEthereumMessage, ii as hashKey, ci as hashMessage, zr as isAndroid, Ae as isBrowser, Tt as isCaipNamespace, Nr as isConformingNamespaces, go as isExpired, rn as isIframe, Jr as isIos, et as isNode, Zi as isOnline, Li as isProposalStruct, ne as isReactNative, lt as isRecap, Pi as isSessionCompatible, ji as isSessionStruct, nn as isTelegram, vo as isTestRun, hi as isTypeOneEnvelope, pi as isTypeTwoEnvelope, ae as isUndefined, br as isValidAccountId, vr as isValidAccounts, Ir as isValidActions, $e as isValidArray, Re as isValidChainId, wr as isValidChains, Ci as isValidController, bn as isValidEip1271Signature, mn as isValidEip191Signature, Hi as isValidErrorReason, qi as isValidEvent, Mi as isValidId, xr as isValidNamespaceAccounts, Pt as isValidNamespaceActions, Er as isValidNamespaceChains, Rt as isValidNamespaceMethodsOrEvents, Or as isValidNamespaces, Gi as isValidNamespacesChainId, zi as isValidNamespacesEvent, Wi as isValidNamespacesRequest, Ge as isValidNumber, qe as isValidObject, Vi as isValidParams, Y as isValidRecap, Ar as isValidRelay, Di as isValidRelays, Ki as isValidRequest, Xi as isValidRequestExpiry, ki as isValidRequiredNamespaces, Fi as isValidResponse, q as isValidString, Bi as isValidUrl, so as mapEntries, ro as mapToObj, Q as mergeArrays, os as mergeEncodedRecaps, Rn as mergeRecaps, $t as normalizeNamespaces, oo as objToMap, tn as openDeeplink, Xe as parseAccountId, Ye as parseChainId, Xt as parseContextNames, ho as parseExpirerTarget, pr as parseNamespaceKey, ir as parseRelayParams, cr as parseTopic, Ei as parseUri, es as populateAuthPayload, ts as recapHasResource, _t as serialize, xo as sleep, $r as subscribeToBrowserNetworkChange, Qi as subscribeToNetworkChange, Rr as subscribeToReactNativeNetworkChange, on as toBase64, Eo as uuidv4, di as validateDecoding, rr as validateEncoding, Zo as validateSignedCacao, mi as verifyP256Jwt, yn as verifySignature };\n//# sourceMappingURL=index.es.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}