{"ast":null,"code":"import { generateAddress, generateAddress2, isValidAddress, privateToAddress, pubToAddress } from './account.js';\nimport { bigIntToBytes, bytesToBigInt, bytesToHex, equalsBytes, hexToBytes, zeros } from './bytes.js';\nimport { BIGINT_0 } from './constants.js';\n/**\n * Handling and generating Ethereum addresses\n */\nexport class Address {\n  constructor(bytes) {\n    if (bytes.length !== 20) {\n      throw new Error('Invalid address length');\n    }\n    this.bytes = bytes;\n  }\n  /**\n   * Returns the zero address.\n   */\n  static zero() {\n    return new Address(zeros(20));\n  }\n  /**\n   * Returns an Address object from a hex-encoded string.\n   * @param str - Hex-encoded address\n   */\n  static fromString(str) {\n    if (!isValidAddress(str)) {\n      throw new Error(`Invalid address input=${str}`);\n    }\n    return new Address(hexToBytes(str));\n  }\n  /**\n   * Returns an address for a given public key.\n   * @param pubKey The two points of an uncompressed key\n   */\n  static fromPublicKey(pubKey) {\n    if (!(pubKey instanceof Uint8Array)) {\n      throw new Error('Public key should be Uint8Array');\n    }\n    const bytes = pubToAddress(pubKey);\n    return new Address(bytes);\n  }\n  /**\n   * Returns an address for a given private key.\n   * @param privateKey A private key must be 256 bits wide\n   */\n  static fromPrivateKey(privateKey) {\n    if (!(privateKey instanceof Uint8Array)) {\n      throw new Error('Private key should be Uint8Array');\n    }\n    const bytes = privateToAddress(privateKey);\n    return new Address(bytes);\n  }\n  /**\n   * Generates an address for a newly created contract.\n   * @param from The address which is creating this new address\n   * @param nonce The nonce of the from account\n   */\n  static generate(from, nonce) {\n    if (typeof nonce !== 'bigint') {\n      throw new Error('Expected nonce to be a bigint');\n    }\n    return new Address(generateAddress(from.bytes, bigIntToBytes(nonce)));\n  }\n  /**\n   * Generates an address for a contract created using CREATE2.\n   * @param from The address which is creating this new address\n   * @param salt A salt\n   * @param initCode The init code of the contract being created\n   */\n  static generate2(from, salt, initCode) {\n    if (!(salt instanceof Uint8Array)) {\n      throw new Error('Expected salt to be a Uint8Array');\n    }\n    if (!(initCode instanceof Uint8Array)) {\n      throw new Error('Expected initCode to be a Uint8Array');\n    }\n    return new Address(generateAddress2(from.bytes, salt, initCode));\n  }\n  /**\n   * Is address equal to another.\n   */\n  equals(address) {\n    return equalsBytes(this.bytes, address.bytes);\n  }\n  /**\n   * Is address zero.\n   */\n  isZero() {\n    return this.equals(Address.zero());\n  }\n  /**\n   * True if address is in the address range defined\n   * by EIP-1352\n   */\n  isPrecompileOrSystemAddress() {\n    const address = bytesToBigInt(this.bytes);\n    const rangeMin = BIGINT_0;\n    const rangeMax = BigInt('0xffff');\n    return address >= rangeMin && address <= rangeMax;\n  }\n  /**\n   * Returns hex encoding of address.\n   */\n  toString() {\n    return bytesToHex(this.bytes);\n  }\n  /**\n   * Returns a new Uint8Array representation of address.\n   */\n  toBytes() {\n    return new Uint8Array(this.bytes);\n  }\n}\n//# sourceMappingURL=address.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}