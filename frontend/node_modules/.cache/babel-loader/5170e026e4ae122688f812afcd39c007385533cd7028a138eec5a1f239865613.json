{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport Transport from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/hid-framing\";\nimport { identifyUSBProductId, ledgerUSBVendorId } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport { TransportOpenUserCancelled, DisconnectedDeviceDuringOperation, DisconnectedDevice, TransportError } from \"@ledgerhq/errors\";\nconst ledgerDevices = [{\n  vendorId: ledgerUSBVendorId\n}];\nconst isSupported = () => Promise.resolve(!!(window.navigator && window.navigator.hid));\nconst getHID = () => {\n  // $FlowFixMe\n  const {\n    hid\n  } = navigator;\n  if (!hid) throw new TransportError(\"navigator.hid is not supported\", \"HIDNotSupported\");\n  return hid;\n};\nfunction requestLedgerDevices() {\n  return __awaiter(this, void 0, void 0, function* () {\n    const device = yield getHID().requestDevice({\n      filters: ledgerDevices\n    });\n    if (Array.isArray(device)) return device;\n    return [device];\n  });\n}\nfunction getLedgerDevices() {\n  return __awaiter(this, void 0, void 0, function* () {\n    const devices = yield getHID().getDevices();\n    return devices.filter(d => d.vendorId === ledgerUSBVendorId);\n  });\n}\nfunction getFirstLedgerDevice() {\n  return __awaiter(this, void 0, void 0, function* () {\n    const existingDevices = yield getLedgerDevices();\n    if (existingDevices.length > 0) return existingDevices[0];\n    const devices = yield requestLedgerDevices();\n    return devices[0];\n  });\n}\n/**\n * WebHID Transport implementation\n * @example\n * import TransportWebHID from \"@ledgerhq/hw-transport-webhid\";\n * ...\n * TransportWebHID.create().then(transport => ...)\n */\nclass TransportWebHID extends Transport {\n  constructor(device) {\n    super();\n    this.channel = Math.floor(Math.random() * 0xffff);\n    this.packetSize = 64;\n    this.inputs = [];\n    this.read = () => {\n      if (this.inputs.length) {\n        return Promise.resolve(this.inputs.shift());\n      }\n      return new Promise(success => {\n        this.inputCallback = success;\n      });\n    };\n    this.onInputReport = e => {\n      const buffer = Buffer.from(e.data.buffer);\n      if (this.inputCallback) {\n        this.inputCallback(buffer);\n        this.inputCallback = null;\n      } else {\n        this.inputs.push(buffer);\n      }\n    };\n    this._disconnectEmitted = false;\n    this._emitDisconnect = e => {\n      if (this._disconnectEmitted) return;\n      this._disconnectEmitted = true;\n      this.emit(\"disconnect\", e);\n    };\n    /**\n     * Exchange with the device using APDU protocol.\n     * @param apdu\n     * @returns a promise of apdu response\n     */\n    this.exchange = apdu => __awaiter(this, void 0, void 0, function* () {\n      const b = yield this.exchangeAtomicImpl(() => __awaiter(this, void 0, void 0, function* () {\n        const {\n          channel,\n          packetSize\n        } = this;\n        log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n        const framing = hidFraming(channel, packetSize);\n        // Write...\n        const blocks = framing.makeBlocks(apdu);\n        for (let i = 0; i < blocks.length; i++) {\n          yield this.device.sendReport(0, blocks[i]);\n        }\n        // Read...\n        let result;\n        let acc;\n        while (!(result = framing.getReducedResult(acc))) {\n          try {\n            const buffer = yield this.read();\n            acc = framing.reduceResponse(acc, buffer);\n          } catch (e) {\n            if (e instanceof TransportError && e.id === \"InvalidChannel\") {\n              // this can happen if the device is connected\n              // on a different channel (like another app)\n              // in this case we just filter out the event\n              continue;\n            }\n            throw e;\n          }\n        }\n        log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n        return result;\n      })).catch(e => {\n        if (e && e.message && e.message.includes(\"write\")) {\n          this._emitDisconnect(e);\n          throw new DisconnectedDeviceDuringOperation(e.message);\n        }\n        throw e;\n      });\n      return b;\n    });\n    this.device = device;\n    this.deviceModel = typeof device.productId === \"number\" ? identifyUSBProductId(device.productId) : undefined;\n    device.addEventListener(\"inputreport\", this.onInputReport);\n  }\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n  static request() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const [device] = yield requestLedgerDevices();\n      return TransportWebHID.open(device);\n    });\n  }\n  /**\n   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n   */\n  static openConnected() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const devices = yield getLedgerDevices();\n      if (devices.length === 0) return null;\n      return TransportWebHID.open(devices[0]);\n    });\n  }\n  /**\n   * Create a Ledger transport with a HIDDevice\n   */\n  static open(device) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield device.open();\n      const transport = new TransportWebHID(device);\n      const onDisconnect = e => {\n        if (device === e.device) {\n          getHID().removeEventListener(\"disconnect\", onDisconnect);\n          transport._emitDisconnect(new DisconnectedDevice());\n        }\n      };\n      getHID().addEventListener(\"disconnect\", onDisconnect);\n      return transport;\n    });\n  }\n  /**\n   * Release the transport device\n   */\n  close() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.exchangeBusyPromise;\n      this.device.removeEventListener(\"inputreport\", this.onInputReport);\n      yield this.device.close();\n    });\n  }\n  setScrambleKey() {}\n}\n/**\n * Check if WebUSB transport is supported.\n */\nTransportWebHID.isSupported = isSupported;\n/**\n * List the WebUSB devices that was previously authorized by the user.\n */\nTransportWebHID.list = getLedgerDevices;\n/**\n * Actively listen to WebUSB devices and emit ONE device\n * that was either accepted before, if not it will trigger the native permission UI.\n *\n * Important: it must be called in the context of a UI click!\n */\nTransportWebHID.listen = observer => {\n  let unsubscribed = false;\n  getFirstLedgerDevice().then(device => {\n    if (!device) {\n      observer.error(new TransportOpenUserCancelled(\"Access denied to use Ledger device\"));\n    } else if (!unsubscribed) {\n      const deviceModel = typeof device.productId === \"number\" ? identifyUSBProductId(device.productId) : undefined;\n      observer.next({\n        type: \"add\",\n        descriptor: device,\n        deviceModel\n      });\n      observer.complete();\n    }\n  }, error => {\n    observer.error(new TransportOpenUserCancelled(error.message));\n  });\n  function unsubscribe() {\n    unsubscribed = true;\n  }\n  return {\n    unsubscribe\n  };\n};\nexport default TransportWebHID;","map":{"version":3,"names":["Transport","hidFraming","identifyUSBProductId","ledgerUSBVendorId","log","TransportOpenUserCancelled","DisconnectedDeviceDuringOperation","DisconnectedDevice","TransportError","ledgerDevices","vendorId","isSupported","Promise","resolve","window","navigator","hid","getHID","requestLedgerDevices","device","requestDevice","filters","Array","isArray","getLedgerDevices","devices","getDevices","filter","d","getFirstLedgerDevice","existingDevices","length","TransportWebHID","constructor","channel","Math","floor","random","packetSize","inputs","read","shift","success","inputCallback","onInputReport","e","buffer","Buffer","from","data","push","_disconnectEmitted","_emitDisconnect","emit","exchange","apdu","__awaiter","b","exchangeAtomicImpl","toString","framing","blocks","makeBlocks","i","sendReport","result","acc","getReducedResult","reduceResponse","id","catch","message","includes","deviceModel","productId","undefined","addEventListener","request","open","openConnected","transport","onDisconnect","removeEventListener","close","exchangeBusyPromise","setScrambleKey","list","listen","observer","unsubscribed","then","error","next","type","descriptor","complete","unsubscribe"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@ledgerhq\\hw-transport-webhid\\src\\TransportWebHID.ts"],"sourcesContent":["import Transport from \"@ledgerhq/hw-transport\";\nimport type { Observer, DescriptorEvent, Subscription } from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/hid-framing\";\nimport { identifyUSBProductId, ledgerUSBVendorId } from \"@ledgerhq/devices\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport {\n  TransportOpenUserCancelled,\n  DisconnectedDeviceDuringOperation,\n  DisconnectedDevice,\n  TransportError,\n} from \"@ledgerhq/errors\";\n\nconst ledgerDevices = [\n  {\n    vendorId: ledgerUSBVendorId,\n  },\n];\n\nconst isSupported = () => Promise.resolve(!!(window.navigator && window.navigator.hid));\n\nconst getHID = (): HID => {\n  // $FlowFixMe\n  const { hid } = navigator;\n  if (!hid) throw new TransportError(\"navigator.hid is not supported\", \"HIDNotSupported\");\n  return hid;\n};\n\nasync function requestLedgerDevices(): Promise<HIDDevice[]> {\n  const device = await getHID().requestDevice({\n    filters: ledgerDevices,\n  });\n  if (Array.isArray(device)) return device;\n  return [device];\n}\n\nasync function getLedgerDevices(): Promise<HIDDevice[]> {\n  const devices = await getHID().getDevices();\n  return devices.filter(d => d.vendorId === ledgerUSBVendorId);\n}\n\nasync function getFirstLedgerDevice(): Promise<HIDDevice> {\n  const existingDevices = await getLedgerDevices();\n  if (existingDevices.length > 0) return existingDevices[0];\n  const devices = await requestLedgerDevices();\n  return devices[0];\n}\n/**\n * WebHID Transport implementation\n * @example\n * import TransportWebHID from \"@ledgerhq/hw-transport-webhid\";\n * ...\n * TransportWebHID.create().then(transport => ...)\n */\n\nexport default class TransportWebHID extends Transport {\n  device: HIDDevice;\n  deviceModel: DeviceModel | null | undefined;\n  channel = Math.floor(Math.random() * 0xffff);\n  packetSize = 64;\n\n  constructor(device: HIDDevice) {\n    super();\n    this.device = device;\n    this.deviceModel =\n      typeof device.productId === \"number\" ? identifyUSBProductId(device.productId) : undefined;\n    device.addEventListener(\"inputreport\", this.onInputReport);\n  }\n\n  inputs: Buffer[] = [];\n  inputCallback: ((arg0: Buffer) => void) | null | undefined;\n  read = (): Promise<Buffer> => {\n    if (this.inputs.length) {\n      return Promise.resolve(this.inputs.shift() as unknown as Buffer);\n    }\n\n    return new Promise(success => {\n      this.inputCallback = success;\n    });\n  };\n  onInputReport = (e: HIDInputReportEvent) => {\n    const buffer = Buffer.from(e.data.buffer);\n\n    if (this.inputCallback) {\n      this.inputCallback(buffer);\n      this.inputCallback = null;\n    } else {\n      this.inputs.push(buffer);\n    }\n  };\n\n  /**\n   * Check if WebUSB transport is supported.\n   */\n  static isSupported = isSupported;\n\n  /**\n   * List the WebUSB devices that was previously authorized by the user.\n   */\n  static list = getLedgerDevices;\n\n  /**\n   * Actively listen to WebUSB devices and emit ONE device\n   * that was either accepted before, if not it will trigger the native permission UI.\n   *\n   * Important: it must be called in the context of a UI click!\n   */\n  static listen = (observer: Observer<DescriptorEvent<HIDDevice>>): Subscription => {\n    let unsubscribed = false;\n    getFirstLedgerDevice().then(\n      device => {\n        if (!device) {\n          observer.error(new TransportOpenUserCancelled(\"Access denied to use Ledger device\"));\n        } else if (!unsubscribed) {\n          const deviceModel =\n            typeof device.productId === \"number\"\n              ? identifyUSBProductId(device.productId)\n              : undefined;\n          observer.next({\n            type: \"add\",\n            descriptor: device,\n            deviceModel,\n          });\n          observer.complete();\n        }\n      },\n      error => {\n        observer.error(new TransportOpenUserCancelled(error.message));\n      },\n    );\n\n    function unsubscribe() {\n      unsubscribed = true;\n    }\n\n    return {\n      unsubscribe,\n    };\n  };\n\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n  static async request() {\n    const [device] = await requestLedgerDevices();\n    return TransportWebHID.open(device);\n  }\n\n  /**\n   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n   */\n  static async openConnected() {\n    const devices = await getLedgerDevices();\n    if (devices.length === 0) return null;\n    return TransportWebHID.open(devices[0]);\n  }\n\n  /**\n   * Create a Ledger transport with a HIDDevice\n   */\n  static async open(device: HIDDevice) {\n    await device.open();\n    const transport = new TransportWebHID(device);\n\n    const onDisconnect = e => {\n      if (device === e.device) {\n        getHID().removeEventListener(\"disconnect\", onDisconnect);\n\n        transport._emitDisconnect(new DisconnectedDevice());\n      }\n    };\n\n    getHID().addEventListener(\"disconnect\", onDisconnect);\n    return transport;\n  }\n\n  _disconnectEmitted = false;\n  _emitDisconnect = (e: Error) => {\n    if (this._disconnectEmitted) return;\n    this._disconnectEmitted = true;\n    this.emit(\"disconnect\", e);\n  };\n\n  /**\n   * Release the transport device\n   */\n  async close(): Promise<void> {\n    await this.exchangeBusyPromise;\n    this.device.removeEventListener(\"inputreport\", this.onInputReport);\n    await this.device.close();\n  }\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  exchange = async (apdu: Buffer): Promise<Buffer> => {\n    const b = await this.exchangeAtomicImpl(async () => {\n      const { channel, packetSize } = this;\n      log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n      const framing = hidFraming(channel, packetSize);\n      // Write...\n      const blocks = framing.makeBlocks(apdu);\n\n      for (let i = 0; i < blocks.length; i++) {\n        await this.device.sendReport(0, blocks[i]);\n      }\n\n      // Read...\n      let result;\n      let acc;\n\n      while (!(result = framing.getReducedResult(acc))) {\n        try {\n          const buffer = await this.read();\n          acc = framing.reduceResponse(acc, buffer);\n        } catch (e) {\n          if (e instanceof TransportError && e.id === \"InvalidChannel\") {\n            // this can happen if the device is connected\n            // on a different channel (like another app)\n            // in this case we just filter out the event\n            continue;\n          }\n\n          throw e;\n        }\n      }\n\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    }).catch(e => {\n      if (e && e.message && e.message.includes(\"write\")) {\n        this._emitDisconnect(e);\n\n        throw new DisconnectedDeviceDuringOperation(e.message);\n      }\n\n      throw e;\n    });\n    return b as Buffer;\n  };\n\n  setScrambleKey() {}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}