{"ast":null,"code":"import { bigIntToBytes, bytesToHex, concatBytes, int32ToBytes, intToBytes, setLengthLeft, setLengthRight, toBytes } from './bytes.js';\n/**\n * @dev Returns the 31-bytes verkle tree stem for a given address and tree index.\n * @dev Assumes that the verkle node width = 256\n * @param ffi The verkle ffi object from verkle-crypotography-wasm.\n * @param address The address to generate the tree key for.\n * @param treeIndex The index of the tree to generate the key for. Defaults to 0.\n * @return The 31-bytes verkle tree stem as a Uint8Array.\n */\nexport function getVerkleStem(ffi, address, treeIndex = 0) {\n  const address32 = setLengthLeft(address.toBytes(), 32);\n  let treeIndexBytes;\n  if (typeof treeIndex === 'number') {\n    treeIndexBytes = setLengthRight(int32ToBytes(Number(treeIndex), true), 32);\n  } else {\n    treeIndexBytes = setLengthRight(bigIntToBytes(BigInt(treeIndex), true).slice(0, 32), 32);\n  }\n  const treeStem = ffi.getTreeKey(address32, treeIndexBytes, 0).slice(0, 31);\n  return treeStem;\n}\n/**\n * Verifies that the executionWitness is valid for the given prestateRoot.\n * @param ffi The verkle ffi object from verkle-crypotography-wasm.\n * @param prestateRoot The prestateRoot matching the executionWitness.\n * @param executionWitness The verkle execution witness.\n * @returns {boolean} Whether or not the executionWitness belongs to the prestateRoot.\n */\nexport function verifyVerkleProof(ffi, prestateRoot, executionWitness) {\n  return ffi.verifyExecutionWitnessPreState(bytesToHex(prestateRoot), JSON.stringify(executionWitness));\n}\nexport var VerkleLeafType;\n(function (VerkleLeafType) {\n  VerkleLeafType[VerkleLeafType[\"Version\"] = 0] = \"Version\";\n  VerkleLeafType[VerkleLeafType[\"Balance\"] = 1] = \"Balance\";\n  VerkleLeafType[VerkleLeafType[\"Nonce\"] = 2] = \"Nonce\";\n  VerkleLeafType[VerkleLeafType[\"CodeHash\"] = 3] = \"CodeHash\";\n  VerkleLeafType[VerkleLeafType[\"CodeSize\"] = 4] = \"CodeSize\";\n})(VerkleLeafType || (VerkleLeafType = {}));\nexport const VERKLE_VERSION_LEAF_KEY = intToBytes(VerkleLeafType.Version);\nexport const VERKLE_BALANCE_LEAF_KEY = intToBytes(VerkleLeafType.Balance);\nexport const VERKLE_NONCE_LEAF_KEY = intToBytes(VerkleLeafType.Nonce);\nexport const VERKLE_CODE_HASH_LEAF_KEY = intToBytes(VerkleLeafType.CodeHash);\nexport const VERKLE_CODE_SIZE_LEAF_KEY = intToBytes(VerkleLeafType.CodeSize);\nexport const VERKLE_HEADER_STORAGE_OFFSET = 64;\nexport const VERKLE_CODE_OFFSET = 128;\nexport const VERKLE_NODE_WIDTH = 256;\nexport const VERKLE_MAIN_STORAGE_OFFSET = BigInt(256) ** BigInt(31);\n/**\n * @dev Returns the tree key for a given verkle tree stem, and sub index.\n * @dev Assumes that the verkle node width = 256\n * @param stem The 31-bytes verkle tree stem as a Uint8Array.\n * @param subIndex The sub index of the tree to generate the key for as a Uint8Array.\n * @return The tree key as a Uint8Array.\n */\nexport const getVerkleKey = (stem, leaf) => {\n  switch (leaf) {\n    case VerkleLeafType.Version:\n      return concatBytes(stem, VERKLE_VERSION_LEAF_KEY);\n    case VerkleLeafType.Balance:\n      return concatBytes(stem, VERKLE_BALANCE_LEAF_KEY);\n    case VerkleLeafType.Nonce:\n      return concatBytes(stem, VERKLE_NONCE_LEAF_KEY);\n    case VerkleLeafType.CodeHash:\n      return concatBytes(stem, VERKLE_CODE_HASH_LEAF_KEY);\n    case VerkleLeafType.CodeSize:\n      return concatBytes(stem, VERKLE_CODE_SIZE_LEAF_KEY);\n    default:\n      return concatBytes(stem, leaf);\n  }\n};\nexport function getVerkleTreeIndexesForStorageSlot(storageKey) {\n  let position;\n  if (storageKey < VERKLE_CODE_OFFSET - VERKLE_HEADER_STORAGE_OFFSET) {\n    position = BigInt(VERKLE_HEADER_STORAGE_OFFSET) + storageKey;\n  } else {\n    position = VERKLE_MAIN_STORAGE_OFFSET + storageKey;\n  }\n  const treeIndex = position / BigInt(VERKLE_NODE_WIDTH);\n  const subIndex = Number(position % BigInt(VERKLE_NODE_WIDTH));\n  return {\n    treeIndex,\n    subIndex\n  };\n}\nexport function getVerkleTreeIndicesForCodeChunk(chunkId) {\n  const treeIndex = Math.floor((VERKLE_CODE_OFFSET + chunkId) / VERKLE_NODE_WIDTH);\n  const subIndex = (VERKLE_CODE_OFFSET + chunkId) % VERKLE_NODE_WIDTH;\n  return {\n    treeIndex,\n    subIndex\n  };\n}\nexport const getVerkleTreeKeyForCodeChunk = async (address, chunkId, verkleCrypto) => {\n  const {\n    treeIndex,\n    subIndex\n  } = getVerkleTreeIndicesForCodeChunk(chunkId);\n  return concatBytes(getVerkleStem(verkleCrypto, address, treeIndex), toBytes(subIndex));\n};\nexport const chunkifyCode = code => {\n  // Pad code to multiple of 31 bytes\n  if (code.length % 31 !== 0) {\n    const paddingLength = 31 - code.length % 31;\n    code = setLengthRight(code, code.length + paddingLength);\n  }\n  throw new Error('Not implemented');\n};\nexport const getVerkleTreeKeyForStorageSlot = async (address, storageKey, verkleCrypto) => {\n  const {\n    treeIndex,\n    subIndex\n  } = getVerkleTreeIndexesForStorageSlot(storageKey);\n  return concatBytes(getVerkleStem(verkleCrypto, address, treeIndex), toBytes(subIndex));\n};","map":{"version":3,"names":["bigIntToBytes","bytesToHex","concatBytes","int32ToBytes","intToBytes","setLengthLeft","setLengthRight","toBytes","getVerkleStem","ffi","address","treeIndex","address32","treeIndexBytes","Number","BigInt","slice","treeStem","getTreeKey","verifyVerkleProof","prestateRoot","executionWitness","verifyExecutionWitnessPreState","JSON","stringify","VerkleLeafType","VERKLE_VERSION_LEAF_KEY","Version","VERKLE_BALANCE_LEAF_KEY","Balance","VERKLE_NONCE_LEAF_KEY","Nonce","VERKLE_CODE_HASH_LEAF_KEY","CodeHash","VERKLE_CODE_SIZE_LEAF_KEY","CodeSize","VERKLE_HEADER_STORAGE_OFFSET","VERKLE_CODE_OFFSET","VERKLE_NODE_WIDTH","VERKLE_MAIN_STORAGE_OFFSET","getVerkleKey","stem","leaf","getVerkleTreeIndexesForStorageSlot","storageKey","position","subIndex","getVerkleTreeIndicesForCodeChunk","chunkId","Math","floor","getVerkleTreeKeyForCodeChunk","verkleCrypto","chunkifyCode","code","length","paddingLength","Error","getVerkleTreeKeyForStorageSlot"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@ethereumjs\\util\\src\\verkle.ts"],"sourcesContent":["import {\n  bigIntToBytes,\n  bytesToHex,\n  concatBytes,\n  int32ToBytes,\n  intToBytes,\n  setLengthLeft,\n  setLengthRight,\n  toBytes,\n} from './bytes.js'\n\nimport type { Address } from './address.js'\nimport type { PrefixedHexString } from './types.js'\n\n/**\n * Verkle related constants and helper functions\n *\n * Experimental (do not use in production!)\n */\n\n/* Verkle Crypto */\nexport interface VerkleCrypto {\n  getTreeKey: (address: Uint8Array, treeIndex: Uint8Array, subIndex: number) => Uint8Array\n  getTreeKeyHash: (address: Uint8Array, treeIndexLE: Uint8Array) => Uint8Array\n  updateCommitment: (\n    commitment: Uint8Array,\n    commitmentIndex: number,\n    oldScalarValue: Uint8Array,\n    newScalarValue: Uint8Array\n  ) => Uint8Array // Commitment\n  zeroCommitment: Uint8Array\n  verifyExecutionWitnessPreState: (prestateRoot: string, execution_witness_json: string) => boolean\n  hashCommitment: (commitment: Uint8Array) => Uint8Array\n  serializeCommitment: (commitment: Uint8Array) => Uint8Array\n}\n\n/**\n * @dev Returns the 31-bytes verkle tree stem for a given address and tree index.\n * @dev Assumes that the verkle node width = 256\n * @param ffi The verkle ffi object from verkle-crypotography-wasm.\n * @param address The address to generate the tree key for.\n * @param treeIndex The index of the tree to generate the key for. Defaults to 0.\n * @return The 31-bytes verkle tree stem as a Uint8Array.\n */\nexport function getVerkleStem(\n  ffi: VerkleCrypto,\n  address: Address,\n  treeIndex: number | bigint = 0\n): Uint8Array {\n  const address32 = setLengthLeft(address.toBytes(), 32)\n\n  let treeIndexBytes: Uint8Array\n  if (typeof treeIndex === 'number') {\n    treeIndexBytes = setLengthRight(int32ToBytes(Number(treeIndex), true), 32)\n  } else {\n    treeIndexBytes = setLengthRight(bigIntToBytes(BigInt(treeIndex), true).slice(0, 32), 32)\n  }\n\n  const treeStem = ffi.getTreeKey(address32, treeIndexBytes, 0).slice(0, 31)\n\n  return treeStem\n}\n\n/**\n * Verifies that the executionWitness is valid for the given prestateRoot.\n * @param ffi The verkle ffi object from verkle-crypotography-wasm.\n * @param prestateRoot The prestateRoot matching the executionWitness.\n * @param executionWitness The verkle execution witness.\n * @returns {boolean} Whether or not the executionWitness belongs to the prestateRoot.\n */\nexport function verifyVerkleProof(\n  ffi: VerkleCrypto,\n  prestateRoot: Uint8Array,\n  executionWitness: VerkleExecutionWitness\n): boolean {\n  return ffi.verifyExecutionWitnessPreState(\n    bytesToHex(prestateRoot),\n    JSON.stringify(executionWitness)\n  )\n}\n\n/* Verkle Structure */\n\nexport interface VerkleProof {\n  commitmentsByPath: PrefixedHexString[]\n  d: PrefixedHexString\n  depthExtensionPresent: PrefixedHexString\n  ipaProof: {\n    cl: PrefixedHexString[]\n    cr: PrefixedHexString[]\n    finalEvaluation: PrefixedHexString\n  }\n  otherStems: PrefixedHexString[]\n}\n\nexport interface VerkleStateDiff {\n  stem: PrefixedHexString\n  suffixDiffs: {\n    currentValue: PrefixedHexString | null\n    newValue: PrefixedHexString | null\n    suffix: number | string\n  }[]\n}\n\n/**\n * Experimental, object format could eventual change.\n * An object that provides the state and proof necessary for verkle stateless execution\n * */\nexport interface VerkleExecutionWitness {\n  /**\n   * An array of state diffs.\n   * Each item corresponding to state accesses or state modifications of the block.\n   * In the current design, it also contains the resulting state of the block execution (post-state).\n   */\n  stateDiff: VerkleStateDiff[]\n  /**\n   * The verkle proof for the block.\n   * Proves that the provided stateDiff belongs to the canonical verkle tree.\n   */\n  verkleProof: VerkleProof\n}\n\nexport enum VerkleLeafType {\n  Version = 0,\n  Balance = 1,\n  Nonce = 2,\n  CodeHash = 3,\n  CodeSize = 4,\n}\n\nexport const VERKLE_VERSION_LEAF_KEY = intToBytes(VerkleLeafType.Version)\nexport const VERKLE_BALANCE_LEAF_KEY = intToBytes(VerkleLeafType.Balance)\nexport const VERKLE_NONCE_LEAF_KEY = intToBytes(VerkleLeafType.Nonce)\nexport const VERKLE_CODE_HASH_LEAF_KEY = intToBytes(VerkleLeafType.CodeHash)\nexport const VERKLE_CODE_SIZE_LEAF_KEY = intToBytes(VerkleLeafType.CodeSize)\n\nexport const VERKLE_HEADER_STORAGE_OFFSET = 64\nexport const VERKLE_CODE_OFFSET = 128\nexport const VERKLE_NODE_WIDTH = 256\nexport const VERKLE_MAIN_STORAGE_OFFSET = BigInt(256) ** BigInt(31)\n\n/**\n * @dev Returns the tree key for a given verkle tree stem, and sub index.\n * @dev Assumes that the verkle node width = 256\n * @param stem The 31-bytes verkle tree stem as a Uint8Array.\n * @param subIndex The sub index of the tree to generate the key for as a Uint8Array.\n * @return The tree key as a Uint8Array.\n */\n\nexport const getVerkleKey = (stem: Uint8Array, leaf: VerkleLeafType | Uint8Array) => {\n  switch (leaf) {\n    case VerkleLeafType.Version:\n      return concatBytes(stem, VERKLE_VERSION_LEAF_KEY)\n    case VerkleLeafType.Balance:\n      return concatBytes(stem, VERKLE_BALANCE_LEAF_KEY)\n    case VerkleLeafType.Nonce:\n      return concatBytes(stem, VERKLE_NONCE_LEAF_KEY)\n    case VerkleLeafType.CodeHash:\n      return concatBytes(stem, VERKLE_CODE_HASH_LEAF_KEY)\n    case VerkleLeafType.CodeSize:\n      return concatBytes(stem, VERKLE_CODE_SIZE_LEAF_KEY)\n    default:\n      return concatBytes(stem, leaf)\n  }\n}\n\nexport function getVerkleTreeIndexesForStorageSlot(storageKey: bigint): {\n  treeIndex: bigint\n  subIndex: number\n} {\n  let position: bigint\n  if (storageKey < VERKLE_CODE_OFFSET - VERKLE_HEADER_STORAGE_OFFSET) {\n    position = BigInt(VERKLE_HEADER_STORAGE_OFFSET) + storageKey\n  } else {\n    position = VERKLE_MAIN_STORAGE_OFFSET + storageKey\n  }\n\n  const treeIndex = position / BigInt(VERKLE_NODE_WIDTH)\n  const subIndex = Number(position % BigInt(VERKLE_NODE_WIDTH))\n\n  return { treeIndex, subIndex }\n}\n\nexport function getVerkleTreeIndicesForCodeChunk(chunkId: number) {\n  const treeIndex = Math.floor((VERKLE_CODE_OFFSET + chunkId) / VERKLE_NODE_WIDTH)\n  const subIndex = (VERKLE_CODE_OFFSET + chunkId) % VERKLE_NODE_WIDTH\n  return { treeIndex, subIndex }\n}\n\nexport const getVerkleTreeKeyForCodeChunk = async (\n  address: Address,\n  chunkId: number,\n  verkleCrypto: VerkleCrypto\n) => {\n  const { treeIndex, subIndex } = getVerkleTreeIndicesForCodeChunk(chunkId)\n  return concatBytes(getVerkleStem(verkleCrypto, address, treeIndex), toBytes(subIndex))\n}\n\nexport const chunkifyCode = (code: Uint8Array) => {\n  // Pad code to multiple of 31 bytes\n  if (code.length % 31 !== 0) {\n    const paddingLength = 31 - (code.length % 31)\n    code = setLengthRight(code, code.length + paddingLength)\n  }\n\n  throw new Error('Not implemented')\n}\n\nexport const getVerkleTreeKeyForStorageSlot = async (\n  address: Address,\n  storageKey: bigint,\n  verkleCrypto: VerkleCrypto\n) => {\n  const { treeIndex, subIndex } = getVerkleTreeIndexesForStorageSlot(storageKey)\n\n  return concatBytes(getVerkleStem(verkleCrypto, address, treeIndex), toBytes(subIndex))\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}