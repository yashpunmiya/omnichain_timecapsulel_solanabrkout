{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\nvar bcUrRegistrySol = require('@keystonehq/bc-ur-registry-sol');\nvar sdk = require('@keystonehq/sdk');\nvar sdk__default = _interopDefault(sdk);\nvar bcUrRegistry = require('@keystonehq/bc-ur-registry');\nvar bs58 = _interopDefault(require('bs58'));\nvar uuid = require('uuid');\nvar web3_js = require('@solana/web3.js');\nclass DefaultInteractionProvider {\n  constructor() {\n    this.keystoneSDK = undefined;\n    this.readCryptoMultiAccounts = async () => {\n      const decodedResult = await this.keystoneSDK.read([sdk.SupportedResult.UR_CRYPTO_MULTI_ACCOUNTS], {\n        title: \"Sync Keystone\",\n        description: \"Please scan the QR code displayed on your Keystone\",\n        renderInitial: {\n          walletMode: \"Solflare\",\n          link: \"https://keyst.one/defi\"\n        },\n        URTypeErrorMessage: \"The scanned QR code is not the sync code from the Keystone hardware wallet. Please verify the code and try again\"\n      });\n      if (decodedResult.status === sdk.ReadStatus.success) {\n        const {\n          result\n        } = decodedResult;\n        return bcUrRegistry.CryptoMultiAccounts.fromCBOR(result.cbor);\n      } else {\n        throw new Error(\"Reading canceled\");\n      }\n    };\n    this.requestSignature = async (solSignRequest, requestTitle, requestDescription) => {\n      const status = await this.keystoneSDK.play(solSignRequest.toUR(), {\n        hasNext: true,\n        title: requestTitle,\n        description: requestDescription,\n        maxFragmentLength: 400\n      });\n      if (status === sdk.PlayStatus.canceled) throw new Error(\"#ktek_error[play-cancel]: play canceled\");\n      const result = await this.keystoneSDK.read([sdk.SupportedResult.UR_SOL_SIGNATURE], {\n        title: \"Scan Keystone\",\n        description: \"Please scan the QR code displayed on your Keystone\"\n      });\n      if (result.status === sdk.ReadStatus.canceled) {\n        throw new Error(\"#ktek_error[read-cancel]: read signature canceled\");\n      } else {\n        return bcUrRegistrySol.SolSignature.fromCBOR(result.result.cbor);\n      }\n    };\n    if (DefaultInteractionProvider.instance) {\n      return DefaultInteractionProvider.instance;\n    }\n    sdk__default.bootstrap();\n    this.keystoneSDK = sdk__default.getSdk();\n    DefaultInteractionProvider.instance = this;\n  }\n}\nconst keyringType = \"QR Hardware Wallet Device\";\nclass BaseKeyring {\n  constructor() {\n    this.getInteraction = () => {\n      throw new Error(\"KeystoneError#invalid_extends: method getInteraction not implemented, please extend BaseKeyring by overwriting this method.\");\n    };\n    this.type = keyringType;\n    this.requestSignature = async (_requestId, signRequest, requestTitle, requestDescription) => {\n      const solSignature = await this.getInteraction().requestSignature(signRequest, requestTitle, requestDescription);\n      const requestIdBuffer = solSignature.getRequestId();\n      const signature = solSignature.getSignature();\n      if (requestIdBuffer) {\n        const requestId = uuid.stringify(requestIdBuffer);\n        if (requestId !== _requestId) {\n          throw new Error(\"KeystoneError#invalid_data: read signature error: mismatched requestId\");\n        }\n      }\n      return signature;\n    };\n    this.getName = () => {\n      return this.name;\n    };\n    //common props\n    this.keys = [];\n    this.name = \"QR Hardware\";\n    this.initialized = false;\n    this.device = \"\";\n    this.xfp = \"\";\n  }\n  //initial read\n  async readKeyring() {\n    const result = await this.getInteraction().readCryptoMultiAccounts();\n    this.syncKeyring(result);\n  }\n  syncKeyring(data) {\n    var _data$getKeys$0$getOr;\n    const keys = data.getKeys();\n    this.device = data.getDevice();\n    this.xfp = (_data$getKeys$0$getOr = data.getKeys()[0].getOrigin().getSourceFingerprint()) === null || _data$getKeys$0$getOr === void 0 ? void 0 : _data$getKeys$0$getOr.toString(\"hex\");\n    this.name = data.getKeys()[0].getName();\n    this.keys = keys.map((each, index) => ({\n      hdPath: each.getOrigin().getPath(),\n      pubKey: bs58.encode(each.getKey()),\n      index\n    }));\n    this.initialized = true;\n  }\n  syncKeyringData({\n    xfp,\n    keys,\n    name = \"QR Hardware\",\n    device\n  }) {\n    this.xfp = xfp;\n    this.name = name;\n    this.keys = keys;\n    this.device = device;\n    this.initialized = true;\n  }\n  getAccounts() {\n    if (!this.initialized) {\n      return [];\n    }\n    return this.keys;\n  }\n  async signTransaction(pubKey, txHex) {\n    const signature = await this._getSignature(pubKey, Buffer.from(txHex), bcUrRegistrySol.SignType.Transaction);\n    return signature;\n  }\n  async signMessage(pubKey, messageHex) {\n    return await this._getSignature(pubKey, Buffer.from(messageHex), bcUrRegistrySol.SignType.Message);\n  }\n  async createSignature(pubKey, messageHex) {\n    try {\n      const messageInstance = web3_js.Message.from(messageHex);\n      const transaction = web3_js.Transaction.populate(messageInstance, []);\n      if (transaction) {\n        return this._getSignature(pubKey, Buffer.from(messageHex), bcUrRegistrySol.SignType.Transaction);\n      }\n    } catch (e) {\n      console.error(e);\n    }\n    return this.signMessage(pubKey, messageHex);\n  }\n  async _getSignature(pubKey, messageHex, signType) {\n    const requestId = uuid.v4();\n    const account = this.getAccounts().find(account => account.pubKey == pubKey);\n    const solSignRequest = bcUrRegistrySol.SolSignRequest.constructSOLRequest(messageHex, account.hdPath, this.xfp, signType, requestId);\n    return this.requestSignature(requestId, solSignRequest, \"Scan with your Keystone\", 'After your Keystone has signed this message, click on \"Scan Keystone\" to receive the signature');\n  }\n}\nBaseKeyring.type = keyringType;\nclass DefaultKeyring extends BaseKeyring {\n  constructor() {\n    super();\n    this.getInteraction = () => {\n      return new DefaultInteractionProvider();\n    };\n  }\n  static getEmptyKeyring() {\n    return new DefaultKeyring();\n  }\n}\nDefaultKeyring.type = BaseKeyring.type;\nexports.BaseKeyring = BaseKeyring;\nexports.DefaultKeyring = DefaultKeyring;\n//# sourceMappingURL=sol-keyring.cjs.development.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}