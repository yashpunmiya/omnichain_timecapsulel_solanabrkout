{"ast":null,"code":"import { isHex } from '../data/isHex.js';\nimport { size } from '../data/size.js';\nimport { hexToBigInt, hexToNumber } from '../encoding/fromHex.js';\nimport { toHex } from '../encoding/toHex.js';\nexport async function recoverPublicKey({\n  hash,\n  signature\n}) {\n  const hashHex = isHex(hash) ? hash : toHex(hash);\n  const {\n    secp256k1\n  } = await import('@noble/curves/secp256k1');\n  const signature_ = (() => {\n    // typeof signature: `Signature`\n    if (typeof signature === 'object' && 'r' in signature && 's' in signature) {\n      const {\n        r,\n        s,\n        v,\n        yParity\n      } = signature;\n      const yParityOrV = Number(yParity ?? v);\n      const recoveryBit = toRecoveryBit(yParityOrV);\n      return new secp256k1.Signature(hexToBigInt(r), hexToBigInt(s)).addRecoveryBit(recoveryBit);\n    }\n    // typeof signature: `Hex | ByteArray`\n    const signatureHex = isHex(signature) ? signature : toHex(signature);\n    if (size(signatureHex) !== 65) throw new Error('invalid signature length');\n    const yParityOrV = hexToNumber(`0x${signatureHex.slice(130)}`);\n    const recoveryBit = toRecoveryBit(yParityOrV);\n    return secp256k1.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(recoveryBit);\n  })();\n  const publicKey = signature_.recoverPublicKey(hashHex.substring(2)).toHex(false);\n  return `0x${publicKey}`;\n}\nfunction toRecoveryBit(yParityOrV) {\n  if (yParityOrV === 0 || yParityOrV === 1) return yParityOrV;\n  if (yParityOrV === 27) return 0;\n  if (yParityOrV === 28) return 1;\n  throw new Error('Invalid yParityOrV value');\n}","map":{"version":3,"names":["isHex","size","hexToBigInt","hexToNumber","toHex","recoverPublicKey","hash","signature","hashHex","secp256k1","signature_","r","s","v","yParity","yParityOrV","Number","recoveryBit","toRecoveryBit","Signature","addRecoveryBit","signatureHex","Error","slice","fromCompact","substring","publicKey"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\viem\\utils\\signature\\recoverPublicKey.ts"],"sourcesContent":["import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex, Signature } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { size } from '../data/size.js'\nimport {\n  type HexToNumberErrorType,\n  hexToBigInt,\n  hexToNumber,\n} from '../encoding/fromHex.js'\nimport { toHex } from '../encoding/toHex.js'\n\nexport type RecoverPublicKeyParameters = {\n  hash: Hex | ByteArray\n  signature: Hex | ByteArray | Signature\n}\n\nexport type RecoverPublicKeyReturnType = Hex\n\nexport type RecoverPublicKeyErrorType =\n  | HexToNumberErrorType\n  | IsHexErrorType\n  | ErrorType\n\nexport async function recoverPublicKey({\n  hash,\n  signature,\n}: RecoverPublicKeyParameters): Promise<RecoverPublicKeyReturnType> {\n  const hashHex = isHex(hash) ? hash : toHex(hash)\n\n  const { secp256k1 } = await import('@noble/curves/secp256k1')\n  const signature_ = (() => {\n    // typeof signature: `Signature`\n    if (typeof signature === 'object' && 'r' in signature && 's' in signature) {\n      const { r, s, v, yParity } = signature\n      const yParityOrV = Number(yParity ?? v)!\n      const recoveryBit = toRecoveryBit(yParityOrV)\n      return new secp256k1.Signature(\n        hexToBigInt(r),\n        hexToBigInt(s),\n      ).addRecoveryBit(recoveryBit)\n    }\n\n    // typeof signature: `Hex | ByteArray`\n    const signatureHex = isHex(signature) ? signature : toHex(signature)\n    if (size(signatureHex) !== 65) throw new Error('invalid signature length')\n    const yParityOrV = hexToNumber(`0x${signatureHex.slice(130)}`)\n    const recoveryBit = toRecoveryBit(yParityOrV)\n    return secp256k1.Signature.fromCompact(\n      signatureHex.substring(2, 130),\n    ).addRecoveryBit(recoveryBit)\n  })()\n\n  const publicKey = signature_\n    .recoverPublicKey(hashHex.substring(2))\n    .toHex(false)\n  return `0x${publicKey}`\n}\n\nfunction toRecoveryBit(yParityOrV: number) {\n  if (yParityOrV === 0 || yParityOrV === 1) return yParityOrV\n  if (yParityOrV === 27) return 0\n  if (yParityOrV === 28) return 1\n  throw new Error('Invalid yParityOrV value')\n}\n"],"mappings":"AAEA,SAA8BA,KAAK,QAAQ,kBAAkB;AAC7D,SAASC,IAAI,QAAQ,iBAAiB;AACtC,SAEEC,WAAW,EACXC,WAAW,QACN,wBAAwB;AAC/B,SAASC,KAAK,QAAQ,sBAAsB;AAc5C,OAAO,eAAeC,gBAAgBA,CAAC;EACrCC,IAAI;EACJC;AAAS,CACkB;EAC3B,MAAMC,OAAO,GAAGR,KAAK,CAACM,IAAI,CAAC,GAAGA,IAAI,GAAGF,KAAK,CAACE,IAAI,CAAC;EAEhD,MAAM;IAAEG;EAAS,CAAE,GAAG,MAAM,MAAM,CAAC,yBAAyB,CAAC;EAC7D,MAAMC,UAAU,GAAG,CAAC,MAAK;IACvB;IACA,IAAI,OAAOH,SAAS,KAAK,QAAQ,IAAI,GAAG,IAAIA,SAAS,IAAI,GAAG,IAAIA,SAAS,EAAE;MACzE,MAAM;QAAEI,CAAC;QAAEC,CAAC;QAAEC,CAAC;QAAEC;MAAO,CAAE,GAAGP,SAAS;MACtC,MAAMQ,UAAU,GAAGC,MAAM,CAACF,OAAO,IAAID,CAAC,CAAE;MACxC,MAAMI,WAAW,GAAGC,aAAa,CAACH,UAAU,CAAC;MAC7C,OAAO,IAAIN,SAAS,CAACU,SAAS,CAC5BjB,WAAW,CAACS,CAAC,CAAC,EACdT,WAAW,CAACU,CAAC,CAAC,CACf,CAACQ,cAAc,CAACH,WAAW,CAAC;IAC/B;IAEA;IACA,MAAMI,YAAY,GAAGrB,KAAK,CAACO,SAAS,CAAC,GAAGA,SAAS,GAAGH,KAAK,CAACG,SAAS,CAAC;IACpE,IAAIN,IAAI,CAACoB,YAAY,CAAC,KAAK,EAAE,EAAE,MAAM,IAAIC,KAAK,CAAC,0BAA0B,CAAC;IAC1E,MAAMP,UAAU,GAAGZ,WAAW,CAAC,KAAKkB,YAAY,CAACE,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC;IAC9D,MAAMN,WAAW,GAAGC,aAAa,CAACH,UAAU,CAAC;IAC7C,OAAON,SAAS,CAACU,SAAS,CAACK,WAAW,CACpCH,YAAY,CAACI,SAAS,CAAC,CAAC,EAAE,GAAG,CAAC,CAC/B,CAACL,cAAc,CAACH,WAAW,CAAC;EAC/B,CAAC,EAAC,CAAE;EAEJ,MAAMS,SAAS,GAAGhB,UAAU,CACzBL,gBAAgB,CAACG,OAAO,CAACiB,SAAS,CAAC,CAAC,CAAC,CAAC,CACtCrB,KAAK,CAAC,KAAK,CAAC;EACf,OAAO,KAAKsB,SAAS,EAAE;AACzB;AAEA,SAASR,aAAaA,CAACH,UAAkB;EACvC,IAAIA,UAAU,KAAK,CAAC,IAAIA,UAAU,KAAK,CAAC,EAAE,OAAOA,UAAU;EAC3D,IAAIA,UAAU,KAAK,EAAE,EAAE,OAAO,CAAC;EAC/B,IAAIA,UAAU,KAAK,EAAE,EAAE,OAAO,CAAC;EAC/B,MAAM,IAAIO,KAAK,CAAC,0BAA0B,CAAC;AAC7C","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}