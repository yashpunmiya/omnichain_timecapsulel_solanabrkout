{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PopupManager = void 0;\nconst tslib_1 = require(\"tslib\");\nconst events_1 = tslib_1.__importDefault(require(\"events\"));\nconst version_1 = require(\"@trezor/connect/lib/data/version\");\nconst events_2 = require(\"@trezor/connect/lib/events\");\nconst urlUtils_1 = require(\"@trezor/connect/lib/utils/urlUtils\");\nconst utils_1 = require(\"@trezor/utils\");\nconst showPopupRequest_1 = require(\"./showPopupRequest\");\nconst serviceworker_window_1 = require(\"../channels/serviceworker-window\");\nconst window_window_1 = require(\"../channels/window-window\");\nconst checkIfTabExists = tabId => new Promise(resolve => {\n  if (!tabId) return resolve(false);\n  function callback() {\n    if (chrome.runtime.lastError) {\n      resolve(false);\n    } else {\n      resolve(true);\n    }\n  }\n  chrome.tabs.get(tabId, callback);\n});\nconst POPUP_REQUEST_TIMEOUT = 850;\nconst POPUP_CLOSE_INTERVAL = 500;\nconst POPUP_OPEN_TIMEOUT = 5000;\nclass PopupManager extends events_1.default {\n  popupWindow;\n  settings;\n  origin;\n  locked = false;\n  channel;\n  channelIframe;\n  handshakePromise;\n  iframeHandshakePromise;\n  popupPromise;\n  requestTimeout;\n  openTimeout;\n  closeInterval;\n  extensionTabId = 0;\n  logger;\n  constructor(settings, {\n    logger\n  }) {\n    super();\n    this.settings = settings;\n    this.origin = (0, urlUtils_1.getOrigin)(settings.popupSrc);\n    this.logger = logger;\n    if (this.isWebExtensionWithTab()) {\n      this.channel = new serviceworker_window_1.ServiceWorkerWindowChannel({\n        name: 'trezor-connect',\n        channel: {\n          here: '@trezor/connect-webextension',\n          peer: '@trezor/connect-content-script'\n        },\n        logger,\n        currentId: () => {\n          if (this.popupWindow?.mode === 'tab') return this.popupWindow?.tab.id;\n        },\n        legacyMode: !this.settings.useCoreInPopup\n      });\n    } else {\n      this.channel = new window_window_1.WindowWindowChannel({\n        windowHere: window,\n        windowPeer: () => {\n          if (this.popupWindow?.mode === 'window') return this.popupWindow?.window;\n        },\n        channel: {\n          here: '@trezor/connect-web',\n          peer: '@trezor/connect-popup'\n        },\n        logger,\n        origin: this.origin,\n        legacyMode: !this.settings.useCoreInPopup\n      });\n    }\n    if (!this.settings.useCoreInPopup) {\n      this.iframeHandshakePromise = (0, utils_1.createDeferred)(events_2.IFRAME.LOADED);\n      this.channelIframe = new window_window_1.WindowWindowChannel({\n        windowHere: window,\n        windowPeer: () => window,\n        channel: {\n          here: '@trezor/connect-web',\n          peer: '@trezor/connect-iframe'\n        },\n        logger,\n        origin: this.origin\n      });\n      this.channelIframe?.on('message', this.handleMessage.bind(this));\n    }\n    if (this.settings.useCoreInPopup) {\n      this.handshakePromise = (0, utils_1.createDeferred)();\n      this.channel.on('message', this.handleCoreMessage.bind(this));\n      return;\n    } else if (this.isWebExtensionWithTab()) {\n      this.channel.on('message', this.handleExtensionMessage.bind(this));\n    } else {\n      this.channel.on('message', this.handleMessage.bind(this));\n    }\n    this.channel.init();\n  }\n  async request() {\n    if (this.settings.useCoreInPopup && this.popupWindow?.mode === 'tab') {\n      const currentPopupExists = await checkIfTabExists(this.popupWindow?.tab?.id);\n      if (!currentPopupExists) {\n        this.clear();\n      }\n    }\n    if (this.locked) {\n      if (this.popupWindow?.mode === 'tab' && this.popupWindow.tab.id) {\n        chrome.tabs.update(this.popupWindow.tab.id, {\n          active: true\n        });\n      } else if (this.popupWindow?.mode === 'window') {\n        this.popupWindow.window.focus();\n      }\n      return;\n    }\n    if (this.popupWindow && !this.locked) {\n      this.close();\n    }\n    const openFn = this.open.bind(this);\n    this.locked = true;\n    const timeout = this.settings.env === 'webextension' ? 1 : POPUP_REQUEST_TIMEOUT;\n    this.requestTimeout = setTimeout(() => {\n      this.requestTimeout = undefined;\n      openFn();\n    }, timeout);\n  }\n  unlock() {\n    this.locked = false;\n  }\n  open() {\n    const src = this.settings.popupSrc;\n    this.popupPromise = (0, utils_1.createDeferred)(events_2.POPUP.LOADED);\n    const url = this.buildPopupUrl(src);\n    this.openWrapper(url);\n    this.closeInterval = setInterval(() => {\n      if (!this.popupWindow) return;\n      if (this.popupWindow.mode === 'tab' && this.popupWindow.tab.id) {\n        chrome.tabs.get(this.popupWindow.tab.id, tab => {\n          if (!tab) {\n            this.emitClosed();\n            this.clear();\n          }\n        });\n      } else if (this.popupWindow.mode === 'window' && this.popupWindow.window.closed) {\n        this.clear();\n        this.emitClosed();\n      }\n    }, POPUP_CLOSE_INTERVAL);\n    if (this.settings.useCoreInPopup) {\n      return;\n    }\n    this.openTimeout = setTimeout(() => {\n      this.clear();\n      (0, showPopupRequest_1.showPopupRequest)(this.open.bind(this), () => {\n        this.emitClosed();\n      });\n    }, POPUP_OPEN_TIMEOUT);\n  }\n  buildPopupUrl(src) {\n    const params = new URLSearchParams();\n    params.set('version', version_1.VERSION);\n    params.set('env', this.settings.env);\n    if (this.settings.env === 'webextension' && chrome?.runtime?.id) {\n      params.set('extension-id', chrome.runtime.id);\n      params.set('cs-ver', version_1.CONTENT_SCRIPT_VERSION.toString());\n    }\n    return src + '?' + params.toString();\n  }\n  openWrapper(url) {\n    if (this.isWebExtensionWithTab()) {\n      chrome.windows.getCurrent(currentWindow => {\n        this.logger.debug('opening popup. currentWindow: ', currentWindow);\n        if (currentWindow.type !== 'normal') {\n          chrome.windows.create({\n            url\n          }, newWindow => {\n            chrome.tabs.query({\n              windowId: newWindow?.id,\n              active: true\n            }, tabs => {\n              this.popupWindow = {\n                mode: 'tab',\n                tab: tabs[0]\n              };\n              this.injectContentScript(tabs[0].id);\n            });\n          });\n        } else {\n          chrome.tabs.query({\n            currentWindow: true,\n            active: true\n          }, tabs => {\n            this.extensionTabId = tabs[0].id;\n            chrome.tabs.create({\n              url,\n              index: tabs[0].index + 1\n            }, tab => {\n              this.popupWindow = {\n                mode: 'tab',\n                tab\n              };\n              this.injectContentScript(tab.id);\n            });\n          });\n        }\n      });\n    } else {\n      const windowResult = window.open(url, 'modal');\n      if (!windowResult) return;\n      this.popupWindow = {\n        mode: 'window',\n        window: windowResult\n      };\n    }\n    if (!this.channel.isConnected) {\n      this.channel.connect();\n    }\n  }\n  injectContentScript = tabId => {\n    chrome.permissions.getAll(permissions => {\n      if (permissions.permissions?.includes('scripting')) {\n        (0, utils_1.scheduleAction)(() => chrome.scripting.executeScript({\n          target: {\n            tabId\n          },\n          func: () => {}\n        }).then(() => {\n          this.logger.debug('content script injected');\n        }).catch(error => {\n          this.logger.error('content script injection error', error);\n          throw error;\n        }), {\n          attempts: new Array(3).fill({\n            timeout: 100\n          })\n        });\n      } else {}\n    });\n  };\n  handleCoreMessage(message) {\n    if (message.type === events_2.POPUP.BOOTSTRAP) {\n      this.channel.init();\n    } else if (message.type === events_2.POPUP.LOADED) {\n      this.handleMessage(message);\n      this.channel.postMessage({\n        type: events_2.POPUP.INIT,\n        payload: {\n          settings: this.settings,\n          useCore: true\n        }\n      });\n    } else if (message.type === events_2.POPUP.CORE_LOADED) {\n      this.channel.postMessage({\n        type: events_2.POPUP.HANDSHAKE,\n        payload: {\n          settings: this.settings\n        }\n      });\n      this.handshakePromise?.resolve();\n    } else if (message.type === events_2.POPUP.CLOSED) {\n      this.emitClosed();\n    } else if (message.type === events_2.POPUP.CONTENT_SCRIPT_LOADED) {\n      const {\n        contentScriptVersion\n      } = message.payload;\n      if (contentScriptVersion !== version_1.CONTENT_SCRIPT_VERSION) {\n        console.warn(`Content script version mismatch. Expected ${version_1.CONTENT_SCRIPT_VERSION}, got ${contentScriptVersion}`);\n      }\n    } else if (message.event === events_2.DEVICE_EVENT) {\n      this.emit(events_2.DEVICE_EVENT, message);\n    }\n  }\n  handleExtensionMessage(data) {\n    if (data.type === events_2.POPUP.ERROR || data.type === events_2.POPUP.LOADED || data.type === events_2.POPUP.BOOTSTRAP) {\n      this.handleMessage(data);\n    } else if (data.type === events_2.POPUP.EXTENSION_USB_PERMISSIONS) {\n      chrome.tabs.query({\n        currentWindow: true,\n        active: true\n      }, tabs => {\n        chrome.tabs.create({\n          url: 'trezor-usb-permissions.html',\n          index: tabs[0].index + 1\n        }, _tab => {});\n      });\n    } else if (data.type === events_2.POPUP.CLOSE_WINDOW) {\n      this.clear();\n    }\n  }\n  handleMessage(data) {\n    if (data.type === events_2.IFRAME.LOADED) {\n      this.iframeHandshakePromise?.resolve(data.payload);\n    } else if (data.type === events_2.POPUP.BOOTSTRAP) {\n      if (this.openTimeout) clearTimeout(this.openTimeout);\n    } else if (data.type === events_2.POPUP.ERROR && this.popupWindow) {\n      const errorMessage = data.payload && typeof data.payload.error === 'string' ? data.payload.error : null;\n      this.emit(events_2.POPUP.CLOSED, errorMessage ? `Popup error: ${errorMessage}` : null);\n      this.clear();\n    } else if (data.type === events_2.POPUP.LOADED) {\n      if (this.openTimeout) clearTimeout(this.openTimeout);\n      if (this.popupPromise) {\n        this.popupPromise.resolve();\n        this.popupPromise = undefined;\n      }\n      this.iframeHandshakePromise?.promise.then(payload => {\n        this.channel.postMessage({\n          type: events_2.POPUP.INIT,\n          payload: {\n            ...payload,\n            settings: this.settings\n          }\n        });\n      });\n    } else if (data.type === events_2.POPUP.CANCEL_POPUP_REQUEST) {\n      clearTimeout(this.requestTimeout);\n      if (this.popupPromise) {\n        this.close();\n      }\n      this.unlock();\n    } else if (data.type === events_2.UI.CLOSE_UI_WINDOW) {\n      this.clear(false);\n    }\n  }\n  clear(focus = true) {\n    this.locked = false;\n    this.popupPromise = undefined;\n    this.handshakePromise = (0, utils_1.createDeferred)();\n    if (this.channel) {\n      this.channel.disconnect();\n    }\n    if (this.requestTimeout) {\n      clearTimeout(this.requestTimeout);\n      this.requestTimeout = undefined;\n    }\n    if (this.openTimeout) {\n      clearTimeout(this.openTimeout);\n      this.openTimeout = undefined;\n    }\n    if (this.closeInterval) {\n      clearInterval(this.closeInterval);\n      this.closeInterval = undefined;\n    }\n    if (focus && this.extensionTabId) {\n      chrome.tabs.update(this.extensionTabId, {\n        active: true\n      });\n      this.extensionTabId = 0;\n    }\n  }\n  close() {\n    if (!this.popupWindow) return;\n    this.logger.debug('closing popup');\n    if (this.popupWindow.mode === 'tab') {\n      let _e = chrome.runtime.lastError;\n      if (this.popupWindow.tab.id) {\n        chrome.tabs.remove(this.popupWindow.tab.id, () => {\n          _e = chrome.runtime.lastError;\n          if (_e) {\n            this.logger.error('closed with error', _e);\n          }\n        });\n      }\n    } else if (this.popupWindow.mode === 'window') {\n      this.popupWindow.window.close();\n    }\n    this.popupWindow = undefined;\n    if (this.settings?.useCoreInPopup) {\n      this.channel.clear();\n    }\n  }\n  async postMessage(message) {\n    if (!this.popupWindow && message.type !== events_2.UI.REQUEST_UI_WINDOW && this.openTimeout) {\n      this.clear();\n      (0, showPopupRequest_1.showPopupRequest)(this.open.bind(this), () => {\n        this.emitClosed();\n      });\n      return;\n    }\n    if (this.popupPromise) {\n      await this.popupPromise.promise;\n    }\n    if (this.popupWindow?.mode === 'window') {\n      this.popupWindow.window.postMessage(message, this.origin);\n    } else if (this.popupWindow?.mode === 'tab') {\n      this.channel.postMessage(message);\n    }\n  }\n  isWebExtensionWithTab() {\n    return this.settings?.env === 'webextension' && typeof chrome !== 'undefined' && typeof chrome?.tabs !== 'undefined';\n  }\n  emitClosed() {\n    if (this.settings?.useCoreInPopup) {\n      this.channel.resolveMessagePromises({\n        code: 'Method_Interrupted',\n        error: events_2.POPUP.CLOSED\n      });\n    }\n    this.emit(events_2.POPUP.CLOSED);\n  }\n}\nexports.PopupManager = PopupManager;\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}