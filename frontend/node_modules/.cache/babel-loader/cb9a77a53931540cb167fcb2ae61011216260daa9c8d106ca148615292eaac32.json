{"ast":null,"code":"import { isHex } from '../data/isHex.js';\nimport { hexToBigInt, hexToNumber } from '../encoding/fromHex.js';\nimport { toHex } from '../encoding/toHex.js';\nexport async function recoverPublicKey({\n  hash,\n  signature\n}) {\n  const hashHex = isHex(hash) ? hash : toHex(hash);\n  const {\n    secp256k1\n  } = await import('@noble/curves/secp256k1');\n  const signature_ = (() => {\n    // typeof signature: `Signature`\n    if (typeof signature === 'object' && 'r' in signature && 's' in signature) {\n      const {\n        r,\n        s,\n        v,\n        yParity\n      } = signature;\n      const yParityOrV = Number(yParity ?? v);\n      const recoveryBit = toRecoveryBit(yParityOrV);\n      return new secp256k1.Signature(hexToBigInt(r), hexToBigInt(s)).addRecoveryBit(recoveryBit);\n    }\n    // typeof signature: `Hex | ByteArray`\n    const signatureHex = isHex(signature) ? signature : toHex(signature);\n    const yParityOrV = hexToNumber(`0x${signatureHex.slice(130)}`);\n    const recoveryBit = toRecoveryBit(yParityOrV);\n    return secp256k1.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(recoveryBit);\n  })();\n  const publicKey = signature_.recoverPublicKey(hashHex.substring(2)).toHex(false);\n  return `0x${publicKey}`;\n}\nfunction toRecoveryBit(yParityOrV) {\n  if (yParityOrV === 0 || yParityOrV === 1) return yParityOrV;\n  if (yParityOrV === 27) return 0;\n  if (yParityOrV === 28) return 1;\n  throw new Error('Invalid yParityOrV value');\n}\n//# sourceMappingURL=recoverPublicKey.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}