{"ast":null,"code":"import { parseAccount } from '../../accounts/utils/parseAccount.js';\nimport { AccountNotFoundError, AccountTypeNotSupportedError } from '../../errors/account.js';\nimport { BaseError } from '../../errors/base.js';\nimport { recoverAuthorizationAddress } from '../../experimental/eip7702/utils/recoverAuthorizationAddress.js';\nimport { assertCurrentChain } from '../../utils/chain/assertCurrentChain.js';\nimport { getTransactionError } from '../../utils/errors/getTransactionError.js';\nimport { extract } from '../../utils/formatters/extract.js';\nimport { formatTransactionRequest } from '../../utils/formatters/transactionRequest.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { LruMap } from '../../utils/lru.js';\nimport { assertRequest } from '../../utils/transaction/assertRequest.js';\nimport { getChainId } from '../public/getChainId.js';\nimport { defaultParameters, prepareTransactionRequest } from './prepareTransactionRequest.js';\nimport { sendRawTransaction } from './sendRawTransaction.js';\nconst supportsWalletNamespace = new LruMap(128);\n/**\n * Creates, signs, and sends a new transaction to the network.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/sendTransaction\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_sending-transactions\n * - JSON-RPC Methods:\n *   - JSON-RPC Accounts: [`eth_sendTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendtransaction)\n *   - Local Accounts: [`eth_sendRawTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendrawtransaction)\n *\n * @param client - Client to use\n * @param parameters - {@link SendTransactionParameters}\n * @returns The [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash. {@link SendTransactionReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { sendTransaction } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const hash = await sendTransaction(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { sendTransaction } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0xâ€¦'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const hash = await sendTransaction(client, {\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n */\nexport async function sendTransaction(client, parameters) {\n  const {\n    account: account_ = client.account,\n    chain = client.chain,\n    accessList,\n    authorizationList,\n    blobs,\n    data,\n    gas,\n    gasPrice,\n    maxFeePerBlobGas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    value,\n    ...rest\n  } = parameters;\n  if (typeof account_ === 'undefined') throw new AccountNotFoundError({\n    docsPath: '/docs/actions/wallet/sendTransaction'\n  });\n  const account = account_ ? parseAccount(account_) : null;\n  try {\n    assertRequest(parameters);\n    const to = await (async () => {\n      // If `to` exists on the parameters, use that.\n      if (parameters.to) return parameters.to;\n      // If no `to` exists, and we are sending a EIP-7702 transaction, use the\n      // address of the first authorization in the list.\n      if (authorizationList && authorizationList.length > 0) return await recoverAuthorizationAddress({\n        authorization: authorizationList[0]\n      }).catch(() => {\n        throw new BaseError('`to` is required. Could not infer from `authorizationList`.');\n      });\n      // Otherwise, we are sending a deployment transaction.\n      return undefined;\n    })();\n    if (account?.type === 'json-rpc' || account === null) {\n      let chainId;\n      if (chain !== null) {\n        chainId = await getAction(client, getChainId, 'getChainId')({});\n        assertCurrentChain({\n          currentChainId: chainId,\n          chain\n        });\n      }\n      const chainFormat = client.chain?.formatters?.transactionRequest?.format;\n      const format = chainFormat || formatTransactionRequest;\n      const request = format({\n        // Pick out extra data that might exist on the chain's transaction request type.\n        ...extract(rest, {\n          format: chainFormat\n        }),\n        accessList,\n        authorizationList,\n        blobs,\n        chainId,\n        data,\n        from: account?.address,\n        gas,\n        gasPrice,\n        maxFeePerBlobGas,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        nonce,\n        to,\n        value\n      });\n      const isWalletNamespaceSupported = supportsWalletNamespace.get(client.uid);\n      const method = isWalletNamespaceSupported ? 'wallet_sendTransaction' : 'eth_sendTransaction';\n      try {\n        return await client.request({\n          method,\n          params: [request]\n        }, {\n          retryCount: 0\n        });\n      } catch (e) {\n        if (isWalletNamespaceSupported === false) throw e;\n        const error = e;\n        // If the transport does not support the method or input, attempt to use the\n        // `wallet_sendTransaction` method.\n        if (error.name === 'InvalidInputRpcError' || error.name === 'InvalidParamsRpcError' || error.name === 'MethodNotFoundRpcError' || error.name === 'MethodNotSupportedRpcError') {\n          return await client.request({\n            method: 'wallet_sendTransaction',\n            params: [request]\n          }, {\n            retryCount: 0\n          }).then(hash => {\n            supportsWalletNamespace.set(client.uid, true);\n            return hash;\n          }).catch(e => {\n            const walletNamespaceError = e;\n            if (walletNamespaceError.name === 'MethodNotFoundRpcError' || walletNamespaceError.name === 'MethodNotSupportedRpcError') {\n              supportsWalletNamespace.set(client.uid, false);\n              throw error;\n            }\n            throw walletNamespaceError;\n          });\n        }\n        throw error;\n      }\n    }\n    if (account?.type === 'local') {\n      // Prepare the request for signing (assign appropriate fees, etc.)\n      const request = await getAction(client, prepareTransactionRequest, 'prepareTransactionRequest')({\n        account,\n        accessList,\n        authorizationList,\n        blobs,\n        chain,\n        data,\n        gas,\n        gasPrice,\n        maxFeePerBlobGas,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        nonce,\n        nonceManager: account.nonceManager,\n        parameters: [...defaultParameters, 'sidecars'],\n        value,\n        ...rest,\n        to\n      });\n      const serializer = chain?.serializers?.transaction;\n      const serializedTransaction = await account.signTransaction(request, {\n        serializer\n      });\n      return await getAction(client, sendRawTransaction, 'sendRawTransaction')({\n        serializedTransaction\n      });\n    }\n    if (account?.type === 'smart') throw new AccountTypeNotSupportedError({\n      metaMessages: ['Consider using the `sendUserOperation` Action instead.'],\n      docsPath: '/docs/actions/bundler/sendUserOperation',\n      type: 'smart'\n    });\n    throw new AccountTypeNotSupportedError({\n      docsPath: '/docs/actions/wallet/sendTransaction',\n      type: account?.type\n    });\n  } catch (err) {\n    if (err instanceof AccountTypeNotSupportedError) throw err;\n    throw getTransactionError(err, {\n      ...parameters,\n      account,\n      chain: parameters.chain || undefined\n    });\n  }\n}\n//# sourceMappingURL=sendTransaction.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}