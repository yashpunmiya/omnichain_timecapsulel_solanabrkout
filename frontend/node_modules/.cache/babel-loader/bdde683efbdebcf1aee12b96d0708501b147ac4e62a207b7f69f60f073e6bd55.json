{"ast":null,"code":"import { AbiEncodingArrayLengthMismatchError, AbiEncodingBytesSizeMismatchError, AbiEncodingLengthMismatchError, InvalidAbiEncodingTypeError, InvalidArrayError } from '../../errors/abi.js';\nimport { InvalidAddressError } from '../../errors/address.js';\nimport { BaseError } from '../../errors/base.js';\nimport { IntegerOutOfRangeError } from '../../errors/encoding.js';\nimport { isAddress } from '../address/isAddress.js';\nimport { concat } from '../data/concat.js';\nimport { padHex } from '../data/pad.js';\nimport { size } from '../data/size.js';\nimport { slice } from '../data/slice.js';\nimport { boolToHex, numberToHex, stringToHex } from '../encoding/toHex.js';\nimport { integerRegex } from '../regex.js';\n/**\n * @description Encodes a list of primitive values into an ABI-encoded hex value.\n *\n * - Docs: https://viem.sh/docs/abi/encodeAbiParameters#encodeabiparameters\n *\n *   Generates ABI encoded data using the [ABI specification](https://docs.soliditylang.org/en/latest/abi-spec), given a set of ABI parameters (inputs/outputs) and their corresponding values.\n *\n * @param params - a set of ABI Parameters (params), that can be in the shape of the inputs or outputs attribute of an ABI Item.\n * @param values - a set of values (values) that correspond to the given params.\n * @example\n * ```typescript\n * import { encodeAbiParameters } from 'viem'\n *\n * const encodedData = encodeAbiParameters(\n *   [\n *     { name: 'x', type: 'string' },\n *     { name: 'y', type: 'uint' },\n *     { name: 'z', type: 'bool' }\n *   ],\n *   ['wagmi', 420n, true]\n * )\n * ```\n *\n * You can also pass in Human Readable parameters with the parseAbiParameters utility.\n *\n * @example\n * ```typescript\n * import { encodeAbiParameters, parseAbiParameters } from 'viem'\n *\n * const encodedData = encodeAbiParameters(\n *   parseAbiParameters('string x, uint y, bool z'),\n *   ['wagmi', 420n, true]\n * )\n * ```\n */\nexport function encodeAbiParameters(params, values) {\n  if (params.length !== values.length) throw new AbiEncodingLengthMismatchError({\n    expectedLength: params.length,\n    givenLength: values.length\n  });\n  // Prepare the parameters to determine dynamic types to encode.\n  const preparedParams = prepareParams({\n    params: params,\n    values: values\n  });\n  const data = encodeParams(preparedParams);\n  if (data.length === 0) return '0x';\n  return data;\n}\nfunction prepareParams({\n  params,\n  values\n}) {\n  const preparedParams = [];\n  for (let i = 0; i < params.length; i++) {\n    preparedParams.push(prepareParam({\n      param: params[i],\n      value: values[i]\n    }));\n  }\n  return preparedParams;\n}\nfunction prepareParam({\n  param,\n  value\n}) {\n  const arrayComponents = getArrayComponents(param.type);\n  if (arrayComponents) {\n    const [length, type] = arrayComponents;\n    return encodeArray(value, {\n      length,\n      param: {\n        ...param,\n        type\n      }\n    });\n  }\n  if (param.type === 'tuple') {\n    return encodeTuple(value, {\n      param: param\n    });\n  }\n  if (param.type === 'address') {\n    return encodeAddress(value);\n  }\n  if (param.type === 'bool') {\n    return encodeBool(value);\n  }\n  if (param.type.startsWith('uint') || param.type.startsWith('int')) {\n    const signed = param.type.startsWith('int');\n    const [,, size = '256'] = integerRegex.exec(param.type) ?? [];\n    return encodeNumber(value, {\n      signed,\n      size: Number(size)\n    });\n  }\n  if (param.type.startsWith('bytes')) {\n    return encodeBytes(value, {\n      param\n    });\n  }\n  if (param.type === 'string') {\n    return encodeString(value);\n  }\n  throw new InvalidAbiEncodingTypeError(param.type, {\n    docsPath: '/docs/contract/encodeAbiParameters'\n  });\n}\nfunction encodeParams(preparedParams) {\n  // 1. Compute the size of the static part of the parameters.\n  let staticSize = 0;\n  for (let i = 0; i < preparedParams.length; i++) {\n    const {\n      dynamic,\n      encoded\n    } = preparedParams[i];\n    if (dynamic) staticSize += 32;else staticSize += size(encoded);\n  }\n  // 2. Split the parameters into static and dynamic parts.\n  const staticParams = [];\n  const dynamicParams = [];\n  let dynamicSize = 0;\n  for (let i = 0; i < preparedParams.length; i++) {\n    const {\n      dynamic,\n      encoded\n    } = preparedParams[i];\n    if (dynamic) {\n      staticParams.push(numberToHex(staticSize + dynamicSize, {\n        size: 32\n      }));\n      dynamicParams.push(encoded);\n      dynamicSize += size(encoded);\n    } else {\n      staticParams.push(encoded);\n    }\n  }\n  // 3. Concatenate static and dynamic parts.\n  return concat([...staticParams, ...dynamicParams]);\n}\nfunction encodeAddress(value) {\n  if (!isAddress(value)) throw new InvalidAddressError({\n    address: value\n  });\n  return {\n    dynamic: false,\n    encoded: padHex(value.toLowerCase())\n  };\n}\nfunction encodeArray(value, {\n  length,\n  param\n}) {\n  const dynamic = length === null;\n  if (!Array.isArray(value)) throw new InvalidArrayError(value);\n  if (!dynamic && value.length !== length) throw new AbiEncodingArrayLengthMismatchError({\n    expectedLength: length,\n    givenLength: value.length,\n    type: `${param.type}[${length}]`\n  });\n  let dynamicChild = false;\n  const preparedParams = [];\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParam({\n      param,\n      value: value[i]\n    });\n    if (preparedParam.dynamic) dynamicChild = true;\n    preparedParams.push(preparedParam);\n  }\n  if (dynamic || dynamicChild) {\n    const data = encodeParams(preparedParams);\n    if (dynamic) {\n      const length = numberToHex(preparedParams.length, {\n        size: 32\n      });\n      return {\n        dynamic: true,\n        encoded: preparedParams.length > 0 ? concat([length, data]) : length\n      };\n    }\n    if (dynamicChild) return {\n      dynamic: true,\n      encoded: data\n    };\n  }\n  return {\n    dynamic: false,\n    encoded: concat(preparedParams.map(({\n      encoded\n    }) => encoded))\n  };\n}\nfunction encodeBytes(value, {\n  param\n}) {\n  const [, paramSize] = param.type.split('bytes');\n  const bytesSize = size(value);\n  if (!paramSize) {\n    let value_ = value;\n    // If the size is not divisible by 32 bytes, pad the end\n    // with empty bytes to the ceiling 32 bytes.\n    if (bytesSize % 32 !== 0) value_ = padHex(value_, {\n      dir: 'right',\n      size: Math.ceil((value.length - 2) / 2 / 32) * 32\n    });\n    return {\n      dynamic: true,\n      encoded: concat([padHex(numberToHex(bytesSize, {\n        size: 32\n      })), value_])\n    };\n  }\n  if (bytesSize !== Number.parseInt(paramSize)) throw new AbiEncodingBytesSizeMismatchError({\n    expectedSize: Number.parseInt(paramSize),\n    value\n  });\n  return {\n    dynamic: false,\n    encoded: padHex(value, {\n      dir: 'right'\n    })\n  };\n}\nfunction encodeBool(value) {\n  if (typeof value !== 'boolean') throw new BaseError(`Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`);\n  return {\n    dynamic: false,\n    encoded: padHex(boolToHex(value))\n  };\n}\nfunction encodeNumber(value, {\n  signed,\n  size = 256\n}) {\n  if (typeof size === 'number') {\n    const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n;\n    const min = signed ? -max - 1n : 0n;\n    if (value > max || value < min) throw new IntegerOutOfRangeError({\n      max: max.toString(),\n      min: min.toString(),\n      signed,\n      size: size / 8,\n      value: value.toString()\n    });\n  }\n  return {\n    dynamic: false,\n    encoded: numberToHex(value, {\n      size: 32,\n      signed\n    })\n  };\n}\nfunction encodeString(value) {\n  const hexValue = stringToHex(value);\n  const partsLength = Math.ceil(size(hexValue) / 32);\n  const parts = [];\n  for (let i = 0; i < partsLength; i++) {\n    parts.push(padHex(slice(hexValue, i * 32, (i + 1) * 32), {\n      dir: 'right'\n    }));\n  }\n  return {\n    dynamic: true,\n    encoded: concat([padHex(numberToHex(size(hexValue), {\n      size: 32\n    })), ...parts])\n  };\n}\nfunction encodeTuple(value, {\n  param\n}) {\n  let dynamic = false;\n  const preparedParams = [];\n  for (let i = 0; i < param.components.length; i++) {\n    const param_ = param.components[i];\n    const index = Array.isArray(value) ? i : param_.name;\n    const preparedParam = prepareParam({\n      param: param_,\n      value: value[index]\n    });\n    preparedParams.push(preparedParam);\n    if (preparedParam.dynamic) dynamic = true;\n  }\n  return {\n    dynamic,\n    encoded: dynamic ? encodeParams(preparedParams) : concat(preparedParams.map(({\n      encoded\n    }) => encoded))\n  };\n}\nexport function getArrayComponents(type) {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/);\n  return matches ?\n  // Return `null` if the array is dynamic.\n  [matches[2] ? Number(matches[2]) : null, matches[1]] : undefined;\n}\n//# sourceMappingURL=encodeAbiParameters.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}