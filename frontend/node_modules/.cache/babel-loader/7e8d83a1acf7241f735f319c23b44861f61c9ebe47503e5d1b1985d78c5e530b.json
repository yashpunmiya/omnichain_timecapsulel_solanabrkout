{"ast":null,"code":"import { createCursor } from '../cursor.js';\nimport { hexToBytes } from '../encoding/toBytes.js';\nimport { bytesToHex } from '../encoding/toHex.js';\nexport function fromBlobs(parameters) {\n  const to = parameters.to ?? (typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes');\n  const blobs = typeof parameters.blobs[0] === 'string' ? parameters.blobs.map(x => hexToBytes(x)) : parameters.blobs;\n  const length = blobs.reduce((length, blob) => length + blob.length, 0);\n  const data = createCursor(new Uint8Array(length));\n  let active = true;\n  for (const blob of blobs) {\n    const cursor = createCursor(blob);\n    while (active && cursor.position < blob.length) {\n      // First byte will be a zero 0x00 byte – we can skip.\n      cursor.incrementPosition(1);\n      let consume = 31;\n      if (blob.length - cursor.position < 31) consume = blob.length - cursor.position;\n      for (const _ in Array.from({\n        length: consume\n      })) {\n        const byte = cursor.readByte();\n        const isTerminator = byte === 0x80 && !cursor.inspectBytes(cursor.remaining).includes(0x80);\n        if (isTerminator) {\n          active = false;\n          break;\n        }\n        data.pushByte(byte);\n      }\n    }\n  }\n  const trimmedData = data.bytes.slice(0, data.position);\n  return to === 'hex' ? bytesToHex(trimmedData) : trimmedData;\n}","map":{"version":3,"names":["createCursor","hexToBytes","bytesToHex","fromBlobs","parameters","to","blobs","map","x","length","reduce","blob","data","Uint8Array","active","cursor","position","incrementPosition","consume","_","Array","from","byte","readByte","isTerminator","inspectBytes","remaining","includes","pushByte","trimmedData","bytes","slice"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@reown\\appkit-controllers\\node_modules\\@walletconnect\\utils\\node_modules\\viem\\utils\\blob\\fromBlobs.ts"],"sourcesContent":["import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type CreateCursorErrorType, createCursor } from '../cursor.js'\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type FromBlobsParameters<\n  blobs extends readonly Hex[] | readonly ByteArray[] =\n    | readonly Hex[]\n    | readonly ByteArray[],\n  to extends To | undefined = undefined,\n> = {\n  /** Blobs to transform to data. */\n  blobs: blobs | readonly Hex[] | readonly ByteArray[]\n  to?: to | To | undefined\n}\n\nexport type FromBlobsReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type FromBlobsErrorType =\n  | BytesToHexErrorType\n  | CreateCursorErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\nexport function fromBlobs<\n  const blobs extends readonly Hex[] | readonly ByteArray[],\n  to extends To =\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n>(parameters: FromBlobsParameters<blobs, to>): FromBlobsReturnType<to> {\n  const to =\n    parameters.to ?? (typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes')\n  const blobs = (\n    typeof parameters.blobs[0] === 'string'\n      ? parameters.blobs.map((x) => hexToBytes(x as Hex))\n      : parameters.blobs\n  ) as ByteArray[]\n\n  const length = blobs.reduce((length, blob) => length + blob.length, 0)\n  const data = createCursor(new Uint8Array(length))\n  let active = true\n\n  for (const blob of blobs) {\n    const cursor = createCursor(blob)\n    while (active && cursor.position < blob.length) {\n      // First byte will be a zero 0x00 byte – we can skip.\n      cursor.incrementPosition(1)\n\n      let consume = 31\n      if (blob.length - cursor.position < 31)\n        consume = blob.length - cursor.position\n\n      for (const _ in Array.from({ length: consume })) {\n        const byte = cursor.readByte()\n        const isTerminator =\n          byte === 0x80 && !cursor.inspectBytes(cursor.remaining).includes(0x80)\n        if (isTerminator) {\n          active = false\n          break\n        }\n        data.pushByte(byte)\n      }\n    }\n  }\n\n  const trimmedData = data.bytes.slice(0, data.position)\n  return (\n    to === 'hex' ? bytesToHex(trimmedData) : trimmedData\n  ) as FromBlobsReturnType<to>\n}\n"],"mappings":"AAEA,SAAqCA,YAAY,QAAQ,cAAc;AACvE,SAAmCC,UAAU,QAAQ,wBAAwB;AAC7E,SAAmCC,UAAU,QAAQ,sBAAsB;AAyB3E,OAAM,SAAUC,SAASA,CAKvBC,UAA0C;EAC1C,MAAMC,EAAE,GACND,UAAU,CAACC,EAAE,KAAK,OAAOD,UAAU,CAACE,KAAK,CAAC,CAAC,CAAC,KAAK,QAAQ,GAAG,KAAK,GAAG,OAAO,CAAC;EAC9E,MAAMA,KAAK,GACT,OAAOF,UAAU,CAACE,KAAK,CAAC,CAAC,CAAC,KAAK,QAAQ,GACnCF,UAAU,CAACE,KAAK,CAACC,GAAG,CAAEC,CAAC,IAAKP,UAAU,CAACO,CAAQ,CAAC,CAAC,GACjDJ,UAAU,CAACE,KACD;EAEhB,MAAMG,MAAM,GAAGH,KAAK,CAACI,MAAM,CAAC,CAACD,MAAM,EAAEE,IAAI,KAAKF,MAAM,GAAGE,IAAI,CAACF,MAAM,EAAE,CAAC,CAAC;EACtE,MAAMG,IAAI,GAAGZ,YAAY,CAAC,IAAIa,UAAU,CAACJ,MAAM,CAAC,CAAC;EACjD,IAAIK,MAAM,GAAG,IAAI;EAEjB,KAAK,MAAMH,IAAI,IAAIL,KAAK,EAAE;IACxB,MAAMS,MAAM,GAAGf,YAAY,CAACW,IAAI,CAAC;IACjC,OAAOG,MAAM,IAAIC,MAAM,CAACC,QAAQ,GAAGL,IAAI,CAACF,MAAM,EAAE;MAC9C;MACAM,MAAM,CAACE,iBAAiB,CAAC,CAAC,CAAC;MAE3B,IAAIC,OAAO,GAAG,EAAE;MAChB,IAAIP,IAAI,CAACF,MAAM,GAAGM,MAAM,CAACC,QAAQ,GAAG,EAAE,EACpCE,OAAO,GAAGP,IAAI,CAACF,MAAM,GAAGM,MAAM,CAACC,QAAQ;MAEzC,KAAK,MAAMG,CAAC,IAAIC,KAAK,CAACC,IAAI,CAAC;QAAEZ,MAAM,EAAES;MAAO,CAAE,CAAC,EAAE;QAC/C,MAAMI,IAAI,GAAGP,MAAM,CAACQ,QAAQ,EAAE;QAC9B,MAAMC,YAAY,GAChBF,IAAI,KAAK,IAAI,IAAI,CAACP,MAAM,CAACU,YAAY,CAACV,MAAM,CAACW,SAAS,CAAC,CAACC,QAAQ,CAAC,IAAI,CAAC;QACxE,IAAIH,YAAY,EAAE;UAChBV,MAAM,GAAG,KAAK;UACd;QACF;QACAF,IAAI,CAACgB,QAAQ,CAACN,IAAI,CAAC;MACrB;IACF;EACF;EAEA,MAAMO,WAAW,GAAGjB,IAAI,CAACkB,KAAK,CAACC,KAAK,CAAC,CAAC,EAAEnB,IAAI,CAACI,QAAQ,CAAC;EACtD,OACEX,EAAE,KAAK,KAAK,GAAGH,UAAU,CAAC2B,WAAW,CAAC,GAAGA,WAAW;AAExD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}