{"ast":null,"code":"// TODO(v3): checksum address.\nimport { AbiEventSignatureNotFoundError, DecodeLogDataMismatch, DecodeLogTopicsMismatch } from '../../errors/abi.js';\nimport { isAddressEqual } from '../address/isAddressEqual.js';\nimport { toBytes } from '../encoding/toBytes.js';\nimport { keccak256 } from '../hash/keccak256.js';\nimport { toEventSelector } from '../hash/toEventSelector.js';\nimport { decodeEventLog } from './decodeEventLog.js';\n/**\n * Extracts & decodes logs matching the provided signature(s) (`abi` + optional `eventName`)\n * from a set of opaque logs.\n *\n * @param parameters - {@link ParseEventLogsParameters}\n * @returns The logs. {@link ParseEventLogsReturnType}\n *\n * @example\n * import { createClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { parseEventLogs } from 'viem/op-stack'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const receipt = await getTransactionReceipt(client, {\n *   hash: '0xec23b2ba4bc59ba61554507c1b1bc91649e6586eb2dd00c728e8ed0db8bb37ea',\n * })\n *\n * const logs = parseEventLogs({ logs: receipt.logs })\n * // [{ args: { ... }, eventName: 'TransactionDeposited', ... }, ...]\n */\nexport function parseEventLogs(parameters) {\n  const {\n    abi,\n    args,\n    logs,\n    strict = true\n  } = parameters;\n  const eventName = (() => {\n    if (!parameters.eventName) return undefined;\n    if (Array.isArray(parameters.eventName)) return parameters.eventName;\n    return [parameters.eventName];\n  })();\n  return logs.map(log => {\n    try {\n      const abiItem = abi.find(abiItem => abiItem.type === 'event' && log.topics[0] === toEventSelector(abiItem));\n      if (!abiItem) return null;\n      const event = decodeEventLog({\n        ...log,\n        abi: [abiItem],\n        strict\n      });\n      // Check that the decoded event name matches the provided event name.\n      if (eventName && !eventName.includes(event.eventName)) return null;\n      // Check that the decoded event args match the provided args.\n      if (!includesArgs({\n        args: event.args,\n        inputs: abiItem.inputs,\n        matchArgs: args\n      })) return null;\n      return {\n        ...event,\n        ...log\n      };\n    } catch (err) {\n      let eventName;\n      let isUnnamed;\n      if (err instanceof AbiEventSignatureNotFoundError) return null;\n      if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {\n        // If strict mode is on, and log data/topics do not match event definition, skip.\n        if (strict) return null;\n        eventName = err.abiItem.name;\n        isUnnamed = err.abiItem.inputs?.some(x => !('name' in x && x.name));\n      }\n      // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).\n      return {\n        ...log,\n        args: isUnnamed ? [] : {},\n        eventName\n      };\n    }\n  }).filter(Boolean);\n}\nfunction includesArgs(parameters) {\n  const {\n    args,\n    inputs,\n    matchArgs\n  } = parameters;\n  if (!matchArgs) return true;\n  if (!args) return false;\n  function isEqual(input, value, arg) {\n    try {\n      if (input.type === 'address') return isAddressEqual(value, arg);\n      if (input.type === 'string' || input.type === 'bytes') return keccak256(toBytes(value)) === arg;\n      return value === arg;\n    } catch {\n      return false;\n    }\n  }\n  if (Array.isArray(args) && Array.isArray(matchArgs)) {\n    return matchArgs.every((value, index) => {\n      if (value === null || value === undefined) return true;\n      const input = inputs[index];\n      if (!input) return false;\n      const value_ = Array.isArray(value) ? value : [value];\n      return value_.some(value => isEqual(input, value, args[index]));\n    });\n  }\n  if (typeof args === 'object' && !Array.isArray(args) && typeof matchArgs === 'object' && !Array.isArray(matchArgs)) return Object.entries(matchArgs).every(([key, value]) => {\n    if (value === null || value === undefined) return true;\n    const input = inputs.find(input => input.name === key);\n    if (!input) return false;\n    const value_ = Array.isArray(value) ? value : [value];\n    return value_.some(value => isEqual(input, value, args[key]));\n  });\n  return false;\n}\n//# sourceMappingURL=parseEventLogs.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}