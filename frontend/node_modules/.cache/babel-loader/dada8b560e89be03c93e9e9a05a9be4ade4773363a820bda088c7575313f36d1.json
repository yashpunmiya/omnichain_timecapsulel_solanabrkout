{"ast":null,"code":"import { createStorage as w } from \"unstorage\";\nimport { createStore as I, get as u, set as p, del as b, keys as v, clear as S } from \"idb-keyval\";\nimport { safeJsonStringify as g, safeJsonParse as d } from \"@walletconnect/safe-json\";\nfunction C(i) {\n  return i;\n}\nconst x = \"idb-keyval\";\nvar z = (i = {}) => {\n  const t = i.base && i.base.length > 0 ? `${i.base}:` : \"\",\n    e = s => t + s;\n  let n;\n  return i.dbName && i.storeName && (n = I(i.dbName, i.storeName)), {\n    name: x,\n    options: i,\n    async hasItem(s) {\n      return !(typeof (await u(e(s), n)) > \"u\");\n    },\n    async getItem(s) {\n      return (await u(e(s), n)) ?? null;\n    },\n    setItem(s, a) {\n      return p(e(s), a, n);\n    },\n    removeItem(s) {\n      return b(e(s), n);\n    },\n    getKeys() {\n      return v(n);\n    },\n    clear() {\n      return S(n);\n    }\n  };\n};\nconst D = \"WALLET_CONNECT_V2_INDEXED_DB\",\n  E = \"keyvaluestorage\";\nclass _ {\n  constructor() {\n    this.indexedDb = w({\n      driver: z({\n        dbName: D,\n        storeName: E\n      })\n    });\n  }\n  async getKeys() {\n    return this.indexedDb.getKeys();\n  }\n  async getEntries() {\n    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map(t => [t.key, t.value]);\n  }\n  async getItem(t) {\n    const e = await this.indexedDb.getItem(t);\n    if (e !== null) return e;\n  }\n  async setItem(t, e) {\n    await this.indexedDb.setItem(t, g(e));\n  }\n  async removeItem(t) {\n    await this.indexedDb.removeItem(t);\n  }\n}\nvar l = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof global < \"u\" ? global : typeof self < \"u\" ? self : {},\n  c = {\n    exports: {}\n  };\n(function () {\n  let i;\n  function t() {}\n  i = t, i.prototype.getItem = function (e) {\n    return this.hasOwnProperty(e) ? String(this[e]) : null;\n  }, i.prototype.setItem = function (e, n) {\n    this[e] = String(n);\n  }, i.prototype.removeItem = function (e) {\n    delete this[e];\n  }, i.prototype.clear = function () {\n    const e = this;\n    Object.keys(e).forEach(function (n) {\n      e[n] = void 0, delete e[n];\n    });\n  }, i.prototype.key = function (e) {\n    return e = e || 0, Object.keys(this)[e];\n  }, i.prototype.__defineGetter__(\"length\", function () {\n    return Object.keys(this).length;\n  }), typeof l < \"u\" && l.localStorage ? c.exports = l.localStorage : typeof window < \"u\" && window.localStorage ? c.exports = window.localStorage : c.exports = new t();\n})();\nfunction k(i) {\n  var t;\n  return [i[0], d((t = i[1]) != null ? t : \"\")];\n}\nclass K {\n  constructor() {\n    this.localStorage = c.exports;\n  }\n  async getKeys() {\n    return Object.keys(this.localStorage);\n  }\n  async getEntries() {\n    return Object.entries(this.localStorage).map(k);\n  }\n  async getItem(t) {\n    const e = this.localStorage.getItem(t);\n    if (e !== null) return d(e);\n  }\n  async setItem(t, e) {\n    this.localStorage.setItem(t, g(e));\n  }\n  async removeItem(t) {\n    this.localStorage.removeItem(t);\n  }\n}\nconst N = \"wc_storage_version\",\n  y = 1,\n  O = async (i, t, e) => {\n    const n = N,\n      s = await t.getItem(n);\n    if (s && s >= y) {\n      e(t);\n      return;\n    }\n    const a = await i.getKeys();\n    if (!a.length) {\n      e(t);\n      return;\n    }\n    const m = [];\n    for (; a.length;) {\n      const r = a.shift();\n      if (!r) continue;\n      const o = r.toLowerCase();\n      if (o.includes(\"wc@\") || o.includes(\"walletconnect\") || o.includes(\"wc_\") || o.includes(\"wallet_connect\")) {\n        const f = await i.getItem(r);\n        await t.setItem(r, f), m.push(r);\n      }\n    }\n    await t.setItem(n, y), e(t), j(i, m);\n  },\n  j = async (i, t) => {\n    t.length && t.forEach(async e => {\n      await i.removeItem(e);\n    });\n  };\nclass h {\n  constructor() {\n    this.initialized = !1, this.setInitialized = e => {\n      this.storage = e, this.initialized = !0;\n    };\n    const t = new K();\n    this.storage = t;\n    try {\n      const e = new _();\n      O(t, e, this.setInitialized);\n    } catch {\n      this.initialized = !0;\n    }\n  }\n  async getKeys() {\n    return await this.initialize(), this.storage.getKeys();\n  }\n  async getEntries() {\n    return await this.initialize(), this.storage.getEntries();\n  }\n  async getItem(t) {\n    return await this.initialize(), this.storage.getItem(t);\n  }\n  async setItem(t, e) {\n    return await this.initialize(), this.storage.setItem(t, e);\n  }\n  async removeItem(t) {\n    return await this.initialize(), this.storage.removeItem(t);\n  }\n  async initialize() {\n    this.initialized || (await new Promise(t => {\n      const e = setInterval(() => {\n        this.initialized && (clearInterval(e), t());\n      }, 20);\n    }));\n  }\n}\nexport { h as KeyValueStorage, h as default };\n//# sourceMappingURL=index.es.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}