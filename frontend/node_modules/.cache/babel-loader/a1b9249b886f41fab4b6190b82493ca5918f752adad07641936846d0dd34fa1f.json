{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TemplateLiteralParserError = void 0;\nexports.TemplateLiteralParse = TemplateLiteralParse;\nexports.TemplateLiteralParseExact = TemplateLiteralParseExact;\nconst index_1 = require(\"../error/index\");\n// ------------------------------------------------------------------\n// TemplateLiteralParserError\n// ------------------------------------------------------------------\nclass TemplateLiteralParserError extends index_1.TypeBoxError {}\nexports.TemplateLiteralParserError = TemplateLiteralParserError;\n// -------------------------------------------------------------------\n// Unescape\n//\n// Unescape for these control characters specifically. Note that this\n// function is only called on non union group content, and where we\n// still want to allow the user to embed control characters in that\n// content. For review.\n// -------------------------------------------------------------------\n// prettier-ignore\nfunction Unescape(pattern) {\n  return pattern.replace(/\\\\\\$/g, '$').replace(/\\\\\\*/g, '*').replace(/\\\\\\^/g, '^').replace(/\\\\\\|/g, '|').replace(/\\\\\\(/g, '(').replace(/\\\\\\)/g, ')');\n}\n// -------------------------------------------------------------------\n// Control Characters\n// -------------------------------------------------------------------\nfunction IsNonEscaped(pattern, index, char) {\n  return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;\n}\nfunction IsOpenParen(pattern, index) {\n  return IsNonEscaped(pattern, index, '(');\n}\nfunction IsCloseParen(pattern, index) {\n  return IsNonEscaped(pattern, index, ')');\n}\nfunction IsSeparator(pattern, index) {\n  return IsNonEscaped(pattern, index, '|');\n}\n// -------------------------------------------------------------------\n// Control Groups\n// -------------------------------------------------------------------\nfunction IsGroup(pattern) {\n  if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1))) return false;\n  let count = 0;\n  for (let index = 0; index < pattern.length; index++) {\n    if (IsOpenParen(pattern, index)) count += 1;\n    if (IsCloseParen(pattern, index)) count -= 1;\n    if (count === 0 && index !== pattern.length - 1) return false;\n  }\n  return true;\n}\n// prettier-ignore\nfunction InGroup(pattern) {\n  return pattern.slice(1, pattern.length - 1);\n}\n// prettier-ignore\nfunction IsPrecedenceOr(pattern) {\n  let count = 0;\n  for (let index = 0; index < pattern.length; index++) {\n    if (IsOpenParen(pattern, index)) count += 1;\n    if (IsCloseParen(pattern, index)) count -= 1;\n    if (IsSeparator(pattern, index) && count === 0) return true;\n  }\n  return false;\n}\n// prettier-ignore\nfunction IsPrecedenceAnd(pattern) {\n  for (let index = 0; index < pattern.length; index++) {\n    if (IsOpenParen(pattern, index)) return true;\n  }\n  return false;\n}\n// prettier-ignore\nfunction Or(pattern) {\n  let [count, start] = [0, 0];\n  const expressions = [];\n  for (let index = 0; index < pattern.length; index++) {\n    if (IsOpenParen(pattern, index)) count += 1;\n    if (IsCloseParen(pattern, index)) count -= 1;\n    if (IsSeparator(pattern, index) && count === 0) {\n      const range = pattern.slice(start, index);\n      if (range.length > 0) expressions.push(TemplateLiteralParse(range));\n      start = index + 1;\n    }\n  }\n  const range = pattern.slice(start);\n  if (range.length > 0) expressions.push(TemplateLiteralParse(range));\n  if (expressions.length === 0) return {\n    type: 'const',\n    const: ''\n  };\n  if (expressions.length === 1) return expressions[0];\n  return {\n    type: 'or',\n    expr: expressions\n  };\n}\n// prettier-ignore\nfunction And(pattern) {\n  function Group(value, index) {\n    if (!IsOpenParen(value, index)) throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);\n    let count = 0;\n    for (let scan = index; scan < value.length; scan++) {\n      if (IsOpenParen(value, scan)) count += 1;\n      if (IsCloseParen(value, scan)) count -= 1;\n      if (count === 0) return [index, scan];\n    }\n    throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);\n  }\n  function Range(pattern, index) {\n    for (let scan = index; scan < pattern.length; scan++) {\n      if (IsOpenParen(pattern, scan)) return [index, scan];\n    }\n    return [index, pattern.length];\n  }\n  const expressions = [];\n  for (let index = 0; index < pattern.length; index++) {\n    if (IsOpenParen(pattern, index)) {\n      const [start, end] = Group(pattern, index);\n      const range = pattern.slice(start, end + 1);\n      expressions.push(TemplateLiteralParse(range));\n      index = end;\n    } else {\n      const [start, end] = Range(pattern, index);\n      const range = pattern.slice(start, end);\n      if (range.length > 0) expressions.push(TemplateLiteralParse(range));\n      index = end - 1;\n    }\n  }\n  return expressions.length === 0 ? {\n    type: 'const',\n    const: ''\n  } : expressions.length === 1 ? expressions[0] : {\n    type: 'and',\n    expr: expressions\n  };\n}\n// ------------------------------------------------------------------\n// TemplateLiteralParse\n// ------------------------------------------------------------------\n/** Parses a pattern and returns an expression tree */\nfunction TemplateLiteralParse(pattern) {\n  // prettier-ignore\n  return IsGroup(pattern) ? TemplateLiteralParse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : {\n    type: 'const',\n    const: Unescape(pattern)\n  };\n}\n// ------------------------------------------------------------------\n// TemplateLiteralParseExact\n// ------------------------------------------------------------------\n/** Parses a pattern and strips forward and trailing ^ and $ */\nfunction TemplateLiteralParseExact(pattern) {\n  return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}