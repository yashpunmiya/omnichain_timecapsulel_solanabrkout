{"ast":null,"code":"/**\n\nSHA1 (RFC 3174), MD5 (RFC 1321) and RIPEMD160 (RFC 2286) legacy, weak hash functions.\nDon't use them in a new protocol. What \"weak\" means:\n\n- Collisions can be made with 2^18 effort in MD5, 2^60 in SHA1, 2^80 in RIPEMD160.\n- No practical pre-image attacks (only theoretical, 2^123.4)\n- HMAC seems kinda ok: https://datatracker.ietf.org/doc/html/rfc6151\n * @module\n */\nimport { Chi, HashMD, Maj } from \"./_md.js\";\nimport { clean, createHasher, rotl } from \"./utils.js\";\n/** Initial SHA1 state */\nconst SHA1_IV = /* @__PURE__ */Uint32Array.from([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0]);\n// Reusable temporary buffer\nconst SHA1_W = /* @__PURE__ */new Uint32Array(80);\n/** SHA1 legacy hash class. */\nexport class SHA1 extends HashMD {\n  constructor() {\n    super(64, 20, 8, false);\n    this.A = SHA1_IV[0] | 0;\n    this.B = SHA1_IV[1] | 0;\n    this.C = SHA1_IV[2] | 0;\n    this.D = SHA1_IV[3] | 0;\n    this.E = SHA1_IV[4] | 0;\n  }\n  get() {\n    const {\n      A,\n      B,\n      C,\n      D,\n      E\n    } = this;\n    return [A, B, C, D, E];\n  }\n  set(A, B, C, D, E) {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n  }\n  process(view, offset) {\n    for (let i = 0; i < 16; i++, offset += 4) SHA1_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 80; i++) SHA1_W[i] = rotl(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);\n    // Compression function main loop, 80 rounds\n    let {\n      A,\n      B,\n      C,\n      D,\n      E\n    } = this;\n    for (let i = 0; i < 80; i++) {\n      let F, K;\n      if (i < 20) {\n        F = Chi(B, C, D);\n        K = 0x5a827999;\n      } else if (i < 40) {\n        F = B ^ C ^ D;\n        K = 0x6ed9eba1;\n      } else if (i < 60) {\n        F = Maj(B, C, D);\n        K = 0x8f1bbcdc;\n      } else {\n        F = B ^ C ^ D;\n        K = 0xca62c1d6;\n      }\n      const T = rotl(A, 5) + F + E + K + SHA1_W[i] | 0;\n      E = D;\n      D = C;\n      C = rotl(B, 30);\n      B = A;\n      A = T;\n    }\n    // Add the compressed chunk to the current hash value\n    A = A + this.A | 0;\n    B = B + this.B | 0;\n    C = C + this.C | 0;\n    D = D + this.D | 0;\n    E = E + this.E | 0;\n    this.set(A, B, C, D, E);\n  }\n  roundClean() {\n    clean(SHA1_W);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0);\n    clean(this.buffer);\n  }\n}\n/** SHA1 (RFC 3174) legacy hash function. It was cryptographically broken. */\nexport const sha1 = /* @__PURE__ */createHasher(() => new SHA1());\n/** Per-round constants */\nconst p32 = /* @__PURE__ */Math.pow(2, 32);\nconst K = /* @__PURE__ */Array.from({\n  length: 64\n}, (_, i) => Math.floor(p32 * Math.abs(Math.sin(i + 1))));\n/** md5 initial state: same as sha1, but 4 u32 instead of 5. */\nconst MD5_IV = /* @__PURE__ */SHA1_IV.slice(0, 4);\n// Reusable temporary buffer\nconst MD5_W = /* @__PURE__ */new Uint32Array(16);\n/** MD5 legacy hash class. */\nexport class MD5 extends HashMD {\n  constructor() {\n    super(64, 16, 8, true);\n    this.A = MD5_IV[0] | 0;\n    this.B = MD5_IV[1] | 0;\n    this.C = MD5_IV[2] | 0;\n    this.D = MD5_IV[3] | 0;\n  }\n  get() {\n    const {\n      A,\n      B,\n      C,\n      D\n    } = this;\n    return [A, B, C, D];\n  }\n  set(A, B, C, D) {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n  }\n  process(view, offset) {\n    for (let i = 0; i < 16; i++, offset += 4) MD5_W[i] = view.getUint32(offset, true);\n    // Compression function main loop, 64 rounds\n    let {\n      A,\n      B,\n      C,\n      D\n    } = this;\n    for (let i = 0; i < 64; i++) {\n      let F, g, s;\n      if (i < 16) {\n        F = Chi(B, C, D);\n        g = i;\n        s = [7, 12, 17, 22];\n      } else if (i < 32) {\n        F = Chi(D, B, C);\n        g = (5 * i + 1) % 16;\n        s = [5, 9, 14, 20];\n      } else if (i < 48) {\n        F = B ^ C ^ D;\n        g = (3 * i + 5) % 16;\n        s = [4, 11, 16, 23];\n      } else {\n        F = C ^ (B | ~D);\n        g = 7 * i % 16;\n        s = [6, 10, 15, 21];\n      }\n      F = F + A + K[i] + MD5_W[g];\n      A = D;\n      D = C;\n      C = B;\n      B = B + rotl(F, s[i % 4]);\n    }\n    // Add the compressed chunk to the current hash value\n    A = A + this.A | 0;\n    B = B + this.B | 0;\n    C = C + this.C | 0;\n    D = D + this.D | 0;\n    this.set(A, B, C, D);\n  }\n  roundClean() {\n    clean(MD5_W);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0);\n    clean(this.buffer);\n  }\n}\n/**\n * MD5 (RFC 1321) legacy hash function. It was cryptographically broken.\n * MD5 architecture is similar to SHA1, with some differences:\n * - Reduced output length: 16 bytes (128 bit) instead of 20\n * - 64 rounds, instead of 80\n * - Little-endian: could be faster, but will require more code\n * - Non-linear index selection: huge speed-up for unroll\n * - Per round constants: more memory accesses, additional speed-up for unroll\n */\nexport const md5 = /* @__PURE__ */createHasher(() => new MD5());\n// RIPEMD-160\nconst Rho160 = /* @__PURE__ */Uint8Array.from([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);\nconst Id160 = /* @__PURE__ */(() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();\nconst Pi160 = /* @__PURE__ */(() => Id160.map(i => (9 * i + 5) % 16))();\nconst idxLR = /* @__PURE__ */(() => {\n  const L = [Id160];\n  const R = [Pi160];\n  const res = [L, R];\n  for (let i = 0; i < 4; i++) for (let j of res) j.push(j[i].map(k => Rho160[k]));\n  return res;\n})();\nconst idxL = /* @__PURE__ */(() => idxLR[0])();\nconst idxR = /* @__PURE__ */(() => idxLR[1])();\n// const [idxL, idxR] = idxLR;\nconst shifts160 = /* @__PURE__ */[[11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8], [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7], [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9], [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6], [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]].map(i => Uint8Array.from(i));\nconst shiftsL160 = /* @__PURE__ */idxL.map((idx, i) => idx.map(j => shifts160[i][j]));\nconst shiftsR160 = /* @__PURE__ */idxR.map((idx, i) => idx.map(j => shifts160[i][j]));\nconst Kl160 = /* @__PURE__ */Uint32Array.from([0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]);\nconst Kr160 = /* @__PURE__ */Uint32Array.from([0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]);\n// It's called f() in spec.\nfunction ripemd_f(group, x, y, z) {\n  if (group === 0) return x ^ y ^ z;\n  if (group === 1) return x & y | ~x & z;\n  if (group === 2) return (x | ~y) ^ z;\n  if (group === 3) return x & z | y & ~z;\n  return x ^ (y | ~z);\n}\n// Reusable temporary buffer\nconst BUF_160 = /* @__PURE__ */new Uint32Array(16);\nexport class RIPEMD160 extends HashMD {\n  constructor() {\n    super(64, 20, 8, true);\n    this.h0 = 0x67452301 | 0;\n    this.h1 = 0xefcdab89 | 0;\n    this.h2 = 0x98badcfe | 0;\n    this.h3 = 0x10325476 | 0;\n    this.h4 = 0xc3d2e1f0 | 0;\n  }\n  get() {\n    const {\n      h0,\n      h1,\n      h2,\n      h3,\n      h4\n    } = this;\n    return [h0, h1, h2, h3, h4];\n  }\n  set(h0, h1, h2, h3, h4) {\n    this.h0 = h0 | 0;\n    this.h1 = h1 | 0;\n    this.h2 = h2 | 0;\n    this.h3 = h3 | 0;\n    this.h4 = h4 | 0;\n  }\n  process(view, offset) {\n    for (let i = 0; i < 16; i++, offset += 4) BUF_160[i] = view.getUint32(offset, true);\n    // prettier-ignore\n    let al = this.h0 | 0,\n      ar = al,\n      bl = this.h1 | 0,\n      br = bl,\n      cl = this.h2 | 0,\n      cr = cl,\n      dl = this.h3 | 0,\n      dr = dl,\n      el = this.h4 | 0,\n      er = el;\n    // Instead of iterating 0 to 80, we split it into 5 groups\n    // And use the groups in constants, functions, etc. Much simpler\n    for (let group = 0; group < 5; group++) {\n      const rGroup = 4 - group;\n      const hbl = Kl160[group],\n        hbr = Kr160[group]; // prettier-ignore\n      const rl = idxL[group],\n        rr = idxR[group]; // prettier-ignore\n      const sl = shiftsL160[group],\n        sr = shiftsR160[group]; // prettier-ignore\n      for (let i = 0; i < 16; i++) {\n        const tl = rotl(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el | 0;\n        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n      }\n      // 2 loops are 10% faster\n      for (let i = 0; i < 16; i++) {\n        const tr = rotl(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er | 0;\n        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n      }\n    }\n    // Add the compressed chunk to the current hash value\n    this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);\n  }\n  roundClean() {\n    clean(BUF_160);\n  }\n  destroy() {\n    this.destroyed = true;\n    clean(this.buffer);\n    this.set(0, 0, 0, 0, 0);\n  }\n}\n/**\n * RIPEMD-160 - a legacy hash function from 1990s.\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n */\nexport const ripemd160 = /* @__PURE__ */createHasher(() => new RIPEMD160());\n//# sourceMappingURL=legacy.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}