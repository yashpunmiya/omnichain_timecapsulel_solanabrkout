{"ast":null,"code":"import * as Address from '../Address.js';\nimport * as Errors from '../Errors.js';\n/** @internal */\nexport function normalizeSignature(signature) {\n  let active = true;\n  let current = '';\n  let level = 0;\n  let result = '';\n  let valid = false;\n  for (let i = 0; i < signature.length; i++) {\n    const char = signature[i];\n    // If the character is a separator, we want to reactivate.\n    if (['(', ')', ','].includes(char)) active = true;\n    // If the character is a \"level\" token, we want to increment/decrement.\n    if (char === '(') level++;\n    if (char === ')') level--;\n    // If we aren't active, we don't want to mutate the result.\n    if (!active) continue;\n    // If level === 0, we are at the definition level.\n    if (level === 0) {\n      if (char === ' ' && ['event', 'function', 'error', ''].includes(result)) result = '';else {\n        result += char;\n        // If we are at the end of the definition, we must be finished.\n        if (char === ')') {\n          valid = true;\n          break;\n        }\n      }\n      continue;\n    }\n    // Ignore spaces\n    if (char === ' ') {\n      // If the previous character is a separator, and the current section isn't empty, we want to deactivate.\n      if (signature[i - 1] !== ',' && current !== ',' && current !== ',(') {\n        current = '';\n        active = false;\n      }\n      continue;\n    }\n    result += char;\n    current += char;\n  }\n  if (!valid) throw new Errors.BaseError('Unable to normalize signature.');\n  return result;\n}\n/** @internal */\nexport function isArgOfType(arg, abiParameter) {\n  const argType = typeof arg;\n  const abiParameterType = abiParameter.type;\n  switch (abiParameterType) {\n    case 'address':\n      return Address.validate(arg, {\n        strict: false\n      });\n    case 'bool':\n      return argType === 'boolean';\n    case 'function':\n      return argType === 'string';\n    case 'string':\n      return argType === 'string';\n    default:\n      {\n        if (abiParameterType === 'tuple' && 'components' in abiParameter) return Object.values(abiParameter.components).every((component, index) => {\n          return isArgOfType(Object.values(arg)[index], component);\n        });\n        // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n        // https://regexr.com/6v8hp\n        if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType)) return argType === 'number' || argType === 'bigint';\n        // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n        // https://regexr.com/6va55\n        if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType)) return argType === 'string' || arg instanceof Uint8Array;\n        // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays\n        // https://regexr.com/6va6i\n        if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n          return Array.isArray(arg) && arg.every(x => isArgOfType(x, {\n            ...abiParameter,\n            // Pop off `[]` or `[M]` from end of type\n            type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, '')\n          }));\n        }\n        return false;\n      }\n  }\n}\n/** @internal */\nexport function getAmbiguousTypes(sourceParameters, targetParameters, args) {\n  for (const parameterIndex in sourceParameters) {\n    const sourceParameter = sourceParameters[parameterIndex];\n    const targetParameter = targetParameters[parameterIndex];\n    if (sourceParameter.type === 'tuple' && targetParameter.type === 'tuple' && 'components' in sourceParameter && 'components' in targetParameter) return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);\n    const types = [sourceParameter.type, targetParameter.type];\n    const ambiguous = (() => {\n      if (types.includes('address') && types.includes('bytes20')) return true;\n      if (types.includes('address') && types.includes('string')) return Address.validate(args[parameterIndex], {\n        strict: false\n      });\n      if (types.includes('address') && types.includes('bytes')) return Address.validate(args[parameterIndex], {\n        strict: false\n      });\n      return false;\n    })();\n    if (ambiguous) return types;\n  }\n  return;\n}\n//# sourceMappingURL=abiItem.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}