{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TemplateLiteralSyntax = TemplateLiteralSyntax;\nconst index_1 = require(\"../literal/index\");\nconst index_2 = require(\"../boolean/index\");\nconst index_3 = require(\"../bigint/index\");\nconst index_4 = require(\"../number/index\");\nconst index_5 = require(\"../string/index\");\nconst index_6 = require(\"../union/index\");\nconst index_7 = require(\"../never/index\");\n// ------------------------------------------------------------------\n// SyntaxParsers\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction* FromUnion(syntax) {\n  const trim = syntax.trim().replace(/\"|'/g, '');\n  return trim === 'boolean' ? yield (0, index_2.Boolean)() : trim === 'number' ? yield (0, index_4.Number)() : trim === 'bigint' ? yield (0, index_3.BigInt)() : trim === 'string' ? yield (0, index_5.String)() : yield (() => {\n    const literals = trim.split('|').map(literal => (0, index_1.Literal)(literal.trim()));\n    return literals.length === 0 ? (0, index_7.Never)() : literals.length === 1 ? literals[0] : (0, index_6.UnionEvaluated)(literals);\n  })();\n}\n// prettier-ignore\nfunction* FromTerminal(syntax) {\n  if (syntax[1] !== '{') {\n    const L = (0, index_1.Literal)('$');\n    const R = FromSyntax(syntax.slice(1));\n    return yield* [L, ...R];\n  }\n  for (let i = 2; i < syntax.length; i++) {\n    if (syntax[i] === '}') {\n      const L = FromUnion(syntax.slice(2, i));\n      const R = FromSyntax(syntax.slice(i + 1));\n      return yield* [...L, ...R];\n    }\n  }\n  yield (0, index_1.Literal)(syntax);\n}\n// prettier-ignore\nfunction* FromSyntax(syntax) {\n  for (let i = 0; i < syntax.length; i++) {\n    if (syntax[i] === '$') {\n      const L = (0, index_1.Literal)(syntax.slice(0, i));\n      const R = FromTerminal(syntax.slice(i));\n      return yield* [L, ...R];\n    }\n  }\n  yield (0, index_1.Literal)(syntax);\n}\n/** Parses TemplateLiteralSyntax and returns a tuple of TemplateLiteralKinds */\nfunction TemplateLiteralSyntax(syntax) {\n  return [...FromSyntax(syntax)];\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","TemplateLiteralSyntax","index_1","require","index_2","index_3","index_4","index_5","index_6","index_7","FromUnion","syntax","trim","replace","Boolean","Number","BigInt","String","literals","split","map","literal","Literal","length","Never","UnionEvaluated","FromTerminal","L","R","FromSyntax","slice","i"],"sources":["C:/Users/yyash/Coding/solana-brkout/frontend/node_modules/@sinclair/typebox/build/cjs/type/template-literal/syntax.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TemplateLiteralSyntax = TemplateLiteralSyntax;\nconst index_1 = require(\"../literal/index\");\nconst index_2 = require(\"../boolean/index\");\nconst index_3 = require(\"../bigint/index\");\nconst index_4 = require(\"../number/index\");\nconst index_5 = require(\"../string/index\");\nconst index_6 = require(\"../union/index\");\nconst index_7 = require(\"../never/index\");\n// ------------------------------------------------------------------\n// SyntaxParsers\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction* FromUnion(syntax) {\n    const trim = syntax.trim().replace(/\"|'/g, '');\n    return (trim === 'boolean' ? yield (0, index_2.Boolean)() :\n        trim === 'number' ? yield (0, index_4.Number)() :\n            trim === 'bigint' ? yield (0, index_3.BigInt)() :\n                trim === 'string' ? yield (0, index_5.String)() :\n                    yield (() => {\n                        const literals = trim.split('|').map((literal) => (0, index_1.Literal)(literal.trim()));\n                        return (literals.length === 0 ? (0, index_7.Never)() :\n                            literals.length === 1 ? literals[0] :\n                                (0, index_6.UnionEvaluated)(literals));\n                    })());\n}\n// prettier-ignore\nfunction* FromTerminal(syntax) {\n    if (syntax[1] !== '{') {\n        const L = (0, index_1.Literal)('$');\n        const R = FromSyntax(syntax.slice(1));\n        return yield* [L, ...R];\n    }\n    for (let i = 2; i < syntax.length; i++) {\n        if (syntax[i] === '}') {\n            const L = FromUnion(syntax.slice(2, i));\n            const R = FromSyntax(syntax.slice(i + 1));\n            return yield* [...L, ...R];\n        }\n    }\n    yield (0, index_1.Literal)(syntax);\n}\n// prettier-ignore\nfunction* FromSyntax(syntax) {\n    for (let i = 0; i < syntax.length; i++) {\n        if (syntax[i] === '$') {\n            const L = (0, index_1.Literal)(syntax.slice(0, i));\n            const R = FromTerminal(syntax.slice(i));\n            return yield* [L, ...R];\n        }\n    }\n    yield (0, index_1.Literal)(syntax);\n}\n/** Parses TemplateLiteralSyntax and returns a tuple of TemplateLiteralKinds */\nfunction TemplateLiteralSyntax(syntax) {\n    return [...FromSyntax(syntax)];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}