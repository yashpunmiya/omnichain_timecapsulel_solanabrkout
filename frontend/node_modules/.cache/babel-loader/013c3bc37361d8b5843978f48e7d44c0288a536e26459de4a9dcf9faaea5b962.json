{"ast":null,"code":"import { assertPayloadIsMessageSignatureNeededResponsePayload, ConnectionManager, Platform, PopupEvent, assertPayloadIsSolanaWalletAdapterApproved, DEFAULT_POPUP_HEIGHT_PX, assertPayloadIsTransactionSignatureNeededResponsePayload } from '@fractalwagmi/popup-connection';\nimport { WalletError, WalletNotConnectedError, WalletSignTransactionError, WalletPublicKeyError, WalletConnectionError, WalletSignMessageError } from '@solana/wallet-adapter-base';\nimport { Transaction, PublicKey } from '@solana/web3.js';\nimport base58 from 'bs58';\nimport { createNonce } from \"./nonce.js\";\nconst UNKNOWN_ERROR_MESSAGE = 'Unknown Error';\nconst FRACTAL_DOMAIN_HTTPS = 'https://fractal.is';\nconst APPROVE_PAGE_URL = `${FRACTAL_DOMAIN_HTTPS}/wallet-adapter/approve`;\nconst SIGN_PAGE_URL = `${FRACTAL_DOMAIN_HTTPS}/wallet-adapter/sign`;\nconst SIGN_MESSAGE_PAGE_URL = `${FRACTAL_DOMAIN_HTTPS}/wallet-adapter/sign/message`;\nconst MIN_POPUP_HEIGHT_PX = DEFAULT_POPUP_HEIGHT_PX;\nconst MAX_POPUP_WIDTH_PX = 850;\nconst LOCAL_STORAGE_KEY_FOR_PUBLIC_KEY = 'RdxqNYxF';\nexport class FractalWalletAdapterImpl {\n  constructor() {\n    this.popupManager = new ConnectionManager(Platform.SOLANA_WALLET_ADAPTER);\n    this.publicKey = null;\n    this.connecting = false;\n  }\n  getPublicKey() {\n    return this.publicKey;\n  }\n  async connect() {\n    let resolve;\n    let reject;\n    const publicKeyInLocalStorage = window.localStorage.getItem(LOCAL_STORAGE_KEY_FOR_PUBLIC_KEY);\n    if (publicKeyInLocalStorage) {\n      this.publicKey = new PublicKey(publicKeyInLocalStorage);\n      return Promise.resolve();\n    }\n    const nonce = createNonce();\n    this.popupManager.open({\n      nonce,\n      url: `${APPROVE_PAGE_URL}/${nonce}`\n    });\n    const handleSolanaWalletAdapterApproved = payload => {\n      if (!assertPayloadIsSolanaWalletAdapterApproved(payload)) {\n        reject(new WalletConnectionError('Malformed payload when setting up connection. ' + 'Expected { solanaPublicKey: string } but ' + `received ${JSON.stringify(payload)}`));\n        this.popupManager.close();\n        return;\n      }\n      try {\n        this.publicKey = new PublicKey(payload.solanaPublicKey);\n        window.localStorage.setItem(LOCAL_STORAGE_KEY_FOR_PUBLIC_KEY, payload.solanaPublicKey);\n        resolve();\n      } catch (error) {\n        const publicKeyError = new WalletPublicKeyError(error instanceof Error ? error.message : UNKNOWN_ERROR_MESSAGE, error);\n        reject(publicKeyError);\n      }\n      this.popupManager.close();\n    };\n    const handleExplicitDenialByUser = () => {\n      reject(new WalletConnectionError('The user denied the connection.'));\n      this.popupManager.close();\n    };\n    const handleClosedByUser = () => {\n      reject(new WalletConnectionError('The user denied the connection.'));\n      this.popupManager.close();\n    };\n    this.popupManager.onConnectionUpdated(connection => {\n      if (!connection) {\n        return;\n      }\n      connection.on(PopupEvent.SOLANA_WALLET_ADAPTER_APPROVED, handleSolanaWalletAdapterApproved);\n      connection.on(PopupEvent.SOLANA_WALLET_ADAPTER_DENIED, handleExplicitDenialByUser);\n      connection.on(PopupEvent.POPUP_CLOSED, handleClosedByUser);\n    });\n    return new Promise((promiseResolver, promiseRejector) => {\n      resolve = promiseResolver;\n      reject = promiseRejector;\n    });\n  }\n  async disconnect() {\n    this.popupManager.tearDown();\n    this.publicKey = null;\n    window.localStorage.removeItem(LOCAL_STORAGE_KEY_FOR_PUBLIC_KEY);\n  }\n  async signTransaction(transaction) {\n    try {\n      this.checkWalletReadiness();\n      const result = await this.signTransactions([transaction]);\n      return result[0];\n    } catch (error) {\n      let errorToThrow = error;\n      if (!(error instanceof WalletError)) {\n        errorToThrow = new WalletSignTransactionError(error instanceof Error ? error.message : UNKNOWN_ERROR_MESSAGE, error);\n      }\n      throw errorToThrow;\n    }\n  }\n  async signAllTransactions(transactions) {\n    try {\n      this.checkWalletReadiness();\n      const result = await this.signTransactions(transactions);\n      return result;\n    } catch (error) {\n      let errorToThrow = error;\n      if (!(error instanceof WalletError)) {\n        errorToThrow = new WalletSignTransactionError(error instanceof Error ? error.message : UNKNOWN_ERROR_MESSAGE, error);\n      }\n      throw errorToThrow;\n    }\n  }\n  async signMessage(encodedMessage) {\n    const decodedMessage = new TextDecoder().decode(encodedMessage);\n    let resolve;\n    let reject;\n    const handleMessageSignatureNeededResponse = payload => {\n      if (!assertPayloadIsMessageSignatureNeededResponsePayload(payload)) {\n        const error = new WalletSignMessageError('Malformed payload when signing message. ' + 'Expected { decodedSignature: string } ' + `but received ${JSON.stringify(payload)}`);\n        reject(error);\n        this.popupManager.close();\n        return;\n      }\n      const encodedSignature = Uint8Array.from(payload.decodedSignature.split(',').map(n => Number(n)));\n      resolve(encodedSignature);\n      this.popupManager.close();\n    };\n    const handleClosedOrDeniedByUser = () => {\n      reject(new WalletSignMessageError('The user did not approve the message'));\n      this.popupManager.close();\n    };\n    const handleAuthLoaded = () => {\n      var _a;\n      const payload = {\n        decodedMessage\n      };\n      (_a = this.popupManager.getConnection()) === null || _a === void 0 ? void 0 : _a.send({\n        event: PopupEvent.MESSAGE_SIGNATURE_NEEDED,\n        payload\n      });\n    };\n    const nonce = createNonce();\n    this.popupManager.open({\n      heightPx: Math.max(MIN_POPUP_HEIGHT_PX, Math.floor(window.innerHeight * 0.8)),\n      nonce,\n      url: `${SIGN_MESSAGE_PAGE_URL}/${nonce}`,\n      widthPx: Math.min(MAX_POPUP_WIDTH_PX, Math.floor(window.innerWidth * 0.8))\n    });\n    this.popupManager.onConnectionUpdated(connection => {\n      if (!connection) {\n        return;\n      }\n      connection.on(PopupEvent.MESSAGE_SIGNATURE_NEEDED_RESPONSE, handleMessageSignatureNeededResponse);\n      connection.on(PopupEvent.TRANSACTION_DENIED, handleClosedOrDeniedByUser);\n      connection.on(PopupEvent.POPUP_CLOSED, handleClosedOrDeniedByUser);\n      connection.on(PopupEvent.AUTH_LOADED, handleAuthLoaded);\n    });\n    return new Promise((promiseResolver, promiseRejector) => {\n      resolve = promiseResolver;\n      reject = promiseRejector;\n    });\n  }\n  async signTransactions(transactions) {\n    let resolve;\n    let reject;\n    const handleTransactionSignatureNeededResponse = payload => {\n      if (!assertPayloadIsTransactionSignatureNeededResponsePayload(payload)) {\n        const error = new WalletSignTransactionError('Malformed payload when signing transactions. ' + 'Expected { signedB58Transactions: string[] } ' + `but received ${JSON.stringify(payload)}`);\n        reject(error);\n        this.popupManager.close();\n        return;\n      }\n      const signedTransactions = payload.signedB58Transactions.map(signedB58Transaction => {\n        return Transaction.from(base58.decode(signedB58Transaction));\n      });\n      resolve(signedTransactions);\n      this.popupManager.close();\n    };\n    const handleClosedOrDeniedByUser = () => {\n      reject(new WalletSignTransactionError('The user did not approve the transaction'));\n      this.popupManager.close();\n    };\n    const handleAuthLoaded = () => {\n      var _a;\n      const payload = {\n        unsignedB58Transactions: transactions.map(t => base58.encode(t.serializeMessage()))\n      };\n      (_a = this.popupManager.getConnection()) === null || _a === void 0 ? void 0 : _a.send({\n        event: PopupEvent.TRANSACTION_SIGNATURE_NEEDED,\n        payload\n      });\n    };\n    const nonce = createNonce();\n    this.popupManager.open({\n      heightPx: Math.max(MIN_POPUP_HEIGHT_PX, Math.floor(window.innerHeight * 0.8)),\n      nonce,\n      url: `${SIGN_PAGE_URL}/${nonce}`,\n      widthPx: Math.min(MAX_POPUP_WIDTH_PX, Math.floor(window.innerWidth * 0.8))\n    });\n    this.popupManager.onConnectionUpdated(connection => {\n      if (!connection) {\n        return;\n      }\n      connection.on(PopupEvent.TRANSACTION_SIGNATURE_NEEDED_RESPONSE, handleTransactionSignatureNeededResponse);\n      connection.on(PopupEvent.TRANSACTION_DENIED, handleClosedOrDeniedByUser);\n      connection.on(PopupEvent.POPUP_CLOSED, handleClosedOrDeniedByUser);\n      connection.on(PopupEvent.AUTH_LOADED, handleAuthLoaded);\n    });\n    return new Promise((promiseResolver, promiseRejector) => {\n      resolve = promiseResolver;\n      reject = promiseRejector;\n    });\n  }\n  checkWalletReadiness() {\n    if (this.publicKey === null) {\n      throw new WalletNotConnectedError('`publicKey` is null. Did you forget to call `.connect()`?');\n    }\n  }\n}\n//# sourceMappingURL=fractal-wallet-adapter-impl.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}