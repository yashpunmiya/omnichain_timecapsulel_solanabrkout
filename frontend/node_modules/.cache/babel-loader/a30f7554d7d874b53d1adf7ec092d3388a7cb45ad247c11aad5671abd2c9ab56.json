{"ast":null,"code":"import { getJsonImage, getMetadataAvatarUri, getNftTokenUri, parseAvatarUri, parseNftUri, resolveAvatarUri } from './utils.js';\n/*\n * @description Parses an ENS avatar record.\n *\n * @example\n * parseAvatarRecord('eip155:1/erc1155:0xb32979486938aa9694bfc898f35dbed459f44424/10063')\n * 'https://ipfs.io/ipfs/QmSP4nq9fnN9dAiCj42ug9Wa79rqmQerZXZch82VqpiH7U/image.gif'\n *\n * @see https://docs.ens.domains/web/avatars\n *\n */\nexport async function parseAvatarRecord(client, {\n  gatewayUrls,\n  record\n}) {\n  if (/eip155:/i.test(record)) return parseNftAvatarUri(client, {\n    gatewayUrls,\n    record\n  });\n  return parseAvatarUri({\n    uri: record,\n    gatewayUrls\n  });\n}\nasync function parseNftAvatarUri(client, {\n  gatewayUrls,\n  record\n}) {\n  // parse NFT URI into properties\n  const nft = parseNftUri(record);\n  // fetch tokenURI from the NFT contract\n  const nftUri = await getNftTokenUri(client, {\n    nft\n  });\n  // resolve the URI from the fetched tokenURI\n  const {\n    uri: resolvedNftUri,\n    isOnChain,\n    isEncoded\n  } = resolveAvatarUri({\n    uri: nftUri,\n    gatewayUrls\n  });\n  // if the resolved URI is on chain, return the data\n  if (isOnChain && (resolvedNftUri.includes('data:application/json;base64,') || resolvedNftUri.startsWith('{'))) {\n    const encodedJson = isEncoded ?\n    // if it is encoded, decode it\n    atob(resolvedNftUri.replace('data:application/json;base64,', '')) :\n    // if it isn't encoded assume it is a JSON string, but it could be anything (it will error if it is)\n    resolvedNftUri;\n    const decoded = JSON.parse(encodedJson);\n    return parseAvatarUri({\n      uri: getJsonImage(decoded),\n      gatewayUrls\n    });\n  }\n  let uriTokenId = nft.tokenID;\n  if (nft.namespace === 'erc1155') uriTokenId = uriTokenId.replace('0x', '').padStart(64, '0');\n  return getMetadataAvatarUri({\n    gatewayUrls,\n    uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId)\n  });\n}","map":{"version":3,"names":["getJsonImage","getMetadataAvatarUri","getNftTokenUri","parseAvatarUri","parseNftUri","resolveAvatarUri","parseAvatarRecord","client","gatewayUrls","record","test","parseNftAvatarUri","uri","nft","nftUri","resolvedNftUri","isOnChain","isEncoded","includes","startsWith","encodedJson","atob","replace","decoded","JSON","parse","uriTokenId","tokenID","namespace","padStart"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\viem\\utils\\ens\\avatar\\parseAvatarRecord.ts"],"sourcesContent":["import type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { AssetGatewayUrls } from '../../../types/ens.js'\n\nimport {\n  type GetJsonImageErrorType,\n  type GetMetadataAvatarUriErrorType,\n  type GetNftTokenUriErrorType,\n  type ParseAvatarUriErrorType,\n  type ParseNftUriErrorType,\n  type ResolveAvatarUriErrorType,\n  getJsonImage,\n  getMetadataAvatarUri,\n  getNftTokenUri,\n  parseAvatarUri,\n  parseNftUri,\n  resolveAvatarUri,\n} from './utils.js'\n\nexport type ParseAvatarRecordErrorType =\n  | ParseNftAvatarUriErrorType\n  | ParseAvatarUriErrorType\n  | ErrorType\n\n/*\n * @description Parses an ENS avatar record.\n *\n * @example\n * parseAvatarRecord('eip155:1/erc1155:0xb32979486938aa9694bfc898f35dbed459f44424/10063')\n * 'https://ipfs.io/ipfs/QmSP4nq9fnN9dAiCj42ug9Wa79rqmQerZXZch82VqpiH7U/image.gif'\n *\n * @see https://docs.ens.domains/web/avatars\n *\n */\nexport async function parseAvatarRecord<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  {\n    gatewayUrls,\n    record,\n  }: {\n    gatewayUrls?: AssetGatewayUrls | undefined\n    record: string\n  },\n): Promise<string> {\n  if (/eip155:/i.test(record))\n    return parseNftAvatarUri(client, { gatewayUrls, record })\n  return parseAvatarUri({ uri: record, gatewayUrls })\n}\n\ntype ParseNftAvatarUriErrorType =\n  | ParseNftUriErrorType\n  | GetNftTokenUriErrorType\n  | ResolveAvatarUriErrorType\n  | ParseAvatarUriErrorType\n  | GetJsonImageErrorType\n  | GetMetadataAvatarUriErrorType\n  | ErrorType\n\nasync function parseNftAvatarUri<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  {\n    gatewayUrls,\n    record,\n  }: {\n    gatewayUrls?: AssetGatewayUrls | undefined\n    record: string\n  },\n): Promise<string> {\n  // parse NFT URI into properties\n  const nft = parseNftUri(record)\n  // fetch tokenURI from the NFT contract\n  const nftUri = await getNftTokenUri(client, { nft })\n  // resolve the URI from the fetched tokenURI\n  const {\n    uri: resolvedNftUri,\n    isOnChain,\n    isEncoded,\n  } = resolveAvatarUri({ uri: nftUri, gatewayUrls })\n\n  // if the resolved URI is on chain, return the data\n  if (\n    isOnChain &&\n    (resolvedNftUri.includes('data:application/json;base64,') ||\n      resolvedNftUri.startsWith('{'))\n  ) {\n    const encodedJson = isEncoded\n      ? // if it is encoded, decode it\n        atob(resolvedNftUri.replace('data:application/json;base64,', ''))\n      : // if it isn't encoded assume it is a JSON string, but it could be anything (it will error if it is)\n        resolvedNftUri\n\n    const decoded = JSON.parse(encodedJson)\n    return parseAvatarUri({ uri: getJsonImage(decoded), gatewayUrls })\n  }\n\n  let uriTokenId = nft.tokenID\n  if (nft.namespace === 'erc1155')\n    uriTokenId = uriTokenId.replace('0x', '').padStart(64, '0')\n\n  return getMetadataAvatarUri({\n    gatewayUrls,\n    uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId),\n  })\n}\n"],"mappings":"AAMA,SAOEA,YAAY,EACZC,oBAAoB,EACpBC,cAAc,EACdC,cAAc,EACdC,WAAW,EACXC,gBAAgB,QACX,YAAY;AAOnB;;;;;;;;;;AAUA,OAAO,eAAeC,iBAAiBA,CACrCC,MAAgC,EAChC;EACEC,WAAW;EACXC;AAAM,CAIP;EAED,IAAI,UAAU,CAACC,IAAI,CAACD,MAAM,CAAC,EACzB,OAAOE,iBAAiB,CAACJ,MAAM,EAAE;IAAEC,WAAW;IAAEC;EAAM,CAAE,CAAC;EAC3D,OAAON,cAAc,CAAC;IAAES,GAAG,EAAEH,MAAM;IAAED;EAAW,CAAE,CAAC;AACrD;AAWA,eAAeG,iBAAiBA,CAC9BJ,MAAgC,EAChC;EACEC,WAAW;EACXC;AAAM,CAIP;EAED;EACA,MAAMI,GAAG,GAAGT,WAAW,CAACK,MAAM,CAAC;EAC/B;EACA,MAAMK,MAAM,GAAG,MAAMZ,cAAc,CAACK,MAAM,EAAE;IAAEM;EAAG,CAAE,CAAC;EACpD;EACA,MAAM;IACJD,GAAG,EAAEG,cAAc;IACnBC,SAAS;IACTC;EAAS,CACV,GAAGZ,gBAAgB,CAAC;IAAEO,GAAG,EAAEE,MAAM;IAAEN;EAAW,CAAE,CAAC;EAElD;EACA,IACEQ,SAAS,KACRD,cAAc,CAACG,QAAQ,CAAC,+BAA+B,CAAC,IACvDH,cAAc,CAACI,UAAU,CAAC,GAAG,CAAC,CAAC,EACjC;IACA,MAAMC,WAAW,GAAGH,SAAS;IACzB;IACAI,IAAI,CAACN,cAAc,CAACO,OAAO,CAAC,+BAA+B,EAAE,EAAE,CAAC,CAAC;IACjE;IACAP,cAAc;IAElB,MAAMQ,OAAO,GAAGC,IAAI,CAACC,KAAK,CAACL,WAAW,CAAC;IACvC,OAAOjB,cAAc,CAAC;MAAES,GAAG,EAAEZ,YAAY,CAACuB,OAAO,CAAC;MAAEf;IAAW,CAAE,CAAC;EACpE;EAEA,IAAIkB,UAAU,GAAGb,GAAG,CAACc,OAAO;EAC5B,IAAId,GAAG,CAACe,SAAS,KAAK,SAAS,EAC7BF,UAAU,GAAGA,UAAU,CAACJ,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,CAACO,QAAQ,CAAC,EAAE,EAAE,GAAG,CAAC;EAE7D,OAAO5B,oBAAoB,CAAC;IAC1BO,WAAW;IACXI,GAAG,EAAEG,cAAc,CAACO,OAAO,CAAC,aAAa,EAAEI,UAAU;GACtD,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}