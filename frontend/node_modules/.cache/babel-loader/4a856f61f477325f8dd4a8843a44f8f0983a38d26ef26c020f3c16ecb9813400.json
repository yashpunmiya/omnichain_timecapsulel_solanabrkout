{"ast":null,"code":"import { proxy, ref, snapshot, subscribe as sub } from 'valtio/vanilla';\nimport { subscribeKey as subKey } from 'valtio/vanilla/utils';\nimport { ConstantsUtil, getW3mThemeVariables } from '@reown/appkit-common';\nimport { MobileWalletUtil } from '../utils/MobileWallet.js';\nimport { StorageUtil } from '../utils/StorageUtil.js';\nimport { ApiController } from './ApiController.js';\nimport { ChainController } from './ChainController.js';\nimport { OptionsController } from './OptionsController.js';\nimport { RouterController } from './RouterController.js';\nimport { ThemeController } from './ThemeController.js';\nconst defaultActiveConnectors = {\n  eip155: undefined,\n  solana: undefined,\n  polkadot: undefined,\n  bip122: undefined\n};\n// -- State --------------------------------------------- //\nconst state = proxy({\n  allConnectors: [],\n  connectors: [],\n  activeConnector: undefined,\n  filterByNamespace: undefined,\n  activeConnectorIds: {\n    ...defaultActiveConnectors\n  }\n});\n// -- Controller ---------------------------------------- //\nexport const ConnectorController = {\n  state,\n  subscribe(callback) {\n    return sub(state, () => {\n      callback(state);\n    });\n  },\n  subscribeKey(key, callback) {\n    return subKey(state, key, callback);\n  },\n  initialize(namespaces) {\n    namespaces.forEach(namespace => {\n      const connectorId = StorageUtil.getConnectedConnectorId(namespace);\n      if (connectorId) {\n        this.setConnectorId(connectorId, namespace);\n      }\n    });\n  },\n  setActiveConnector(connector) {\n    if (connector) {\n      state.activeConnector = ref(connector);\n    }\n  },\n  setConnectors(connectors) {\n    const newConnectors = connectors.filter(newConnector => !state.allConnectors.some(existingConnector => existingConnector.id === newConnector.id && this.getConnectorName(existingConnector.name) === this.getConnectorName(newConnector.name) && existingConnector.chain === newConnector.chain));\n    /**\n     * We are reassigning the state of the proxy to a new array of new objects, this can cause issues. So it is better to use ref in this case.\n     * Check more about proxy on https://valtio.dev/docs/api/basic/proxy#Gotchas\n     * Check more about ref on https://valtio.dev/docs/api/basic/ref\n     */\n    newConnectors.forEach(connector => {\n      if (connector.type !== 'MULTI_CHAIN') {\n        state.allConnectors.push(ref(connector));\n      }\n    });\n    state.connectors = this.mergeMultiChainConnectors(state.allConnectors);\n  },\n  removeAdapter(namespace) {\n    state.allConnectors = state.allConnectors.filter(connector => connector.chain !== namespace);\n    state.connectors = this.mergeMultiChainConnectors(state.allConnectors);\n  },\n  mergeMultiChainConnectors(connectors) {\n    const connectorsByNameMap = this.generateConnectorMapByName(connectors);\n    const mergedConnectors = [];\n    connectorsByNameMap.forEach(keyConnectors => {\n      const firstItem = keyConnectors[0];\n      const isAuthConnector = firstItem?.id === ConstantsUtil.CONNECTOR_ID.AUTH;\n      if (keyConnectors.length > 1 && firstItem) {\n        mergedConnectors.push({\n          name: firstItem.name,\n          imageUrl: firstItem.imageUrl,\n          imageId: firstItem.imageId,\n          connectors: [...keyConnectors],\n          type: isAuthConnector ? 'AUTH' : 'MULTI_CHAIN',\n          // These values are just placeholders, we don't use them in multi-chain connector select screen\n          chain: 'eip155',\n          id: firstItem?.id || ''\n        });\n      } else if (firstItem) {\n        mergedConnectors.push(firstItem);\n      }\n    });\n    return mergedConnectors;\n  },\n  generateConnectorMapByName(connectors) {\n    const connectorsByNameMap = new Map();\n    connectors.forEach(connector => {\n      const {\n        name\n      } = connector;\n      const connectorName = this.getConnectorName(name);\n      if (!connectorName) {\n        return;\n      }\n      const connectorsByName = connectorsByNameMap.get(connectorName) || [];\n      const haveSameConnector = connectorsByName.find(c => c.chain === connector.chain);\n      if (!haveSameConnector) {\n        connectorsByName.push(connector);\n      }\n      connectorsByNameMap.set(connectorName, connectorsByName);\n    });\n    return connectorsByNameMap;\n  },\n  getConnectorName(name) {\n    if (!name) {\n      return name;\n    }\n    const nameOverrideMap = {\n      'Trust Wallet': 'Trust'\n    };\n    return nameOverrideMap[name] || name;\n  },\n  getUniqueConnectorsByName(connectors) {\n    const uniqueConnectors = [];\n    connectors.forEach(c => {\n      if (!uniqueConnectors.find(uc => uc.chain === c.chain)) {\n        uniqueConnectors.push(c);\n      }\n    });\n    return uniqueConnectors;\n  },\n  addConnector(connector) {\n    if (connector.id === ConstantsUtil.CONNECTOR_ID.AUTH) {\n      const authConnector = connector;\n      const optionsState = snapshot(OptionsController.state);\n      const themeMode = ThemeController.getSnapshot().themeMode;\n      const themeVariables = ThemeController.getSnapshot().themeVariables;\n      authConnector?.provider?.syncDappData?.({\n        metadata: optionsState.metadata,\n        sdkVersion: optionsState.sdkVersion,\n        projectId: optionsState.projectId,\n        sdkType: optionsState.sdkType\n      });\n      authConnector?.provider?.syncTheme({\n        themeMode,\n        themeVariables,\n        w3mThemeVariables: getW3mThemeVariables(themeVariables, themeMode)\n      });\n      this.setConnectors([connector]);\n    } else {\n      this.setConnectors([connector]);\n    }\n  },\n  getAuthConnector(chainNamespace) {\n    const activeNamespace = chainNamespace || ChainController.state.activeChain;\n    const authConnector = state.connectors.find(c => c.id === ConstantsUtil.CONNECTOR_ID.AUTH);\n    if (!authConnector) {\n      return undefined;\n    }\n    if (authConnector?.connectors?.length) {\n      const connector = authConnector.connectors.find(c => c.chain === activeNamespace);\n      return connector;\n    }\n    return authConnector;\n  },\n  getAnnouncedConnectorRdns() {\n    return state.connectors.filter(c => c.type === 'ANNOUNCED').map(c => c.info?.rdns);\n  },\n  getConnectorById(id) {\n    return state.allConnectors.find(c => c.id === id);\n  },\n  getConnector(id, rdns) {\n    const connectorsByNamespace = state.allConnectors.filter(c => c.chain === ChainController.state.activeChain);\n    return connectorsByNamespace.find(c => c.explorerId === id || c.info?.rdns === rdns);\n  },\n  syncIfAuthConnector(connector) {\n    if (connector.id !== 'ID_AUTH') {\n      return;\n    }\n    const authConnector = connector;\n    const optionsState = snapshot(OptionsController.state);\n    const themeMode = ThemeController.getSnapshot().themeMode;\n    const themeVariables = ThemeController.getSnapshot().themeVariables;\n    authConnector?.provider?.syncDappData?.({\n      metadata: optionsState.metadata,\n      sdkVersion: optionsState.sdkVersion,\n      sdkType: optionsState.sdkType,\n      projectId: optionsState.projectId\n    });\n    authConnector.provider.syncTheme({\n      themeMode,\n      themeVariables,\n      w3mThemeVariables: getW3mThemeVariables(themeVariables, themeMode)\n    });\n  },\n  /**\n   * Returns the connectors filtered by namespace.\n   * @param namespace - The namespace to filter the connectors by.\n   * @returns ConnectorWithProviders[].\n   */\n  getConnectorsByNamespace(namespace) {\n    const namespaceConnectors = state.allConnectors.filter(connector => connector.chain === namespace);\n    return this.mergeMultiChainConnectors(namespaceConnectors);\n  },\n  selectWalletConnector(wallet) {\n    const connector = ConnectorController.getConnector(wallet.id, wallet.rdns);\n    if (ChainController.state.activeChain === ConstantsUtil.CHAIN.SOLANA) {\n      MobileWalletUtil.handleSolanaDeeplinkRedirect(connector?.name || wallet.name || '');\n    }\n    if (connector) {\n      RouterController.push('ConnectingExternal', {\n        connector\n      });\n    } else {\n      RouterController.push('ConnectingWalletConnect', {\n        wallet\n      });\n    }\n  },\n  /**\n   * Returns the connectors. If a namespace is provided, the connectors are filtered by namespace.\n   * @param namespace - The namespace to filter the connectors by. If not provided, all connectors are returned.\n   * @returns ConnectorWithProviders[].\n   */\n  getConnectors(namespace) {\n    if (namespace) {\n      return this.getConnectorsByNamespace(namespace);\n    }\n    return this.mergeMultiChainConnectors(state.allConnectors);\n  },\n  /**\n   * Sets the filter by namespace and updates the connectors.\n   * @param namespace - The namespace to filter the connectors by.\n   */\n  setFilterByNamespace(namespace) {\n    state.filterByNamespace = namespace;\n    state.connectors = this.getConnectors(namespace);\n    ApiController.setFilterByNamespace(namespace);\n  },\n  setConnectorId(connectorId, namespace) {\n    if (connectorId) {\n      state.activeConnectorIds = {\n        ...state.activeConnectorIds,\n        [namespace]: connectorId\n      };\n      StorageUtil.setConnectedConnectorId(namespace, connectorId);\n    }\n  },\n  removeConnectorId(namespace) {\n    state.activeConnectorIds = {\n      ...state.activeConnectorIds,\n      [namespace]: undefined\n    };\n    StorageUtil.deleteConnectedConnectorId(namespace);\n  },\n  getConnectorId(namespace) {\n    if (!namespace) {\n      return undefined;\n    }\n    return state.activeConnectorIds[namespace];\n  },\n  isConnected(namespace) {\n    if (!namespace) {\n      return Object.values(state.activeConnectorIds).some(id => Boolean(id));\n    }\n    return Boolean(state.activeConnectorIds[namespace]);\n  },\n  resetConnectorIds() {\n    state.activeConnectorIds = {\n      ...defaultActiveConnectors\n    };\n  }\n};\n//# sourceMappingURL=ConnectorController.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}