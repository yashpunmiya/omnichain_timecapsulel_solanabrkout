{"ast":null,"code":"/*!\n * Draggabilly v3.0.0\n * Make that shiz draggable\n * https://draggabilly.desandro.com\n * MIT license\n */\n\n(function (window, factory) {\n  // universal module definition\n  if (typeof module == 'object' && module.exports) {\n    // CommonJS\n    module.exports = factory(window, require('get-size'), require('unidragger'));\n  } else {\n    // browser global\n    window.Draggabilly = factory(window, window.getSize, window.Unidragger);\n  }\n})(typeof window != 'undefined' ? window : this, function factory(window, getSize, Unidragger) {\n  // -------------------------- helpers & variables -------------------------- //\n\n  function noop() {}\n  let jQuery = window.jQuery;\n\n  // -------------------------- Draggabilly -------------------------- //\n\n  function Draggabilly(element, options) {\n    // querySelector if string\n    this.element = typeof element == 'string' ? document.querySelector(element) : element;\n    if (jQuery) {\n      this.$element = jQuery(this.element);\n    }\n\n    // options\n    this.options = {};\n    this.option(options);\n    this._create();\n  }\n\n  // inherit Unidragger methods\n  let proto = Draggabilly.prototype = Object.create(Unidragger.prototype);\n\n  /**\n   * set options\n   * @param {Object} opts\n   */\n  proto.option = function (opts) {\n    this.options = {\n      ...this.options,\n      ...opts\n    };\n  };\n\n  // css position values that don't need to be set\n  const positionValues = ['relative', 'absolute', 'fixed'];\n  proto._create = function () {\n    // properties\n    this.position = {};\n    this._getPosition();\n    this.startPoint = {\n      x: 0,\n      y: 0\n    };\n    this.dragPoint = {\n      x: 0,\n      y: 0\n    };\n    this.startPosition = {\n      ...this.position\n    };\n\n    // set relative positioning\n    let style = getComputedStyle(this.element);\n    if (!positionValues.includes(style.position)) {\n      this.element.style.position = 'relative';\n    }\n\n    // events\n    this.on('pointerDown', this.handlePointerDown);\n    this.on('pointerUp', this.handlePointerUp);\n    this.on('dragStart', this.handleDragStart);\n    this.on('dragMove', this.handleDragMove);\n    this.on('dragEnd', this.handleDragEnd);\n    this.setHandles();\n    this.enable();\n  };\n\n  // set this.handles  and bind start events to 'em\n  proto.setHandles = function () {\n    let {\n      handle\n    } = this.options;\n    if (typeof handle == 'string') {\n      this.handles = this.element.querySelectorAll(handle);\n    } else if (typeof handle == 'object' && handle.length) {\n      this.handles = handle;\n    } else if (handle instanceof HTMLElement) {\n      this.handles = [handle];\n    } else {\n      this.handles = [this.element];\n    }\n  };\n  const cancelableEvents = ['dragStart', 'dragMove', 'dragEnd'];\n\n  // duck-punch emitEvent to dispatch jQuery events as well\n  let emitEvent = proto.emitEvent;\n  proto.emitEvent = function (eventName, args) {\n    // do not emit cancelable events if dragging is disabled\n    let isCanceled = !this.isEnabled && cancelableEvents.includes(eventName);\n    if (isCanceled) return;\n    emitEvent.call(this, eventName, args);\n\n    // trigger jQuery event\n    let jquery = window.jQuery;\n    if (!jquery || !this.$element) return;\n    // create jQuery event\n    let event;\n    let jqArgs = args;\n    let isFirstArgEvent = args && args[0] instanceof Event;\n    if (isFirstArgEvent) [event, ...jqArgs] = args;\n    /* eslint-disable-next-line new-cap */\n    let $event = jquery.Event(event);\n    $event.type = eventName;\n    this.$element.trigger($event, jqArgs);\n  };\n\n  // -------------------------- position -------------------------- //\n\n  // get x/y position from style\n  proto._getPosition = function () {\n    let style = getComputedStyle(this.element);\n    let x = this._getPositionCoord(style.left, 'width');\n    let y = this._getPositionCoord(style.top, 'height');\n    // clean up 'auto' or other non-integer values\n    this.position.x = isNaN(x) ? 0 : x;\n    this.position.y = isNaN(y) ? 0 : y;\n    this._addTransformPosition(style);\n  };\n  proto._getPositionCoord = function (styleSide, measure) {\n    if (styleSide.includes('%')) {\n      // convert percent into pixel for Safari, #75\n      let parentSize = getSize(this.element.parentNode);\n      // prevent not-in-DOM element throwing bug, #131\n      return !parentSize ? 0 : parseFloat(styleSide) / 100 * parentSize[measure];\n    }\n    return parseInt(styleSide, 10);\n  };\n\n  // add transform: translate( x, y ) to position\n  proto._addTransformPosition = function (style) {\n    let transform = style.transform;\n    // bail out if value is 'none'\n    if (!transform.startsWith('matrix')) return;\n\n    // split matrix(1, 0, 0, 1, x, y)\n    let matrixValues = transform.split(',');\n    // translate X value is in 12th or 4th position\n    let xIndex = transform.startsWith('matrix3d') ? 12 : 4;\n    let translateX = parseInt(matrixValues[xIndex], 10);\n    // translate Y value is in 13th or 5th position\n    let translateY = parseInt(matrixValues[xIndex + 1], 10);\n    this.position.x += translateX;\n    this.position.y += translateY;\n  };\n\n  // -------------------------- events -------------------------- //\n\n  proto.handlePointerDown = function (event, pointer) {\n    if (!this.isEnabled) return;\n    // track start event position\n    // Safari 9 overrides pageX and pageY. These values needs to be copied. flickity#842\n    this.pointerDownPointer = {\n      pageX: pointer.pageX,\n      pageY: pointer.pageY\n    };\n    event.preventDefault();\n    document.activeElement.blur();\n    // bind move and end events\n    this.bindActivePointerEvents(event);\n    this.element.classList.add('is-pointer-down');\n  };\n  proto.handleDragStart = function () {\n    if (!this.isEnabled) return;\n    this._getPosition();\n    this.measureContainment();\n    // position _when_ drag began\n    this.startPosition.x = this.position.x;\n    this.startPosition.y = this.position.y;\n    // reset left/top style\n    this.setLeftTop();\n    this.dragPoint.x = 0;\n    this.dragPoint.y = 0;\n    this.element.classList.add('is-dragging');\n    // start animation\n    this.animate();\n  };\n  proto.measureContainment = function () {\n    let container = this.getContainer();\n    if (!container) return;\n    let elemSize = getSize(this.element);\n    let containerSize = getSize(container);\n    let {\n      borderLeftWidth,\n      borderRightWidth,\n      borderTopWidth,\n      borderBottomWidth\n    } = containerSize;\n    let elemRect = this.element.getBoundingClientRect();\n    let containerRect = container.getBoundingClientRect();\n    let borderSizeX = borderLeftWidth + borderRightWidth;\n    let borderSizeY = borderTopWidth + borderBottomWidth;\n    let position = this.relativeStartPosition = {\n      x: elemRect.left - (containerRect.left + borderLeftWidth),\n      y: elemRect.top - (containerRect.top + borderTopWidth)\n    };\n    this.containSize = {\n      width: containerSize.width - borderSizeX - position.x - elemSize.width,\n      height: containerSize.height - borderSizeY - position.y - elemSize.height\n    };\n  };\n  proto.getContainer = function () {\n    let containment = this.options.containment;\n    if (!containment) return;\n    let isElement = containment instanceof HTMLElement;\n    // use as element\n    if (isElement) return containment;\n\n    // querySelector if string\n    if (typeof containment == 'string') {\n      return document.querySelector(containment);\n    }\n    // fallback to parent element\n    return this.element.parentNode;\n  };\n\n  // ----- move event ----- //\n\n  /**\n   * drag move\n   * @param {Event} event\n   * @param {Event | Touch} pointer\n   * @param {Object} moveVector - x and y coordinates\n   */\n  proto.handleDragMove = function (event, pointer, moveVector) {\n    if (!this.isEnabled) return;\n    let dragX = moveVector.x;\n    let dragY = moveVector.y;\n    let grid = this.options.grid;\n    let gridX = grid && grid[0];\n    let gridY = grid && grid[1];\n    dragX = applyGrid(dragX, gridX);\n    dragY = applyGrid(dragY, gridY);\n    dragX = this.containDrag('x', dragX, gridX);\n    dragY = this.containDrag('y', dragY, gridY);\n\n    // constrain to axis\n    dragX = this.options.axis == 'y' ? 0 : dragX;\n    dragY = this.options.axis == 'x' ? 0 : dragY;\n    this.position.x = this.startPosition.x + dragX;\n    this.position.y = this.startPosition.y + dragY;\n    // set dragPoint properties\n    this.dragPoint.x = dragX;\n    this.dragPoint.y = dragY;\n  };\n  function applyGrid(value, grid, method) {\n    if (!grid) return value;\n    method = method || 'round';\n    return Math[method](value / grid) * grid;\n  }\n  proto.containDrag = function (axis, drag, grid) {\n    if (!this.options.containment) return drag;\n    let measure = axis == 'x' ? 'width' : 'height';\n    let rel = this.relativeStartPosition[axis];\n    let min = applyGrid(-rel, grid, 'ceil');\n    let max = this.containSize[measure];\n    max = applyGrid(max, grid, 'floor');\n    return Math.max(min, Math.min(max, drag));\n  };\n\n  // ----- end event ----- //\n\n  proto.handlePointerUp = function () {\n    this.element.classList.remove('is-pointer-down');\n  };\n  proto.handleDragEnd = function () {\n    if (!this.isEnabled) return;\n\n    // use top left position when complete\n    this.element.style.transform = '';\n    this.setLeftTop();\n    this.element.classList.remove('is-dragging');\n  };\n\n  // -------------------------- animation -------------------------- //\n\n  proto.animate = function () {\n    // only render and animate if dragging\n    if (!this.isDragging) return;\n    this.positionDrag();\n    requestAnimationFrame(() => this.animate());\n  };\n\n  // left/top positioning\n  proto.setLeftTop = function () {\n    let {\n      x,\n      y\n    } = this.position;\n    this.element.style.left = `${x}px`;\n    this.element.style.top = `${y}px`;\n  };\n  proto.positionDrag = function () {\n    let {\n      x,\n      y\n    } = this.dragPoint;\n    this.element.style.transform = `translate3d(${x}px, ${y}px, 0)`;\n  };\n\n  // ----- methods ----- //\n\n  /**\n   * @param {Number} x\n   * @param {Number} y\n   */\n  proto.setPosition = function (x, y) {\n    this.position.x = x;\n    this.position.y = y;\n    this.setLeftTop();\n  };\n  proto.enable = function () {\n    if (this.isEnabled) return;\n    this.isEnabled = true;\n    this.bindHandles();\n  };\n  proto.disable = function () {\n    if (!this.isEnabled) return;\n    this.isEnabled = false;\n    if (this.isDragging) this.dragEnd();\n    this.unbindHandles();\n  };\n  const resetCssProperties = ['transform', 'left', 'top', 'position'];\n  proto.destroy = function () {\n    this.disable();\n    // reset styles\n    resetCssProperties.forEach(prop => {\n      this.element.style[prop] = '';\n    });\n    // unbind handles\n    this.unbindHandles();\n    // remove jQuery data\n    if (this.$element) this.$element.removeData('draggabilly');\n  };\n\n  // ----- jQuery bridget ----- //\n\n  // required for jQuery bridget\n  proto._init = noop;\n  if (jQuery && jQuery.bridget) {\n    jQuery.bridget('draggabilly', Draggabilly);\n  }\n\n  // -----  ----- //\n\n  return Draggabilly;\n});","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}