{"ast":null,"code":"import { sha256 } from 'ethereum-cryptography/sha256.js';\nimport { utf8ToBytes } from './bytes.js';\n/**\n * These utilities for constructing blobs are borrowed from https://github.com/Inphi/eip4844-interop.git\n */\nconst BYTES_PER_FIELD_ELEMENT = 32;\nconst FIELD_ELEMENTS_PER_BLOB = 4096;\nconst USEFUL_BYTES_PER_BLOB = 32 * FIELD_ELEMENTS_PER_BLOB;\nconst MAX_BLOBS_PER_TX = 2;\nconst MAX_USEFUL_BYTES_PER_TX = USEFUL_BYTES_PER_BLOB * MAX_BLOBS_PER_TX - 1;\nconst BLOB_SIZE = BYTES_PER_FIELD_ELEMENT * FIELD_ELEMENTS_PER_BLOB;\nfunction get_padded(data, blobs_len) {\n  const pdata = new Uint8Array(blobs_len * USEFUL_BYTES_PER_BLOB).fill(0);\n  pdata.set(data);\n  pdata[data.byteLength] = 0x80;\n  return pdata;\n}\nfunction get_blob(data) {\n  const blob = new Uint8Array(BLOB_SIZE);\n  for (let i = 0; i < FIELD_ELEMENTS_PER_BLOB; i++) {\n    const chunk = new Uint8Array(32);\n    chunk.set(data.subarray(i * 31, (i + 1) * 31), 0);\n    blob.set(chunk, i * 32);\n  }\n  return blob;\n}\nexport const getBlobs = input => {\n  const data = utf8ToBytes(input);\n  const len = data.byteLength;\n  if (len === 0) {\n    throw Error('invalid blob data');\n  }\n  if (len > MAX_USEFUL_BYTES_PER_TX) {\n    throw Error('blob data is too large');\n  }\n  const blobs_len = Math.ceil(len / USEFUL_BYTES_PER_BLOB);\n  const pdata = get_padded(data, blobs_len);\n  const blobs = [];\n  for (let i = 0; i < blobs_len; i++) {\n    const chunk = pdata.subarray(i * USEFUL_BYTES_PER_BLOB, (i + 1) * USEFUL_BYTES_PER_BLOB);\n    const blob = get_blob(chunk);\n    blobs.push(blob);\n  }\n  return blobs;\n};\nexport const blobsToCommitments = (kzg, blobs) => {\n  const commitments = [];\n  for (const blob of blobs) {\n    commitments.push(kzg.blobToKzgCommitment(blob));\n  }\n  return commitments;\n};\nexport const blobsToProofs = (kzg, blobs, commitments) => {\n  const proofs = blobs.map((blob, ctx) => kzg.computeBlobKzgProof(blob, commitments[ctx]));\n  return proofs;\n};\n/**\n * Converts a vector commitment for a given data blob to its versioned hash.  For 4844, this version\n * number will be 0x01 for KZG vector commitments but could be different if future vector commitment\n * types are introduced\n * @param commitment a vector commitment to a blob\n * @param blobCommitmentVersion the version number corresponding to the type of vector commitment\n * @returns a versioned hash corresponding to a given blob vector commitment\n */\nexport const computeVersionedHash = (commitment, blobCommitmentVersion) => {\n  const computedVersionedHash = new Uint8Array(32);\n  computedVersionedHash.set([blobCommitmentVersion], 0);\n  computedVersionedHash.set(sha256(commitment).subarray(1), 1);\n  return computedVersionedHash;\n};\n/**\n * Generate an array of versioned hashes from corresponding kzg commitments\n * @param commitments array of kzg commitments\n * @returns array of versioned hashes\n * Note: assumes KZG commitments (version 1 version hashes)\n */\nexport const commitmentsToVersionedHashes = commitments => {\n  const hashes = [];\n  for (const commitment of commitments) {\n    hashes.push(computeVersionedHash(commitment, 0x01));\n  }\n  return hashes;\n};\n//# sourceMappingURL=blobs.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}