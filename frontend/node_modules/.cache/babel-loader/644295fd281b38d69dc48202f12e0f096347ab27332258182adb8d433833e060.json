{"ast":null,"code":"import { WalletNotConnectedError, WalletNotReadyError, WalletReadyState } from '@solana/wallet-adapter-base';\nimport React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { WalletNotSelectedError } from './errors.js';\nimport { WalletContext } from './useWallet.js';\nexport function WalletProviderBase({\n  children,\n  wallets: adapters,\n  adapter,\n  isUnloadingRef,\n  onAutoConnectRequest,\n  onConnectError,\n  onError,\n  onSelectWallet\n}) {\n  const isConnectingRef = useRef(false);\n  const [connecting, setConnecting] = useState(false);\n  const isDisconnectingRef = useRef(false);\n  const [disconnecting, setDisconnecting] = useState(false);\n  const [publicKey, setPublicKey] = useState(() => adapter?.publicKey ?? null);\n  const [connected, setConnected] = useState(() => adapter?.connected ?? false);\n  /**\n   * Store the error handlers as refs so that a change in the\n   * custom error handler does not recompute other dependencies.\n   */\n  const onErrorRef = useRef(onError);\n  useEffect(() => {\n    onErrorRef.current = onError;\n    return () => {\n      onErrorRef.current = undefined;\n    };\n  }, [onError]);\n  const handleErrorRef = useRef((error, adapter) => {\n    if (!isUnloadingRef.current) {\n      if (onErrorRef.current) {\n        onErrorRef.current(error, adapter);\n      } else {\n        console.error(error, adapter);\n        if (error instanceof WalletNotReadyError && typeof window !== 'undefined' && adapter) {\n          window.open(adapter.url, '_blank');\n        }\n      }\n    }\n    return error;\n  });\n  // Wrap adapters to conform to the `Wallet` interface\n  const [wallets, setWallets] = useState(() => adapters.map(adapter => ({\n    adapter,\n    readyState: adapter.readyState\n  })).filter(({\n    readyState\n  }) => readyState !== WalletReadyState.Unsupported));\n  // When the adapters change, start to listen for changes to their `readyState`\n  useEffect(() => {\n    // When the adapters change, wrap them to conform to the `Wallet` interface\n    setWallets(wallets => adapters.map((adapter, index) => {\n      const wallet = wallets[index];\n      // If the wallet hasn't changed, return the same instance\n      return wallet && wallet.adapter === adapter && wallet.readyState === adapter.readyState ? wallet : {\n        adapter: adapter,\n        readyState: adapter.readyState\n      };\n    }).filter(({\n      readyState\n    }) => readyState !== WalletReadyState.Unsupported));\n    function handleReadyStateChange(readyState) {\n      setWallets(prevWallets => {\n        const index = prevWallets.findIndex(({\n          adapter\n        }) => adapter === this);\n        if (index === -1) return prevWallets;\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const {\n          adapter\n        } = prevWallets[index];\n        return [...prevWallets.slice(0, index), {\n          adapter,\n          readyState\n        }, ...prevWallets.slice(index + 1)].filter(({\n          readyState\n        }) => readyState !== WalletReadyState.Unsupported);\n      });\n    }\n    adapters.forEach(adapter => adapter.on('readyStateChange', handleReadyStateChange, adapter));\n    return () => {\n      adapters.forEach(adapter => adapter.off('readyStateChange', handleReadyStateChange, adapter));\n    };\n  }, [adapter, adapters]);\n  const wallet = useMemo(() => wallets.find(wallet => wallet.adapter === adapter) ?? null, [adapter, wallets]);\n  // Setup and teardown event listeners when the adapter changes\n  useEffect(() => {\n    if (!adapter) return;\n    const handleConnect = publicKey => {\n      setPublicKey(publicKey);\n      isConnectingRef.current = false;\n      setConnecting(false);\n      setConnected(true);\n      isDisconnectingRef.current = false;\n      setDisconnecting(false);\n    };\n    const handleDisconnect = () => {\n      if (isUnloadingRef.current) return;\n      setPublicKey(null);\n      isConnectingRef.current = false;\n      setConnecting(false);\n      setConnected(false);\n      isDisconnectingRef.current = false;\n      setDisconnecting(false);\n    };\n    const handleError = error => {\n      handleErrorRef.current(error, adapter);\n    };\n    adapter.on('connect', handleConnect);\n    adapter.on('disconnect', handleDisconnect);\n    adapter.on('error', handleError);\n    return () => {\n      adapter.off('connect', handleConnect);\n      adapter.off('disconnect', handleDisconnect);\n      adapter.off('error', handleError);\n      handleDisconnect();\n    };\n  }, [adapter, isUnloadingRef]);\n  // When the adapter changes, clear the `autoConnect` tracking flag\n  const didAttemptAutoConnectRef = useRef(false);\n  useEffect(() => {\n    return () => {\n      didAttemptAutoConnectRef.current = false;\n    };\n  }, [adapter]);\n  // If auto-connect is enabled, request to connect when the adapter changes and is ready\n  useEffect(() => {\n    if (didAttemptAutoConnectRef.current || isConnectingRef.current || connected || !onAutoConnectRequest || !(wallet?.readyState === WalletReadyState.Installed || wallet?.readyState === WalletReadyState.Loadable)) return;\n    isConnectingRef.current = true;\n    setConnecting(true);\n    didAttemptAutoConnectRef.current = true;\n    (async function () {\n      try {\n        await onAutoConnectRequest();\n      } catch {\n        onConnectError();\n        // Drop the error. It will be caught by `handleError` anyway.\n      } finally {\n        setConnecting(false);\n        isConnectingRef.current = false;\n      }\n    })();\n  }, [connected, onAutoConnectRequest, onConnectError, wallet]);\n  // Send a transaction using the provided connection\n  const sendTransaction = useCallback(async (transaction, connection, options) => {\n    if (!adapter) throw handleErrorRef.current(new WalletNotSelectedError());\n    if (!connected) throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n    return await adapter.sendTransaction(transaction, connection, options);\n  }, [adapter, connected]);\n  // Sign a transaction if the wallet supports it\n  const signTransaction = useMemo(() => adapter && 'signTransaction' in adapter ? async transaction => {\n    if (!connected) throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n    return await adapter.signTransaction(transaction);\n  } : undefined, [adapter, connected]);\n  // Sign multiple transactions if the wallet supports it\n  const signAllTransactions = useMemo(() => adapter && 'signAllTransactions' in adapter ? async transactions => {\n    if (!connected) throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n    return await adapter.signAllTransactions(transactions);\n  } : undefined, [adapter, connected]);\n  // Sign an arbitrary message if the wallet supports it\n  const signMessage = useMemo(() => adapter && 'signMessage' in adapter ? async message => {\n    if (!connected) throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n    return await adapter.signMessage(message);\n  } : undefined, [adapter, connected]);\n  // Sign in if the wallet supports it\n  const signIn = useMemo(() => adapter && 'signIn' in adapter ? async input => {\n    return await adapter.signIn(input);\n  } : undefined, [adapter]);\n  const handleConnect = useCallback(async () => {\n    if (isConnectingRef.current || isDisconnectingRef.current || wallet?.adapter.connected) return;\n    if (!wallet) throw handleErrorRef.current(new WalletNotSelectedError());\n    const {\n      adapter,\n      readyState\n    } = wallet;\n    if (!(readyState === WalletReadyState.Installed || readyState === WalletReadyState.Loadable)) throw handleErrorRef.current(new WalletNotReadyError(), adapter);\n    isConnectingRef.current = true;\n    setConnecting(true);\n    try {\n      await adapter.connect();\n    } catch (e) {\n      onConnectError();\n      throw e;\n    } finally {\n      setConnecting(false);\n      isConnectingRef.current = false;\n    }\n  }, [onConnectError, wallet]);\n  const handleDisconnect = useCallback(async () => {\n    if (isDisconnectingRef.current) return;\n    if (!adapter) return;\n    isDisconnectingRef.current = true;\n    setDisconnecting(true);\n    try {\n      await adapter.disconnect();\n    } finally {\n      setDisconnecting(false);\n      isDisconnectingRef.current = false;\n    }\n  }, [adapter]);\n  return React.createElement(WalletContext.Provider, {\n    value: {\n      autoConnect: !!onAutoConnectRequest,\n      wallets,\n      wallet,\n      publicKey,\n      connected,\n      connecting,\n      disconnecting,\n      select: onSelectWallet,\n      connect: handleConnect,\n      disconnect: handleDisconnect,\n      sendTransaction,\n      signTransaction,\n      signAllTransactions,\n      signMessage,\n      signIn\n    }\n  }, children);\n}","map":{"version":3,"names":["WalletNotConnectedError","WalletNotReadyError","WalletReadyState","React","useCallback","useEffect","useMemo","useRef","useState","WalletNotSelectedError","WalletContext","WalletProviderBase","children","wallets","adapters","adapter","isUnloadingRef","onAutoConnectRequest","onConnectError","onError","onSelectWallet","isConnectingRef","connecting","setConnecting","isDisconnectingRef","disconnecting","setDisconnecting","publicKey","setPublicKey","connected","setConnected","onErrorRef","current","undefined","handleErrorRef","error","console","window","open","url","setWallets","map","readyState","filter","Unsupported","index","wallet","handleReadyStateChange","prevWallets","findIndex","slice","forEach","on","off","find","handleConnect","handleDisconnect","handleError","didAttemptAutoConnectRef","Installed","Loadable","sendTransaction","transaction","connection","options","signTransaction","signAllTransactions","transactions","signMessage","message","signIn","input","connect","e","disconnect","createElement","Provider","value","autoConnect","select"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@solana\\wallet-adapter-react\\src\\WalletProviderBase.tsx"],"sourcesContent":["import {\n    type Adapter,\n    type MessageSignerWalletAdapterProps,\n    type SignerWalletAdapterProps,\n    type SignInMessageSignerWalletAdapterProps,\n    type WalletAdapterProps,\n    type WalletError,\n    type WalletName,\n    WalletNotConnectedError,\n    WalletNotReadyError,\n    WalletReadyState,\n} from '@solana/wallet-adapter-base';\nimport { type PublicKey } from '@solana/web3.js';\nimport React, { type ReactNode, useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { WalletNotSelectedError } from './errors.js';\nimport { WalletContext } from './useWallet.js';\n\nexport interface WalletProviderBaseProps {\n    children: ReactNode;\n    wallets: Adapter[];\n    adapter: Adapter | null;\n    isUnloadingRef: React.RefObject<boolean>;\n    // NOTE: The presence/absence of this handler implies that auto-connect is enabled/disabled.\n    onAutoConnectRequest?: () => Promise<void>;\n    onConnectError: () => void;\n    onError?: (error: WalletError, adapter?: Adapter) => void;\n    onSelectWallet: (walletName: WalletName | null) => void;\n}\n\nexport function WalletProviderBase({\n    children,\n    wallets: adapters,\n    adapter,\n    isUnloadingRef,\n    onAutoConnectRequest,\n    onConnectError,\n    onError,\n    onSelectWallet,\n}: WalletProviderBaseProps) {\n    const isConnectingRef = useRef(false);\n    const [connecting, setConnecting] = useState(false);\n    const isDisconnectingRef = useRef(false);\n    const [disconnecting, setDisconnecting] = useState(false);\n    const [publicKey, setPublicKey] = useState(() => adapter?.publicKey ?? null);\n    const [connected, setConnected] = useState(() => adapter?.connected ?? false);\n\n    /**\n     * Store the error handlers as refs so that a change in the\n     * custom error handler does not recompute other dependencies.\n     */\n    const onErrorRef = useRef(onError);\n    useEffect(() => {\n        onErrorRef.current = onError;\n        return () => {\n            onErrorRef.current = undefined;\n        };\n    }, [onError]);\n    const handleErrorRef = useRef((error: WalletError, adapter?: Adapter) => {\n        if (!isUnloadingRef.current) {\n            if (onErrorRef.current) {\n                onErrorRef.current(error, adapter);\n            } else {\n                console.error(error, adapter);\n                if (error instanceof WalletNotReadyError && typeof window !== 'undefined' && adapter) {\n                    window.open(adapter.url, '_blank');\n                }\n            }\n        }\n        return error;\n    });\n\n    // Wrap adapters to conform to the `Wallet` interface\n    const [wallets, setWallets] = useState(() =>\n        adapters\n            .map((adapter) => ({\n                adapter,\n                readyState: adapter.readyState,\n            }))\n            .filter(({ readyState }) => readyState !== WalletReadyState.Unsupported)\n    );\n\n    // When the adapters change, start to listen for changes to their `readyState`\n    useEffect(() => {\n        // When the adapters change, wrap them to conform to the `Wallet` interface\n        setWallets((wallets) =>\n            adapters\n                .map((adapter, index) => {\n                    const wallet = wallets[index];\n                    // If the wallet hasn't changed, return the same instance\n                    return wallet && wallet.adapter === adapter && wallet.readyState === adapter.readyState\n                        ? wallet\n                        : {\n                              adapter: adapter,\n                              readyState: adapter.readyState,\n                          };\n                })\n                .filter(({ readyState }) => readyState !== WalletReadyState.Unsupported)\n        );\n        function handleReadyStateChange(this: Adapter, readyState: WalletReadyState) {\n            setWallets((prevWallets) => {\n                const index = prevWallets.findIndex(({ adapter }) => adapter === this);\n                if (index === -1) return prevWallets;\n\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const { adapter } = prevWallets[index]!;\n                return [\n                    ...prevWallets.slice(0, index),\n                    { adapter, readyState },\n                    ...prevWallets.slice(index + 1),\n                ].filter(({ readyState }) => readyState !== WalletReadyState.Unsupported);\n            });\n        }\n        adapters.forEach((adapter) => adapter.on('readyStateChange', handleReadyStateChange, adapter));\n        return () => {\n            adapters.forEach((adapter) => adapter.off('readyStateChange', handleReadyStateChange, adapter));\n        };\n    }, [adapter, adapters]);\n\n    const wallet = useMemo(() => wallets.find((wallet) => wallet.adapter === adapter) ?? null, [adapter, wallets]);\n\n    // Setup and teardown event listeners when the adapter changes\n    useEffect(() => {\n        if (!adapter) return;\n\n        const handleConnect = (publicKey: PublicKey) => {\n            setPublicKey(publicKey);\n            isConnectingRef.current = false;\n            setConnecting(false);\n            setConnected(true);\n            isDisconnectingRef.current = false;\n            setDisconnecting(false);\n        };\n\n        const handleDisconnect = () => {\n            if (isUnloadingRef.current) return;\n\n            setPublicKey(null);\n            isConnectingRef.current = false;\n            setConnecting(false);\n            setConnected(false);\n            isDisconnectingRef.current = false;\n            setDisconnecting(false);\n        };\n\n        const handleError = (error: WalletError) => {\n            handleErrorRef.current(error, adapter);\n        };\n\n        adapter.on('connect', handleConnect);\n        adapter.on('disconnect', handleDisconnect);\n        adapter.on('error', handleError);\n\n        return () => {\n            adapter.off('connect', handleConnect);\n            adapter.off('disconnect', handleDisconnect);\n            adapter.off('error', handleError);\n\n            handleDisconnect();\n        };\n    }, [adapter, isUnloadingRef]);\n\n    // When the adapter changes, clear the `autoConnect` tracking flag\n    const didAttemptAutoConnectRef = useRef(false);\n    useEffect(() => {\n        return () => {\n            didAttemptAutoConnectRef.current = false;\n        };\n    }, [adapter]);\n\n    // If auto-connect is enabled, request to connect when the adapter changes and is ready\n    useEffect(() => {\n        if (\n            didAttemptAutoConnectRef.current ||\n            isConnectingRef.current ||\n            connected ||\n            !onAutoConnectRequest ||\n            !(wallet?.readyState === WalletReadyState.Installed || wallet?.readyState === WalletReadyState.Loadable)\n        )\n            return;\n\n        isConnectingRef.current = true;\n        setConnecting(true);\n        didAttemptAutoConnectRef.current = true;\n        (async function () {\n            try {\n                await onAutoConnectRequest();\n            } catch {\n                onConnectError();\n                // Drop the error. It will be caught by `handleError` anyway.\n            } finally {\n                setConnecting(false);\n                isConnectingRef.current = false;\n            }\n        })();\n    }, [connected, onAutoConnectRequest, onConnectError, wallet]);\n\n    // Send a transaction using the provided connection\n    const sendTransaction: WalletAdapterProps['sendTransaction'] = useCallback(\n        async (transaction, connection, options) => {\n            if (!adapter) throw handleErrorRef.current(new WalletNotSelectedError());\n            if (!connected) throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n            return await adapter.sendTransaction(transaction, connection, options);\n        },\n        [adapter, connected]\n    );\n\n    // Sign a transaction if the wallet supports it\n    const signTransaction: SignerWalletAdapterProps['signTransaction'] | undefined = useMemo(\n        () =>\n            adapter && 'signTransaction' in adapter\n                ? async (transaction) => {\n                      if (!connected) throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n                      return await adapter.signTransaction(transaction);\n                  }\n                : undefined,\n        [adapter, connected]\n    );\n\n    // Sign multiple transactions if the wallet supports it\n    const signAllTransactions: SignerWalletAdapterProps['signAllTransactions'] | undefined = useMemo(\n        () =>\n            adapter && 'signAllTransactions' in adapter\n                ? async (transactions) => {\n                      if (!connected) throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n                      return await adapter.signAllTransactions(transactions);\n                  }\n                : undefined,\n        [adapter, connected]\n    );\n\n    // Sign an arbitrary message if the wallet supports it\n    const signMessage: MessageSignerWalletAdapterProps['signMessage'] | undefined = useMemo(\n        () =>\n            adapter && 'signMessage' in adapter\n                ? async (message) => {\n                      if (!connected) throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n                      return await adapter.signMessage(message);\n                  }\n                : undefined,\n        [adapter, connected]\n    );\n\n    // Sign in if the wallet supports it\n    const signIn: SignInMessageSignerWalletAdapterProps['signIn'] | undefined = useMemo(\n        () =>\n            adapter && 'signIn' in adapter\n                ? async (input) => {\n                      return await adapter.signIn(input);\n                  }\n                : undefined,\n        [adapter]\n    );\n\n    const handleConnect = useCallback(async () => {\n        if (isConnectingRef.current || isDisconnectingRef.current || wallet?.adapter.connected) return;\n        if (!wallet) throw handleErrorRef.current(new WalletNotSelectedError());\n        const { adapter, readyState } = wallet;\n        if (!(readyState === WalletReadyState.Installed || readyState === WalletReadyState.Loadable))\n            throw handleErrorRef.current(new WalletNotReadyError(), adapter);\n        isConnectingRef.current = true;\n        setConnecting(true);\n        try {\n            await adapter.connect();\n        } catch (e) {\n            onConnectError();\n            throw e;\n        } finally {\n            setConnecting(false);\n            isConnectingRef.current = false;\n        }\n    }, [onConnectError, wallet]);\n\n    const handleDisconnect = useCallback(async () => {\n        if (isDisconnectingRef.current) return;\n        if (!adapter) return;\n        isDisconnectingRef.current = true;\n        setDisconnecting(true);\n        try {\n            await adapter.disconnect();\n        } finally {\n            setDisconnecting(false);\n            isDisconnectingRef.current = false;\n        }\n    }, [adapter]);\n\n    return (\n        <WalletContext.Provider\n            value={{\n                autoConnect: !!onAutoConnectRequest,\n                wallets,\n                wallet,\n                publicKey,\n                connected,\n                connecting,\n                disconnecting,\n                select: onSelectWallet,\n                connect: handleConnect,\n                disconnect: handleDisconnect,\n                sendTransaction,\n                signTransaction,\n                signAllTransactions,\n                signMessage,\n                signIn,\n            }}\n        >\n            {children}\n        </WalletContext.Provider>\n    );\n}\n"],"mappings":"AAAA,SAQIA,uBAAuB,EACvBC,mBAAmB,EACnBC,gBAAgB,QACb,6BAA6B;AAEpC,OAAOC,KAAK,IAAoBC,WAAW,EAAEC,SAAS,EAAEC,OAAO,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,OAAO;AAChG,SAASC,sBAAsB,QAAQ,aAAa;AACpD,SAASC,aAAa,QAAQ,gBAAgB;AAc9C,OAAM,SAAUC,kBAAkBA,CAAC;EAC/BC,QAAQ;EACRC,OAAO,EAAEC,QAAQ;EACjBC,OAAO;EACPC,cAAc;EACdC,oBAAoB;EACpBC,cAAc;EACdC,OAAO;EACPC;AAAc,CACQ;EACtB,MAAMC,eAAe,GAAGd,MAAM,CAAC,KAAK,CAAC;EACrC,MAAM,CAACe,UAAU,EAAEC,aAAa,CAAC,GAAGf,QAAQ,CAAC,KAAK,CAAC;EACnD,MAAMgB,kBAAkB,GAAGjB,MAAM,CAAC,KAAK,CAAC;EACxC,MAAM,CAACkB,aAAa,EAAEC,gBAAgB,CAAC,GAAGlB,QAAQ,CAAC,KAAK,CAAC;EACzD,MAAM,CAACmB,SAAS,EAAEC,YAAY,CAAC,GAAGpB,QAAQ,CAAC,MAAMO,OAAO,EAAEY,SAAS,IAAI,IAAI,CAAC;EAC5E,MAAM,CAACE,SAAS,EAAEC,YAAY,CAAC,GAAGtB,QAAQ,CAAC,MAAMO,OAAO,EAAEc,SAAS,IAAI,KAAK,CAAC;EAE7E;;;;EAIA,MAAME,UAAU,GAAGxB,MAAM,CAACY,OAAO,CAAC;EAClCd,SAAS,CAAC,MAAK;IACX0B,UAAU,CAACC,OAAO,GAAGb,OAAO;IAC5B,OAAO,MAAK;MACRY,UAAU,CAACC,OAAO,GAAGC,SAAS;IAClC,CAAC;EACL,CAAC,EAAE,CAACd,OAAO,CAAC,CAAC;EACb,MAAMe,cAAc,GAAG3B,MAAM,CAAC,CAAC4B,KAAkB,EAAEpB,OAAiB,KAAI;IACpE,IAAI,CAACC,cAAc,CAACgB,OAAO,EAAE;MACzB,IAAID,UAAU,CAACC,OAAO,EAAE;QACpBD,UAAU,CAACC,OAAO,CAACG,KAAK,EAAEpB,OAAO,CAAC;MACtC,CAAC,MAAM;QACHqB,OAAO,CAACD,KAAK,CAACA,KAAK,EAAEpB,OAAO,CAAC;QAC7B,IAAIoB,KAAK,YAAYlC,mBAAmB,IAAI,OAAOoC,MAAM,KAAK,WAAW,IAAItB,OAAO,EAAE;UAClFsB,MAAM,CAACC,IAAI,CAACvB,OAAO,CAACwB,GAAG,EAAE,QAAQ,CAAC;QACtC;MACJ;IACJ;IACA,OAAOJ,KAAK;EAChB,CAAC,CAAC;EAEF;EACA,MAAM,CAACtB,OAAO,EAAE2B,UAAU,CAAC,GAAGhC,QAAQ,CAAC,MACnCM,QAAQ,CACH2B,GAAG,CAAE1B,OAAO,KAAM;IACfA,OAAO;IACP2B,UAAU,EAAE3B,OAAO,CAAC2B;GACvB,CAAC,CAAC,CACFC,MAAM,CAAC,CAAC;IAAED;EAAU,CAAE,KAAKA,UAAU,KAAKxC,gBAAgB,CAAC0C,WAAW,CAAC,CAC/E;EAED;EACAvC,SAAS,CAAC,MAAK;IACX;IACAmC,UAAU,CAAE3B,OAAO,IACfC,QAAQ,CACH2B,GAAG,CAAC,CAAC1B,OAAO,EAAE8B,KAAK,KAAI;MACpB,MAAMC,MAAM,GAAGjC,OAAO,CAACgC,KAAK,CAAC;MAC7B;MACA,OAAOC,MAAM,IAAIA,MAAM,CAAC/B,OAAO,KAAKA,OAAO,IAAI+B,MAAM,CAACJ,UAAU,KAAK3B,OAAO,CAAC2B,UAAU,GACjFI,MAAM,GACN;QACI/B,OAAO,EAAEA,OAAO;QAChB2B,UAAU,EAAE3B,OAAO,CAAC2B;OACvB;IACX,CAAC,CAAC,CACDC,MAAM,CAAC,CAAC;MAAED;IAAU,CAAE,KAAKA,UAAU,KAAKxC,gBAAgB,CAAC0C,WAAW,CAAC,CAC/E;IACD,SAASG,sBAAsBA,CAAgBL,UAA4B;MACvEF,UAAU,CAAEQ,WAAW,IAAI;QACvB,MAAMH,KAAK,GAAGG,WAAW,CAACC,SAAS,CAAC,CAAC;UAAElC;QAAO,CAAE,KAAKA,OAAO,KAAK,IAAI,CAAC;QACtE,IAAI8B,KAAK,KAAK,CAAC,CAAC,EAAE,OAAOG,WAAW;QAEpC;QACA,MAAM;UAAEjC;QAAO,CAAE,GAAGiC,WAAW,CAACH,KAAK,CAAE;QACvC,OAAO,CACH,GAAGG,WAAW,CAACE,KAAK,CAAC,CAAC,EAAEL,KAAK,CAAC,EAC9B;UAAE9B,OAAO;UAAE2B;QAAU,CAAE,EACvB,GAAGM,WAAW,CAACE,KAAK,CAACL,KAAK,GAAG,CAAC,CAAC,CAClC,CAACF,MAAM,CAAC,CAAC;UAAED;QAAU,CAAE,KAAKA,UAAU,KAAKxC,gBAAgB,CAAC0C,WAAW,CAAC;MAC7E,CAAC,CAAC;IACN;IACA9B,QAAQ,CAACqC,OAAO,CAAEpC,OAAO,IAAKA,OAAO,CAACqC,EAAE,CAAC,kBAAkB,EAAEL,sBAAsB,EAAEhC,OAAO,CAAC,CAAC;IAC9F,OAAO,MAAK;MACRD,QAAQ,CAACqC,OAAO,CAAEpC,OAAO,IAAKA,OAAO,CAACsC,GAAG,CAAC,kBAAkB,EAAEN,sBAAsB,EAAEhC,OAAO,CAAC,CAAC;IACnG,CAAC;EACL,CAAC,EAAE,CAACA,OAAO,EAAED,QAAQ,CAAC,CAAC;EAEvB,MAAMgC,MAAM,GAAGxC,OAAO,CAAC,MAAMO,OAAO,CAACyC,IAAI,CAAER,MAAM,IAAKA,MAAM,CAAC/B,OAAO,KAAKA,OAAO,CAAC,IAAI,IAAI,EAAE,CAACA,OAAO,EAAEF,OAAO,CAAC,CAAC;EAE9G;EACAR,SAAS,CAAC,MAAK;IACX,IAAI,CAACU,OAAO,EAAE;IAEd,MAAMwC,aAAa,GAAI5B,SAAoB,IAAI;MAC3CC,YAAY,CAACD,SAAS,CAAC;MACvBN,eAAe,CAACW,OAAO,GAAG,KAAK;MAC/BT,aAAa,CAAC,KAAK,CAAC;MACpBO,YAAY,CAAC,IAAI,CAAC;MAClBN,kBAAkB,CAACQ,OAAO,GAAG,KAAK;MAClCN,gBAAgB,CAAC,KAAK,CAAC;IAC3B,CAAC;IAED,MAAM8B,gBAAgB,GAAGA,CAAA,KAAK;MAC1B,IAAIxC,cAAc,CAACgB,OAAO,EAAE;MAE5BJ,YAAY,CAAC,IAAI,CAAC;MAClBP,eAAe,CAACW,OAAO,GAAG,KAAK;MAC/BT,aAAa,CAAC,KAAK,CAAC;MACpBO,YAAY,CAAC,KAAK,CAAC;MACnBN,kBAAkB,CAACQ,OAAO,GAAG,KAAK;MAClCN,gBAAgB,CAAC,KAAK,CAAC;IAC3B,CAAC;IAED,MAAM+B,WAAW,GAAItB,KAAkB,IAAI;MACvCD,cAAc,CAACF,OAAO,CAACG,KAAK,EAAEpB,OAAO,CAAC;IAC1C,CAAC;IAEDA,OAAO,CAACqC,EAAE,CAAC,SAAS,EAAEG,aAAa,CAAC;IACpCxC,OAAO,CAACqC,EAAE,CAAC,YAAY,EAAEI,gBAAgB,CAAC;IAC1CzC,OAAO,CAACqC,EAAE,CAAC,OAAO,EAAEK,WAAW,CAAC;IAEhC,OAAO,MAAK;MACR1C,OAAO,CAACsC,GAAG,CAAC,SAAS,EAAEE,aAAa,CAAC;MACrCxC,OAAO,CAACsC,GAAG,CAAC,YAAY,EAAEG,gBAAgB,CAAC;MAC3CzC,OAAO,CAACsC,GAAG,CAAC,OAAO,EAAEI,WAAW,CAAC;MAEjCD,gBAAgB,EAAE;IACtB,CAAC;EACL,CAAC,EAAE,CAACzC,OAAO,EAAEC,cAAc,CAAC,CAAC;EAE7B;EACA,MAAM0C,wBAAwB,GAAGnD,MAAM,CAAC,KAAK,CAAC;EAC9CF,SAAS,CAAC,MAAK;IACX,OAAO,MAAK;MACRqD,wBAAwB,CAAC1B,OAAO,GAAG,KAAK;IAC5C,CAAC;EACL,CAAC,EAAE,CAACjB,OAAO,CAAC,CAAC;EAEb;EACAV,SAAS,CAAC,MAAK;IACX,IACIqD,wBAAwB,CAAC1B,OAAO,IAChCX,eAAe,CAACW,OAAO,IACvBH,SAAS,IACT,CAACZ,oBAAoB,IACrB,EAAE6B,MAAM,EAAEJ,UAAU,KAAKxC,gBAAgB,CAACyD,SAAS,IAAIb,MAAM,EAAEJ,UAAU,KAAKxC,gBAAgB,CAAC0D,QAAQ,CAAC,EAExG;IAEJvC,eAAe,CAACW,OAAO,GAAG,IAAI;IAC9BT,aAAa,CAAC,IAAI,CAAC;IACnBmC,wBAAwB,CAAC1B,OAAO,GAAG,IAAI;IACvC,CAAC,kBAAK;MACF,IAAI;QACA,MAAMf,oBAAoB,EAAE;MAChC,CAAC,CAAC,MAAM;QACJC,cAAc,EAAE;QAChB;MACJ,CAAC,SAAS;QACNK,aAAa,CAAC,KAAK,CAAC;QACpBF,eAAe,CAACW,OAAO,GAAG,KAAK;MACnC;IACJ,CAAC,EAAC,CAAE;EACR,CAAC,EAAE,CAACH,SAAS,EAAEZ,oBAAoB,EAAEC,cAAc,EAAE4B,MAAM,CAAC,CAAC;EAE7D;EACA,MAAMe,eAAe,GAA0CzD,WAAW,CACtE,OAAO0D,WAAW,EAAEC,UAAU,EAAEC,OAAO,KAAI;IACvC,IAAI,CAACjD,OAAO,EAAE,MAAMmB,cAAc,CAACF,OAAO,CAAC,IAAIvB,sBAAsB,EAAE,CAAC;IACxE,IAAI,CAACoB,SAAS,EAAE,MAAMK,cAAc,CAACF,OAAO,CAAC,IAAIhC,uBAAuB,EAAE,EAAEe,OAAO,CAAC;IACpF,OAAO,MAAMA,OAAO,CAAC8C,eAAe,CAACC,WAAW,EAAEC,UAAU,EAAEC,OAAO,CAAC;EAC1E,CAAC,EACD,CAACjD,OAAO,EAAEc,SAAS,CAAC,CACvB;EAED;EACA,MAAMoC,eAAe,GAA4D3D,OAAO,CACpF,MACIS,OAAO,IAAI,iBAAiB,IAAIA,OAAO,GACjC,MAAO+C,WAAW,IAAI;IAClB,IAAI,CAACjC,SAAS,EAAE,MAAMK,cAAc,CAACF,OAAO,CAAC,IAAIhC,uBAAuB,EAAE,EAAEe,OAAO,CAAC;IACpF,OAAO,MAAMA,OAAO,CAACkD,eAAe,CAACH,WAAW,CAAC;EACrD,CAAC,GACD7B,SAAS,EACnB,CAAClB,OAAO,EAAEc,SAAS,CAAC,CACvB;EAED;EACA,MAAMqC,mBAAmB,GAAgE5D,OAAO,CAC5F,MACIS,OAAO,IAAI,qBAAqB,IAAIA,OAAO,GACrC,MAAOoD,YAAY,IAAI;IACnB,IAAI,CAACtC,SAAS,EAAE,MAAMK,cAAc,CAACF,OAAO,CAAC,IAAIhC,uBAAuB,EAAE,EAAEe,OAAO,CAAC;IACpF,OAAO,MAAMA,OAAO,CAACmD,mBAAmB,CAACC,YAAY,CAAC;EAC1D,CAAC,GACDlC,SAAS,EACnB,CAAClB,OAAO,EAAEc,SAAS,CAAC,CACvB;EAED;EACA,MAAMuC,WAAW,GAA+D9D,OAAO,CACnF,MACIS,OAAO,IAAI,aAAa,IAAIA,OAAO,GAC7B,MAAOsD,OAAO,IAAI;IACd,IAAI,CAACxC,SAAS,EAAE,MAAMK,cAAc,CAACF,OAAO,CAAC,IAAIhC,uBAAuB,EAAE,EAAEe,OAAO,CAAC;IACpF,OAAO,MAAMA,OAAO,CAACqD,WAAW,CAACC,OAAO,CAAC;EAC7C,CAAC,GACDpC,SAAS,EACnB,CAAClB,OAAO,EAAEc,SAAS,CAAC,CACvB;EAED;EACA,MAAMyC,MAAM,GAAgEhE,OAAO,CAC/E,MACIS,OAAO,IAAI,QAAQ,IAAIA,OAAO,GACxB,MAAOwD,KAAK,IAAI;IACZ,OAAO,MAAMxD,OAAO,CAACuD,MAAM,CAACC,KAAK,CAAC;EACtC,CAAC,GACDtC,SAAS,EACnB,CAAClB,OAAO,CAAC,CACZ;EAED,MAAMwC,aAAa,GAAGnD,WAAW,CAAC,YAAW;IACzC,IAAIiB,eAAe,CAACW,OAAO,IAAIR,kBAAkB,CAACQ,OAAO,IAAIc,MAAM,EAAE/B,OAAO,CAACc,SAAS,EAAE;IACxF,IAAI,CAACiB,MAAM,EAAE,MAAMZ,cAAc,CAACF,OAAO,CAAC,IAAIvB,sBAAsB,EAAE,CAAC;IACvE,MAAM;MAAEM,OAAO;MAAE2B;IAAU,CAAE,GAAGI,MAAM;IACtC,IAAI,EAAEJ,UAAU,KAAKxC,gBAAgB,CAACyD,SAAS,IAAIjB,UAAU,KAAKxC,gBAAgB,CAAC0D,QAAQ,CAAC,EACxF,MAAM1B,cAAc,CAACF,OAAO,CAAC,IAAI/B,mBAAmB,EAAE,EAAEc,OAAO,CAAC;IACpEM,eAAe,CAACW,OAAO,GAAG,IAAI;IAC9BT,aAAa,CAAC,IAAI,CAAC;IACnB,IAAI;MACA,MAAMR,OAAO,CAACyD,OAAO,EAAE;IAC3B,CAAC,CAAC,OAAOC,CAAC,EAAE;MACRvD,cAAc,EAAE;MAChB,MAAMuD,CAAC;IACX,CAAC,SAAS;MACNlD,aAAa,CAAC,KAAK,CAAC;MACpBF,eAAe,CAACW,OAAO,GAAG,KAAK;IACnC;EACJ,CAAC,EAAE,CAACd,cAAc,EAAE4B,MAAM,CAAC,CAAC;EAE5B,MAAMU,gBAAgB,GAAGpD,WAAW,CAAC,YAAW;IAC5C,IAAIoB,kBAAkB,CAACQ,OAAO,EAAE;IAChC,IAAI,CAACjB,OAAO,EAAE;IACdS,kBAAkB,CAACQ,OAAO,GAAG,IAAI;IACjCN,gBAAgB,CAAC,IAAI,CAAC;IACtB,IAAI;MACA,MAAMX,OAAO,CAAC2D,UAAU,EAAE;IAC9B,CAAC,SAAS;MACNhD,gBAAgB,CAAC,KAAK,CAAC;MACvBF,kBAAkB,CAACQ,OAAO,GAAG,KAAK;IACtC;EACJ,CAAC,EAAE,CAACjB,OAAO,CAAC,CAAC;EAEb,OACIZ,KAAA,CAAAwE,aAAA,CAACjE,aAAa,CAACkE,QAAQ;IACnBC,KAAK,EAAE;MACHC,WAAW,EAAE,CAAC,CAAC7D,oBAAoB;MACnCJ,OAAO;MACPiC,MAAM;MACNnB,SAAS;MACTE,SAAS;MACTP,UAAU;MACVG,aAAa;MACbsD,MAAM,EAAE3D,cAAc;MACtBoD,OAAO,EAAEjB,aAAa;MACtBmB,UAAU,EAAElB,gBAAgB;MAC5BK,eAAe;MACfI,eAAe;MACfC,mBAAmB;MACnBE,WAAW;MACXE;;EACH,GAEA1D,QAAQ,CACY;AAEjC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}