{"ast":null,"code":"import * as AbiParameters from '../AbiParameters.js';\nimport * as Address from '../Address.js';\nimport * as Bytes from '../Bytes.js';\nimport * as Errors from '../Errors.js';\nimport * as Hex from '../Hex.js';\nimport { integerRegex } from '../Solidity.js';\n/** @internal */\nexport function decodeParameter(cursor, param, options) {\n  const {\n    checksumAddress,\n    staticPosition\n  } = options;\n  const arrayComponents = getArrayComponents(param.type);\n  if (arrayComponents) {\n    const [length, type] = arrayComponents;\n    return decodeArray(cursor, {\n      ...param,\n      type\n    }, {\n      checksumAddress,\n      length,\n      staticPosition\n    });\n  }\n  if (param.type === 'tuple') return decodeTuple(cursor, param, {\n    checksumAddress,\n    staticPosition\n  });\n  if (param.type === 'address') return decodeAddress(cursor, {\n    checksum: checksumAddress\n  });\n  if (param.type === 'bool') return decodeBool(cursor);\n  if (param.type.startsWith('bytes')) return decodeBytes(cursor, param, {\n    staticPosition\n  });\n  if (param.type.startsWith('uint') || param.type.startsWith('int')) return decodeNumber(cursor, param);\n  if (param.type === 'string') return decodeString(cursor, {\n    staticPosition\n  });\n  throw new AbiParameters.InvalidTypeError(param.type);\n}\nconst sizeOfLength = 32;\nconst sizeOfOffset = 32;\n/** @internal */\nexport function decodeAddress(cursor, options = {}) {\n  const {\n    checksum = false\n  } = options;\n  const value = cursor.readBytes(32);\n  const wrap = address => checksum ? Address.checksum(address) : address;\n  return [wrap(Hex.fromBytes(Bytes.slice(value, -20))), 32];\n}\n/** @internal */\nexport function decodeArray(cursor, param, options) {\n  const {\n    checksumAddress,\n    length,\n    staticPosition\n  } = options;\n  // If the length of the array is not known in advance (dynamic array),\n  // this means we will need to wonder off to the pointer and decode.\n  if (!length) {\n    // Dealing with a dynamic type, so get the offset of the array data.\n    const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset));\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset;\n    const startOfData = start + sizeOfLength;\n    // Get the length of the array from the offset.\n    cursor.setPosition(start);\n    const length = Bytes.toNumber(cursor.readBytes(sizeOfLength));\n    // Check if the array has any dynamic children.\n    const dynamicChild = hasDynamicChild(param);\n    let consumed = 0;\n    const value = [];\n    for (let i = 0; i < length; ++i) {\n      // If any of the children is dynamic, then all elements will be offset pointer, thus size of one slot (32 bytes).\n      // Otherwise, elements will be the size of their encoding (consumed bytes).\n      cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed));\n      const [data, consumed_] = decodeParameter(cursor, param, {\n        checksumAddress,\n        staticPosition: startOfData\n      });\n      consumed += consumed_;\n      value.push(data);\n    }\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32);\n    return [value, 32];\n  }\n  // If the length of the array is known in advance,\n  // and the length of an element deeply nested in the array is not known,\n  // we need to decode the offset of the array data.\n  if (hasDynamicChild(param)) {\n    // Dealing with dynamic types, so get the offset of the array data.\n    const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset));\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset;\n    const value = [];\n    for (let i = 0; i < length; ++i) {\n      // Move cursor along to the next slot (next offset pointer).\n      cursor.setPosition(start + i * 32);\n      const [data] = decodeParameter(cursor, param, {\n        checksumAddress,\n        staticPosition: start\n      });\n      value.push(data);\n    }\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32);\n    return [value, 32];\n  }\n  // If the length of the array is known in advance and the array is deeply static,\n  // then we can just decode each element in sequence.\n  let consumed = 0;\n  const value = [];\n  for (let i = 0; i < length; ++i) {\n    const [data, consumed_] = decodeParameter(cursor, param, {\n      checksumAddress,\n      staticPosition: staticPosition + consumed\n    });\n    consumed += consumed_;\n    value.push(data);\n  }\n  return [value, consumed];\n}\n/** @internal */\nexport function decodeBool(cursor) {\n  return [Bytes.toBoolean(cursor.readBytes(32), {\n    size: 32\n  }), 32];\n}\n/** @internal */\nexport function decodeBytes(cursor, param, {\n  staticPosition\n}) {\n  const [_, size] = param.type.split('bytes');\n  if (!size) {\n    // Dealing with dynamic types, so get the offset of the bytes data.\n    const offset = Bytes.toNumber(cursor.readBytes(32));\n    // Set position of the cursor to start of bytes data.\n    cursor.setPosition(staticPosition + offset);\n    const length = Bytes.toNumber(cursor.readBytes(32));\n    // If there is no length, we have zero data.\n    if (length === 0) {\n      // As we have gone wondering, restore to the original position + next slot.\n      cursor.setPosition(staticPosition + 32);\n      return ['0x', 32];\n    }\n    const data = cursor.readBytes(length);\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32);\n    return [Hex.fromBytes(data), 32];\n  }\n  const value = Hex.fromBytes(cursor.readBytes(Number.parseInt(size), 32));\n  return [value, 32];\n}\n/** @internal */\nexport function decodeNumber(cursor, param) {\n  const signed = param.type.startsWith('int');\n  const size = Number.parseInt(param.type.split('int')[1] || '256');\n  const value = cursor.readBytes(32);\n  return [size > 48 ? Bytes.toBigInt(value, {\n    signed\n  }) : Bytes.toNumber(value, {\n    signed\n  }), 32];\n}\n/** @internal */\nexport function decodeTuple(cursor, param, options) {\n  const {\n    checksumAddress,\n    staticPosition\n  } = options;\n  // Tuples can have unnamed components (i.e. they are arrays), so we must\n  // determine whether the tuple is named or unnamed. In the case of a named\n  // tuple, the value will be an object where each property is the name of the\n  // component. In the case of an unnamed tuple, the value will be an array.\n  const hasUnnamedChild = param.components.length === 0 || param.components.some(({\n    name\n  }) => !name);\n  // Initialize the value to an object or an array, depending on whether the\n  // tuple is named or unnamed.\n  const value = hasUnnamedChild ? [] : {};\n  let consumed = 0;\n  // If the tuple has a dynamic child, we must first decode the offset to the\n  // tuple data.\n  if (hasDynamicChild(param)) {\n    // Dealing with dynamic types, so get the offset of the tuple data.\n    const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset));\n    // Start is the static position of referencing slot + offset.\n    const start = staticPosition + offset;\n    for (let i = 0; i < param.components.length; ++i) {\n      const component = param.components[i];\n      cursor.setPosition(start + consumed);\n      const [data, consumed_] = decodeParameter(cursor, component, {\n        checksumAddress,\n        staticPosition: start\n      });\n      consumed += consumed_;\n      value[hasUnnamedChild ? i : component?.name] = data;\n    }\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32);\n    return [value, 32];\n  }\n  // If the tuple has static children, we can just decode each component\n  // in sequence.\n  for (let i = 0; i < param.components.length; ++i) {\n    const component = param.components[i];\n    const [data, consumed_] = decodeParameter(cursor, component, {\n      checksumAddress,\n      staticPosition\n    });\n    value[hasUnnamedChild ? i : component?.name] = data;\n    consumed += consumed_;\n  }\n  return [value, consumed];\n}\n/** @internal */\nexport function decodeString(cursor, {\n  staticPosition\n}) {\n  // Get offset to start of string data.\n  const offset = Bytes.toNumber(cursor.readBytes(32));\n  // Start is the static position of current slot + offset.\n  const start = staticPosition + offset;\n  cursor.setPosition(start);\n  const length = Bytes.toNumber(cursor.readBytes(32));\n  // If there is no length, we have zero data (empty string).\n  if (length === 0) {\n    cursor.setPosition(staticPosition + 32);\n    return ['', 32];\n  }\n  const data = cursor.readBytes(length, 32);\n  const value = Bytes.toString(Bytes.trimLeft(data));\n  // As we have gone wondering, restore to the original position + next slot.\n  cursor.setPosition(staticPosition + 32);\n  return [value, 32];\n}\n/** @internal */\nexport function prepareParameters({\n  checksumAddress,\n  parameters,\n  values\n}) {\n  const preparedParameters = [];\n  for (let i = 0; i < parameters.length; i++) {\n    preparedParameters.push(prepareParameter({\n      checksumAddress,\n      parameter: parameters[i],\n      value: values[i]\n    }));\n  }\n  return preparedParameters;\n}\n/** @internal */\nexport function prepareParameter({\n  checksumAddress = false,\n  parameter: parameter_,\n  value\n}) {\n  const parameter = parameter_;\n  const arrayComponents = getArrayComponents(parameter.type);\n  if (arrayComponents) {\n    const [length, type] = arrayComponents;\n    return encodeArray(value, {\n      checksumAddress,\n      length,\n      parameter: {\n        ...parameter,\n        type\n      }\n    });\n  }\n  if (parameter.type === 'tuple') {\n    return encodeTuple(value, {\n      checksumAddress,\n      parameter: parameter\n    });\n  }\n  if (parameter.type === 'address') {\n    return encodeAddress(value, {\n      checksum: checksumAddress\n    });\n  }\n  if (parameter.type === 'bool') {\n    return encodeBoolean(value);\n  }\n  if (parameter.type.startsWith('uint') || parameter.type.startsWith('int')) {\n    const signed = parameter.type.startsWith('int');\n    const [,, size = '256'] = integerRegex.exec(parameter.type) ?? [];\n    return encodeNumber(value, {\n      signed,\n      size: Number(size)\n    });\n  }\n  if (parameter.type.startsWith('bytes')) {\n    return encodeBytes(value, {\n      type: parameter.type\n    });\n  }\n  if (parameter.type === 'string') {\n    return encodeString(value);\n  }\n  throw new AbiParameters.InvalidTypeError(parameter.type);\n}\n/** @internal */\nexport function encode(preparedParameters) {\n  // 1. Compute the size of the static part of the parameters.\n  let staticSize = 0;\n  for (let i = 0; i < preparedParameters.length; i++) {\n    const {\n      dynamic,\n      encoded\n    } = preparedParameters[i];\n    if (dynamic) staticSize += 32;else staticSize += Hex.size(encoded);\n  }\n  // 2. Split the parameters into static and dynamic parts.\n  const staticParameters = [];\n  const dynamicParameters = [];\n  let dynamicSize = 0;\n  for (let i = 0; i < preparedParameters.length; i++) {\n    const {\n      dynamic,\n      encoded\n    } = preparedParameters[i];\n    if (dynamic) {\n      staticParameters.push(Hex.fromNumber(staticSize + dynamicSize, {\n        size: 32\n      }));\n      dynamicParameters.push(encoded);\n      dynamicSize += Hex.size(encoded);\n    } else {\n      staticParameters.push(encoded);\n    }\n  }\n  // 3. Concatenate static and dynamic parts.\n  return Hex.concat(...staticParameters, ...dynamicParameters);\n}\n/** @internal */\nexport function encodeAddress(value, options) {\n  const {\n    checksum = false\n  } = options;\n  Address.assert(value, {\n    strict: checksum\n  });\n  return {\n    dynamic: false,\n    encoded: Hex.padLeft(value.toLowerCase())\n  };\n}\n/** @internal */\nexport function encodeArray(value, options) {\n  const {\n    checksumAddress,\n    length,\n    parameter\n  } = options;\n  const dynamic = length === null;\n  if (!Array.isArray(value)) throw new AbiParameters.InvalidArrayError(value);\n  if (!dynamic && value.length !== length) throw new AbiParameters.ArrayLengthMismatchError({\n    expectedLength: length,\n    givenLength: value.length,\n    type: `${parameter.type}[${length}]`\n  });\n  let dynamicChild = false;\n  const preparedParameters = [];\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParameter({\n      checksumAddress,\n      parameter,\n      value: value[i]\n    });\n    if (preparedParam.dynamic) dynamicChild = true;\n    preparedParameters.push(preparedParam);\n  }\n  if (dynamic || dynamicChild) {\n    const data = encode(preparedParameters);\n    if (dynamic) {\n      const length = Hex.fromNumber(preparedParameters.length, {\n        size: 32\n      });\n      return {\n        dynamic: true,\n        encoded: preparedParameters.length > 0 ? Hex.concat(length, data) : length\n      };\n    }\n    if (dynamicChild) return {\n      dynamic: true,\n      encoded: data\n    };\n  }\n  return {\n    dynamic: false,\n    encoded: Hex.concat(...preparedParameters.map(({\n      encoded\n    }) => encoded))\n  };\n}\n/** @internal */\nexport function encodeBytes(value, {\n  type\n}) {\n  const [, parametersize] = type.split('bytes');\n  const bytesSize = Hex.size(value);\n  if (!parametersize) {\n    let value_ = value;\n    // If the size is not divisible by 32 bytes, pad the end\n    // with empty bytes to the ceiling 32 bytes.\n    if (bytesSize % 32 !== 0) value_ = Hex.padRight(value_, Math.ceil((value.length - 2) / 2 / 32) * 32);\n    return {\n      dynamic: true,\n      encoded: Hex.concat(Hex.padLeft(Hex.fromNumber(bytesSize, {\n        size: 32\n      })), value_)\n    };\n  }\n  if (bytesSize !== Number.parseInt(parametersize)) throw new AbiParameters.BytesSizeMismatchError({\n    expectedSize: Number.parseInt(parametersize),\n    value\n  });\n  return {\n    dynamic: false,\n    encoded: Hex.padRight(value)\n  };\n}\n/** @internal */\nexport function encodeBoolean(value) {\n  if (typeof value !== 'boolean') throw new Errors.BaseError(`Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`);\n  return {\n    dynamic: false,\n    encoded: Hex.padLeft(Hex.fromBoolean(value))\n  };\n}\n/** @internal */\nexport function encodeNumber(value, {\n  signed,\n  size\n}) {\n  if (typeof size === 'number') {\n    const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n;\n    const min = signed ? -max - 1n : 0n;\n    if (value > max || value < min) throw new Hex.IntegerOutOfRangeError({\n      max: max.toString(),\n      min: min.toString(),\n      signed,\n      size: size / 8,\n      value: value.toString()\n    });\n  }\n  return {\n    dynamic: false,\n    encoded: Hex.fromNumber(value, {\n      size: 32,\n      signed\n    })\n  };\n}\n/** @internal */\nexport function encodeString(value) {\n  const hexValue = Hex.fromString(value);\n  const partsLength = Math.ceil(Hex.size(hexValue) / 32);\n  const parts = [];\n  for (let i = 0; i < partsLength; i++) {\n    parts.push(Hex.padRight(Hex.slice(hexValue, i * 32, (i + 1) * 32)));\n  }\n  return {\n    dynamic: true,\n    encoded: Hex.concat(Hex.padRight(Hex.fromNumber(Hex.size(hexValue), {\n      size: 32\n    })), ...parts)\n  };\n}\n/** @internal */\nexport function encodeTuple(value, options) {\n  const {\n    checksumAddress,\n    parameter\n  } = options;\n  let dynamic = false;\n  const preparedParameters = [];\n  for (let i = 0; i < parameter.components.length; i++) {\n    const param_ = parameter.components[i];\n    const index = Array.isArray(value) ? i : param_.name;\n    const preparedParam = prepareParameter({\n      checksumAddress,\n      parameter: param_,\n      value: value[index]\n    });\n    preparedParameters.push(preparedParam);\n    if (preparedParam.dynamic) dynamic = true;\n  }\n  return {\n    dynamic,\n    encoded: dynamic ? encode(preparedParameters) : Hex.concat(...preparedParameters.map(({\n      encoded\n    }) => encoded))\n  };\n}\n/** @internal */\nexport function getArrayComponents(type) {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/);\n  return matches ?\n  // Return `null` if the array is dynamic.\n  [matches[2] ? Number(matches[2]) : null, matches[1]] : undefined;\n}\n/** @internal */\nexport function hasDynamicChild(param) {\n  const {\n    type\n  } = param;\n  if (type === 'string') return true;\n  if (type === 'bytes') return true;\n  if (type.endsWith('[]')) return true;\n  if (type === 'tuple') return param.components?.some(hasDynamicChild);\n  const arrayComponents = getArrayComponents(param.type);\n  if (arrayComponents && hasDynamicChild({\n    ...param,\n    type: arrayComponents[1]\n  })) return true;\n  return false;\n}","map":{"version":3,"names":["AbiParameters","Address","Bytes","Errors","Hex","integerRegex","decodeParameter","cursor","param","options","checksumAddress","staticPosition","arrayComponents","getArrayComponents","type","length","decodeArray","decodeTuple","decodeAddress","checksum","decodeBool","startsWith","decodeBytes","decodeNumber","decodeString","InvalidTypeError","sizeOfLength","sizeOfOffset","value","readBytes","wrap","address","fromBytes","slice","offset","toNumber","start","startOfData","setPosition","dynamicChild","hasDynamicChild","consumed","i","data","consumed_","push","toBoolean","size","_","split","Number","parseInt","signed","toBigInt","hasUnnamedChild","components","some","name","component","toString","trimLeft","prepareParameters","parameters","values","preparedParameters","prepareParameter","parameter","parameter_","encodeArray","encodeTuple","encodeAddress","encodeBoolean","exec","encodeNumber","encodeBytes","encodeString","encode","staticSize","dynamic","encoded","staticParameters","dynamicParameters","dynamicSize","fromNumber","concat","assert","strict","padLeft","toLowerCase","Array","isArray","InvalidArrayError","ArrayLengthMismatchError","expectedLength","givenLength","preparedParam","map","parametersize","bytesSize","value_","padRight","Math","ceil","BytesSizeMismatchError","expectedSize","BaseError","fromBoolean","max","BigInt","min","IntegerOutOfRangeError","hexValue","fromString","partsLength","parts","param_","index","matches","match","undefined","endsWith"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@reown\\appkit-controllers\\node_modules\\ox\\core\\internal\\abiParameters.ts"],"sourcesContent":["import type {\n  AbiParameter,\n  AbiParameterKind,\n  AbiParameterToPrimitiveType,\n  AbiParametersToPrimitiveTypes,\n} from 'abitype'\nimport * as AbiParameters from '../AbiParameters.js'\nimport * as Address from '../Address.js'\nimport * as Bytes from '../Bytes.js'\nimport * as Errors from '../Errors.js'\nimport * as Hex from '../Hex.js'\nimport { integerRegex } from '../Solidity.js'\nimport type * as Cursor from './cursor.js'\nimport type { Compute, IsNarrowable, UnionToIntersection } from './types.js'\n\n/** @internal */\nexport type ParameterToPrimitiveType<\n  abiParameter extends AbiParameter | { name: string; type: unknown },\n  abiParameterKind extends AbiParameterKind = AbiParameterKind,\n> = AbiParameterToPrimitiveType<abiParameter, abiParameterKind>\n\n/** @internal */\nexport type PreparedParameter = { dynamic: boolean; encoded: Hex.Hex }\n\n/** @internal */\nexport type ToObject<\n  parameters extends readonly AbiParameter[],\n  kind extends AbiParameterKind = AbiParameterKind,\n> = IsNarrowable<parameters, AbiParameters.AbiParameters> extends true\n  ? Compute<\n      UnionToIntersection<\n        {\n          [index in keyof parameters]: parameters[index] extends {\n            name: infer name extends string\n          }\n            ? {\n                [key in name]: AbiParameterToPrimitiveType<\n                  parameters[index],\n                  kind\n                >\n              }\n            : {\n                [key in index]: AbiParameterToPrimitiveType<\n                  parameters[index],\n                  kind\n                >\n              }\n        }[number]\n      >\n    >\n  : unknown\n\n/** @internal */\nexport type ToPrimitiveTypes<\n  abiParameters extends readonly AbiParameter[],\n  abiParameterKind extends AbiParameterKind = AbiParameterKind,\n> = AbiParametersToPrimitiveTypes<abiParameters, abiParameterKind>\n\n/** @internal */\nexport type Tuple = ParameterToPrimitiveType<TupleAbiParameter>\n\n/** @internal */\nexport function decodeParameter(\n  cursor: Cursor.Cursor,\n  param: AbiParameters.Parameter,\n  options: { checksumAddress?: boolean | undefined; staticPosition: number },\n) {\n  const { checksumAddress, staticPosition } = options\n  const arrayComponents = getArrayComponents(param.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return decodeArray(\n      cursor,\n      { ...param, type },\n      { checksumAddress, length, staticPosition },\n    )\n  }\n  if (param.type === 'tuple')\n    return decodeTuple(cursor, param as TupleAbiParameter, {\n      checksumAddress,\n      staticPosition,\n    })\n  if (param.type === 'address')\n    return decodeAddress(cursor, { checksum: checksumAddress })\n  if (param.type === 'bool') return decodeBool(cursor)\n  if (param.type.startsWith('bytes'))\n    return decodeBytes(cursor, param, { staticPosition })\n  if (param.type.startsWith('uint') || param.type.startsWith('int'))\n    return decodeNumber(cursor, param)\n  if (param.type === 'string') return decodeString(cursor, { staticPosition })\n  throw new AbiParameters.InvalidTypeError(param.type)\n}\n\nexport declare namespace decodeParameter {\n  type ErrorType =\n    | decodeArray.ErrorType\n    | decodeTuple.ErrorType\n    | decodeAddress.ErrorType\n    | decodeBool.ErrorType\n    | decodeBytes.ErrorType\n    | decodeNumber.ErrorType\n    | decodeString.ErrorType\n    | AbiParameters.InvalidTypeError\n    | Errors.GlobalErrorType\n}\n\nconst sizeOfLength = 32\nconst sizeOfOffset = 32\n\n/** @internal */\nexport function decodeAddress(\n  cursor: Cursor.Cursor,\n  options: { checksum?: boolean | undefined } = {},\n) {\n  const { checksum = false } = options\n  const value = cursor.readBytes(32)\n  const wrap = (address: Hex.Hex) =>\n    checksum ? Address.checksum(address) : address\n  return [wrap(Hex.fromBytes(Bytes.slice(value, -20))), 32]\n}\n\nexport declare namespace decodeAddress {\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | Bytes.slice.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function decodeArray(\n  cursor: Cursor.Cursor,\n  param: AbiParameters.Parameter,\n  options: {\n    checksumAddress?: boolean | undefined\n    length: number | null\n    staticPosition: number\n  },\n) {\n  const { checksumAddress, length, staticPosition } = options\n\n  // If the length of the array is not known in advance (dynamic array),\n  // this means we will need to wonder off to the pointer and decode.\n  if (!length) {\n    // Dealing with a dynamic type, so get the offset of the array data.\n    const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset\n    const startOfData = start + sizeOfLength\n\n    // Get the length of the array from the offset.\n    cursor.setPosition(start)\n    const length = Bytes.toNumber(cursor.readBytes(sizeOfLength))\n\n    // Check if the array has any dynamic children.\n    const dynamicChild = hasDynamicChild(param)\n\n    let consumed = 0\n    const value: unknown[] = []\n    for (let i = 0; i < length; ++i) {\n      // If any of the children is dynamic, then all elements will be offset pointer, thus size of one slot (32 bytes).\n      // Otherwise, elements will be the size of their encoding (consumed bytes).\n      cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed))\n      const [data, consumed_] = decodeParameter(cursor, param, {\n        checksumAddress,\n        staticPosition: startOfData,\n      })\n      consumed += consumed_\n      value.push(data)\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the length of the array is known in advance,\n  // and the length of an element deeply nested in the array is not known,\n  // we need to decode the offset of the array data.\n  if (hasDynamicChild(param)) {\n    // Dealing with dynamic types, so get the offset of the array data.\n    const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset\n\n    const value: unknown[] = []\n    for (let i = 0; i < length; ++i) {\n      // Move cursor along to the next slot (next offset pointer).\n      cursor.setPosition(start + i * 32)\n      const [data] = decodeParameter(cursor, param, {\n        checksumAddress,\n        staticPosition: start,\n      })\n      value.push(data)\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the length of the array is known in advance and the array is deeply static,\n  // then we can just decode each element in sequence.\n  let consumed = 0\n  const value: unknown[] = []\n  for (let i = 0; i < length; ++i) {\n    const [data, consumed_] = decodeParameter(cursor, param, {\n      checksumAddress,\n      staticPosition: staticPosition + consumed,\n    })\n    consumed += consumed_\n    value.push(data)\n  }\n  return [value, consumed]\n}\n\nexport declare namespace decodeArray {\n  type ErrorType = Bytes.toNumber.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function decodeBool(cursor: Cursor.Cursor) {\n  return [Bytes.toBoolean(cursor.readBytes(32), { size: 32 }), 32]\n}\n\nexport declare namespace decodeBool {\n  type ErrorType = Bytes.toBoolean.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function decodeBytes(\n  cursor: Cursor.Cursor,\n  param: AbiParameters.Parameter,\n  { staticPosition }: { staticPosition: number },\n) {\n  const [_, size] = param.type.split('bytes')\n  if (!size) {\n    // Dealing with dynamic types, so get the offset of the bytes data.\n    const offset = Bytes.toNumber(cursor.readBytes(32))\n\n    // Set position of the cursor to start of bytes data.\n    cursor.setPosition(staticPosition + offset)\n\n    const length = Bytes.toNumber(cursor.readBytes(32))\n\n    // If there is no length, we have zero data.\n    if (length === 0) {\n      // As we have gone wondering, restore to the original position + next slot.\n      cursor.setPosition(staticPosition + 32)\n      return ['0x', 32]\n    }\n\n    const data = cursor.readBytes(length)\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [Hex.fromBytes(data), 32]\n  }\n\n  const value = Hex.fromBytes(cursor.readBytes(Number.parseInt(size), 32))\n  return [value, 32]\n}\n\nexport declare namespace decodeBytes {\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | Bytes.toNumber.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function decodeNumber(\n  cursor: Cursor.Cursor,\n  param: AbiParameters.Parameter,\n) {\n  const signed = param.type.startsWith('int')\n  const size = Number.parseInt(param.type.split('int')[1] || '256')\n  const value = cursor.readBytes(32)\n  return [\n    size > 48\n      ? Bytes.toBigInt(value, { signed })\n      : Bytes.toNumber(value, { signed }),\n    32,\n  ]\n}\n\nexport declare namespace decodeNumber {\n  type ErrorType =\n    | Bytes.toNumber.ErrorType\n    | Bytes.toBigInt.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport type TupleAbiParameter = AbiParameters.Parameter & {\n  components: readonly AbiParameters.Parameter[]\n}\n\n/** @internal */\nexport function decodeTuple(\n  cursor: Cursor.Cursor,\n  param: TupleAbiParameter,\n  options: { checksumAddress?: boolean | undefined; staticPosition: number },\n) {\n  const { checksumAddress, staticPosition } = options\n\n  // Tuples can have unnamed components (i.e. they are arrays), so we must\n  // determine whether the tuple is named or unnamed. In the case of a named\n  // tuple, the value will be an object where each property is the name of the\n  // component. In the case of an unnamed tuple, the value will be an array.\n  const hasUnnamedChild =\n    param.components.length === 0 || param.components.some(({ name }) => !name)\n\n  // Initialize the value to an object or an array, depending on whether the\n  // tuple is named or unnamed.\n  const value: any = hasUnnamedChild ? [] : {}\n  let consumed = 0\n\n  // If the tuple has a dynamic child, we must first decode the offset to the\n  // tuple data.\n  if (hasDynamicChild(param)) {\n    // Dealing with dynamic types, so get the offset of the tuple data.\n    const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of referencing slot + offset.\n    const start = staticPosition + offset\n\n    for (let i = 0; i < param.components.length; ++i) {\n      const component = param.components[i]!\n      cursor.setPosition(start + consumed)\n      const [data, consumed_] = decodeParameter(cursor, component, {\n        checksumAddress,\n        staticPosition: start,\n      })\n      consumed += consumed_\n      value[hasUnnamedChild ? i : component?.name!] = data\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the tuple has static children, we can just decode each component\n  // in sequence.\n  for (let i = 0; i < param.components.length; ++i) {\n    const component = param.components[i]!\n    const [data, consumed_] = decodeParameter(cursor, component, {\n      checksumAddress,\n      staticPosition,\n    })\n    value[hasUnnamedChild ? i : component?.name!] = data\n    consumed += consumed_\n  }\n  return [value, consumed]\n}\n\nexport declare namespace decodeTuple {\n  type ErrorType = Bytes.toNumber.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function decodeString(\n  cursor: Cursor.Cursor,\n  { staticPosition }: { staticPosition: number },\n) {\n  // Get offset to start of string data.\n  const offset = Bytes.toNumber(cursor.readBytes(32))\n\n  // Start is the static position of current slot + offset.\n  const start = staticPosition + offset\n  cursor.setPosition(start)\n\n  const length = Bytes.toNumber(cursor.readBytes(32))\n\n  // If there is no length, we have zero data (empty string).\n  if (length === 0) {\n    cursor.setPosition(staticPosition + 32)\n    return ['', 32]\n  }\n\n  const data = cursor.readBytes(length, 32)\n  const value = Bytes.toString(Bytes.trimLeft(data))\n\n  // As we have gone wondering, restore to the original position + next slot.\n  cursor.setPosition(staticPosition + 32)\n\n  return [value, 32]\n}\n\nexport declare namespace decodeString {\n  type ErrorType =\n    | Bytes.toNumber.ErrorType\n    | Bytes.toString.ErrorType\n    | Bytes.trimLeft.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function prepareParameters<\n  const parameters extends AbiParameters.AbiParameters,\n>({\n  checksumAddress,\n  parameters,\n  values,\n}: {\n  checksumAddress?: boolean | undefined\n  parameters: parameters\n  values: parameters extends AbiParameters.AbiParameters\n    ? ToPrimitiveTypes<parameters>\n    : never\n}) {\n  const preparedParameters: PreparedParameter[] = []\n  for (let i = 0; i < parameters.length; i++) {\n    preparedParameters.push(\n      prepareParameter({\n        checksumAddress,\n        parameter: parameters[i]!,\n        value: values[i],\n      }),\n    )\n  }\n  return preparedParameters\n}\n\n/** @internal */\nexport declare namespace prepareParameters {\n  type ErrorType = prepareParameter.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function prepareParameter<\n  const parameter extends AbiParameters.Parameter,\n>({\n  checksumAddress = false,\n  parameter: parameter_,\n  value,\n}: {\n  parameter: parameter\n  value: parameter extends AbiParameters.Parameter\n    ? ParameterToPrimitiveType<parameter>\n    : never\n  checksumAddress?: boolean | undefined\n}): PreparedParameter {\n  const parameter = parameter_ as AbiParameters.Parameter\n\n  const arrayComponents = getArrayComponents(parameter.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return encodeArray(value, {\n      checksumAddress,\n      length,\n      parameter: {\n        ...parameter,\n        type,\n      },\n    })\n  }\n  if (parameter.type === 'tuple') {\n    return encodeTuple(value as unknown as Tuple, {\n      checksumAddress,\n      parameter: parameter as TupleAbiParameter,\n    })\n  }\n  if (parameter.type === 'address') {\n    return encodeAddress(value as unknown as Hex.Hex, {\n      checksum: checksumAddress,\n    })\n  }\n  if (parameter.type === 'bool') {\n    return encodeBoolean(value as unknown as boolean)\n  }\n  if (parameter.type.startsWith('uint') || parameter.type.startsWith('int')) {\n    const signed = parameter.type.startsWith('int')\n    const [, , size = '256'] = integerRegex.exec(parameter.type) ?? []\n    return encodeNumber(value as unknown as number, {\n      signed,\n      size: Number(size),\n    })\n  }\n  if (parameter.type.startsWith('bytes')) {\n    return encodeBytes(value as unknown as Hex.Hex, { type: parameter.type })\n  }\n  if (parameter.type === 'string') {\n    return encodeString(value as unknown as string)\n  }\n  throw new AbiParameters.InvalidTypeError(parameter.type)\n}\n\n/** @internal */\nexport declare namespace prepareParameter {\n  type ErrorType =\n    | encodeArray.ErrorType\n    | encodeTuple.ErrorType\n    | encodeAddress.ErrorType\n    | encodeBoolean.ErrorType\n    | encodeBytes.ErrorType\n    | encodeString.ErrorType\n    | AbiParameters.InvalidTypeError\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encode(preparedParameters: PreparedParameter[]): Hex.Hex {\n  // 1. Compute the size of the static part of the parameters.\n  let staticSize = 0\n  for (let i = 0; i < preparedParameters.length; i++) {\n    const { dynamic, encoded } = preparedParameters[i]!\n    if (dynamic) staticSize += 32\n    else staticSize += Hex.size(encoded)\n  }\n\n  // 2. Split the parameters into static and dynamic parts.\n  const staticParameters: Hex.Hex[] = []\n  const dynamicParameters: Hex.Hex[] = []\n  let dynamicSize = 0\n  for (let i = 0; i < preparedParameters.length; i++) {\n    const { dynamic, encoded } = preparedParameters[i]!\n    if (dynamic) {\n      staticParameters.push(\n        Hex.fromNumber(staticSize + dynamicSize, { size: 32 }),\n      )\n      dynamicParameters.push(encoded)\n      dynamicSize += Hex.size(encoded)\n    } else {\n      staticParameters.push(encoded)\n    }\n  }\n\n  // 3. Concatenate static and dynamic parts.\n  return Hex.concat(...staticParameters, ...dynamicParameters)\n}\n\n/** @internal */\nexport declare namespace encode {\n  type ErrorType =\n    | Hex.concat.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Hex.size.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeAddress(\n  value: Hex.Hex,\n  options: { checksum: boolean },\n): PreparedParameter {\n  const { checksum = false } = options\n  Address.assert(value, { strict: checksum })\n  return {\n    dynamic: false,\n    encoded: Hex.padLeft(value.toLowerCase() as Hex.Hex),\n  }\n}\n\n/** @internal */\nexport declare namespace encodeAddress {\n  type ErrorType =\n    | Address.assert.ErrorType\n    | Hex.padLeft.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeArray<const parameter extends AbiParameters.Parameter>(\n  value: ParameterToPrimitiveType<parameter>,\n  options: {\n    checksumAddress?: boolean | undefined\n    length: number | null\n    parameter: parameter\n  },\n): PreparedParameter {\n  const { checksumAddress, length, parameter } = options\n\n  const dynamic = length === null\n\n  if (!Array.isArray(value)) throw new AbiParameters.InvalidArrayError(value)\n  if (!dynamic && value.length !== length)\n    throw new AbiParameters.ArrayLengthMismatchError({\n      expectedLength: length!,\n      givenLength: value.length,\n      type: `${parameter.type}[${length}]`,\n    })\n\n  let dynamicChild = false\n  const preparedParameters: PreparedParameter[] = []\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParameter({\n      checksumAddress,\n      parameter,\n      value: value[i],\n    })\n    if (preparedParam.dynamic) dynamicChild = true\n    preparedParameters.push(preparedParam)\n  }\n\n  if (dynamic || dynamicChild) {\n    const data = encode(preparedParameters)\n    if (dynamic) {\n      const length = Hex.fromNumber(preparedParameters.length, { size: 32 })\n      return {\n        dynamic: true,\n        encoded:\n          preparedParameters.length > 0 ? Hex.concat(length, data) : length,\n      }\n    }\n    if (dynamicChild) return { dynamic: true, encoded: data }\n  }\n  return {\n    dynamic: false,\n    encoded: Hex.concat(...preparedParameters.map(({ encoded }) => encoded)),\n  }\n}\n\n/** @internal */\nexport declare namespace encodeArray {\n  type ErrorType =\n    | AbiParameters.InvalidArrayError\n    | AbiParameters.ArrayLengthMismatchError\n    | Hex.concat.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeBytes(\n  value: Hex.Hex,\n  { type }: { type: string },\n): PreparedParameter {\n  const [, parametersize] = type.split('bytes')\n  const bytesSize = Hex.size(value)\n  if (!parametersize) {\n    let value_ = value\n    // If the size is not divisible by 32 bytes, pad the end\n    // with empty bytes to the ceiling 32 bytes.\n    if (bytesSize % 32 !== 0)\n      value_ = Hex.padRight(value_, Math.ceil((value.length - 2) / 2 / 32) * 32)\n    return {\n      dynamic: true,\n      encoded: Hex.concat(\n        Hex.padLeft(Hex.fromNumber(bytesSize, { size: 32 })),\n        value_,\n      ),\n    }\n  }\n  if (bytesSize !== Number.parseInt(parametersize))\n    throw new AbiParameters.BytesSizeMismatchError({\n      expectedSize: Number.parseInt(parametersize),\n      value,\n    })\n  return { dynamic: false, encoded: Hex.padRight(value) }\n}\n\n/** @internal */\nexport declare namespace encodeBytes {\n  type ErrorType =\n    | Hex.padLeft.ErrorType\n    | Hex.padRight.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Hex.slice.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeBoolean(value: boolean): PreparedParameter {\n  if (typeof value !== 'boolean')\n    throw new Errors.BaseError(\n      `Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`,\n    )\n  return { dynamic: false, encoded: Hex.padLeft(Hex.fromBoolean(value)) }\n}\n\n/** @internal */\nexport declare namespace encodeBoolean {\n  type ErrorType =\n    | Hex.padLeft.ErrorType\n    | Hex.fromBoolean.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeNumber(\n  value: number,\n  { signed, size }: { signed: boolean; size: number },\n): PreparedParameter {\n  if (typeof size === 'number') {\n    const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n\n    const min = signed ? -max - 1n : 0n\n    if (value > max || value < min)\n      throw new Hex.IntegerOutOfRangeError({\n        max: max.toString(),\n        min: min.toString(),\n        signed,\n        size: size / 8,\n        value: value.toString(),\n      })\n  }\n  return {\n    dynamic: false,\n    encoded: Hex.fromNumber(value, {\n      size: 32,\n      signed,\n    }),\n  }\n}\n\n/** @internal */\nexport declare namespace encodeNumber {\n  type ErrorType = Hex.fromNumber.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeString(value: string): PreparedParameter {\n  const hexValue = Hex.fromString(value)\n  const partsLength = Math.ceil(Hex.size(hexValue) / 32)\n  const parts: Hex.Hex[] = []\n  for (let i = 0; i < partsLength; i++) {\n    parts.push(Hex.padRight(Hex.slice(hexValue, i * 32, (i + 1) * 32)))\n  }\n  return {\n    dynamic: true,\n    encoded: Hex.concat(\n      Hex.padRight(Hex.fromNumber(Hex.size(hexValue), { size: 32 })),\n      ...parts,\n    ),\n  }\n}\n\n/** @internal */\nexport declare namespace encodeString {\n  type ErrorType =\n    | Hex.fromNumber.ErrorType\n    | Hex.padRight.ErrorType\n    | Hex.slice.ErrorType\n    | Hex.size.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeTuple<\n  const parameter extends AbiParameters.Parameter & {\n    components: readonly AbiParameters.Parameter[]\n  },\n>(\n  value: ParameterToPrimitiveType<parameter>,\n  options: {\n    checksumAddress?: boolean | undefined\n    parameter: parameter\n  },\n): PreparedParameter {\n  const { checksumAddress, parameter } = options\n\n  let dynamic = false\n  const preparedParameters: PreparedParameter[] = []\n  for (let i = 0; i < parameter.components.length; i++) {\n    const param_ = parameter.components[i]!\n    const index = Array.isArray(value) ? i : param_.name\n    const preparedParam = prepareParameter({\n      checksumAddress,\n      parameter: param_,\n      value: (value as any)[index!] as readonly unknown[],\n    })\n    preparedParameters.push(preparedParam)\n    if (preparedParam.dynamic) dynamic = true\n  }\n  return {\n    dynamic,\n    encoded: dynamic\n      ? encode(preparedParameters)\n      : Hex.concat(...preparedParameters.map(({ encoded }) => encoded)),\n  }\n}\n\n/** @internal */\nexport declare namespace encodeTuple {\n  type ErrorType = Hex.concat.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function getArrayComponents(\n  type: string,\n): [length: number | null, innerType: string] | undefined {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/)\n  return matches\n    ? // Return `null` if the array is dynamic.\n      [matches[2]! ? Number(matches[2]!) : null, matches[1]!]\n    : undefined\n}\n\n/** @internal */\nexport function hasDynamicChild(param: AbiParameters.Parameter) {\n  const { type } = param\n  if (type === 'string') return true\n  if (type === 'bytes') return true\n  if (type.endsWith('[]')) return true\n\n  if (type === 'tuple') return (param as any).components?.some(hasDynamicChild)\n\n  const arrayComponents = getArrayComponents(param.type)\n  if (\n    arrayComponents &&\n    hasDynamicChild({\n      ...param,\n      type: arrayComponents[1],\n    } as AbiParameters.Parameter)\n  )\n    return true\n\n  return false\n}\n"],"mappings":"AAMA,OAAO,KAAKA,aAAa,MAAM,qBAAqB;AACpD,OAAO,KAAKC,OAAO,MAAM,eAAe;AACxC,OAAO,KAAKC,KAAK,MAAM,aAAa;AACpC,OAAO,KAAKC,MAAM,MAAM,cAAc;AACtC,OAAO,KAAKC,GAAG,MAAM,WAAW;AAChC,SAASC,YAAY,QAAQ,gBAAgB;AAkD7C;AACA,OAAM,SAAUC,eAAeA,CAC7BC,MAAqB,EACrBC,KAA8B,EAC9BC,OAA0E;EAE1E,MAAM;IAAEC,eAAe;IAAEC;EAAc,CAAE,GAAGF,OAAO;EACnD,MAAMG,eAAe,GAAGC,kBAAkB,CAACL,KAAK,CAACM,IAAI,CAAC;EACtD,IAAIF,eAAe,EAAE;IACnB,MAAM,CAACG,MAAM,EAAED,IAAI,CAAC,GAAGF,eAAe;IACtC,OAAOI,WAAW,CAChBT,MAAM,EACN;MAAE,GAAGC,KAAK;MAAEM;IAAI,CAAE,EAClB;MAAEJ,eAAe;MAAEK,MAAM;MAAEJ;IAAc,CAAE,CAC5C;EACH;EACA,IAAIH,KAAK,CAACM,IAAI,KAAK,OAAO,EACxB,OAAOG,WAAW,CAACV,MAAM,EAAEC,KAA0B,EAAE;IACrDE,eAAe;IACfC;GACD,CAAC;EACJ,IAAIH,KAAK,CAACM,IAAI,KAAK,SAAS,EAC1B,OAAOI,aAAa,CAACX,MAAM,EAAE;IAAEY,QAAQ,EAAET;EAAe,CAAE,CAAC;EAC7D,IAAIF,KAAK,CAACM,IAAI,KAAK,MAAM,EAAE,OAAOM,UAAU,CAACb,MAAM,CAAC;EACpD,IAAIC,KAAK,CAACM,IAAI,CAACO,UAAU,CAAC,OAAO,CAAC,EAChC,OAAOC,WAAW,CAACf,MAAM,EAAEC,KAAK,EAAE;IAAEG;EAAc,CAAE,CAAC;EACvD,IAAIH,KAAK,CAACM,IAAI,CAACO,UAAU,CAAC,MAAM,CAAC,IAAIb,KAAK,CAACM,IAAI,CAACO,UAAU,CAAC,KAAK,CAAC,EAC/D,OAAOE,YAAY,CAAChB,MAAM,EAAEC,KAAK,CAAC;EACpC,IAAIA,KAAK,CAACM,IAAI,KAAK,QAAQ,EAAE,OAAOU,YAAY,CAACjB,MAAM,EAAE;IAAEI;EAAc,CAAE,CAAC;EAC5E,MAAM,IAAIX,aAAa,CAACyB,gBAAgB,CAACjB,KAAK,CAACM,IAAI,CAAC;AACtD;AAeA,MAAMY,YAAY,GAAG,EAAE;AACvB,MAAMC,YAAY,GAAG,EAAE;AAEvB;AACA,OAAM,SAAUT,aAAaA,CAC3BX,MAAqB,EACrBE,OAAA,GAA8C,EAAE;EAEhD,MAAM;IAAEU,QAAQ,GAAG;EAAK,CAAE,GAAGV,OAAO;EACpC,MAAMmB,KAAK,GAAGrB,MAAM,CAACsB,SAAS,CAAC,EAAE,CAAC;EAClC,MAAMC,IAAI,GAAIC,OAAgB,IAC5BZ,QAAQ,GAAGlB,OAAO,CAACkB,QAAQ,CAACY,OAAO,CAAC,GAAGA,OAAO;EAChD,OAAO,CAACD,IAAI,CAAC1B,GAAG,CAAC4B,SAAS,CAAC9B,KAAK,CAAC+B,KAAK,CAACL,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;AAC3D;AASA;AACA,OAAM,SAAUZ,WAAWA,CACzBT,MAAqB,EACrBC,KAA8B,EAC9BC,OAIC;EAED,MAAM;IAAEC,eAAe;IAAEK,MAAM;IAAEJ;EAAc,CAAE,GAAGF,OAAO;EAE3D;EACA;EACA,IAAI,CAACM,MAAM,EAAE;IACX;IACA,MAAMmB,MAAM,GAAGhC,KAAK,CAACiC,QAAQ,CAAC5B,MAAM,CAACsB,SAAS,CAACF,YAAY,CAAC,CAAC;IAE7D;IACA,MAAMS,KAAK,GAAGzB,cAAc,GAAGuB,MAAM;IACrC,MAAMG,WAAW,GAAGD,KAAK,GAAGV,YAAY;IAExC;IACAnB,MAAM,CAAC+B,WAAW,CAACF,KAAK,CAAC;IACzB,MAAMrB,MAAM,GAAGb,KAAK,CAACiC,QAAQ,CAAC5B,MAAM,CAACsB,SAAS,CAACH,YAAY,CAAC,CAAC;IAE7D;IACA,MAAMa,YAAY,GAAGC,eAAe,CAAChC,KAAK,CAAC;IAE3C,IAAIiC,QAAQ,GAAG,CAAC;IAChB,MAAMb,KAAK,GAAc,EAAE;IAC3B,KAAK,IAAIc,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG3B,MAAM,EAAE,EAAE2B,CAAC,EAAE;MAC/B;MACA;MACAnC,MAAM,CAAC+B,WAAW,CAACD,WAAW,IAAIE,YAAY,GAAGG,CAAC,GAAG,EAAE,GAAGD,QAAQ,CAAC,CAAC;MACpE,MAAM,CAACE,IAAI,EAAEC,SAAS,CAAC,GAAGtC,eAAe,CAACC,MAAM,EAAEC,KAAK,EAAE;QACvDE,eAAe;QACfC,cAAc,EAAE0B;OACjB,CAAC;MACFI,QAAQ,IAAIG,SAAS;MACrBhB,KAAK,CAACiB,IAAI,CAACF,IAAI,CAAC;IAClB;IAEA;IACApC,MAAM,CAAC+B,WAAW,CAAC3B,cAAc,GAAG,EAAE,CAAC;IACvC,OAAO,CAACiB,KAAK,EAAE,EAAE,CAAC;EACpB;EAEA;EACA;EACA;EACA,IAAIY,eAAe,CAAChC,KAAK,CAAC,EAAE;IAC1B;IACA,MAAM0B,MAAM,GAAGhC,KAAK,CAACiC,QAAQ,CAAC5B,MAAM,CAACsB,SAAS,CAACF,YAAY,CAAC,CAAC;IAE7D;IACA,MAAMS,KAAK,GAAGzB,cAAc,GAAGuB,MAAM;IAErC,MAAMN,KAAK,GAAc,EAAE;IAC3B,KAAK,IAAIc,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG3B,MAAM,EAAE,EAAE2B,CAAC,EAAE;MAC/B;MACAnC,MAAM,CAAC+B,WAAW,CAACF,KAAK,GAAGM,CAAC,GAAG,EAAE,CAAC;MAClC,MAAM,CAACC,IAAI,CAAC,GAAGrC,eAAe,CAACC,MAAM,EAAEC,KAAK,EAAE;QAC5CE,eAAe;QACfC,cAAc,EAAEyB;OACjB,CAAC;MACFR,KAAK,CAACiB,IAAI,CAACF,IAAI,CAAC;IAClB;IAEA;IACApC,MAAM,CAAC+B,WAAW,CAAC3B,cAAc,GAAG,EAAE,CAAC;IACvC,OAAO,CAACiB,KAAK,EAAE,EAAE,CAAC;EACpB;EAEA;EACA;EACA,IAAIa,QAAQ,GAAG,CAAC;EAChB,MAAMb,KAAK,GAAc,EAAE;EAC3B,KAAK,IAAIc,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG3B,MAAM,EAAE,EAAE2B,CAAC,EAAE;IAC/B,MAAM,CAACC,IAAI,EAAEC,SAAS,CAAC,GAAGtC,eAAe,CAACC,MAAM,EAAEC,KAAK,EAAE;MACvDE,eAAe;MACfC,cAAc,EAAEA,cAAc,GAAG8B;KAClC,CAAC;IACFA,QAAQ,IAAIG,SAAS;IACrBhB,KAAK,CAACiB,IAAI,CAACF,IAAI,CAAC;EAClB;EACA,OAAO,CAACf,KAAK,EAAEa,QAAQ,CAAC;AAC1B;AAMA;AACA,OAAM,SAAUrB,UAAUA,CAACb,MAAqB;EAC9C,OAAO,CAACL,KAAK,CAAC4C,SAAS,CAACvC,MAAM,CAACsB,SAAS,CAAC,EAAE,CAAC,EAAE;IAAEkB,IAAI,EAAE;EAAE,CAAE,CAAC,EAAE,EAAE,CAAC;AAClE;AAMA;AACA,OAAM,SAAUzB,WAAWA,CACzBf,MAAqB,EACrBC,KAA8B,EAC9B;EAAEG;AAAc,CAA8B;EAE9C,MAAM,CAACqC,CAAC,EAAED,IAAI,CAAC,GAAGvC,KAAK,CAACM,IAAI,CAACmC,KAAK,CAAC,OAAO,CAAC;EAC3C,IAAI,CAACF,IAAI,EAAE;IACT;IACA,MAAMb,MAAM,GAAGhC,KAAK,CAACiC,QAAQ,CAAC5B,MAAM,CAACsB,SAAS,CAAC,EAAE,CAAC,CAAC;IAEnD;IACAtB,MAAM,CAAC+B,WAAW,CAAC3B,cAAc,GAAGuB,MAAM,CAAC;IAE3C,MAAMnB,MAAM,GAAGb,KAAK,CAACiC,QAAQ,CAAC5B,MAAM,CAACsB,SAAS,CAAC,EAAE,CAAC,CAAC;IAEnD;IACA,IAAId,MAAM,KAAK,CAAC,EAAE;MAChB;MACAR,MAAM,CAAC+B,WAAW,CAAC3B,cAAc,GAAG,EAAE,CAAC;MACvC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC;IACnB;IAEA,MAAMgC,IAAI,GAAGpC,MAAM,CAACsB,SAAS,CAACd,MAAM,CAAC;IAErC;IACAR,MAAM,CAAC+B,WAAW,CAAC3B,cAAc,GAAG,EAAE,CAAC;IACvC,OAAO,CAACP,GAAG,CAAC4B,SAAS,CAACW,IAAI,CAAC,EAAE,EAAE,CAAC;EAClC;EAEA,MAAMf,KAAK,GAAGxB,GAAG,CAAC4B,SAAS,CAACzB,MAAM,CAACsB,SAAS,CAACqB,MAAM,CAACC,QAAQ,CAACJ,IAAI,CAAC,EAAE,EAAE,CAAC,CAAC;EACxE,OAAO,CAACnB,KAAK,EAAE,EAAE,CAAC;AACpB;AASA;AACA,OAAM,SAAUL,YAAYA,CAC1BhB,MAAqB,EACrBC,KAA8B;EAE9B,MAAM4C,MAAM,GAAG5C,KAAK,CAACM,IAAI,CAACO,UAAU,CAAC,KAAK,CAAC;EAC3C,MAAM0B,IAAI,GAAGG,MAAM,CAACC,QAAQ,CAAC3C,KAAK,CAACM,IAAI,CAACmC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC;EACjE,MAAMrB,KAAK,GAAGrB,MAAM,CAACsB,SAAS,CAAC,EAAE,CAAC;EAClC,OAAO,CACLkB,IAAI,GAAG,EAAE,GACL7C,KAAK,CAACmD,QAAQ,CAACzB,KAAK,EAAE;IAAEwB;EAAM,CAAE,CAAC,GACjClD,KAAK,CAACiC,QAAQ,CAACP,KAAK,EAAE;IAAEwB;EAAM,CAAE,CAAC,EACrC,EAAE,CACH;AACH;AAcA;AACA,OAAM,SAAUnC,WAAWA,CACzBV,MAAqB,EACrBC,KAAwB,EACxBC,OAA0E;EAE1E,MAAM;IAAEC,eAAe;IAAEC;EAAc,CAAE,GAAGF,OAAO;EAEnD;EACA;EACA;EACA;EACA,MAAM6C,eAAe,GACnB9C,KAAK,CAAC+C,UAAU,CAACxC,MAAM,KAAK,CAAC,IAAIP,KAAK,CAAC+C,UAAU,CAACC,IAAI,CAAC,CAAC;IAAEC;EAAI,CAAE,KAAK,CAACA,IAAI,CAAC;EAE7E;EACA;EACA,MAAM7B,KAAK,GAAQ0B,eAAe,GAAG,EAAE,GAAG,EAAE;EAC5C,IAAIb,QAAQ,GAAG,CAAC;EAEhB;EACA;EACA,IAAID,eAAe,CAAChC,KAAK,CAAC,EAAE;IAC1B;IACA,MAAM0B,MAAM,GAAGhC,KAAK,CAACiC,QAAQ,CAAC5B,MAAM,CAACsB,SAAS,CAACF,YAAY,CAAC,CAAC;IAE7D;IACA,MAAMS,KAAK,GAAGzB,cAAc,GAAGuB,MAAM;IAErC,KAAK,IAAIQ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGlC,KAAK,CAAC+C,UAAU,CAACxC,MAAM,EAAE,EAAE2B,CAAC,EAAE;MAChD,MAAMgB,SAAS,GAAGlD,KAAK,CAAC+C,UAAU,CAACb,CAAC,CAAE;MACtCnC,MAAM,CAAC+B,WAAW,CAACF,KAAK,GAAGK,QAAQ,CAAC;MACpC,MAAM,CAACE,IAAI,EAAEC,SAAS,CAAC,GAAGtC,eAAe,CAACC,MAAM,EAAEmD,SAAS,EAAE;QAC3DhD,eAAe;QACfC,cAAc,EAAEyB;OACjB,CAAC;MACFK,QAAQ,IAAIG,SAAS;MACrBhB,KAAK,CAAC0B,eAAe,GAAGZ,CAAC,GAAGgB,SAAS,EAAED,IAAK,CAAC,GAAGd,IAAI;IACtD;IAEA;IACApC,MAAM,CAAC+B,WAAW,CAAC3B,cAAc,GAAG,EAAE,CAAC;IACvC,OAAO,CAACiB,KAAK,EAAE,EAAE,CAAC;EACpB;EAEA;EACA;EACA,KAAK,IAAIc,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGlC,KAAK,CAAC+C,UAAU,CAACxC,MAAM,EAAE,EAAE2B,CAAC,EAAE;IAChD,MAAMgB,SAAS,GAAGlD,KAAK,CAAC+C,UAAU,CAACb,CAAC,CAAE;IACtC,MAAM,CAACC,IAAI,EAAEC,SAAS,CAAC,GAAGtC,eAAe,CAACC,MAAM,EAAEmD,SAAS,EAAE;MAC3DhD,eAAe;MACfC;KACD,CAAC;IACFiB,KAAK,CAAC0B,eAAe,GAAGZ,CAAC,GAAGgB,SAAS,EAAED,IAAK,CAAC,GAAGd,IAAI;IACpDF,QAAQ,IAAIG,SAAS;EACvB;EACA,OAAO,CAAChB,KAAK,EAAEa,QAAQ,CAAC;AAC1B;AAMA;AACA,OAAM,SAAUjB,YAAYA,CAC1BjB,MAAqB,EACrB;EAAEI;AAAc,CAA8B;EAE9C;EACA,MAAMuB,MAAM,GAAGhC,KAAK,CAACiC,QAAQ,CAAC5B,MAAM,CAACsB,SAAS,CAAC,EAAE,CAAC,CAAC;EAEnD;EACA,MAAMO,KAAK,GAAGzB,cAAc,GAAGuB,MAAM;EACrC3B,MAAM,CAAC+B,WAAW,CAACF,KAAK,CAAC;EAEzB,MAAMrB,MAAM,GAAGb,KAAK,CAACiC,QAAQ,CAAC5B,MAAM,CAACsB,SAAS,CAAC,EAAE,CAAC,CAAC;EAEnD;EACA,IAAId,MAAM,KAAK,CAAC,EAAE;IAChBR,MAAM,CAAC+B,WAAW,CAAC3B,cAAc,GAAG,EAAE,CAAC;IACvC,OAAO,CAAC,EAAE,EAAE,EAAE,CAAC;EACjB;EAEA,MAAMgC,IAAI,GAAGpC,MAAM,CAACsB,SAAS,CAACd,MAAM,EAAE,EAAE,CAAC;EACzC,MAAMa,KAAK,GAAG1B,KAAK,CAACyD,QAAQ,CAACzD,KAAK,CAAC0D,QAAQ,CAACjB,IAAI,CAAC,CAAC;EAElD;EACApC,MAAM,CAAC+B,WAAW,CAAC3B,cAAc,GAAG,EAAE,CAAC;EAEvC,OAAO,CAACiB,KAAK,EAAE,EAAE,CAAC;AACpB;AAUA;AACA,OAAM,SAAUiC,iBAAiBA,CAE/B;EACAnD,eAAe;EACfoD,UAAU;EACVC;AAAM,CAOP;EACC,MAAMC,kBAAkB,GAAwB,EAAE;EAClD,KAAK,IAAItB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoB,UAAU,CAAC/C,MAAM,EAAE2B,CAAC,EAAE,EAAE;IAC1CsB,kBAAkB,CAACnB,IAAI,CACrBoB,gBAAgB,CAAC;MACfvD,eAAe;MACfwD,SAAS,EAAEJ,UAAU,CAACpB,CAAC,CAAE;MACzBd,KAAK,EAAEmC,MAAM,CAACrB,CAAC;KAChB,CAAC,CACH;EACH;EACA,OAAOsB,kBAAkB;AAC3B;AAOA;AACA,OAAM,SAAUC,gBAAgBA,CAE9B;EACAvD,eAAe,GAAG,KAAK;EACvBwD,SAAS,EAAEC,UAAU;EACrBvC;AAAK,CAON;EACC,MAAMsC,SAAS,GAAGC,UAAqC;EAEvD,MAAMvD,eAAe,GAAGC,kBAAkB,CAACqD,SAAS,CAACpD,IAAI,CAAC;EAC1D,IAAIF,eAAe,EAAE;IACnB,MAAM,CAACG,MAAM,EAAED,IAAI,CAAC,GAAGF,eAAe;IACtC,OAAOwD,WAAW,CAACxC,KAAK,EAAE;MACxBlB,eAAe;MACfK,MAAM;MACNmD,SAAS,EAAE;QACT,GAAGA,SAAS;QACZpD;;KAEH,CAAC;EACJ;EACA,IAAIoD,SAAS,CAACpD,IAAI,KAAK,OAAO,EAAE;IAC9B,OAAOuD,WAAW,CAACzC,KAAyB,EAAE;MAC5ClB,eAAe;MACfwD,SAAS,EAAEA;KACZ,CAAC;EACJ;EACA,IAAIA,SAAS,CAACpD,IAAI,KAAK,SAAS,EAAE;IAChC,OAAOwD,aAAa,CAAC1C,KAA2B,EAAE;MAChDT,QAAQ,EAAET;KACX,CAAC;EACJ;EACA,IAAIwD,SAAS,CAACpD,IAAI,KAAK,MAAM,EAAE;IAC7B,OAAOyD,aAAa,CAAC3C,KAA2B,CAAC;EACnD;EACA,IAAIsC,SAAS,CAACpD,IAAI,CAACO,UAAU,CAAC,MAAM,CAAC,IAAI6C,SAAS,CAACpD,IAAI,CAACO,UAAU,CAAC,KAAK,CAAC,EAAE;IACzE,MAAM+B,MAAM,GAAGc,SAAS,CAACpD,IAAI,CAACO,UAAU,CAAC,KAAK,CAAC;IAC/C,MAAM,IAAK0B,IAAI,GAAG,KAAK,CAAC,GAAG1C,YAAY,CAACmE,IAAI,CAACN,SAAS,CAACpD,IAAI,CAAC,IAAI,EAAE;IAClE,OAAO2D,YAAY,CAAC7C,KAA0B,EAAE;MAC9CwB,MAAM;MACNL,IAAI,EAAEG,MAAM,CAACH,IAAI;KAClB,CAAC;EACJ;EACA,IAAImB,SAAS,CAACpD,IAAI,CAACO,UAAU,CAAC,OAAO,CAAC,EAAE;IACtC,OAAOqD,WAAW,CAAC9C,KAA2B,EAAE;MAAEd,IAAI,EAAEoD,SAAS,CAACpD;IAAI,CAAE,CAAC;EAC3E;EACA,IAAIoD,SAAS,CAACpD,IAAI,KAAK,QAAQ,EAAE;IAC/B,OAAO6D,YAAY,CAAC/C,KAA0B,CAAC;EACjD;EACA,MAAM,IAAI5B,aAAa,CAACyB,gBAAgB,CAACyC,SAAS,CAACpD,IAAI,CAAC;AAC1D;AAeA;AACA,OAAM,SAAU8D,MAAMA,CAACZ,kBAAuC;EAC5D;EACA,IAAIa,UAAU,GAAG,CAAC;EAClB,KAAK,IAAInC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsB,kBAAkB,CAACjD,MAAM,EAAE2B,CAAC,EAAE,EAAE;IAClD,MAAM;MAAEoC,OAAO;MAAEC;IAAO,CAAE,GAAGf,kBAAkB,CAACtB,CAAC,CAAE;IACnD,IAAIoC,OAAO,EAAED,UAAU,IAAI,EAAE,MACxBA,UAAU,IAAIzE,GAAG,CAAC2C,IAAI,CAACgC,OAAO,CAAC;EACtC;EAEA;EACA,MAAMC,gBAAgB,GAAc,EAAE;EACtC,MAAMC,iBAAiB,GAAc,EAAE;EACvC,IAAIC,WAAW,GAAG,CAAC;EACnB,KAAK,IAAIxC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsB,kBAAkB,CAACjD,MAAM,EAAE2B,CAAC,EAAE,EAAE;IAClD,MAAM;MAAEoC,OAAO;MAAEC;IAAO,CAAE,GAAGf,kBAAkB,CAACtB,CAAC,CAAE;IACnD,IAAIoC,OAAO,EAAE;MACXE,gBAAgB,CAACnC,IAAI,CACnBzC,GAAG,CAAC+E,UAAU,CAACN,UAAU,GAAGK,WAAW,EAAE;QAAEnC,IAAI,EAAE;MAAE,CAAE,CAAC,CACvD;MACDkC,iBAAiB,CAACpC,IAAI,CAACkC,OAAO,CAAC;MAC/BG,WAAW,IAAI9E,GAAG,CAAC2C,IAAI,CAACgC,OAAO,CAAC;IAClC,CAAC,MAAM;MACLC,gBAAgB,CAACnC,IAAI,CAACkC,OAAO,CAAC;IAChC;EACF;EAEA;EACA,OAAO3E,GAAG,CAACgF,MAAM,CAAC,GAAGJ,gBAAgB,EAAE,GAAGC,iBAAiB,CAAC;AAC9D;AAWA;AACA,OAAM,SAAUX,aAAaA,CAC3B1C,KAAc,EACdnB,OAA8B;EAE9B,MAAM;IAAEU,QAAQ,GAAG;EAAK,CAAE,GAAGV,OAAO;EACpCR,OAAO,CAACoF,MAAM,CAACzD,KAAK,EAAE;IAAE0D,MAAM,EAAEnE;EAAQ,CAAE,CAAC;EAC3C,OAAO;IACL2D,OAAO,EAAE,KAAK;IACdC,OAAO,EAAE3E,GAAG,CAACmF,OAAO,CAAC3D,KAAK,CAAC4D,WAAW,EAAa;GACpD;AACH;AAUA;AACA,OAAM,SAAUpB,WAAWA,CACzBxC,KAA0C,EAC1CnB,OAIC;EAED,MAAM;IAAEC,eAAe;IAAEK,MAAM;IAAEmD;EAAS,CAAE,GAAGzD,OAAO;EAEtD,MAAMqE,OAAO,GAAG/D,MAAM,KAAK,IAAI;EAE/B,IAAI,CAAC0E,KAAK,CAACC,OAAO,CAAC9D,KAAK,CAAC,EAAE,MAAM,IAAI5B,aAAa,CAAC2F,iBAAiB,CAAC/D,KAAK,CAAC;EAC3E,IAAI,CAACkD,OAAO,IAAIlD,KAAK,CAACb,MAAM,KAAKA,MAAM,EACrC,MAAM,IAAIf,aAAa,CAAC4F,wBAAwB,CAAC;IAC/CC,cAAc,EAAE9E,MAAO;IACvB+E,WAAW,EAAElE,KAAK,CAACb,MAAM;IACzBD,IAAI,EAAE,GAAGoD,SAAS,CAACpD,IAAI,IAAIC,MAAM;GAClC,CAAC;EAEJ,IAAIwB,YAAY,GAAG,KAAK;EACxB,MAAMyB,kBAAkB,GAAwB,EAAE;EAClD,KAAK,IAAItB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGd,KAAK,CAACb,MAAM,EAAE2B,CAAC,EAAE,EAAE;IACrC,MAAMqD,aAAa,GAAG9B,gBAAgB,CAAC;MACrCvD,eAAe;MACfwD,SAAS;MACTtC,KAAK,EAAEA,KAAK,CAACc,CAAC;KACf,CAAC;IACF,IAAIqD,aAAa,CAACjB,OAAO,EAAEvC,YAAY,GAAG,IAAI;IAC9CyB,kBAAkB,CAACnB,IAAI,CAACkD,aAAa,CAAC;EACxC;EAEA,IAAIjB,OAAO,IAAIvC,YAAY,EAAE;IAC3B,MAAMI,IAAI,GAAGiC,MAAM,CAACZ,kBAAkB,CAAC;IACvC,IAAIc,OAAO,EAAE;MACX,MAAM/D,MAAM,GAAGX,GAAG,CAAC+E,UAAU,CAACnB,kBAAkB,CAACjD,MAAM,EAAE;QAAEgC,IAAI,EAAE;MAAE,CAAE,CAAC;MACtE,OAAO;QACL+B,OAAO,EAAE,IAAI;QACbC,OAAO,EACLf,kBAAkB,CAACjD,MAAM,GAAG,CAAC,GAAGX,GAAG,CAACgF,MAAM,CAACrE,MAAM,EAAE4B,IAAI,CAAC,GAAG5B;OAC9D;IACH;IACA,IAAIwB,YAAY,EAAE,OAAO;MAAEuC,OAAO,EAAE,IAAI;MAAEC,OAAO,EAAEpC;IAAI,CAAE;EAC3D;EACA,OAAO;IACLmC,OAAO,EAAE,KAAK;IACdC,OAAO,EAAE3E,GAAG,CAACgF,MAAM,CAAC,GAAGpB,kBAAkB,CAACgC,GAAG,CAAC,CAAC;MAAEjB;IAAO,CAAE,KAAKA,OAAO,CAAC;GACxE;AACH;AAYA;AACA,OAAM,SAAUL,WAAWA,CACzB9C,KAAc,EACd;EAAEd;AAAI,CAAoB;EAE1B,MAAM,GAAGmF,aAAa,CAAC,GAAGnF,IAAI,CAACmC,KAAK,CAAC,OAAO,CAAC;EAC7C,MAAMiD,SAAS,GAAG9F,GAAG,CAAC2C,IAAI,CAACnB,KAAK,CAAC;EACjC,IAAI,CAACqE,aAAa,EAAE;IAClB,IAAIE,MAAM,GAAGvE,KAAK;IAClB;IACA;IACA,IAAIsE,SAAS,GAAG,EAAE,KAAK,CAAC,EACtBC,MAAM,GAAG/F,GAAG,CAACgG,QAAQ,CAACD,MAAM,EAAEE,IAAI,CAACC,IAAI,CAAC,CAAC1E,KAAK,CAACb,MAAM,GAAG,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,CAAC;IAC5E,OAAO;MACL+D,OAAO,EAAE,IAAI;MACbC,OAAO,EAAE3E,GAAG,CAACgF,MAAM,CACjBhF,GAAG,CAACmF,OAAO,CAACnF,GAAG,CAAC+E,UAAU,CAACe,SAAS,EAAE;QAAEnD,IAAI,EAAE;MAAE,CAAE,CAAC,CAAC,EACpDoD,MAAM;KAET;EACH;EACA,IAAID,SAAS,KAAKhD,MAAM,CAACC,QAAQ,CAAC8C,aAAa,CAAC,EAC9C,MAAM,IAAIjG,aAAa,CAACuG,sBAAsB,CAAC;IAC7CC,YAAY,EAAEtD,MAAM,CAACC,QAAQ,CAAC8C,aAAa,CAAC;IAC5CrE;GACD,CAAC;EACJ,OAAO;IAAEkD,OAAO,EAAE,KAAK;IAAEC,OAAO,EAAE3E,GAAG,CAACgG,QAAQ,CAACxE,KAAK;EAAC,CAAE;AACzD;AAYA;AACA,OAAM,SAAU2C,aAAaA,CAAC3C,KAAc;EAC1C,IAAI,OAAOA,KAAK,KAAK,SAAS,EAC5B,MAAM,IAAIzB,MAAM,CAACsG,SAAS,CACxB,2BAA2B7E,KAAK,YAAY,OAAOA,KAAK,qCAAqC,CAC9F;EACH,OAAO;IAAEkD,OAAO,EAAE,KAAK;IAAEC,OAAO,EAAE3E,GAAG,CAACmF,OAAO,CAACnF,GAAG,CAACsG,WAAW,CAAC9E,KAAK,CAAC;EAAC,CAAE;AACzE;AAUA;AACA,OAAM,SAAU6C,YAAYA,CAC1B7C,KAAa,EACb;EAAEwB,MAAM;EAAEL;AAAI,CAAqC;EAEnD,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;IAC5B,MAAM4D,GAAG,GAAG,EAAE,KAAKC,MAAM,CAAC7D,IAAI,CAAC,IAAIK,MAAM,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC,GAAG,EAAE;IAC1D,MAAMyD,GAAG,GAAGzD,MAAM,GAAG,CAACuD,GAAG,GAAG,EAAE,GAAG,EAAE;IACnC,IAAI/E,KAAK,GAAG+E,GAAG,IAAI/E,KAAK,GAAGiF,GAAG,EAC5B,MAAM,IAAIzG,GAAG,CAAC0G,sBAAsB,CAAC;MACnCH,GAAG,EAAEA,GAAG,CAAChD,QAAQ,EAAE;MACnBkD,GAAG,EAAEA,GAAG,CAAClD,QAAQ,EAAE;MACnBP,MAAM;MACNL,IAAI,EAAEA,IAAI,GAAG,CAAC;MACdnB,KAAK,EAAEA,KAAK,CAAC+B,QAAQ;KACtB,CAAC;EACN;EACA,OAAO;IACLmB,OAAO,EAAE,KAAK;IACdC,OAAO,EAAE3E,GAAG,CAAC+E,UAAU,CAACvD,KAAK,EAAE;MAC7BmB,IAAI,EAAE,EAAE;MACRK;KACD;GACF;AACH;AAOA;AACA,OAAM,SAAUuB,YAAYA,CAAC/C,KAAa;EACxC,MAAMmF,QAAQ,GAAG3G,GAAG,CAAC4G,UAAU,CAACpF,KAAK,CAAC;EACtC,MAAMqF,WAAW,GAAGZ,IAAI,CAACC,IAAI,CAAClG,GAAG,CAAC2C,IAAI,CAACgE,QAAQ,CAAC,GAAG,EAAE,CAAC;EACtD,MAAMG,KAAK,GAAc,EAAE;EAC3B,KAAK,IAAIxE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGuE,WAAW,EAAEvE,CAAC,EAAE,EAAE;IACpCwE,KAAK,CAACrE,IAAI,CAACzC,GAAG,CAACgG,QAAQ,CAAChG,GAAG,CAAC6B,KAAK,CAAC8E,QAAQ,EAAErE,CAAC,GAAG,EAAE,EAAE,CAACA,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;EACrE;EACA,OAAO;IACLoC,OAAO,EAAE,IAAI;IACbC,OAAO,EAAE3E,GAAG,CAACgF,MAAM,CACjBhF,GAAG,CAACgG,QAAQ,CAAChG,GAAG,CAAC+E,UAAU,CAAC/E,GAAG,CAAC2C,IAAI,CAACgE,QAAQ,CAAC,EAAE;MAAEhE,IAAI,EAAE;IAAE,CAAE,CAAC,CAAC,EAC9D,GAAGmE,KAAK;GAEX;AACH;AAYA;AACA,OAAM,SAAU7C,WAAWA,CAKzBzC,KAA0C,EAC1CnB,OAGC;EAED,MAAM;IAAEC,eAAe;IAAEwD;EAAS,CAAE,GAAGzD,OAAO;EAE9C,IAAIqE,OAAO,GAAG,KAAK;EACnB,MAAMd,kBAAkB,GAAwB,EAAE;EAClD,KAAK,IAAItB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwB,SAAS,CAACX,UAAU,CAACxC,MAAM,EAAE2B,CAAC,EAAE,EAAE;IACpD,MAAMyE,MAAM,GAAGjD,SAAS,CAACX,UAAU,CAACb,CAAC,CAAE;IACvC,MAAM0E,KAAK,GAAG3B,KAAK,CAACC,OAAO,CAAC9D,KAAK,CAAC,GAAGc,CAAC,GAAGyE,MAAM,CAAC1D,IAAI;IACpD,MAAMsC,aAAa,GAAG9B,gBAAgB,CAAC;MACrCvD,eAAe;MACfwD,SAAS,EAAEiD,MAAM;MACjBvF,KAAK,EAAGA,KAAa,CAACwF,KAAM;KAC7B,CAAC;IACFpD,kBAAkB,CAACnB,IAAI,CAACkD,aAAa,CAAC;IACtC,IAAIA,aAAa,CAACjB,OAAO,EAAEA,OAAO,GAAG,IAAI;EAC3C;EACA,OAAO;IACLA,OAAO;IACPC,OAAO,EAAED,OAAO,GACZF,MAAM,CAACZ,kBAAkB,CAAC,GAC1B5D,GAAG,CAACgF,MAAM,CAAC,GAAGpB,kBAAkB,CAACgC,GAAG,CAAC,CAAC;MAAEjB;IAAO,CAAE,KAAKA,OAAO,CAAC;GACnE;AACH;AAOA;AACA,OAAM,SAAUlE,kBAAkBA,CAChCC,IAAY;EAEZ,MAAMuG,OAAO,GAAGvG,IAAI,CAACwG,KAAK,CAAC,kBAAkB,CAAC;EAC9C,OAAOD,OAAO;EACV;EACA,CAACA,OAAO,CAAC,CAAC,CAAE,GAAGnE,MAAM,CAACmE,OAAO,CAAC,CAAC,CAAE,CAAC,GAAG,IAAI,EAAEA,OAAO,CAAC,CAAC,CAAE,CAAC,GACvDE,SAAS;AACf;AAEA;AACA,OAAM,SAAU/E,eAAeA,CAAChC,KAA8B;EAC5D,MAAM;IAAEM;EAAI,CAAE,GAAGN,KAAK;EACtB,IAAIM,IAAI,KAAK,QAAQ,EAAE,OAAO,IAAI;EAClC,IAAIA,IAAI,KAAK,OAAO,EAAE,OAAO,IAAI;EACjC,IAAIA,IAAI,CAAC0G,QAAQ,CAAC,IAAI,CAAC,EAAE,OAAO,IAAI;EAEpC,IAAI1G,IAAI,KAAK,OAAO,EAAE,OAAQN,KAAa,CAAC+C,UAAU,EAAEC,IAAI,CAAChB,eAAe,CAAC;EAE7E,MAAM5B,eAAe,GAAGC,kBAAkB,CAACL,KAAK,CAACM,IAAI,CAAC;EACtD,IACEF,eAAe,IACf4B,eAAe,CAAC;IACd,GAAGhC,KAAK;IACRM,IAAI,EAAEF,eAAe,CAAC,CAAC;GACG,CAAC,EAE7B,OAAO,IAAI;EAEb,OAAO,KAAK;AACd","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}