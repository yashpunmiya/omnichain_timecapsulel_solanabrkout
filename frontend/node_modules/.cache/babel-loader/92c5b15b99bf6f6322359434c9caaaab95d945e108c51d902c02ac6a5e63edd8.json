{"ast":null,"code":"import { RELAYER_EVENTS as Xe, TRANSPORT_TYPES as P, EXPIRER_EVENTS as Tt, PAIRING_EVENTS as Je, RELAYER_DEFAULT_PROTOCOL as qt, EVENT_CLIENT_SESSION_TRACES as k, EVENT_CLIENT_SESSION_ERRORS as H, EVENT_CLIENT_AUTHENTICATE_TRACES as z, EVENT_CLIENT_AUTHENTICATE_ERRORS as re, EVENT_CLIENT_PAIRING_ERRORS as Pt, EVENT_CLIENT_PAIRING_TRACES as Nt, VERIFY_SERVER as Ot, Store as B, Core as bt } from \"@walletconnect/core\";\nimport { pino as At, getDefaultLoggerOptions as xt, generateChildLogger as Ct, getLoggerContext as Vt } from \"@walletconnect/logger\";\nimport { IEngine as Dt, ISignClient as Lt } from \"@walletconnect/types\";\nimport { THIRTY_DAYS as kt, SEVEN_DAYS as Be, FIVE_MINUTES as C, ONE_DAY as K, ONE_HOUR as We, ONE_SECOND as Ze, toMiliseconds as Oe } from \"@walletconnect/time\";\nimport { getInternalError as y, BASE64URL as ne, BASE64 as de, hashMessage as W, parseExpirerTarget as Mt, isValidString as Y, isExpired as Z, isValidId as $t, calcExpiry as V, engineEvent as R, createDelayedPromise as ee, getSdkError as O, getDeepLink as Ut, handleDeeplinkRedirect as Kt, isSessionCompatible as Gt, hashKey as be, parseChainId as Ae, createEncodedRecap as jt, getRecapFromResources as xe, mergeEncodedRecaps as Ft, TYPE_2 as Qt, getLinkModeURL as ue, validateSignedCacao as et, getNamespacedDidChainId as tt, getDidAddress as st, getMethodsFromRecap as it, getChainsFromRecap as rt, buildNamespacesFromAuth as nt, formatMessage as Ht, MemoryStore as oe, isValidParams as M, isUndefined as X, isValidRelays as zt, isValidObject as ot, isValidRequiredNamespaces as Yt, isValidNamespaces as Ce, isConformingNamespaces as at, isValidErrorReason as Xt, isValidRelay as Jt, isValidController as Bt, isValidNamespacesChainId as ct, isValidRequest as Wt, isValidNamespacesRequest as Zt, isValidRequestExpiry as es, isValidResponse as ts, isValidEvent as ss, isValidNamespacesEvent as is, getSearchParamFromURL as lt, isTestRun as rs, isReactNative as ns, isValidArray as os, extractSolanaTransactionId as as, TYPE_1 as Ve, getAppMetadata as cs } from \"@walletconnect/utils\";\nimport ls, { EventEmitter as ps } from \"events\";\nimport { isJsonRpcRequest as hs, isJsonRpcResponse as ds, payloadId as G, getBigIntRpcId as ge, isJsonRpcResult as j, isJsonRpcError as F, formatJsonRpcRequest as ye, formatJsonRpcResult as us, formatJsonRpcError as gs } from \"@walletconnect/jsonrpc-utils\";\nconst De = \"wc\",\n  Le = 2,\n  ke = \"client\",\n  we = `${De}@${Le}:${ke}:`,\n  me = {\n    name: ke,\n    logger: \"error\",\n    controller: !1,\n    relayUrl: \"wss://relay.walletconnect.org\"\n  },\n  ys = {\n    session_proposal: \"session_proposal\",\n    session_update: \"session_update\",\n    session_extend: \"session_extend\",\n    session_ping: \"session_ping\",\n    session_delete: \"session_delete\",\n    session_expire: \"session_expire\",\n    session_request: \"session_request\",\n    session_request_sent: \"session_request_sent\",\n    session_event: \"session_event\",\n    proposal_expire: \"proposal_expire\",\n    session_authenticate: \"session_authenticate\",\n    session_request_expire: \"session_request_expire\",\n    session_connect: \"session_connect\"\n  },\n  ws = {\n    database: \":memory:\"\n  },\n  Me = \"WALLETCONNECT_DEEPLINK_CHOICE\",\n  ms = {\n    created: \"history_created\",\n    updated: \"history_updated\",\n    deleted: \"history_deleted\",\n    sync: \"history_sync\"\n  },\n  _s = \"history\",\n  Es = \"0.3\",\n  pt = \"proposal\",\n  fs = kt,\n  $e = \"Proposal expired\",\n  ht = \"session\",\n  J = Be,\n  dt = \"engine\",\n  N = {\n    wc_sessionPropose: {\n      req: {\n        ttl: C,\n        prompt: !0,\n        tag: 1100\n      },\n      res: {\n        ttl: C,\n        prompt: !1,\n        tag: 1101\n      },\n      reject: {\n        ttl: C,\n        prompt: !1,\n        tag: 1120\n      },\n      autoReject: {\n        ttl: C,\n        prompt: !1,\n        tag: 1121\n      }\n    },\n    wc_sessionSettle: {\n      req: {\n        ttl: C,\n        prompt: !1,\n        tag: 1102\n      },\n      res: {\n        ttl: C,\n        prompt: !1,\n        tag: 1103\n      }\n    },\n    wc_sessionUpdate: {\n      req: {\n        ttl: K,\n        prompt: !1,\n        tag: 1104\n      },\n      res: {\n        ttl: K,\n        prompt: !1,\n        tag: 1105\n      }\n    },\n    wc_sessionExtend: {\n      req: {\n        ttl: K,\n        prompt: !1,\n        tag: 1106\n      },\n      res: {\n        ttl: K,\n        prompt: !1,\n        tag: 1107\n      }\n    },\n    wc_sessionRequest: {\n      req: {\n        ttl: C,\n        prompt: !0,\n        tag: 1108\n      },\n      res: {\n        ttl: C,\n        prompt: !1,\n        tag: 1109\n      }\n    },\n    wc_sessionEvent: {\n      req: {\n        ttl: C,\n        prompt: !0,\n        tag: 1110\n      },\n      res: {\n        ttl: C,\n        prompt: !1,\n        tag: 1111\n      }\n    },\n    wc_sessionDelete: {\n      req: {\n        ttl: K,\n        prompt: !1,\n        tag: 1112\n      },\n      res: {\n        ttl: K,\n        prompt: !1,\n        tag: 1113\n      }\n    },\n    wc_sessionPing: {\n      req: {\n        ttl: K,\n        prompt: !1,\n        tag: 1114\n      },\n      res: {\n        ttl: K,\n        prompt: !1,\n        tag: 1115\n      }\n    },\n    wc_sessionAuthenticate: {\n      req: {\n        ttl: We,\n        prompt: !0,\n        tag: 1116\n      },\n      res: {\n        ttl: We,\n        prompt: !1,\n        tag: 1117\n      },\n      reject: {\n        ttl: C,\n        prompt: !1,\n        tag: 1118\n      },\n      autoReject: {\n        ttl: C,\n        prompt: !1,\n        tag: 1119\n      }\n    }\n  },\n  _e = {\n    min: C,\n    max: Be\n  },\n  $ = {\n    idle: \"IDLE\",\n    active: \"ACTIVE\"\n  },\n  Ue = {\n    eth_sendTransaction: {\n      key: \"\"\n    },\n    eth_sendRawTransaction: {\n      key: \"\"\n    },\n    wallet_sendCalls: {\n      key: \"\"\n    },\n    solana_signTransaction: {\n      key: \"signature\"\n    },\n    solana_signAllTransactions: {\n      key: \"transactions\"\n    },\n    solana_signAndSendTransaction: {\n      key: \"signature\"\n    }\n  },\n  ut = \"request\",\n  gt = [\"wc_sessionPropose\", \"wc_sessionRequest\", \"wc_authRequest\", \"wc_sessionAuthenticate\"],\n  yt = \"wc\",\n  Ss = 1.5,\n  wt = \"auth\",\n  mt = \"authKeys\",\n  _t = \"pairingTopics\",\n  Et = \"requests\",\n  ae = `${yt}@${1.5}:${wt}:`,\n  ce = `${ae}:PUB_KEY`;\nvar Rs = Object.defineProperty,\n  vs = Object.defineProperties,\n  Is = Object.getOwnPropertyDescriptors,\n  ft = Object.getOwnPropertySymbols,\n  Ts = Object.prototype.hasOwnProperty,\n  qs = Object.prototype.propertyIsEnumerable,\n  Ke = (S, n, e) => n in S ? Rs(S, n, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : S[n] = e,\n  v = (S, n) => {\n    for (var e in n || (n = {})) Ts.call(n, e) && Ke(S, e, n[e]);\n    if (ft) for (var e of ft(n)) qs.call(n, e) && Ke(S, e, n[e]);\n    return S;\n  },\n  b = (S, n) => vs(S, Is(n)),\n  c = (S, n, e) => Ke(S, typeof n != \"symbol\" ? n + \"\" : n, e);\nclass Ps extends Dt {\n  constructor(n) {\n    super(n), c(this, \"name\", dt), c(this, \"events\", new ls()), c(this, \"initialized\", !1), c(this, \"requestQueue\", {\n      state: $.idle,\n      queue: []\n    }), c(this, \"sessionRequestQueue\", {\n      state: $.idle,\n      queue: []\n    }), c(this, \"requestQueueDelay\", Ze), c(this, \"expectedPairingMethodMap\", new Map()), c(this, \"recentlyDeletedMap\", new Map()), c(this, \"recentlyDeletedLimit\", 200), c(this, \"relayMessageCache\", []), c(this, \"pendingSessions\", new Map()), c(this, \"init\", async () => {\n      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({\n        methods: Object.keys(N)\n      }), this.initialized = !0, setTimeout(async () => {\n        await this.processPendingMessageEvents(), this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();\n      }, Oe(this.requestQueueDelay)));\n    }), c(this, \"connect\", async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      const t = b(v({}, e), {\n        requiredNamespaces: e.requiredNamespaces || {},\n        optionalNamespaces: e.optionalNamespaces || {}\n      });\n      await this.isValidConnect(t);\n      const {\n        pairingTopic: s,\n        requiredNamespaces: i,\n        optionalNamespaces: r,\n        sessionProperties: o,\n        scopedProperties: a,\n        relays: l\n      } = t;\n      let p = s,\n        h,\n        u = !1;\n      try {\n        if (p) {\n          const T = this.client.core.pairing.pairings.get(p);\n          this.client.logger.warn(\"connect() with existing pairing topic is deprecated and will be removed in the next major release.\"), u = T.active;\n        }\n      } catch (T) {\n        throw this.client.logger.error(`connect() -> pairing.get(${p}) failed`), T;\n      }\n      if (!p || !u) {\n        const {\n          topic: T,\n          uri: U\n        } = await this.client.core.pairing.create();\n        p = T, h = U;\n      }\n      if (!p) {\n        const {\n          message: T\n        } = y(\"NO_MATCHING_KEY\", `connect() pairing topic: ${p}`);\n        throw new Error(T);\n      }\n      const d = await this.client.core.crypto.generateKeyPair(),\n        w = N.wc_sessionPropose.req.ttl || C,\n        m = V(w),\n        f = b(v(v({\n          requiredNamespaces: i,\n          optionalNamespaces: r,\n          relays: l ?? [{\n            protocol: qt\n          }],\n          proposer: {\n            publicKey: d,\n            metadata: this.client.metadata\n          },\n          expiryTimestamp: m,\n          pairingTopic: p\n        }, o && {\n          sessionProperties: o\n        }), a && {\n          scopedProperties: a\n        }), {\n          id: G()\n        }),\n        _ = R(\"session_connect\", f.id),\n        {\n          reject: g,\n          resolve: A,\n          done: D\n        } = ee(w, $e),\n        I = ({\n          id: T\n        }) => {\n          T === f.id && (this.client.events.off(\"proposal_expire\", I), this.pendingSessions.delete(f.id), this.events.emit(_, {\n            error: {\n              message: $e,\n              code: 0\n            }\n          }));\n        };\n      return this.client.events.on(\"proposal_expire\", I), this.events.once(_, ({\n        error: T,\n        session: U\n      }) => {\n        this.client.events.off(\"proposal_expire\", I), T ? g(T) : U && A(U);\n      }), await this.sendRequest({\n        topic: p,\n        method: \"wc_sessionPropose\",\n        params: f,\n        throwOnFailedPublish: !0,\n        clientRpcId: f.id\n      }), await this.setProposal(f.id, f), {\n        uri: h,\n        approval: D\n      };\n    }), c(this, \"pair\", async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      try {\n        return await this.client.core.pairing.pair(e);\n      } catch (t) {\n        throw this.client.logger.error(\"pair() failed\"), t;\n      }\n    }), c(this, \"approve\", async e => {\n      var t, s, i;\n      const r = this.client.core.eventClient.createEvent({\n        properties: {\n          topic: (t = e?.id) == null ? void 0 : t.toString(),\n          trace: [k.session_approve_started]\n        }\n      });\n      try {\n        this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      } catch (q) {\n        throw r.setError(H.no_internet_connection), q;\n      }\n      try {\n        await this.isValidProposalId(e?.id);\n      } catch (q) {\n        throw this.client.logger.error(`approve() -> proposal.get(${e?.id}) failed`), r.setError(H.proposal_not_found), q;\n      }\n      try {\n        await this.isValidApprove(e);\n      } catch (q) {\n        throw this.client.logger.error(\"approve() -> isValidApprove() failed\"), r.setError(H.session_approve_namespace_validation_failure), q;\n      }\n      const {\n          id: o,\n          relayProtocol: a,\n          namespaces: l,\n          sessionProperties: p,\n          scopedProperties: h,\n          sessionConfig: u\n        } = e,\n        d = this.client.proposal.get(o);\n      this.client.core.eventClient.deleteEvent({\n        eventId: r.eventId\n      });\n      const {\n        pairingTopic: w,\n        proposer: m,\n        requiredNamespaces: f,\n        optionalNamespaces: _\n      } = d;\n      let g = (s = this.client.core.eventClient) == null ? void 0 : s.getEvent({\n        topic: w\n      });\n      g || (g = (i = this.client.core.eventClient) == null ? void 0 : i.createEvent({\n        type: k.session_approve_started,\n        properties: {\n          topic: w,\n          trace: [k.session_approve_started, k.session_namespaces_validation_success]\n        }\n      }));\n      const A = await this.client.core.crypto.generateKeyPair(),\n        D = m.publicKey,\n        I = await this.client.core.crypto.generateSharedKey(A, D),\n        T = v(v(v({\n          relay: {\n            protocol: a ?? \"irn\"\n          },\n          namespaces: l,\n          controller: {\n            publicKey: A,\n            metadata: this.client.metadata\n          },\n          expiry: V(J)\n        }, p && {\n          sessionProperties: p\n        }), h && {\n          scopedProperties: h\n        }), u && {\n          sessionConfig: u\n        }),\n        U = P.relay;\n      g.addTrace(k.subscribing_session_topic);\n      try {\n        await this.client.core.relayer.subscribe(I, {\n          transportType: U\n        });\n      } catch (q) {\n        throw g.setError(H.subscribe_session_topic_failure), q;\n      }\n      g.addTrace(k.subscribe_session_topic_success);\n      const fe = b(v({}, T), {\n        topic: I,\n        requiredNamespaces: f,\n        optionalNamespaces: _,\n        pairingTopic: w,\n        acknowledged: !1,\n        self: T.controller,\n        peer: {\n          publicKey: m.publicKey,\n          metadata: m.metadata\n        },\n        controller: A,\n        transportType: P.relay\n      });\n      await this.client.session.set(I, fe), g.addTrace(k.store_session);\n      try {\n        g.addTrace(k.publishing_session_settle), await this.sendRequest({\n          topic: I,\n          method: \"wc_sessionSettle\",\n          params: T,\n          throwOnFailedPublish: !0\n        }).catch(q => {\n          throw g?.setError(H.session_settle_publish_failure), q;\n        }), g.addTrace(k.session_settle_publish_success), g.addTrace(k.publishing_session_approve), await this.sendResult({\n          id: o,\n          topic: w,\n          result: {\n            relay: {\n              protocol: a ?? \"irn\"\n            },\n            responderPublicKey: A\n          },\n          throwOnFailedPublish: !0\n        }).catch(q => {\n          throw g?.setError(H.session_approve_publish_failure), q;\n        }), g.addTrace(k.session_approve_publish_success);\n      } catch (q) {\n        throw this.client.logger.error(q), this.client.session.delete(I, O(\"USER_DISCONNECTED\")), await this.client.core.relayer.unsubscribe(I), q;\n      }\n      return this.client.core.eventClient.deleteEvent({\n        eventId: g.eventId\n      }), await this.client.core.pairing.updateMetadata({\n        topic: w,\n        metadata: m.metadata\n      }), await this.client.proposal.delete(o, O(\"USER_DISCONNECTED\")), await this.client.core.pairing.activate({\n        topic: w\n      }), await this.setExpiry(I, V(J)), {\n        topic: I,\n        acknowledged: () => Promise.resolve(this.client.session.get(I))\n      };\n    }), c(this, \"reject\", async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      try {\n        await this.isValidReject(e);\n      } catch (r) {\n        throw this.client.logger.error(\"reject() -> isValidReject() failed\"), r;\n      }\n      const {\n        id: t,\n        reason: s\n      } = e;\n      let i;\n      try {\n        i = this.client.proposal.get(t).pairingTopic;\n      } catch (r) {\n        throw this.client.logger.error(`reject() -> proposal.get(${t}) failed`), r;\n      }\n      i && (await this.sendError({\n        id: t,\n        topic: i,\n        error: s,\n        rpcOpts: N.wc_sessionPropose.reject\n      }), await this.client.proposal.delete(t, O(\"USER_DISCONNECTED\")));\n    }), c(this, \"update\", async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      try {\n        await this.isValidUpdate(e);\n      } catch (h) {\n        throw this.client.logger.error(\"update() -> isValidUpdate() failed\"), h;\n      }\n      const {\n          topic: t,\n          namespaces: s\n        } = e,\n        {\n          done: i,\n          resolve: r,\n          reject: o\n        } = ee(),\n        a = G(),\n        l = ge().toString(),\n        p = this.client.session.get(t).namespaces;\n      return this.events.once(R(\"session_update\", a), ({\n        error: h\n      }) => {\n        h ? o(h) : r();\n      }), await this.client.session.update(t, {\n        namespaces: s\n      }), await this.sendRequest({\n        topic: t,\n        method: \"wc_sessionUpdate\",\n        params: {\n          namespaces: s\n        },\n        throwOnFailedPublish: !0,\n        clientRpcId: a,\n        relayRpcId: l\n      }).catch(h => {\n        this.client.logger.error(h), this.client.session.update(t, {\n          namespaces: p\n        }), o(h);\n      }), {\n        acknowledged: i\n      };\n    }), c(this, \"extend\", async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      try {\n        await this.isValidExtend(e);\n      } catch (a) {\n        throw this.client.logger.error(\"extend() -> isValidExtend() failed\"), a;\n      }\n      const {\n          topic: t\n        } = e,\n        s = G(),\n        {\n          done: i,\n          resolve: r,\n          reject: o\n        } = ee();\n      return this.events.once(R(\"session_extend\", s), ({\n        error: a\n      }) => {\n        a ? o(a) : r();\n      }), await this.setExpiry(t, V(J)), this.sendRequest({\n        topic: t,\n        method: \"wc_sessionExtend\",\n        params: {},\n        clientRpcId: s,\n        throwOnFailedPublish: !0\n      }).catch(a => {\n        o(a);\n      }), {\n        acknowledged: i\n      };\n    }), c(this, \"request\", async e => {\n      this.isInitialized();\n      try {\n        await this.isValidRequest(e);\n      } catch (_) {\n        throw this.client.logger.error(\"request() -> isValidRequest() failed\"), _;\n      }\n      const {\n          chainId: t,\n          request: s,\n          topic: i,\n          expiry: r = N.wc_sessionRequest.req.ttl\n        } = e,\n        o = this.client.session.get(i);\n      o?.transportType === P.relay && (await this.confirmOnlineStateOrThrow());\n      const a = G(),\n        l = ge().toString(),\n        {\n          done: p,\n          resolve: h,\n          reject: u\n        } = ee(r, \"Request expired. Please try again.\");\n      this.events.once(R(\"session_request\", a), ({\n        error: _,\n        result: g\n      }) => {\n        _ ? u(_) : h(g);\n      });\n      const d = \"wc_sessionRequest\",\n        w = this.getAppLinkIfEnabled(o.peer.metadata, o.transportType);\n      if (w) return await this.sendRequest({\n        clientRpcId: a,\n        relayRpcId: l,\n        topic: i,\n        method: d,\n        params: {\n          request: b(v({}, s), {\n            expiryTimestamp: V(r)\n          }),\n          chainId: t\n        },\n        expiry: r,\n        throwOnFailedPublish: !0,\n        appLink: w\n      }).catch(_ => u(_)), this.client.events.emit(\"session_request_sent\", {\n        topic: i,\n        request: s,\n        chainId: t,\n        id: a\n      }), await p();\n      const m = {\n          request: b(v({}, s), {\n            expiryTimestamp: V(r)\n          }),\n          chainId: t\n        },\n        f = this.shouldSetTVF(d, m);\n      return await Promise.all([new Promise(async _ => {\n        await this.sendRequest(v({\n          clientRpcId: a,\n          relayRpcId: l,\n          topic: i,\n          method: d,\n          params: m,\n          expiry: r,\n          throwOnFailedPublish: !0\n        }, f && {\n          tvf: this.getTVFParams(a, m)\n        })).catch(g => u(g)), this.client.events.emit(\"session_request_sent\", {\n          topic: i,\n          request: s,\n          chainId: t,\n          id: a\n        }), _();\n      }), new Promise(async _ => {\n        var g;\n        if (!((g = o.sessionConfig) != null && g.disableDeepLink)) {\n          const A = await Ut(this.client.core.storage, Me);\n          await Kt({\n            id: a,\n            topic: i,\n            wcDeepLink: A\n          });\n        }\n        _();\n      }), p()]).then(_ => _[2]);\n    }), c(this, \"respond\", async e => {\n      this.isInitialized(), await this.isValidRespond(e);\n      const {\n          topic: t,\n          response: s\n        } = e,\n        {\n          id: i\n        } = s,\n        r = this.client.session.get(t);\n      r.transportType === P.relay && (await this.confirmOnlineStateOrThrow());\n      const o = this.getAppLinkIfEnabled(r.peer.metadata, r.transportType);\n      j(s) ? await this.sendResult({\n        id: i,\n        topic: t,\n        result: s.result,\n        throwOnFailedPublish: !0,\n        appLink: o\n      }) : F(s) && (await this.sendError({\n        id: i,\n        topic: t,\n        error: s.error,\n        appLink: o\n      })), this.cleanupAfterResponse(e);\n    }), c(this, \"ping\", async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      try {\n        await this.isValidPing(e);\n      } catch (s) {\n        throw this.client.logger.error(\"ping() -> isValidPing() failed\"), s;\n      }\n      const {\n        topic: t\n      } = e;\n      if (this.client.session.keys.includes(t)) {\n        const s = G(),\n          i = ge().toString(),\n          {\n            done: r,\n            resolve: o,\n            reject: a\n          } = ee();\n        this.events.once(R(\"session_ping\", s), ({\n          error: l\n        }) => {\n          l ? a(l) : o();\n        }), await Promise.all([this.sendRequest({\n          topic: t,\n          method: \"wc_sessionPing\",\n          params: {},\n          throwOnFailedPublish: !0,\n          clientRpcId: s,\n          relayRpcId: i\n        }), r()]);\n      } else this.client.core.pairing.pairings.keys.includes(t) && (this.client.logger.warn(\"ping() on pairing topic is deprecated and will be removed in the next major release.\"), await this.client.core.pairing.ping({\n        topic: t\n      }));\n    }), c(this, \"emit\", async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(e);\n      const {\n          topic: t,\n          event: s,\n          chainId: i\n        } = e,\n        r = ge().toString(),\n        o = G();\n      await this.sendRequest({\n        topic: t,\n        method: \"wc_sessionEvent\",\n        params: {\n          event: s,\n          chainId: i\n        },\n        throwOnFailedPublish: !0,\n        relayRpcId: r,\n        clientRpcId: o\n      });\n    }), c(this, \"disconnect\", async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(e);\n      const {\n        topic: t\n      } = e;\n      if (this.client.session.keys.includes(t)) await this.sendRequest({\n        topic: t,\n        method: \"wc_sessionDelete\",\n        params: O(\"USER_DISCONNECTED\"),\n        throwOnFailedPublish: !0\n      }), await this.deleteSession({\n        topic: t,\n        emitEvent: !1\n      });else if (this.client.core.pairing.pairings.keys.includes(t)) await this.client.core.pairing.disconnect({\n        topic: t\n      });else {\n        const {\n          message: s\n        } = y(\"MISMATCHED_TOPIC\", `Session or pairing topic not found: ${t}`);\n        throw new Error(s);\n      }\n    }), c(this, \"find\", e => (this.isInitialized(), this.client.session.getAll().filter(t => Gt(t, e)))), c(this, \"getPendingSessionRequests\", () => this.client.pendingRequest.getAll()), c(this, \"authenticate\", async (e, t) => {\n      var s;\n      this.isInitialized(), this.isValidAuthenticate(e);\n      const i = t && this.client.core.linkModeSupportedApps.includes(t) && ((s = this.client.metadata.redirect) == null ? void 0 : s.linkMode),\n        r = i ? P.link_mode : P.relay;\n      r === P.relay && (await this.confirmOnlineStateOrThrow());\n      const {\n          chains: o,\n          statement: a = \"\",\n          uri: l,\n          domain: p,\n          nonce: h,\n          type: u,\n          exp: d,\n          nbf: w,\n          methods: m = [],\n          expiry: f\n        } = e,\n        _ = [...(e.resources || [])],\n        {\n          topic: g,\n          uri: A\n        } = await this.client.core.pairing.create({\n          methods: [\"wc_sessionAuthenticate\"],\n          transportType: r\n        });\n      this.client.logger.info({\n        message: \"Generated new pairing\",\n        pairing: {\n          topic: g,\n          uri: A\n        }\n      });\n      const D = await this.client.core.crypto.generateKeyPair(),\n        I = be(D);\n      if (await Promise.all([this.client.auth.authKeys.set(ce, {\n        responseTopic: I,\n        publicKey: D\n      }), this.client.auth.pairingTopics.set(I, {\n        topic: I,\n        pairingTopic: g\n      })]), await this.client.core.relayer.subscribe(I, {\n        transportType: r\n      }), this.client.logger.info(`sending request to new pairing topic: ${g}`), m.length > 0) {\n        const {\n          namespace: x\n        } = Ae(o[0]);\n        let L = jt(x, \"request\", m);\n        xe(_) && (L = Ft(L, _.pop())), _.push(L);\n      }\n      const T = f && f > N.wc_sessionAuthenticate.req.ttl ? f : N.wc_sessionAuthenticate.req.ttl,\n        U = {\n          authPayload: {\n            type: u ?? \"caip122\",\n            chains: o,\n            statement: a,\n            aud: l,\n            domain: p,\n            version: \"1\",\n            nonce: h,\n            iat: new Date().toISOString(),\n            exp: d,\n            nbf: w,\n            resources: _\n          },\n          requester: {\n            publicKey: D,\n            metadata: this.client.metadata\n          },\n          expiryTimestamp: V(T)\n        },\n        fe = {\n          eip155: {\n            chains: o,\n            methods: [...new Set([\"personal_sign\", ...m])],\n            events: [\"chainChanged\", \"accountsChanged\"]\n          }\n        },\n        q = {\n          requiredNamespaces: {},\n          optionalNamespaces: fe,\n          relays: [{\n            protocol: \"irn\"\n          }],\n          pairingTopic: g,\n          proposer: {\n            publicKey: D,\n            metadata: this.client.metadata\n          },\n          expiryTimestamp: V(N.wc_sessionPropose.req.ttl),\n          id: G()\n        },\n        {\n          done: Rt,\n          resolve: je,\n          reject: Se\n        } = ee(T, \"Request expired\"),\n        te = G(),\n        le = R(\"session_connect\", q.id),\n        Re = R(\"session_request\", te),\n        pe = async ({\n          error: x,\n          session: L\n        }) => {\n          this.events.off(Re, ve), x ? Se(x) : L && je({\n            session: L\n          });\n        },\n        ve = async x => {\n          var L, Fe, Qe;\n          if (await this.deletePendingAuthRequest(te, {\n            message: \"fulfilled\",\n            code: 0\n          }), x.error) {\n            const ie = O(\"WC_METHOD_UNSUPPORTED\", \"wc_sessionAuthenticate\");\n            return x.error.code === ie.code ? void 0 : (this.events.off(le, pe), Se(x.error.message));\n          }\n          await this.deleteProposal(q.id), this.events.off(le, pe);\n          const {\n              cacaos: He,\n              responder: Q\n            } = x.result,\n            Te = [],\n            ze = [];\n          for (const ie of He) {\n            (await et({\n              cacao: ie,\n              projectId: this.client.core.projectId\n            })) || (this.client.logger.error(ie, \"Signature verification failed\"), Se(O(\"SESSION_SETTLEMENT_FAILED\", \"Signature verification failed\")));\n            const {\n                p: qe\n              } = ie,\n              Pe = xe(qe.resources),\n              Ye = [tt(qe.iss)],\n              vt = st(qe.iss);\n            if (Pe) {\n              const Ne = it(Pe),\n                It = rt(Pe);\n              Te.push(...Ne), Ye.push(...It);\n            }\n            for (const Ne of Ye) ze.push(`${Ne}:${vt}`);\n          }\n          const se = await this.client.core.crypto.generateSharedKey(D, Q.publicKey);\n          let he;\n          Te.length > 0 && (he = {\n            topic: se,\n            acknowledged: !0,\n            self: {\n              publicKey: D,\n              metadata: this.client.metadata\n            },\n            peer: Q,\n            controller: Q.publicKey,\n            expiry: V(J),\n            requiredNamespaces: {},\n            optionalNamespaces: {},\n            relay: {\n              protocol: \"irn\"\n            },\n            pairingTopic: g,\n            namespaces: nt([...new Set(Te)], [...new Set(ze)]),\n            transportType: r\n          }, await this.client.core.relayer.subscribe(se, {\n            transportType: r\n          }), await this.client.session.set(se, he), g && (await this.client.core.pairing.updateMetadata({\n            topic: g,\n            metadata: Q.metadata\n          })), he = this.client.session.get(se)), (L = this.client.metadata.redirect) != null && L.linkMode && (Fe = Q.metadata.redirect) != null && Fe.linkMode && (Qe = Q.metadata.redirect) != null && Qe.universal && t && (this.client.core.addLinkModeSupportedApp(Q.metadata.redirect.universal), this.client.session.update(se, {\n            transportType: P.link_mode\n          })), je({\n            auths: He,\n            session: he\n          });\n        };\n      this.events.once(le, pe), this.events.once(Re, ve);\n      let Ie;\n      try {\n        if (i) {\n          const x = ye(\"wc_sessionAuthenticate\", U, te);\n          this.client.core.history.set(g, x);\n          const L = await this.client.core.crypto.encode(\"\", x, {\n            type: Qt,\n            encoding: ne\n          });\n          Ie = ue(t, g, L);\n        } else await Promise.all([this.sendRequest({\n          topic: g,\n          method: \"wc_sessionAuthenticate\",\n          params: U,\n          expiry: e.expiry,\n          throwOnFailedPublish: !0,\n          clientRpcId: te\n        }), this.sendRequest({\n          topic: g,\n          method: \"wc_sessionPropose\",\n          params: q,\n          expiry: N.wc_sessionPropose.req.ttl,\n          throwOnFailedPublish: !0,\n          clientRpcId: q.id\n        })]);\n      } catch (x) {\n        throw this.events.off(le, pe), this.events.off(Re, ve), x;\n      }\n      return await this.setProposal(q.id, q), await this.setAuthRequest(te, {\n        request: b(v({}, U), {\n          verifyContext: {}\n        }),\n        pairingTopic: g,\n        transportType: r\n      }), {\n        uri: Ie ?? A,\n        response: Rt\n      };\n    }), c(this, \"approveSessionAuthenticate\", async e => {\n      const {\n          id: t,\n          auths: s\n        } = e,\n        i = this.client.core.eventClient.createEvent({\n          properties: {\n            topic: t.toString(),\n            trace: [z.authenticated_session_approve_started]\n          }\n        });\n      try {\n        this.isInitialized();\n      } catch (f) {\n        throw i.setError(re.no_internet_connection), f;\n      }\n      const r = this.getPendingAuthRequest(t);\n      if (!r) throw i.setError(re.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${t}`);\n      const o = r.transportType || P.relay;\n      o === P.relay && (await this.confirmOnlineStateOrThrow());\n      const a = r.requester.publicKey,\n        l = await this.client.core.crypto.generateKeyPair(),\n        p = be(a),\n        h = {\n          type: Ve,\n          receiverPublicKey: a,\n          senderPublicKey: l\n        },\n        u = [],\n        d = [];\n      for (const f of s) {\n        if (!(await et({\n          cacao: f,\n          projectId: this.client.core.projectId\n        }))) {\n          i.setError(re.invalid_cacao);\n          const I = O(\"SESSION_SETTLEMENT_FAILED\", \"Signature verification failed\");\n          throw await this.sendError({\n            id: t,\n            topic: p,\n            error: I,\n            encodeOpts: h\n          }), new Error(I.message);\n        }\n        i.addTrace(z.cacaos_verified);\n        const {\n            p: _\n          } = f,\n          g = xe(_.resources),\n          A = [tt(_.iss)],\n          D = st(_.iss);\n        if (g) {\n          const I = it(g),\n            T = rt(g);\n          u.push(...I), A.push(...T);\n        }\n        for (const I of A) d.push(`${I}:${D}`);\n      }\n      const w = await this.client.core.crypto.generateSharedKey(l, a);\n      i.addTrace(z.create_authenticated_session_topic);\n      let m;\n      if (u?.length > 0) {\n        m = {\n          topic: w,\n          acknowledged: !0,\n          self: {\n            publicKey: l,\n            metadata: this.client.metadata\n          },\n          peer: {\n            publicKey: a,\n            metadata: r.requester.metadata\n          },\n          controller: a,\n          expiry: V(J),\n          authentication: s,\n          requiredNamespaces: {},\n          optionalNamespaces: {},\n          relay: {\n            protocol: \"irn\"\n          },\n          pairingTopic: r.pairingTopic,\n          namespaces: nt([...new Set(u)], [...new Set(d)]),\n          transportType: o\n        }, i.addTrace(z.subscribing_authenticated_session_topic);\n        try {\n          await this.client.core.relayer.subscribe(w, {\n            transportType: o\n          });\n        } catch (f) {\n          throw i.setError(re.subscribe_authenticated_session_topic_failure), f;\n        }\n        i.addTrace(z.subscribe_authenticated_session_topic_success), await this.client.session.set(w, m), i.addTrace(z.store_authenticated_session), await this.client.core.pairing.updateMetadata({\n          topic: r.pairingTopic,\n          metadata: r.requester.metadata\n        });\n      }\n      i.addTrace(z.publishing_authenticated_session_approve);\n      try {\n        await this.sendResult({\n          topic: p,\n          id: t,\n          result: {\n            cacaos: s,\n            responder: {\n              publicKey: l,\n              metadata: this.client.metadata\n            }\n          },\n          encodeOpts: h,\n          throwOnFailedPublish: !0,\n          appLink: this.getAppLinkIfEnabled(r.requester.metadata, o)\n        });\n      } catch (f) {\n        throw i.setError(re.authenticated_session_approve_publish_failure), f;\n      }\n      return await this.client.auth.requests.delete(t, {\n        message: \"fulfilled\",\n        code: 0\n      }), await this.client.core.pairing.activate({\n        topic: r.pairingTopic\n      }), this.client.core.eventClient.deleteEvent({\n        eventId: i.eventId\n      }), {\n        session: m\n      };\n    }), c(this, \"rejectSessionAuthenticate\", async e => {\n      this.isInitialized();\n      const {\n          id: t,\n          reason: s\n        } = e,\n        i = this.getPendingAuthRequest(t);\n      if (!i) throw new Error(`Could not find pending auth request with id ${t}`);\n      i.transportType === P.relay && (await this.confirmOnlineStateOrThrow());\n      const r = i.requester.publicKey,\n        o = await this.client.core.crypto.generateKeyPair(),\n        a = be(r),\n        l = {\n          type: Ve,\n          receiverPublicKey: r,\n          senderPublicKey: o\n        };\n      await this.sendError({\n        id: t,\n        topic: a,\n        error: s,\n        encodeOpts: l,\n        rpcOpts: N.wc_sessionAuthenticate.reject,\n        appLink: this.getAppLinkIfEnabled(i.requester.metadata, i.transportType)\n      }), await this.client.auth.requests.delete(t, {\n        message: \"rejected\",\n        code: 0\n      }), await this.client.proposal.delete(t, O(\"USER_DISCONNECTED\"));\n    }), c(this, \"formatAuthMessage\", e => {\n      this.isInitialized();\n      const {\n        request: t,\n        iss: s\n      } = e;\n      return Ht(t, s);\n    }), c(this, \"processRelayMessageCache\", () => {\n      setTimeout(async () => {\n        if (this.relayMessageCache.length !== 0) for (; this.relayMessageCache.length > 0;) try {\n          const e = this.relayMessageCache.shift();\n          e && (await this.onRelayMessage(e));\n        } catch (e) {\n          this.client.logger.error(e);\n        }\n      }, 50);\n    }), c(this, \"cleanupDuplicatePairings\", async e => {\n      if (e.pairingTopic) try {\n        const t = this.client.core.pairing.pairings.get(e.pairingTopic),\n          s = this.client.core.pairing.pairings.getAll().filter(i => {\n            var r, o;\n            return ((r = i.peerMetadata) == null ? void 0 : r.url) && ((o = i.peerMetadata) == null ? void 0 : o.url) === e.peer.metadata.url && i.topic && i.topic !== t.topic;\n          });\n        if (s.length === 0) return;\n        this.client.logger.info(`Cleaning up ${s.length} duplicate pairing(s)`), await Promise.all(s.map(i => this.client.core.pairing.disconnect({\n          topic: i.topic\n        }))), this.client.logger.info(\"Duplicate pairings clean up finished\");\n      } catch (t) {\n        this.client.logger.error(t);\n      }\n    }), c(this, \"deleteSession\", async e => {\n      var t;\n      const {\n          topic: s,\n          expirerHasDeleted: i = !1,\n          emitEvent: r = !0,\n          id: o = 0\n        } = e,\n        {\n          self: a\n        } = this.client.session.get(s);\n      await this.client.core.relayer.unsubscribe(s), await this.client.session.delete(s, O(\"USER_DISCONNECTED\")), this.addToRecentlyDeleted(s, \"session\"), this.client.core.crypto.keychain.has(a.publicKey) && (await this.client.core.crypto.deleteKeyPair(a.publicKey)), this.client.core.crypto.keychain.has(s) && (await this.client.core.crypto.deleteSymKey(s)), i || this.client.core.expirer.del(s), this.client.core.storage.removeItem(Me).catch(l => this.client.logger.warn(l)), this.getPendingSessionRequests().forEach(l => {\n        l.topic === s && this.deletePendingSessionRequest(l.id, O(\"USER_DISCONNECTED\"));\n      }), s === ((t = this.sessionRequestQueue.queue[0]) == null ? void 0 : t.topic) && (this.sessionRequestQueue.state = $.idle), r && this.client.events.emit(\"session_delete\", {\n        id: o,\n        topic: s\n      });\n    }), c(this, \"deleteProposal\", async (e, t) => {\n      if (t) try {\n        const s = this.client.proposal.get(e),\n          i = this.client.core.eventClient.getEvent({\n            topic: s.pairingTopic\n          });\n        i?.setError(H.proposal_expired);\n      } catch {}\n      await Promise.all([this.client.proposal.delete(e, O(\"USER_DISCONNECTED\")), t ? Promise.resolve() : this.client.core.expirer.del(e)]), this.addToRecentlyDeleted(e, \"proposal\");\n    }), c(this, \"deletePendingSessionRequest\", async (e, t, s = !1) => {\n      await Promise.all([this.client.pendingRequest.delete(e, t), s ? Promise.resolve() : this.client.core.expirer.del(e)]), this.addToRecentlyDeleted(e, \"request\"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter(i => i.id !== e), s && (this.sessionRequestQueue.state = $.idle, this.client.events.emit(\"session_request_expire\", {\n        id: e\n      }));\n    }), c(this, \"deletePendingAuthRequest\", async (e, t, s = !1) => {\n      await Promise.all([this.client.auth.requests.delete(e, t), s ? Promise.resolve() : this.client.core.expirer.del(e)]);\n    }), c(this, \"setExpiry\", async (e, t) => {\n      this.client.session.keys.includes(e) && (this.client.core.expirer.set(e, t), await this.client.session.update(e, {\n        expiry: t\n      }));\n    }), c(this, \"setProposal\", async (e, t) => {\n      this.client.core.expirer.set(e, V(N.wc_sessionPropose.req.ttl)), await this.client.proposal.set(e, t);\n    }), c(this, \"setAuthRequest\", async (e, t) => {\n      const {\n        request: s,\n        pairingTopic: i,\n        transportType: r = P.relay\n      } = t;\n      this.client.core.expirer.set(e, s.expiryTimestamp), await this.client.auth.requests.set(e, {\n        authPayload: s.authPayload,\n        requester: s.requester,\n        expiryTimestamp: s.expiryTimestamp,\n        id: e,\n        pairingTopic: i,\n        verifyContext: s.verifyContext,\n        transportType: r\n      });\n    }), c(this, \"setPendingSessionRequest\", async e => {\n      const {\n          id: t,\n          topic: s,\n          params: i,\n          verifyContext: r\n        } = e,\n        o = i.request.expiryTimestamp || V(N.wc_sessionRequest.req.ttl);\n      this.client.core.expirer.set(t, o), await this.client.pendingRequest.set(t, {\n        id: t,\n        topic: s,\n        params: i,\n        verifyContext: r\n      });\n    }), c(this, \"sendRequest\", async e => {\n      const {\n          topic: t,\n          method: s,\n          params: i,\n          expiry: r,\n          relayRpcId: o,\n          clientRpcId: a,\n          throwOnFailedPublish: l,\n          appLink: p,\n          tvf: h\n        } = e,\n        u = ye(s, i, a);\n      let d;\n      const w = !!p;\n      try {\n        const _ = w ? ne : de;\n        d = await this.client.core.crypto.encode(t, u, {\n          encoding: _\n        });\n      } catch (_) {\n        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${t} failed`), _;\n      }\n      let m;\n      if (gt.includes(s)) {\n        const _ = W(JSON.stringify(u)),\n          g = W(d);\n        m = await this.client.core.verify.register({\n          id: g,\n          decryptedId: _\n        });\n      }\n      const f = N[s].req;\n      if (f.attestation = m, r && (f.ttl = r), o && (f.id = o), this.client.core.history.set(t, u), w) {\n        const _ = ue(p, t, d);\n        await global.Linking.openURL(_, this.client.name);\n      } else {\n        const _ = N[s].req;\n        r && (_.ttl = r), o && (_.id = o), _.tvf = b(v({}, h), {\n          correlationId: u.id\n        }), l ? (_.internal = b(v({}, _.internal), {\n          throwOnFailedPublish: !0\n        }), await this.client.core.relayer.publish(t, d, _)) : this.client.core.relayer.publish(t, d, _).catch(g => this.client.logger.error(g));\n      }\n      return u.id;\n    }), c(this, \"sendResult\", async e => {\n      const {\n          id: t,\n          topic: s,\n          result: i,\n          throwOnFailedPublish: r,\n          encodeOpts: o,\n          appLink: a\n        } = e,\n        l = us(t, i);\n      let p;\n      const h = a && typeof (global == null ? void 0 : global.Linking) < \"u\";\n      try {\n        const w = h ? ne : de;\n        p = await this.client.core.crypto.encode(s, l, b(v({}, o || {}), {\n          encoding: w\n        }));\n      } catch (w) {\n        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s} failed`), w;\n      }\n      let u, d;\n      try {\n        u = await this.client.core.history.get(s, t);\n        const w = u.request;\n        try {\n          this.shouldSetTVF(w.method, w.params) && (d = this.getTVFParams(t, w.params, i));\n        } catch (m) {\n          this.client.logger.warn(\"sendResult() -> getTVFParams() failed\", m);\n        }\n      } catch (w) {\n        throw this.client.logger.error(`sendResult() -> history.get(${s}, ${t}) failed`), w;\n      }\n      if (h) {\n        const w = ue(a, s, p);\n        await global.Linking.openURL(w, this.client.name);\n      } else {\n        const w = u.request.method,\n          m = N[w].res;\n        m.tvf = b(v({}, d), {\n          correlationId: t\n        }), r ? (m.internal = b(v({}, m.internal), {\n          throwOnFailedPublish: !0\n        }), await this.client.core.relayer.publish(s, p, m)) : this.client.core.relayer.publish(s, p, m).catch(f => this.client.logger.error(f));\n      }\n      await this.client.core.history.resolve(l);\n    }), c(this, \"sendError\", async e => {\n      const {\n          id: t,\n          topic: s,\n          error: i,\n          encodeOpts: r,\n          rpcOpts: o,\n          appLink: a\n        } = e,\n        l = gs(t, i);\n      let p;\n      const h = a && typeof (global == null ? void 0 : global.Linking) < \"u\";\n      try {\n        const d = h ? ne : de;\n        p = await this.client.core.crypto.encode(s, l, b(v({}, r || {}), {\n          encoding: d\n        }));\n      } catch (d) {\n        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s} failed`), d;\n      }\n      let u;\n      try {\n        u = await this.client.core.history.get(s, t);\n      } catch (d) {\n        throw this.client.logger.error(`sendError() -> history.get(${s}, ${t}) failed`), d;\n      }\n      if (h) {\n        const d = ue(a, s, p);\n        await global.Linking.openURL(d, this.client.name);\n      } else {\n        const d = u.request.method,\n          w = o || N[d].res;\n        this.client.core.relayer.publish(s, p, w);\n      }\n      await this.client.core.history.resolve(l);\n    }), c(this, \"cleanup\", async () => {\n      const e = [],\n        t = [];\n      this.client.session.getAll().forEach(s => {\n        let i = !1;\n        Z(s.expiry) && (i = !0), this.client.core.crypto.keychain.has(s.topic) || (i = !0), i && e.push(s.topic);\n      }), this.client.proposal.getAll().forEach(s => {\n        Z(s.expiryTimestamp) && t.push(s.id);\n      }), await Promise.all([...e.map(s => this.deleteSession({\n        topic: s\n      })), ...t.map(s => this.deleteProposal(s))]);\n    }), c(this, \"onProviderMessageEvent\", async e => {\n      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(e) : await this.onRelayMessage(e);\n    }), c(this, \"onRelayEventRequest\", async e => {\n      this.requestQueue.queue.push(e), await this.processRequestsQueue();\n    }), c(this, \"processRequestsQueue\", async () => {\n      if (this.requestQueue.state === $.active) {\n        this.client.logger.info(\"Request queue already active, skipping...\");\n        return;\n      }\n      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0;) {\n        this.requestQueue.state = $.active;\n        const e = this.requestQueue.queue.shift();\n        if (e) try {\n          await this.processRequest(e);\n        } catch (t) {\n          this.client.logger.warn(t);\n        }\n      }\n      this.requestQueue.state = $.idle;\n    }), c(this, \"processRequest\", async e => {\n      const {\n          topic: t,\n          payload: s,\n          attestation: i,\n          transportType: r,\n          encryptedId: o\n        } = e,\n        a = s.method;\n      if (!this.shouldIgnorePairingRequest({\n        topic: t,\n        requestMethod: a\n      })) switch (a) {\n        case \"wc_sessionPropose\":\n          return await this.onSessionProposeRequest({\n            topic: t,\n            payload: s,\n            attestation: i,\n            encryptedId: o\n          });\n        case \"wc_sessionSettle\":\n          return await this.onSessionSettleRequest(t, s);\n        case \"wc_sessionUpdate\":\n          return await this.onSessionUpdateRequest(t, s);\n        case \"wc_sessionExtend\":\n          return await this.onSessionExtendRequest(t, s);\n        case \"wc_sessionPing\":\n          return await this.onSessionPingRequest(t, s);\n        case \"wc_sessionDelete\":\n          return await this.onSessionDeleteRequest(t, s);\n        case \"wc_sessionRequest\":\n          return await this.onSessionRequest({\n            topic: t,\n            payload: s,\n            attestation: i,\n            encryptedId: o,\n            transportType: r\n          });\n        case \"wc_sessionEvent\":\n          return await this.onSessionEventRequest(t, s);\n        case \"wc_sessionAuthenticate\":\n          return await this.onSessionAuthenticateRequest({\n            topic: t,\n            payload: s,\n            attestation: i,\n            encryptedId: o,\n            transportType: r\n          });\n        default:\n          return this.client.logger.info(`Unsupported request method ${a}`);\n      }\n    }), c(this, \"onRelayEventResponse\", async e => {\n      const {\n          topic: t,\n          payload: s,\n          transportType: i\n        } = e,\n        r = (await this.client.core.history.get(t, s.id)).request.method;\n      switch (r) {\n        case \"wc_sessionPropose\":\n          return this.onSessionProposeResponse(t, s, i);\n        case \"wc_sessionSettle\":\n          return this.onSessionSettleResponse(t, s);\n        case \"wc_sessionUpdate\":\n          return this.onSessionUpdateResponse(t, s);\n        case \"wc_sessionExtend\":\n          return this.onSessionExtendResponse(t, s);\n        case \"wc_sessionPing\":\n          return this.onSessionPingResponse(t, s);\n        case \"wc_sessionRequest\":\n          return this.onSessionRequestResponse(t, s);\n        case \"wc_sessionAuthenticate\":\n          return this.onSessionAuthenticateResponse(t, s);\n        default:\n          return this.client.logger.info(`Unsupported response method ${r}`);\n      }\n    }), c(this, \"onRelayEventUnknownPayload\", e => {\n      const {\n          topic: t\n        } = e,\n        {\n          message: s\n        } = y(\"MISSING_OR_INVALID\", `Decoded payload on topic ${t} is not identifiable as a JSON-RPC request or a response.`);\n      throw new Error(s);\n    }), c(this, \"shouldIgnorePairingRequest\", e => {\n      const {\n          topic: t,\n          requestMethod: s\n        } = e,\n        i = this.expectedPairingMethodMap.get(t);\n      return !i || i.includes(s) ? !1 : !!(i.includes(\"wc_sessionAuthenticate\") && this.client.events.listenerCount(\"session_authenticate\") > 0);\n    }), c(this, \"onSessionProposeRequest\", async e => {\n      const {\n          topic: t,\n          payload: s,\n          attestation: i,\n          encryptedId: r\n        } = e,\n        {\n          params: o,\n          id: a\n        } = s;\n      try {\n        const l = this.client.core.eventClient.getEvent({\n          topic: t\n        });\n        this.client.events.listenerCount(\"session_proposal\") === 0 && (console.warn(\"No listener for session_proposal event\"), l?.setError(Pt.proposal_listener_not_found)), this.isValidConnect(v({}, s.params));\n        const p = o.expiryTimestamp || V(N.wc_sessionPropose.req.ttl),\n          h = v({\n            id: a,\n            pairingTopic: t,\n            expiryTimestamp: p\n          }, o);\n        await this.setProposal(a, h);\n        const u = await this.getVerifyContext({\n          attestationId: i,\n          hash: W(JSON.stringify(s)),\n          encryptedId: r,\n          metadata: h.proposer.metadata\n        });\n        l?.addTrace(Nt.emit_session_proposal), this.client.events.emit(\"session_proposal\", {\n          id: a,\n          params: h,\n          verifyContext: u\n        });\n      } catch (l) {\n        await this.sendError({\n          id: a,\n          topic: t,\n          error: l,\n          rpcOpts: N.wc_sessionPropose.autoReject\n        }), this.client.logger.error(l);\n      }\n    }), c(this, \"onSessionProposeResponse\", async (e, t, s) => {\n      const {\n        id: i\n      } = t;\n      if (j(t)) {\n        const {\n          result: r\n        } = t;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          result: r\n        });\n        const o = this.client.proposal.get(i);\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          proposal: o\n        });\n        const a = o.proposer.publicKey;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          selfPublicKey: a\n        });\n        const l = r.responderPublicKey;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          peerPublicKey: l\n        });\n        const p = await this.client.core.crypto.generateSharedKey(a, l);\n        this.pendingSessions.set(i, {\n          sessionTopic: p,\n          pairingTopic: e,\n          proposalId: i,\n          publicKey: a\n        });\n        const h = await this.client.core.relayer.subscribe(p, {\n          transportType: s\n        });\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          subscriptionId: h\n        }), await this.client.core.pairing.activate({\n          topic: e\n        });\n      } else if (F(t)) {\n        await this.client.proposal.delete(i, O(\"USER_DISCONNECTED\"));\n        const r = R(\"session_connect\", i);\n        if (this.events.listenerCount(r) === 0) throw new Error(`emitting ${r} without any listeners, 954`);\n        this.events.emit(r, {\n          error: t.error\n        });\n      }\n    }), c(this, \"onSessionSettleRequest\", async (e, t) => {\n      const {\n        id: s,\n        params: i\n      } = t;\n      try {\n        this.isValidSessionSettleRequest(i);\n        const {\n            relay: r,\n            controller: o,\n            expiry: a,\n            namespaces: l,\n            sessionProperties: p,\n            scopedProperties: h,\n            sessionConfig: u\n          } = t.params,\n          d = [...this.pendingSessions.values()].find(f => f.sessionTopic === e);\n        if (!d) return this.client.logger.error(`Pending session not found for topic ${e}`);\n        const w = this.client.proposal.get(d.proposalId),\n          m = b(v(v(v({\n            topic: e,\n            relay: r,\n            expiry: a,\n            namespaces: l,\n            acknowledged: !0,\n            pairingTopic: d.pairingTopic,\n            requiredNamespaces: w.requiredNamespaces,\n            optionalNamespaces: w.optionalNamespaces,\n            controller: o.publicKey,\n            self: {\n              publicKey: d.publicKey,\n              metadata: this.client.metadata\n            },\n            peer: {\n              publicKey: o.publicKey,\n              metadata: o.metadata\n            }\n          }, p && {\n            sessionProperties: p\n          }), h && {\n            scopedProperties: h\n          }), u && {\n            sessionConfig: u\n          }), {\n            transportType: P.relay\n          });\n        await this.client.session.set(m.topic, m), await this.setExpiry(m.topic, m.expiry), await this.client.core.pairing.updateMetadata({\n          topic: d.pairingTopic,\n          metadata: m.peer.metadata\n        }), this.client.events.emit(\"session_connect\", {\n          session: m\n        }), this.events.emit(R(\"session_connect\", d.proposalId), {\n          session: m\n        }), this.pendingSessions.delete(d.proposalId), this.deleteProposal(d.proposalId, !1), this.cleanupDuplicatePairings(m), await this.sendResult({\n          id: t.id,\n          topic: e,\n          result: !0,\n          throwOnFailedPublish: !0\n        });\n      } catch (r) {\n        await this.sendError({\n          id: s,\n          topic: e,\n          error: r\n        }), this.client.logger.error(r);\n      }\n    }), c(this, \"onSessionSettleResponse\", async (e, t) => {\n      const {\n        id: s\n      } = t;\n      j(t) ? (await this.client.session.update(e, {\n        acknowledged: !0\n      }), this.events.emit(R(\"session_approve\", s), {})) : F(t) && (await this.client.session.delete(e, O(\"USER_DISCONNECTED\")), this.events.emit(R(\"session_approve\", s), {\n        error: t.error\n      }));\n    }), c(this, \"onSessionUpdateRequest\", async (e, t) => {\n      const {\n        params: s,\n        id: i\n      } = t;\n      try {\n        const r = `${e}_session_update`,\n          o = oe.get(r);\n        if (o && this.isRequestOutOfSync(o, i)) {\n          this.client.logger.warn(`Discarding out of sync request - ${i}`), this.sendError({\n            id: i,\n            topic: e,\n            error: O(\"INVALID_UPDATE_REQUEST\")\n          });\n          return;\n        }\n        this.isValidUpdate(v({\n          topic: e\n        }, s));\n        try {\n          oe.set(r, i), await this.client.session.update(e, {\n            namespaces: s.namespaces\n          }), await this.sendResult({\n            id: i,\n            topic: e,\n            result: !0,\n            throwOnFailedPublish: !0\n          });\n        } catch (a) {\n          throw oe.delete(r), a;\n        }\n        this.client.events.emit(\"session_update\", {\n          id: i,\n          topic: e,\n          params: s\n        });\n      } catch (r) {\n        await this.sendError({\n          id: i,\n          topic: e,\n          error: r\n        }), this.client.logger.error(r);\n      }\n    }), c(this, \"isRequestOutOfSync\", (e, t) => t.toString().slice(0, -3) < e.toString().slice(0, -3)), c(this, \"onSessionUpdateResponse\", (e, t) => {\n      const {\n          id: s\n        } = t,\n        i = R(\"session_update\", s);\n      if (this.events.listenerCount(i) === 0) throw new Error(`emitting ${i} without any listeners`);\n      j(t) ? this.events.emit(R(\"session_update\", s), {}) : F(t) && this.events.emit(R(\"session_update\", s), {\n        error: t.error\n      });\n    }), c(this, \"onSessionExtendRequest\", async (e, t) => {\n      const {\n        id: s\n      } = t;\n      try {\n        this.isValidExtend({\n          topic: e\n        }), await this.setExpiry(e, V(J)), await this.sendResult({\n          id: s,\n          topic: e,\n          result: !0,\n          throwOnFailedPublish: !0\n        }), this.client.events.emit(\"session_extend\", {\n          id: s,\n          topic: e\n        });\n      } catch (i) {\n        await this.sendError({\n          id: s,\n          topic: e,\n          error: i\n        }), this.client.logger.error(i);\n      }\n    }), c(this, \"onSessionExtendResponse\", (e, t) => {\n      const {\n          id: s\n        } = t,\n        i = R(\"session_extend\", s);\n      if (this.events.listenerCount(i) === 0) throw new Error(`emitting ${i} without any listeners`);\n      j(t) ? this.events.emit(R(\"session_extend\", s), {}) : F(t) && this.events.emit(R(\"session_extend\", s), {\n        error: t.error\n      });\n    }), c(this, \"onSessionPingRequest\", async (e, t) => {\n      const {\n        id: s\n      } = t;\n      try {\n        this.isValidPing({\n          topic: e\n        }), await this.sendResult({\n          id: s,\n          topic: e,\n          result: !0,\n          throwOnFailedPublish: !0\n        }), this.client.events.emit(\"session_ping\", {\n          id: s,\n          topic: e\n        });\n      } catch (i) {\n        await this.sendError({\n          id: s,\n          topic: e,\n          error: i\n        }), this.client.logger.error(i);\n      }\n    }), c(this, \"onSessionPingResponse\", (e, t) => {\n      const {\n          id: s\n        } = t,\n        i = R(\"session_ping\", s);\n      setTimeout(() => {\n        if (this.events.listenerCount(i) === 0) throw new Error(`emitting ${i} without any listeners 2176`);\n        j(t) ? this.events.emit(R(\"session_ping\", s), {}) : F(t) && this.events.emit(R(\"session_ping\", s), {\n          error: t.error\n        });\n      }, 500);\n    }), c(this, \"onSessionDeleteRequest\", async (e, t) => {\n      const {\n        id: s\n      } = t;\n      try {\n        this.isValidDisconnect({\n          topic: e,\n          reason: t.params\n        }), Promise.all([new Promise(i => {\n          this.client.core.relayer.once(Xe.publish, async () => {\n            i(await this.deleteSession({\n              topic: e,\n              id: s\n            }));\n          });\n        }), this.sendResult({\n          id: s,\n          topic: e,\n          result: !0,\n          throwOnFailedPublish: !0\n        }), this.cleanupPendingSentRequestsForTopic({\n          topic: e,\n          error: O(\"USER_DISCONNECTED\")\n        })]).catch(i => this.client.logger.error(i));\n      } catch (i) {\n        this.client.logger.error(i);\n      }\n    }), c(this, \"onSessionRequest\", async e => {\n      var t, s, i;\n      const {\n          topic: r,\n          payload: o,\n          attestation: a,\n          encryptedId: l,\n          transportType: p\n        } = e,\n        {\n          id: h,\n          params: u\n        } = o;\n      try {\n        await this.isValidRequest(v({\n          topic: r\n        }, u));\n        const d = this.client.session.get(r),\n          w = await this.getVerifyContext({\n            attestationId: a,\n            hash: W(JSON.stringify(ye(\"wc_sessionRequest\", u, h))),\n            encryptedId: l,\n            metadata: d.peer.metadata,\n            transportType: p\n          }),\n          m = {\n            id: h,\n            topic: r,\n            params: u,\n            verifyContext: w\n          };\n        await this.setPendingSessionRequest(m), p === P.link_mode && (t = d.peer.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp((s = d.peer.metadata.redirect) == null ? void 0 : s.universal), (i = this.client.signConfig) != null && i.disableRequestQueue ? this.emitSessionRequest(m) : (this.addSessionRequestToSessionRequestQueue(m), this.processSessionRequestQueue());\n      } catch (d) {\n        await this.sendError({\n          id: h,\n          topic: r,\n          error: d\n        }), this.client.logger.error(d);\n      }\n    }), c(this, \"onSessionRequestResponse\", (e, t) => {\n      const {\n          id: s\n        } = t,\n        i = R(\"session_request\", s);\n      if (this.events.listenerCount(i) === 0) throw new Error(`emitting ${i} without any listeners`);\n      j(t) ? this.events.emit(R(\"session_request\", s), {\n        result: t.result\n      }) : F(t) && this.events.emit(R(\"session_request\", s), {\n        error: t.error\n      });\n    }), c(this, \"onSessionEventRequest\", async (e, t) => {\n      const {\n        id: s,\n        params: i\n      } = t;\n      try {\n        const r = `${e}_session_event_${i.event.name}`,\n          o = oe.get(r);\n        if (o && this.isRequestOutOfSync(o, s)) {\n          this.client.logger.info(`Discarding out of sync request - ${s}`);\n          return;\n        }\n        this.isValidEmit(v({\n          topic: e\n        }, i)), this.client.events.emit(\"session_event\", {\n          id: s,\n          topic: e,\n          params: i\n        }), oe.set(r, s);\n      } catch (r) {\n        await this.sendError({\n          id: s,\n          topic: e,\n          error: r\n        }), this.client.logger.error(r);\n      }\n    }), c(this, \"onSessionAuthenticateResponse\", (e, t) => {\n      const {\n        id: s\n      } = t;\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionAuthenticateResponse\",\n        topic: e,\n        payload: t\n      }), j(t) ? this.events.emit(R(\"session_request\", s), {\n        result: t.result\n      }) : F(t) && this.events.emit(R(\"session_request\", s), {\n        error: t.error\n      });\n    }), c(this, \"onSessionAuthenticateRequest\", async e => {\n      var t;\n      const {\n        topic: s,\n        payload: i,\n        attestation: r,\n        encryptedId: o,\n        transportType: a\n      } = e;\n      try {\n        const {\n            requester: l,\n            authPayload: p,\n            expiryTimestamp: h\n          } = i.params,\n          u = await this.getVerifyContext({\n            attestationId: r,\n            hash: W(JSON.stringify(i)),\n            encryptedId: o,\n            metadata: l.metadata,\n            transportType: a\n          }),\n          d = {\n            requester: l,\n            pairingTopic: s,\n            id: i.id,\n            authPayload: p,\n            verifyContext: u,\n            expiryTimestamp: h\n          };\n        await this.setAuthRequest(i.id, {\n          request: d,\n          pairingTopic: s,\n          transportType: a\n        }), a === P.link_mode && (t = l.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp(l.metadata.redirect.universal), this.client.events.emit(\"session_authenticate\", {\n          topic: s,\n          params: i.params,\n          id: i.id,\n          verifyContext: u\n        });\n      } catch (l) {\n        this.client.logger.error(l);\n        const p = i.params.requester.publicKey,\n          h = await this.client.core.crypto.generateKeyPair(),\n          u = this.getAppLinkIfEnabled(i.params.requester.metadata, a),\n          d = {\n            type: Ve,\n            receiverPublicKey: p,\n            senderPublicKey: h\n          };\n        await this.sendError({\n          id: i.id,\n          topic: s,\n          error: l,\n          encodeOpts: d,\n          rpcOpts: N.wc_sessionAuthenticate.autoReject,\n          appLink: u\n        });\n      }\n    }), c(this, \"addSessionRequestToSessionRequestQueue\", e => {\n      this.sessionRequestQueue.queue.push(e);\n    }), c(this, \"cleanupAfterResponse\", e => {\n      this.deletePendingSessionRequest(e.response.id, {\n        message: \"fulfilled\",\n        code: 0\n      }), setTimeout(() => {\n        this.sessionRequestQueue.state = $.idle, this.processSessionRequestQueue();\n      }, Oe(this.requestQueueDelay));\n    }), c(this, \"cleanupPendingSentRequestsForTopic\", ({\n      topic: e,\n      error: t\n    }) => {\n      const s = this.client.core.history.pending;\n      s.length > 0 && s.filter(i => i.topic === e && i.request.method === \"wc_sessionRequest\").forEach(i => {\n        const r = i.request.id,\n          o = R(\"session_request\", r);\n        if (this.events.listenerCount(o) === 0) throw new Error(`emitting ${o} without any listeners`);\n        this.events.emit(R(\"session_request\", i.request.id), {\n          error: t\n        });\n      });\n    }), c(this, \"processSessionRequestQueue\", () => {\n      if (this.sessionRequestQueue.state === $.active) {\n        this.client.logger.info(\"session request queue is already active.\");\n        return;\n      }\n      const e = this.sessionRequestQueue.queue[0];\n      if (!e) {\n        this.client.logger.info(\"session request queue is empty.\");\n        return;\n      }\n      try {\n        this.sessionRequestQueue.state = $.active, this.emitSessionRequest(e);\n      } catch (t) {\n        this.client.logger.error(t);\n      }\n    }), c(this, \"emitSessionRequest\", e => {\n      this.client.events.emit(\"session_request\", e);\n    }), c(this, \"onPairingCreated\", e => {\n      if (e.methods && this.expectedPairingMethodMap.set(e.topic, e.methods), e.active) return;\n      const t = this.client.proposal.getAll().find(s => s.pairingTopic === e.topic);\n      t && this.onSessionProposeRequest({\n        topic: e.topic,\n        payload: ye(\"wc_sessionPropose\", b(v({}, t), {\n          requiredNamespaces: t.requiredNamespaces,\n          optionalNamespaces: t.optionalNamespaces,\n          relays: t.relays,\n          proposer: t.proposer,\n          sessionProperties: t.sessionProperties,\n          scopedProperties: t.scopedProperties\n        }), t.id)\n      });\n    }), c(this, \"isValidConnect\", async e => {\n      if (!M(e)) {\n        const {\n          message: l\n        } = y(\"MISSING_OR_INVALID\", `connect() params: ${JSON.stringify(e)}`);\n        throw new Error(l);\n      }\n      const {\n        pairingTopic: t,\n        requiredNamespaces: s,\n        optionalNamespaces: i,\n        sessionProperties: r,\n        scopedProperties: o,\n        relays: a\n      } = e;\n      if (X(t) || (await this.isValidPairingTopic(t)), !zt(a, !0)) {\n        const {\n          message: l\n        } = y(\"MISSING_OR_INVALID\", `connect() relays: ${a}`);\n        throw new Error(l);\n      }\n      if (!X(s) && ot(s) !== 0 && this.validateNamespaces(s, \"requiredNamespaces\"), !X(i) && ot(i) !== 0 && this.validateNamespaces(i, \"optionalNamespaces\"), X(r) || this.validateSessionProps(r, \"sessionProperties\"), !X(o)) {\n        this.validateSessionProps(o, \"scopedProperties\");\n        const l = Object.keys(s || {}).concat(Object.keys(i || {}));\n        if (!Object.keys(o).every(p => l.includes(p))) throw new Error(`Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(o)}, required/optional namespaces: ${JSON.stringify(l)}`);\n      }\n    }), c(this, \"validateNamespaces\", (e, t) => {\n      const s = Yt(e, \"connect()\", t);\n      if (s) throw new Error(s.message);\n    }), c(this, \"isValidApprove\", async e => {\n      if (!M(e)) throw new Error(y(\"MISSING_OR_INVALID\", `approve() params: ${e}`).message);\n      const {\n        id: t,\n        namespaces: s,\n        relayProtocol: i,\n        sessionProperties: r,\n        scopedProperties: o\n      } = e;\n      this.checkRecentlyDeleted(t), await this.isValidProposalId(t);\n      const a = this.client.proposal.get(t),\n        l = Ce(s, \"approve()\");\n      if (l) throw new Error(l.message);\n      const p = at(a.requiredNamespaces, s, \"approve()\");\n      if (p) throw new Error(p.message);\n      if (!Y(i, !0)) {\n        const {\n          message: h\n        } = y(\"MISSING_OR_INVALID\", `approve() relayProtocol: ${i}`);\n        throw new Error(h);\n      }\n      if (X(r) || this.validateSessionProps(r, \"sessionProperties\"), !X(o)) {\n        this.validateSessionProps(o, \"scopedProperties\");\n        const h = new Set(Object.keys(s));\n        if (!Object.keys(o).every(u => h.has(u))) throw new Error(`Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(o)}, approved namespaces: ${Array.from(h).join(\", \")}`);\n      }\n    }), c(this, \"isValidReject\", async e => {\n      if (!M(e)) {\n        const {\n          message: i\n        } = y(\"MISSING_OR_INVALID\", `reject() params: ${e}`);\n        throw new Error(i);\n      }\n      const {\n        id: t,\n        reason: s\n      } = e;\n      if (this.checkRecentlyDeleted(t), await this.isValidProposalId(t), !Xt(s)) {\n        const {\n          message: i\n        } = y(\"MISSING_OR_INVALID\", `reject() reason: ${JSON.stringify(s)}`);\n        throw new Error(i);\n      }\n    }), c(this, \"isValidSessionSettleRequest\", e => {\n      if (!M(e)) {\n        const {\n          message: l\n        } = y(\"MISSING_OR_INVALID\", `onSessionSettleRequest() params: ${e}`);\n        throw new Error(l);\n      }\n      const {\n        relay: t,\n        controller: s,\n        namespaces: i,\n        expiry: r\n      } = e;\n      if (!Jt(t)) {\n        const {\n          message: l\n        } = y(\"MISSING_OR_INVALID\", \"onSessionSettleRequest() relay protocol should be a string\");\n        throw new Error(l);\n      }\n      const o = Bt(s, \"onSessionSettleRequest()\");\n      if (o) throw new Error(o.message);\n      const a = Ce(i, \"onSessionSettleRequest()\");\n      if (a) throw new Error(a.message);\n      if (Z(r)) {\n        const {\n          message: l\n        } = y(\"EXPIRED\", \"onSessionSettleRequest()\");\n        throw new Error(l);\n      }\n    }), c(this, \"isValidUpdate\", async e => {\n      if (!M(e)) {\n        const {\n          message: a\n        } = y(\"MISSING_OR_INVALID\", `update() params: ${e}`);\n        throw new Error(a);\n      }\n      const {\n        topic: t,\n        namespaces: s\n      } = e;\n      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);\n      const i = this.client.session.get(t),\n        r = Ce(s, \"update()\");\n      if (r) throw new Error(r.message);\n      const o = at(i.requiredNamespaces, s, \"update()\");\n      if (o) throw new Error(o.message);\n    }), c(this, \"isValidExtend\", async e => {\n      if (!M(e)) {\n        const {\n          message: s\n        } = y(\"MISSING_OR_INVALID\", `extend() params: ${e}`);\n        throw new Error(s);\n      }\n      const {\n        topic: t\n      } = e;\n      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);\n    }), c(this, \"isValidRequest\", async e => {\n      if (!M(e)) {\n        const {\n          message: a\n        } = y(\"MISSING_OR_INVALID\", `request() params: ${e}`);\n        throw new Error(a);\n      }\n      const {\n        topic: t,\n        request: s,\n        chainId: i,\n        expiry: r\n      } = e;\n      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);\n      const {\n        namespaces: o\n      } = this.client.session.get(t);\n      if (!ct(o, i)) {\n        const {\n          message: a\n        } = y(\"MISSING_OR_INVALID\", `request() chainId: ${i}`);\n        throw new Error(a);\n      }\n      if (!Wt(s)) {\n        const {\n          message: a\n        } = y(\"MISSING_OR_INVALID\", `request() ${JSON.stringify(s)}`);\n        throw new Error(a);\n      }\n      if (!Zt(o, i, s.method)) {\n        const {\n          message: a\n        } = y(\"MISSING_OR_INVALID\", `request() method: ${s.method}`);\n        throw new Error(a);\n      }\n      if (r && !es(r, _e)) {\n        const {\n          message: a\n        } = y(\"MISSING_OR_INVALID\", `request() expiry: ${r}. Expiry must be a number (in seconds) between ${_e.min} and ${_e.max}`);\n        throw new Error(a);\n      }\n    }), c(this, \"isValidRespond\", async e => {\n      var t;\n      if (!M(e)) {\n        const {\n          message: r\n        } = y(\"MISSING_OR_INVALID\", `respond() params: ${e}`);\n        throw new Error(r);\n      }\n      const {\n        topic: s,\n        response: i\n      } = e;\n      try {\n        await this.isValidSessionTopic(s);\n      } catch (r) {\n        throw (t = e?.response) != null && t.id && this.cleanupAfterResponse(e), r;\n      }\n      if (!ts(i)) {\n        const {\n          message: r\n        } = y(\"MISSING_OR_INVALID\", `respond() response: ${JSON.stringify(i)}`);\n        throw new Error(r);\n      }\n    }), c(this, \"isValidPing\", async e => {\n      if (!M(e)) {\n        const {\n          message: s\n        } = y(\"MISSING_OR_INVALID\", `ping() params: ${e}`);\n        throw new Error(s);\n      }\n      const {\n        topic: t\n      } = e;\n      await this.isValidSessionOrPairingTopic(t);\n    }), c(this, \"isValidEmit\", async e => {\n      if (!M(e)) {\n        const {\n          message: o\n        } = y(\"MISSING_OR_INVALID\", `emit() params: ${e}`);\n        throw new Error(o);\n      }\n      const {\n        topic: t,\n        event: s,\n        chainId: i\n      } = e;\n      await this.isValidSessionTopic(t);\n      const {\n        namespaces: r\n      } = this.client.session.get(t);\n      if (!ct(r, i)) {\n        const {\n          message: o\n        } = y(\"MISSING_OR_INVALID\", `emit() chainId: ${i}`);\n        throw new Error(o);\n      }\n      if (!ss(s)) {\n        const {\n          message: o\n        } = y(\"MISSING_OR_INVALID\", `emit() event: ${JSON.stringify(s)}`);\n        throw new Error(o);\n      }\n      if (!is(r, i, s.name)) {\n        const {\n          message: o\n        } = y(\"MISSING_OR_INVALID\", `emit() event: ${JSON.stringify(s)}`);\n        throw new Error(o);\n      }\n    }), c(this, \"isValidDisconnect\", async e => {\n      if (!M(e)) {\n        const {\n          message: s\n        } = y(\"MISSING_OR_INVALID\", `disconnect() params: ${e}`);\n        throw new Error(s);\n      }\n      const {\n        topic: t\n      } = e;\n      await this.isValidSessionOrPairingTopic(t);\n    }), c(this, \"isValidAuthenticate\", e => {\n      const {\n        chains: t,\n        uri: s,\n        domain: i,\n        nonce: r\n      } = e;\n      if (!Array.isArray(t) || t.length === 0) throw new Error(\"chains is required and must be a non-empty array\");\n      if (!Y(s, !1)) throw new Error(\"uri is required parameter\");\n      if (!Y(i, !1)) throw new Error(\"domain is required parameter\");\n      if (!Y(r, !1)) throw new Error(\"nonce is required parameter\");\n      if ([...new Set(t.map(a => Ae(a).namespace))].length > 1) throw new Error(\"Multi-namespace requests are not supported. Please request single namespace only.\");\n      const {\n        namespace: o\n      } = Ae(t[0]);\n      if (o !== \"eip155\") throw new Error(\"Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.\");\n    }), c(this, \"getVerifyContext\", async e => {\n      const {\n          attestationId: t,\n          hash: s,\n          encryptedId: i,\n          metadata: r,\n          transportType: o\n        } = e,\n        a = {\n          verified: {\n            verifyUrl: r.verifyUrl || Ot,\n            validation: \"UNKNOWN\",\n            origin: r.url || \"\"\n          }\n        };\n      try {\n        if (o === P.link_mode) {\n          const p = this.getAppLinkIfEnabled(r, o);\n          return a.verified.validation = p && new URL(p).origin === new URL(r.url).origin ? \"VALID\" : \"INVALID\", a;\n        }\n        const l = await this.client.core.verify.resolve({\n          attestationId: t,\n          hash: s,\n          encryptedId: i,\n          verifyUrl: r.verifyUrl\n        });\n        l && (a.verified.origin = l.origin, a.verified.isScam = l.isScam, a.verified.validation = l.origin === new URL(r.url).origin ? \"VALID\" : \"INVALID\");\n      } catch (l) {\n        this.client.logger.warn(l);\n      }\n      return this.client.logger.debug(`Verify context: ${JSON.stringify(a)}`), a;\n    }), c(this, \"validateSessionProps\", (e, t) => {\n      Object.values(e).forEach((s, i) => {\n        if (s == null) {\n          const {\n            message: r\n          } = y(\"MISSING_OR_INVALID\", `${t} must contain an existing value for each key. Received: ${s} for key ${Object.keys(e)[i]}`);\n          throw new Error(r);\n        }\n      });\n    }), c(this, \"getPendingAuthRequest\", e => {\n      const t = this.client.auth.requests.get(e);\n      return typeof t == \"object\" ? t : void 0;\n    }), c(this, \"addToRecentlyDeleted\", (e, t) => {\n      if (this.recentlyDeletedMap.set(e, t), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {\n        let s = 0;\n        const i = this.recentlyDeletedLimit / 2;\n        for (const r of this.recentlyDeletedMap.keys()) {\n          if (s++ >= i) break;\n          this.recentlyDeletedMap.delete(r);\n        }\n      }\n    }), c(this, \"checkRecentlyDeleted\", e => {\n      const t = this.recentlyDeletedMap.get(e);\n      if (t) {\n        const {\n          message: s\n        } = y(\"MISSING_OR_INVALID\", `Record was recently deleted - ${t}: ${e}`);\n        throw new Error(s);\n      }\n    }), c(this, \"isLinkModeEnabled\", (e, t) => {\n      var s, i, r, o, a, l, p, h, u;\n      return !e || t !== P.link_mode ? !1 : ((i = (s = this.client.metadata) == null ? void 0 : s.redirect) == null ? void 0 : i.linkMode) === !0 && ((o = (r = this.client.metadata) == null ? void 0 : r.redirect) == null ? void 0 : o.universal) !== void 0 && ((l = (a = this.client.metadata) == null ? void 0 : a.redirect) == null ? void 0 : l.universal) !== \"\" && ((p = e?.redirect) == null ? void 0 : p.universal) !== void 0 && ((h = e?.redirect) == null ? void 0 : h.universal) !== \"\" && ((u = e?.redirect) == null ? void 0 : u.linkMode) === !0 && this.client.core.linkModeSupportedApps.includes(e.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < \"u\";\n    }), c(this, \"getAppLinkIfEnabled\", (e, t) => {\n      var s;\n      return this.isLinkModeEnabled(e, t) ? (s = e?.redirect) == null ? void 0 : s.universal : void 0;\n    }), c(this, \"handleLinkModeMessage\", ({\n      url: e\n    }) => {\n      if (!e || !e.includes(\"wc_ev\") || !e.includes(\"topic\")) return;\n      const t = lt(e, \"topic\") || \"\",\n        s = decodeURIComponent(lt(e, \"wc_ev\") || \"\"),\n        i = this.client.session.keys.includes(t);\n      i && this.client.session.update(t, {\n        transportType: P.link_mode\n      }), this.client.core.dispatchEnvelope({\n        topic: t,\n        message: s,\n        sessionExists: i\n      });\n    }), c(this, \"registerLinkModeListeners\", async () => {\n      var e;\n      if (rs() || ns() && (e = this.client.metadata.redirect) != null && e.linkMode) {\n        const t = global == null ? void 0 : global.Linking;\n        if (typeof t < \"u\") {\n          t.addEventListener(\"url\", this.handleLinkModeMessage, this.client.name);\n          const s = await t.getInitialURL();\n          s && setTimeout(() => {\n            this.handleLinkModeMessage({\n              url: s\n            });\n          }, 50);\n        }\n      }\n    }), c(this, \"shouldSetTVF\", (e, t) => {\n      if (!t || e !== \"wc_sessionRequest\") return !1;\n      const {\n        request: s\n      } = t;\n      return Object.keys(Ue).includes(s.method);\n    }), c(this, \"getTVFParams\", (e, t, s) => {\n      var i, r;\n      try {\n        const o = t.request.method,\n          a = this.extractTxHashesFromResult(o, s);\n        return b(v({\n          correlationId: e,\n          rpcMethods: [o],\n          chainId: t.chainId\n        }, this.isValidContractData(t.request.params) && {\n          contractAddresses: [(r = (i = t.request.params) == null ? void 0 : i[0]) == null ? void 0 : r.to]\n        }), {\n          txHashes: a\n        });\n      } catch (o) {\n        this.client.logger.warn(\"Error getting TVF params\", o);\n      }\n      return {};\n    }), c(this, \"isValidContractData\", e => {\n      var t;\n      if (!e) return !1;\n      try {\n        const s = e?.data || ((t = e?.[0]) == null ? void 0 : t.data);\n        if (!s.startsWith(\"0x\")) return !1;\n        const i = s.slice(2);\n        return /^[0-9a-fA-F]*$/.test(i) ? i.length % 2 === 0 : !1;\n      } catch {}\n      return !1;\n    }), c(this, \"extractTxHashesFromResult\", (e, t) => {\n      try {\n        const s = Ue[e];\n        if (typeof t == \"string\") return [t];\n        const i = t[s.key];\n        if (os(i)) return e === \"solana_signAllTransactions\" ? i.map(r => as(r)) : i;\n        if (typeof i == \"string\") return [i];\n      } catch (s) {\n        this.client.logger.warn(\"Error extracting tx hashes from result\", s);\n      }\n      return [];\n    });\n  }\n  async processPendingMessageEvents() {\n    try {\n      const n = this.client.session.keys,\n        e = this.client.core.relayer.messages.getWithoutAck(n);\n      for (const [t, s] of Object.entries(e)) for (const i of s) try {\n        await this.onProviderMessageEvent({\n          topic: t,\n          message: i,\n          publishedAt: Date.now()\n        });\n      } catch {\n        this.client.logger.warn(`Error processing pending message event for topic: ${t}, message: ${i}`);\n      }\n    } catch (n) {\n      this.client.logger.warn(\"processPendingMessageEvents failed\", n);\n    }\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: n\n      } = y(\"NOT_INITIALIZED\", this.name);\n      throw new Error(n);\n    }\n  }\n  async confirmOnlineStateOrThrow() {\n    await this.client.core.relayer.confirmOnlineStateOrThrow();\n  }\n  registerRelayerEvents() {\n    this.client.core.relayer.on(Xe.message, n => {\n      this.onProviderMessageEvent(n);\n    });\n  }\n  async onRelayMessage(n) {\n    const {\n        topic: e,\n        message: t,\n        attestation: s,\n        transportType: i\n      } = n,\n      {\n        publicKey: r\n      } = this.client.auth.authKeys.keys.includes(ce) ? this.client.auth.authKeys.get(ce) : {\n        responseTopic: void 0,\n        publicKey: void 0\n      };\n    try {\n      const o = await this.client.core.crypto.decode(e, t, {\n        receiverPublicKey: r,\n        encoding: i === P.link_mode ? ne : de\n      });\n      hs(o) ? (this.client.core.history.set(e, o), await this.onRelayEventRequest({\n        topic: e,\n        payload: o,\n        attestation: s,\n        transportType: i,\n        encryptedId: W(t)\n      })) : ds(o) ? (await this.client.core.history.resolve(o), await this.onRelayEventResponse({\n        topic: e,\n        payload: o,\n        transportType: i\n      }), this.client.core.history.delete(e, o.id)) : await this.onRelayEventUnknownPayload({\n        topic: e,\n        payload: o,\n        transportType: i\n      }), await this.client.core.relayer.messages.ack(e, t);\n    } catch (o) {\n      this.client.logger.error(o);\n    }\n  }\n  registerExpirerEvents() {\n    this.client.core.expirer.on(Tt.expired, async n => {\n      const {\n        topic: e,\n        id: t\n      } = Mt(n.target);\n      if (t && this.client.pendingRequest.keys.includes(t)) return await this.deletePendingSessionRequest(t, y(\"EXPIRED\"), !0);\n      if (t && this.client.auth.requests.keys.includes(t)) return await this.deletePendingAuthRequest(t, y(\"EXPIRED\"), !0);\n      e ? this.client.session.keys.includes(e) && (await this.deleteSession({\n        topic: e,\n        expirerHasDeleted: !0\n      }), this.client.events.emit(\"session_expire\", {\n        topic: e\n      })) : t && (await this.deleteProposal(t, !0), this.client.events.emit(\"proposal_expire\", {\n        id: t\n      }));\n    });\n  }\n  registerPairingEvents() {\n    this.client.core.pairing.events.on(Je.create, n => this.onPairingCreated(n)), this.client.core.pairing.events.on(Je.delete, n => {\n      this.addToRecentlyDeleted(n.topic, \"pairing\");\n    });\n  }\n  isValidPairingTopic(n) {\n    if (!Y(n, !1)) {\n      const {\n        message: e\n      } = y(\"MISSING_OR_INVALID\", `pairing topic should be a string: ${n}`);\n      throw new Error(e);\n    }\n    if (!this.client.core.pairing.pairings.keys.includes(n)) {\n      const {\n        message: e\n      } = y(\"NO_MATCHING_KEY\", `pairing topic doesn't exist: ${n}`);\n      throw new Error(e);\n    }\n    if (Z(this.client.core.pairing.pairings.get(n).expiry)) {\n      const {\n        message: e\n      } = y(\"EXPIRED\", `pairing topic: ${n}`);\n      throw new Error(e);\n    }\n  }\n  async isValidSessionTopic(n) {\n    if (!Y(n, !1)) {\n      const {\n        message: e\n      } = y(\"MISSING_OR_INVALID\", `session topic should be a string: ${n}`);\n      throw new Error(e);\n    }\n    if (this.checkRecentlyDeleted(n), !this.client.session.keys.includes(n)) {\n      const {\n        message: e\n      } = y(\"NO_MATCHING_KEY\", `session topic doesn't exist: ${n}`);\n      throw new Error(e);\n    }\n    if (Z(this.client.session.get(n).expiry)) {\n      await this.deleteSession({\n        topic: n\n      });\n      const {\n        message: e\n      } = y(\"EXPIRED\", `session topic: ${n}`);\n      throw new Error(e);\n    }\n    if (!this.client.core.crypto.keychain.has(n)) {\n      const {\n        message: e\n      } = y(\"MISSING_OR_INVALID\", `session topic does not exist in keychain: ${n}`);\n      throw await this.deleteSession({\n        topic: n\n      }), new Error(e);\n    }\n  }\n  async isValidSessionOrPairingTopic(n) {\n    if (this.checkRecentlyDeleted(n), this.client.session.keys.includes(n)) await this.isValidSessionTopic(n);else if (this.client.core.pairing.pairings.keys.includes(n)) this.isValidPairingTopic(n);else if (Y(n, !1)) {\n      const {\n        message: e\n      } = y(\"NO_MATCHING_KEY\", `session or pairing topic doesn't exist: ${n}`);\n      throw new Error(e);\n    } else {\n      const {\n        message: e\n      } = y(\"MISSING_OR_INVALID\", `session or pairing topic should be a string: ${n}`);\n      throw new Error(e);\n    }\n  }\n  async isValidProposalId(n) {\n    if (!$t(n)) {\n      const {\n        message: e\n      } = y(\"MISSING_OR_INVALID\", `proposal id should be a number: ${n}`);\n      throw new Error(e);\n    }\n    if (!this.client.proposal.keys.includes(n)) {\n      const {\n        message: e\n      } = y(\"NO_MATCHING_KEY\", `proposal id doesn't exist: ${n}`);\n      throw new Error(e);\n    }\n    if (Z(this.client.proposal.get(n).expiryTimestamp)) {\n      await this.deleteProposal(n);\n      const {\n        message: e\n      } = y(\"EXPIRED\", `proposal id: ${n}`);\n      throw new Error(e);\n    }\n  }\n}\nclass Ns extends B {\n  constructor(n, e) {\n    super(n, e, pt, we), this.core = n, this.logger = e;\n  }\n}\nclass St extends B {\n  constructor(n, e) {\n    super(n, e, ht, we), this.core = n, this.logger = e;\n  }\n}\nclass Os extends B {\n  constructor(n, e) {\n    super(n, e, ut, we, t => t.id), this.core = n, this.logger = e;\n  }\n}\nclass bs extends B {\n  constructor(n, e) {\n    super(n, e, mt, ae, () => ce), this.core = n, this.logger = e;\n  }\n}\nclass As extends B {\n  constructor(n, e) {\n    super(n, e, _t, ae), this.core = n, this.logger = e;\n  }\n}\nclass xs extends B {\n  constructor(n, e) {\n    super(n, e, Et, ae, t => t.id), this.core = n, this.logger = e;\n  }\n}\nvar Cs = Object.defineProperty,\n  Vs = (S, n, e) => n in S ? Cs(S, n, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : S[n] = e,\n  Ge = (S, n, e) => Vs(S, typeof n != \"symbol\" ? n + \"\" : n, e);\nclass Ds {\n  constructor(n, e) {\n    this.core = n, this.logger = e, Ge(this, \"authKeys\"), Ge(this, \"pairingTopics\"), Ge(this, \"requests\"), this.authKeys = new bs(this.core, this.logger), this.pairingTopics = new As(this.core, this.logger), this.requests = new xs(this.core, this.logger);\n  }\n  async init() {\n    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();\n  }\n}\nvar Ls = Object.defineProperty,\n  ks = (S, n, e) => n in S ? Ls(S, n, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : S[n] = e,\n  E = (S, n, e) => ks(S, typeof n != \"symbol\" ? n + \"\" : n, e);\nclass Ee extends Lt {\n  constructor(n) {\n    super(n), E(this, \"protocol\", De), E(this, \"version\", Le), E(this, \"name\", me.name), E(this, \"metadata\"), E(this, \"core\"), E(this, \"logger\"), E(this, \"events\", new ps()), E(this, \"engine\"), E(this, \"session\"), E(this, \"proposal\"), E(this, \"pendingRequest\"), E(this, \"auth\"), E(this, \"signConfig\"), E(this, \"on\", (t, s) => this.events.on(t, s)), E(this, \"once\", (t, s) => this.events.once(t, s)), E(this, \"off\", (t, s) => this.events.off(t, s)), E(this, \"removeListener\", (t, s) => this.events.removeListener(t, s)), E(this, \"removeAllListeners\", t => this.events.removeAllListeners(t)), E(this, \"connect\", async t => {\n      try {\n        return await this.engine.connect(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), E(this, \"pair\", async t => {\n      try {\n        return await this.engine.pair(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), E(this, \"approve\", async t => {\n      try {\n        return await this.engine.approve(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), E(this, \"reject\", async t => {\n      try {\n        return await this.engine.reject(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), E(this, \"update\", async t => {\n      try {\n        return await this.engine.update(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), E(this, \"extend\", async t => {\n      try {\n        return await this.engine.extend(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), E(this, \"request\", async t => {\n      try {\n        return await this.engine.request(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), E(this, \"respond\", async t => {\n      try {\n        return await this.engine.respond(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), E(this, \"ping\", async t => {\n      try {\n        return await this.engine.ping(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), E(this, \"emit\", async t => {\n      try {\n        return await this.engine.emit(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), E(this, \"disconnect\", async t => {\n      try {\n        return await this.engine.disconnect(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), E(this, \"find\", t => {\n      try {\n        return this.engine.find(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), E(this, \"getPendingSessionRequests\", () => {\n      try {\n        return this.engine.getPendingSessionRequests();\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }), E(this, \"authenticate\", async (t, s) => {\n      try {\n        return await this.engine.authenticate(t, s);\n      } catch (i) {\n        throw this.logger.error(i.message), i;\n      }\n    }), E(this, \"formatAuthMessage\", t => {\n      try {\n        return this.engine.formatAuthMessage(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), E(this, \"approveSessionAuthenticate\", async t => {\n      try {\n        return await this.engine.approveSessionAuthenticate(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), E(this, \"rejectSessionAuthenticate\", async t => {\n      try {\n        return await this.engine.rejectSessionAuthenticate(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }), this.name = n?.name || me.name, this.metadata = n?.metadata || cs(), this.signConfig = n?.signConfig;\n    const e = typeof n?.logger < \"u\" && typeof n?.logger != \"string\" ? n.logger : At(xt({\n      level: n?.logger || me.logger\n    }));\n    this.core = n?.core || new bt(n), this.logger = Ct(e, this.name), this.session = new St(this.core, this.logger), this.proposal = new Ns(this.core, this.logger), this.pendingRequest = new Os(this.core, this.logger), this.engine = new Ps(this), this.auth = new Ds(this.core, this.logger);\n  }\n  static async init(n) {\n    const e = new Ee(n);\n    return await e.initialize(), e;\n  }\n  get context() {\n    return Vt(this.logger);\n  }\n  get pairing() {\n    return this.core.pairing.pairings;\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\");\n    try {\n      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info(\"SignClient Initialization Success\"), setTimeout(() => {\n        this.engine.processRelayMessageCache();\n      }, Oe(Ze));\n    } catch (n) {\n      throw this.logger.info(\"SignClient Initialization Failure\"), this.logger.error(n.message), n;\n    }\n  }\n}\nconst Ms = St,\n  $s = Ee;\nexport { wt as AUTH_CONTEXT, mt as AUTH_KEYS_CONTEXT, _t as AUTH_PAIRING_TOPIC_CONTEXT, yt as AUTH_PROTOCOL, ce as AUTH_PUBLIC_KEY_NAME, Et as AUTH_REQUEST_CONTEXT, ae as AUTH_STORAGE_PREFIX, Ss as AUTH_VERSION, dt as ENGINE_CONTEXT, $ as ENGINE_QUEUE_STATES, N as ENGINE_RPC_OPTS, _s as HISTORY_CONTEXT, ms as HISTORY_EVENTS, Es as HISTORY_STORAGE_VERSION, gt as METHODS_TO_VERIFY, pt as PROPOSAL_CONTEXT, fs as PROPOSAL_EXPIRY, $e as PROPOSAL_EXPIRY_MESSAGE, ut as REQUEST_CONTEXT, ht as SESSION_CONTEXT, J as SESSION_EXPIRY, _e as SESSION_REQUEST_EXPIRY_BOUNDARIES, ke as SIGN_CLIENT_CONTEXT, me as SIGN_CLIENT_DEFAULT, ys as SIGN_CLIENT_EVENTS, De as SIGN_CLIENT_PROTOCOL, ws as SIGN_CLIENT_STORAGE_OPTIONS, we as SIGN_CLIENT_STORAGE_PREFIX, Le as SIGN_CLIENT_VERSION, Ms as SessionStore, $s as SignClient, Ue as TVF_METHODS, Me as WALLETCONNECT_DEEPLINK_CHOICE, Ee as default };","map":{"version":3,"names":[],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@reown\\appkit-controllers\\node_modules\\@walletconnect\\sign-client\\src\\constants\\client.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@reown\\appkit-controllers\\node_modules\\@walletconnect\\sign-client\\src\\constants\\history.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@reown\\appkit-controllers\\node_modules\\@walletconnect\\sign-client\\src\\constants\\proposal.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@reown\\appkit-controllers\\node_modules\\@walletconnect\\sign-client\\src\\constants\\session.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@reown\\appkit-controllers\\node_modules\\@walletconnect\\sign-client\\src\\constants\\engine.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@reown\\appkit-controllers\\node_modules\\@walletconnect\\sign-client\\src\\constants\\pendingRequest.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@reown\\appkit-controllers\\node_modules\\@walletconnect\\sign-client\\src\\constants\\verify.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@reown\\appkit-controllers\\node_modules\\@walletconnect\\sign-client\\src\\constants\\auth.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@reown\\appkit-controllers\\node_modules\\@walletconnect\\sign-client\\src\\controllers\\engine.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@reown\\appkit-controllers\\node_modules\\@walletconnect\\sign-client\\src\\controllers\\proposal.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@reown\\appkit-controllers\\node_modules\\@walletconnect\\sign-client\\src\\controllers\\session.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@reown\\appkit-controllers\\node_modules\\@walletconnect\\sign-client\\src\\controllers\\pendingRequest.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@reown\\appkit-controllers\\node_modules\\@walletconnect\\sign-client\\src\\controllers\\authKey.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@reown\\appkit-controllers\\node_modules\\@walletconnect\\sign-client\\src\\controllers\\authPairingTopic.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@reown\\appkit-controllers\\node_modules\\@walletconnect\\sign-client\\src\\controllers\\authRequest.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@reown\\appkit-controllers\\node_modules\\@walletconnect\\sign-client\\src\\controllers\\authStore.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@reown\\appkit-controllers\\node_modules\\@walletconnect\\sign-client\\src\\client.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@reown\\appkit-controllers\\node_modules\\@walletconnect\\sign-client\\src\\index.ts"],"sourcesContent":["import { SignClientTypes } from \"@walletconnect/types\";\n\nexport const SIGN_CLIENT_PROTOCOL = \"wc\";\nexport const SIGN_CLIENT_VERSION = 2;\nexport const SIGN_CLIENT_CONTEXT = \"client\";\n\nexport const SIGN_CLIENT_STORAGE_PREFIX = `${SIGN_CLIENT_PROTOCOL}@${SIGN_CLIENT_VERSION}:${SIGN_CLIENT_CONTEXT}:`;\n\nexport const SIGN_CLIENT_DEFAULT = {\n  name: SIGN_CLIENT_CONTEXT,\n  logger: \"error\",\n  controller: false,\n  relayUrl: \"wss://relay.walletconnect.org\",\n};\n\nexport const SIGN_CLIENT_EVENTS: Record<SignClientTypes.Event, SignClientTypes.Event> = {\n  session_proposal: \"session_proposal\",\n  session_update: \"session_update\",\n  session_extend: \"session_extend\",\n  session_ping: \"session_ping\",\n  session_delete: \"session_delete\",\n  session_expire: \"session_expire\",\n  session_request: \"session_request\",\n  session_request_sent: \"session_request_sent\",\n  session_event: \"session_event\",\n  proposal_expire: \"proposal_expire\",\n  session_authenticate: \"session_authenticate\",\n  session_request_expire: \"session_request_expire\",\n  session_connect: \"session_connect\",\n};\n\nexport const SIGN_CLIENT_STORAGE_OPTIONS = {\n  database: \":memory:\",\n};\n\nexport const WALLETCONNECT_DEEPLINK_CHOICE = \"WALLETCONNECT_DEEPLINK_CHOICE\";\n","export const HISTORY_EVENTS = {\n  created: \"history_created\",\n  updated: \"history_updated\",\n  deleted: \"history_deleted\",\n  sync: \"history_sync\",\n};\n\nexport const HISTORY_CONTEXT = \"history\";\n\nexport const HISTORY_STORAGE_VERSION = \"0.3\";\n","import { THIRTY_DAYS } from \"@walletconnect/time\";\n\nexport const PROPOSAL_CONTEXT = \"proposal\";\n\nexport const PROPOSAL_EXPIRY = THIRTY_DAYS;\n\nexport const PROPOSAL_EXPIRY_MESSAGE = \"Proposal expired\";\n","import { SEVEN_DAYS } from \"@walletconnect/time\";\n\nexport const SESSION_CONTEXT = \"session\";\n\nexport const SESSION_EXPIRY = SEVEN_DAYS;\n","import { FIVE_MINUTES, ONE_DAY, ONE_HOUR, SEVEN_DAYS } from \"@walletconnect/time\";\nimport { EngineTypes } from \"@walletconnect/types\";\n\nexport const ENGINE_CONTEXT = \"engine\";\n\nexport const ENGINE_RPC_OPTS: EngineTypes.RpcOptsMap = {\n  wc_sessionPropose: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: true,\n      tag: 1100,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1101,\n    },\n    reject: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1120,\n    },\n    autoReject: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1121,\n    },\n  },\n  wc_sessionSettle: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1102,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1103,\n    },\n  },\n  wc_sessionUpdate: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1104,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1105,\n    },\n  },\n  wc_sessionExtend: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1106,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1107,\n    },\n  },\n  wc_sessionRequest: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: true,\n      tag: 1108,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1109,\n    },\n  },\n  wc_sessionEvent: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: true,\n      tag: 1110,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1111,\n    },\n  },\n\n  wc_sessionDelete: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1112,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1113,\n    },\n  },\n  wc_sessionPing: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1114,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1115,\n    },\n  },\n  wc_sessionAuthenticate: {\n    req: {\n      ttl: ONE_HOUR,\n      prompt: true,\n      tag: 1116,\n    },\n    res: {\n      ttl: ONE_HOUR,\n      prompt: false,\n      tag: 1117,\n    },\n    reject: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1118,\n    },\n    autoReject: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1119,\n    },\n  },\n};\n\nexport const SESSION_REQUEST_EXPIRY_BOUNDARIES = {\n  min: FIVE_MINUTES,\n  max: SEVEN_DAYS,\n};\n\nexport const ENGINE_QUEUE_STATES: { idle: \"IDLE\"; active: \"ACTIVE\" } = {\n  idle: \"IDLE\",\n  active: \"ACTIVE\",\n};\n\nexport const TVF_METHODS = {\n  eth_sendTransaction: {\n    key: \"\",\n  },\n  eth_sendRawTransaction: {\n    key: \"\",\n  },\n  wallet_sendCalls: {\n    key: \"\",\n  },\n\n  solana_signTransaction: {\n    key: \"signature\",\n  },\n  solana_signAllTransactions: {\n    key: \"transactions\",\n  },\n  solana_signAndSendTransaction: {\n    key: \"signature\",\n  },\n};\n","export const REQUEST_CONTEXT = \"request\";\n","export const METHODS_TO_VERIFY = [\n  \"wc_sessionPropose\",\n  \"wc_sessionRequest\",\n  \"wc_authRequest\",\n  \"wc_sessionAuthenticate\",\n];\n","export const AUTH_PROTOCOL = \"wc\";\nexport const AUTH_VERSION = 1.5;\nexport const AUTH_CONTEXT = \"auth\";\nexport const AUTH_KEYS_CONTEXT = \"authKeys\";\nexport const AUTH_PAIRING_TOPIC_CONTEXT = \"pairingTopics\";\nexport const AUTH_REQUEST_CONTEXT = \"requests\";\n\nexport const AUTH_STORAGE_PREFIX = `${AUTH_PROTOCOL}@${AUTH_VERSION}:${AUTH_CONTEXT}:`;\nexport const AUTH_PUBLIC_KEY_NAME = `${AUTH_STORAGE_PREFIX}:PUB_KEY`;\n","/* eslint-disable no-console */\nimport {\n  EVENT_CLIENT_AUTHENTICATE_ERRORS,\n  EVENT_CLIENT_AUTHENTICATE_TRACES,\n  EVENT_CLIENT_PAIRING_ERRORS,\n  EVENT_CLIENT_PAIRING_TRACES,\n  EVENT_CLIENT_SESSION_ERRORS,\n  EVENT_CLIENT_SESSION_TRACES,\n  EXPIRER_EVENTS,\n  PAIRING_EVENTS,\n  RELAYER_DEFAULT_PROTOCOL,\n  RELAYER_EVENTS,\n  TRANSPORT_TYPES,\n  VERIFY_SERVER,\n} from \"@walletconnect/core\";\n\nimport {\n  formatJsonRpcError,\n  formatJsonRpcRequest,\n  formatJsonRpcResult,\n  payloadId,\n  isJsonRpcError,\n  isJsonRpcRequest,\n  isJsonRpcResponse,\n  isJsonRpcResult,\n  JsonRpcRequest,\n  ErrorResponse,\n  getBigIntRpcId,\n} from \"@walletconnect/jsonrpc-utils\";\nimport { FIVE_MINUTES, ONE_SECOND, toMiliseconds } from \"@walletconnect/time\";\nimport {\n  EnginePrivate,\n  EngineTypes,\n  ExpirerTypes,\n  IEngine,\n  IEngineEvents,\n  JsonRpcTypes,\n  PendingRequestTypes,\n  Verify,\n  CoreTypes,\n  ProposalTypes,\n  RelayerTypes,\n  SessionTypes,\n  PairingTypes,\n  AuthTypes,\n  EventClientTypes,\n} from \"@walletconnect/types\";\nimport {\n  calcExpiry,\n  createDelayedPromise,\n  engineEvent,\n  getInternalError,\n  getSdkError,\n  isConformingNamespaces,\n  isExpired,\n  isSessionCompatible,\n  isUndefined,\n  isValidController,\n  isValidErrorReason,\n  isValidEvent,\n  isValidId,\n  isValidNamespaces,\n  isValidNamespacesChainId,\n  isValidNamespacesEvent,\n  isValidNamespacesRequest,\n  isValidObject,\n  isValidParams,\n  isValidRelay,\n  isValidRelays,\n  isValidRequest,\n  isValidRequestExpiry,\n  hashMessage,\n  isValidRequiredNamespaces,\n  isValidResponse,\n  isValidString,\n  parseExpirerTarget,\n  TYPE_1,\n  TYPE_2,\n  handleDeeplinkRedirect,\n  MemoryStore,\n  getDeepLink,\n  hashKey,\n  getDidAddress,\n  formatMessage,\n  getMethodsFromRecap,\n  buildNamespacesFromAuth,\n  createEncodedRecap,\n  getChainsFromRecap,\n  mergeEncodedRecaps,\n  getRecapFromResources,\n  validateSignedCacao,\n  getNamespacedDidChainId,\n  parseChainId,\n  getLinkModeURL,\n  BASE64,\n  BASE64URL,\n  getSearchParamFromURL,\n  isReactNative,\n  isTestRun,\n  isValidArray,\n  extractSolanaTransactionId,\n} from \"@walletconnect/utils\";\nimport EventEmmiter from \"events\";\nimport {\n  ENGINE_CONTEXT,\n  ENGINE_RPC_OPTS,\n  PROPOSAL_EXPIRY_MESSAGE,\n  SESSION_EXPIRY,\n  SESSION_REQUEST_EXPIRY_BOUNDARIES,\n  METHODS_TO_VERIFY,\n  WALLETCONNECT_DEEPLINK_CHOICE,\n  ENGINE_QUEUE_STATES,\n  AUTH_PUBLIC_KEY_NAME,\n  TVF_METHODS,\n} from \"../constants\";\n\nexport class Engine extends IEngine {\n  public name = ENGINE_CONTEXT;\n\n  private events: IEngineEvents = new EventEmmiter();\n  private initialized = false;\n\n  /**\n   * Queue responsible for processing incoming requests such as session_update, session_event, session_ping etc\n   * It's needed when the client receives multiple requests at once from the mailbox immediately after initialization and to avoid attempting to process them all at the same time\n   */\n  private requestQueue: EngineTypes.EngineQueue<EngineTypes.EventCallback<JsonRpcRequest>> = {\n    state: ENGINE_QUEUE_STATES.idle,\n    queue: [],\n  };\n\n  /**\n   * Queue responsible for processing incoming session_request\n   * The queue emits the next request only after the previous one has been responded to\n   */\n  private sessionRequestQueue: EngineTypes.EngineQueue<PendingRequestTypes.Struct> = {\n    state: ENGINE_QUEUE_STATES.idle,\n    queue: [],\n  };\n\n  private requestQueueDelay = ONE_SECOND;\n  private expectedPairingMethodMap: Map<string, string[]> = new Map();\n  // Ephemeral (in-memory) map to store recently deleted items\n  private recentlyDeletedMap = new Map<\n    string | number,\n    \"pairing\" | \"session\" | \"proposal\" | \"request\"\n  >();\n\n  private recentlyDeletedLimit = 200;\n  private relayMessageCache: RelayerTypes.MessageEvent[] = [];\n  private pendingSessions: Map<\n    number,\n    {\n      sessionTopic: string;\n      pairingTopic: string;\n      proposalId: number;\n      publicKey: string;\n    }\n  > = new Map();\n\n  constructor(client: IEngine[\"client\"]) {\n    super(client);\n  }\n\n  public init: IEngine[\"init\"] = async () => {\n    if (!this.initialized) {\n      await this.cleanup();\n      this.registerRelayerEvents();\n      this.registerExpirerEvents();\n      this.registerPairingEvents();\n      await this.registerLinkModeListeners();\n      this.client.core.pairing.register({ methods: Object.keys(ENGINE_RPC_OPTS) });\n      this.initialized = true;\n      setTimeout(async () => {\n        await this.processPendingMessageEvents();\n\n        this.sessionRequestQueue.queue = this.getPendingSessionRequests();\n        this.processSessionRequestQueue();\n      }, toMiliseconds(this.requestQueueDelay));\n    }\n  };\n\n  private async processPendingMessageEvents() {\n    try {\n      const topics = this.client.session.keys;\n      const pendingMessages = this.client.core.relayer.messages.getWithoutAck(topics);\n      for (const [topic, messages] of Object.entries(pendingMessages)) {\n        for (const message of messages) {\n          try {\n            await this.onProviderMessageEvent({\n              topic,\n              message,\n              publishedAt: Date.now(),\n            });\n          } catch (error) {\n            this.client.logger.warn(\n              `Error processing pending message event for topic: ${topic}, message: ${message}`,\n            );\n          }\n        }\n      }\n    } catch (error) {\n      this.client.logger.warn(\"processPendingMessageEvents failed\", error);\n    }\n  }\n\n  // ---------- Public ------------------------------------------------ //\n\n  public connect: IEngine[\"connect\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    const connectParams = {\n      ...params,\n      requiredNamespaces: params.requiredNamespaces || {},\n      optionalNamespaces: params.optionalNamespaces || {},\n    };\n    await this.isValidConnect(connectParams);\n    const {\n      pairingTopic,\n      requiredNamespaces,\n      optionalNamespaces,\n      sessionProperties,\n      scopedProperties,\n      relays,\n    } = connectParams;\n    let topic = pairingTopic;\n    let uri: string | undefined;\n    let active = false;\n    try {\n      if (topic) {\n        const pairing = this.client.core.pairing.pairings.get(topic);\n        this.client.logger.warn(\n          \"connect() with existing pairing topic is deprecated and will be removed in the next major release.\",\n        );\n        active = pairing.active;\n      }\n    } catch (error) {\n      this.client.logger.error(`connect() -> pairing.get(${topic}) failed`);\n      throw error;\n    }\n    if (!topic || !active) {\n      const { topic: newTopic, uri: newUri } = await this.client.core.pairing.create();\n      topic = newTopic;\n      uri = newUri;\n    }\n    // safety check to ensure pairing topic is available\n    if (!topic) {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `connect() pairing topic: ${topic}`);\n      throw new Error(message);\n    }\n\n    const publicKey = await this.client.core.crypto.generateKeyPair();\n\n    const expiry = ENGINE_RPC_OPTS.wc_sessionPropose.req.ttl || FIVE_MINUTES;\n    const expiryTimestamp = calcExpiry(expiry);\n    const proposal = {\n      requiredNamespaces,\n      optionalNamespaces,\n      relays: relays ?? [{ protocol: RELAYER_DEFAULT_PROTOCOL }],\n      proposer: {\n        publicKey,\n        metadata: this.client.metadata,\n      },\n      expiryTimestamp,\n      pairingTopic: topic,\n      ...(sessionProperties && { sessionProperties }),\n      ...(scopedProperties && { scopedProperties }),\n      id: payloadId(),\n    };\n    const sessionConnectTarget = engineEvent(\"session_connect\", proposal.id);\n\n    const {\n      reject,\n      resolve,\n      done: approval,\n    } = createDelayedPromise<SessionTypes.Struct>(expiry, PROPOSAL_EXPIRY_MESSAGE);\n\n    const proposalExpireHandler = ({ id }: { id: number }) => {\n      if (id === proposal.id) {\n        this.client.events.off(\"proposal_expire\", proposalExpireHandler);\n        this.pendingSessions.delete(proposal.id);\n        // emit the event to trigger reject, this approach automatically cleans up the .once listener below\n        this.events.emit(sessionConnectTarget, {\n          error: { message: PROPOSAL_EXPIRY_MESSAGE, code: 0 },\n        });\n      }\n    };\n\n    this.client.events.on(\"proposal_expire\", proposalExpireHandler);\n    this.events.once<\"session_connect\">(sessionConnectTarget, ({ error, session }) => {\n      this.client.events.off(\"proposal_expire\", proposalExpireHandler);\n      if (error) reject(error);\n      else if (session) {\n        resolve(session);\n      }\n    });\n\n    await this.sendRequest({\n      topic,\n      method: \"wc_sessionPropose\",\n      params: proposal,\n      throwOnFailedPublish: true,\n      clientRpcId: proposal.id,\n    });\n\n    await this.setProposal(proposal.id, proposal);\n    return { uri, approval };\n  };\n\n  public pair: IEngine[\"pair\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    try {\n      return await this.client.core.pairing.pair(params);\n    } catch (error) {\n      this.client.logger.error(\"pair() failed\");\n      throw error;\n    }\n  };\n\n  public approve: IEngine[\"approve\"] = async (params) => {\n    const configEvent = this.client.core.eventClient.createEvent({\n      properties: {\n        topic: params?.id?.toString(),\n        trace: [EVENT_CLIENT_SESSION_TRACES.session_approve_started],\n      },\n    });\n    try {\n      this.isInitialized();\n      await this.confirmOnlineStateOrThrow();\n    } catch (error) {\n      configEvent.setError(EVENT_CLIENT_SESSION_ERRORS.no_internet_connection);\n      throw error;\n    }\n    try {\n      await this.isValidProposalId(params?.id);\n    } catch (error) {\n      this.client.logger.error(`approve() -> proposal.get(${params?.id}) failed`);\n      configEvent.setError(EVENT_CLIENT_SESSION_ERRORS.proposal_not_found);\n      throw error;\n    }\n\n    try {\n      await this.isValidApprove(params);\n    } catch (error) {\n      this.client.logger.error(\"approve() -> isValidApprove() failed\");\n      configEvent.setError(\n        EVENT_CLIENT_SESSION_ERRORS.session_approve_namespace_validation_failure,\n      );\n      throw error;\n    }\n\n    const { id, relayProtocol, namespaces, sessionProperties, scopedProperties, sessionConfig } =\n      params;\n\n    const proposal = this.client.proposal.get(id);\n\n    this.client.core.eventClient.deleteEvent({ eventId: configEvent.eventId });\n\n    const { pairingTopic, proposer, requiredNamespaces, optionalNamespaces } = proposal;\n\n    let event = this.client.core.eventClient?.getEvent({\n      topic: pairingTopic,\n    }) as EventClientTypes.Event;\n    if (!event) {\n      event = this.client.core.eventClient?.createEvent({\n        type: EVENT_CLIENT_SESSION_TRACES.session_approve_started,\n        properties: {\n          topic: pairingTopic,\n          trace: [\n            EVENT_CLIENT_SESSION_TRACES.session_approve_started,\n            EVENT_CLIENT_SESSION_TRACES.session_namespaces_validation_success,\n          ],\n        },\n      });\n    }\n\n    const selfPublicKey = await this.client.core.crypto.generateKeyPair();\n    const peerPublicKey = proposer.publicKey;\n    const sessionTopic = await this.client.core.crypto.generateSharedKey(\n      selfPublicKey,\n      peerPublicKey,\n    );\n    const sessionSettle = {\n      relay: { protocol: relayProtocol ?? \"irn\" },\n      namespaces,\n      controller: { publicKey: selfPublicKey, metadata: this.client.metadata },\n      expiry: calcExpiry(SESSION_EXPIRY),\n      ...(sessionProperties && { sessionProperties }),\n      ...(scopedProperties && { scopedProperties }),\n      ...(sessionConfig && { sessionConfig }),\n    };\n    const transportType = TRANSPORT_TYPES.relay;\n    event.addTrace(EVENT_CLIENT_SESSION_TRACES.subscribing_session_topic);\n    try {\n      await this.client.core.relayer.subscribe(sessionTopic, { transportType });\n    } catch (error) {\n      event.setError(EVENT_CLIENT_SESSION_ERRORS.subscribe_session_topic_failure);\n      throw error;\n    }\n\n    event.addTrace(EVENT_CLIENT_SESSION_TRACES.subscribe_session_topic_success);\n\n    const session = {\n      ...sessionSettle,\n      topic: sessionTopic,\n      requiredNamespaces,\n      optionalNamespaces,\n      pairingTopic,\n      acknowledged: false,\n      self: sessionSettle.controller,\n      peer: {\n        publicKey: proposer.publicKey,\n        metadata: proposer.metadata,\n      },\n      controller: selfPublicKey,\n      transportType: TRANSPORT_TYPES.relay,\n    };\n    await this.client.session.set(sessionTopic, session);\n\n    event.addTrace(EVENT_CLIENT_SESSION_TRACES.store_session);\n\n    try {\n      event.addTrace(EVENT_CLIENT_SESSION_TRACES.publishing_session_settle);\n      await this.sendRequest({\n        topic: sessionTopic,\n        method: \"wc_sessionSettle\",\n        params: sessionSettle,\n        throwOnFailedPublish: true,\n      }).catch((error) => {\n        event?.setError(EVENT_CLIENT_SESSION_ERRORS.session_settle_publish_failure);\n        throw error;\n      });\n\n      event.addTrace(EVENT_CLIENT_SESSION_TRACES.session_settle_publish_success);\n\n      event.addTrace(EVENT_CLIENT_SESSION_TRACES.publishing_session_approve);\n      await this.sendResult<\"wc_sessionPropose\">({\n        id,\n        topic: pairingTopic,\n        result: {\n          relay: {\n            protocol: relayProtocol ?? \"irn\",\n          },\n          responderPublicKey: selfPublicKey,\n        },\n        throwOnFailedPublish: true,\n      }).catch((error) => {\n        event?.setError(EVENT_CLIENT_SESSION_ERRORS.session_approve_publish_failure);\n        throw error;\n      });\n\n      event.addTrace(EVENT_CLIENT_SESSION_TRACES.session_approve_publish_success);\n    } catch (error) {\n      this.client.logger.error(error);\n      // if the publish fails, delete the session and throw an error\n      this.client.session.delete(sessionTopic, getSdkError(\"USER_DISCONNECTED\"));\n      await this.client.core.relayer.unsubscribe(sessionTopic);\n      throw error;\n    }\n\n    this.client.core.eventClient.deleteEvent({ eventId: event.eventId });\n\n    await this.client.core.pairing.updateMetadata({\n      topic: pairingTopic,\n      metadata: proposer.metadata,\n    });\n    await this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\"));\n    await this.client.core.pairing.activate({ topic: pairingTopic });\n    await this.setExpiry(sessionTopic, calcExpiry(SESSION_EXPIRY));\n    return {\n      topic: sessionTopic,\n      acknowledged: () => Promise.resolve(this.client.session.get(sessionTopic)),\n    };\n  };\n\n  public reject: IEngine[\"reject\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    try {\n      await this.isValidReject(params);\n    } catch (error) {\n      this.client.logger.error(\"reject() -> isValidReject() failed\");\n      throw error;\n    }\n    const { id, reason } = params;\n    let pairingTopic;\n    try {\n      const proposal = this.client.proposal.get(id);\n      pairingTopic = proposal.pairingTopic;\n    } catch (error) {\n      this.client.logger.error(`reject() -> proposal.get(${id}) failed`);\n      throw error;\n    }\n\n    if (pairingTopic) {\n      await this.sendError({\n        id,\n        topic: pairingTopic,\n        error: reason,\n        rpcOpts: ENGINE_RPC_OPTS.wc_sessionPropose.reject,\n      });\n      await this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\"));\n    }\n  };\n\n  public update: IEngine[\"update\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    try {\n      await this.isValidUpdate(params);\n    } catch (error) {\n      this.client.logger.error(\"update() -> isValidUpdate() failed\");\n      throw error;\n    }\n    const { topic, namespaces } = params;\n\n    const { done: acknowledged, resolve, reject } = createDelayedPromise<void>();\n    const clientRpcId = payloadId();\n    const relayRpcId = getBigIntRpcId().toString() as any;\n\n    const oldNamespaces = this.client.session.get(topic).namespaces;\n    this.events.once(engineEvent(\"session_update\", clientRpcId), ({ error }: any) => {\n      if (error) reject(error);\n      else {\n        resolve();\n      }\n    });\n    // Update the session with the new namespaces, if the publish fails, revert to the old.\n    // This allows the client to use the updated session like emitting events\n    // without waiting for the peer to acknowledge\n    await this.client.session.update(topic, { namespaces });\n    await this.sendRequest({\n      topic,\n      method: \"wc_sessionUpdate\",\n      params: { namespaces },\n      throwOnFailedPublish: true,\n      clientRpcId,\n      relayRpcId,\n    }).catch((error) => {\n      this.client.logger.error(error);\n      this.client.session.update(topic, { namespaces: oldNamespaces });\n      reject(error);\n    });\n    return { acknowledged };\n  };\n\n  public extend: IEngine[\"extend\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    try {\n      await this.isValidExtend(params);\n    } catch (error) {\n      this.client.logger.error(\"extend() -> isValidExtend() failed\");\n      throw error;\n    }\n\n    const { topic } = params;\n    const clientRpcId = payloadId();\n    const { done: acknowledged, resolve, reject } = createDelayedPromise<void>();\n    this.events.once(engineEvent(\"session_extend\", clientRpcId), ({ error }: any) => {\n      if (error) reject(error);\n      else resolve();\n    });\n\n    await this.setExpiry(topic, calcExpiry(SESSION_EXPIRY));\n    this.sendRequest({\n      topic,\n      method: \"wc_sessionExtend\",\n      params: {},\n      clientRpcId,\n      throwOnFailedPublish: true,\n    }).catch((e) => {\n      reject(e);\n    });\n\n    return { acknowledged };\n  };\n\n  public request: IEngine[\"request\"] = async <T>(params: EngineTypes.RequestParams) => {\n    this.isInitialized();\n    try {\n      await this.isValidRequest(params);\n    } catch (error) {\n      this.client.logger.error(\"request() -> isValidRequest() failed\");\n      throw error;\n    }\n    const { chainId, request, topic, expiry = ENGINE_RPC_OPTS.wc_sessionRequest.req.ttl } = params;\n    const session = this.client.session.get(topic);\n\n    if (session?.transportType === TRANSPORT_TYPES.relay) {\n      await this.confirmOnlineStateOrThrow();\n    }\n    const clientRpcId = payloadId();\n    const relayRpcId = getBigIntRpcId().toString() as any;\n    const { done, resolve, reject } = createDelayedPromise<T>(\n      expiry,\n      \"Request expired. Please try again.\",\n    );\n    this.events.once<\"session_request\">(\n      engineEvent(\"session_request\", clientRpcId),\n      ({ error, result }) => {\n        if (error) reject(error);\n        else resolve(result);\n      },\n    );\n    const protocolMethod = \"wc_sessionRequest\";\n    const appLink = this.getAppLinkIfEnabled(session.peer.metadata, session.transportType);\n    if (appLink) {\n      await this.sendRequest({\n        clientRpcId,\n        relayRpcId,\n        topic,\n        method: protocolMethod,\n        params: {\n          request: {\n            ...request,\n            expiryTimestamp: calcExpiry(expiry),\n          },\n          chainId,\n        },\n        expiry,\n        throwOnFailedPublish: true,\n        appLink,\n      }).catch((error) => reject(error));\n\n      this.client.events.emit(\"session_request_sent\", {\n        topic,\n        request,\n        chainId,\n        id: clientRpcId,\n      });\n      const result = await done();\n      return result;\n    }\n\n    const protocolRequestParams: JsonRpcTypes.RequestParams[\"wc_sessionRequest\"] = {\n      request: {\n        ...request,\n        expiryTimestamp: calcExpiry(expiry),\n      },\n      chainId,\n    };\n    const shouldSetTVF = this.shouldSetTVF(protocolMethod, protocolRequestParams);\n\n    return await Promise.all([\n      new Promise<void>(async (resolve) => {\n        await this.sendRequest({\n          clientRpcId,\n          relayRpcId,\n          topic,\n          method: protocolMethod,\n          params: protocolRequestParams,\n          expiry,\n          throwOnFailedPublish: true,\n          ...(shouldSetTVF && {\n            tvf: this.getTVFParams(clientRpcId, protocolRequestParams),\n          }),\n        }).catch((error) => reject(error));\n        this.client.events.emit(\"session_request_sent\", {\n          topic,\n          request,\n          chainId,\n          id: clientRpcId,\n        });\n        resolve();\n      }),\n      new Promise<void>(async (resolve) => {\n        // only attempt to handle deeplinks if they are not explicitly disabled in the session config\n        if (!session.sessionConfig?.disableDeepLink) {\n          const wcDeepLink = (await getDeepLink(\n            this.client.core.storage,\n            WALLETCONNECT_DEEPLINK_CHOICE,\n          )) as string;\n          await handleDeeplinkRedirect({ id: clientRpcId, topic, wcDeepLink });\n        }\n        resolve();\n      }),\n      done(),\n    ]).then((result) => result[2]); // order is important here, we want to return the result of the `done` promise\n  };\n\n  public respond: IEngine[\"respond\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidRespond(params);\n    const { topic, response } = params;\n    const { id } = response;\n    const session = this.client.session.get(topic);\n\n    if (session.transportType === TRANSPORT_TYPES.relay) {\n      await this.confirmOnlineStateOrThrow();\n    }\n\n    const appLink = this.getAppLinkIfEnabled(session.peer.metadata, session.transportType);\n    if (isJsonRpcResult(response)) {\n      await this.sendResult({\n        id,\n        topic,\n        result: response.result,\n        throwOnFailedPublish: true,\n        appLink,\n      });\n    } else if (isJsonRpcError(response)) {\n      await this.sendError({ id, topic, error: response.error, appLink });\n    }\n    this.cleanupAfterResponse(params);\n  };\n\n  public ping: IEngine[\"ping\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    try {\n      await this.isValidPing(params);\n    } catch (error) {\n      this.client.logger.error(\"ping() -> isValidPing() failed\");\n      throw error;\n    }\n    const { topic } = params;\n    if (this.client.session.keys.includes(topic)) {\n      const clientRpcId = payloadId();\n      const relayRpcId = getBigIntRpcId().toString() as any;\n      const { done, resolve, reject } = createDelayedPromise<void>();\n      this.events.once(engineEvent(\"session_ping\", clientRpcId), ({ error }: any) => {\n        if (error) reject(error);\n        else resolve();\n      });\n      await Promise.all([\n        this.sendRequest({\n          topic,\n          method: \"wc_sessionPing\",\n          params: {},\n          throwOnFailedPublish: true,\n          clientRpcId,\n          relayRpcId,\n        }),\n        done(),\n      ]);\n    } else if (this.client.core.pairing.pairings.keys.includes(topic)) {\n      this.client.logger.warn(\n        \"ping() on pairing topic is deprecated and will be removed in the next major release.\",\n      );\n      await this.client.core.pairing.ping({ topic });\n    }\n  };\n\n  public emit: IEngine[\"emit\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    await this.isValidEmit(params);\n    const { topic, event, chainId } = params;\n    const relayRpcId = getBigIntRpcId().toString() as any;\n    const clientRpcId = payloadId();\n    await this.sendRequest({\n      topic,\n      method: \"wc_sessionEvent\",\n      params: { event, chainId },\n      throwOnFailedPublish: true,\n      relayRpcId,\n      clientRpcId,\n    });\n  };\n\n  public disconnect: IEngine[\"disconnect\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    await this.isValidDisconnect(params);\n    const { topic } = params;\n    if (this.client.session.keys.includes(topic)) {\n      // await an ack to ensure the relay has received the disconnect request\n      await this.sendRequest({\n        topic,\n        method: \"wc_sessionDelete\",\n        params: getSdkError(\"USER_DISCONNECTED\"),\n        throwOnFailedPublish: true,\n      });\n      await this.deleteSession({ topic, emitEvent: false });\n    } else if (this.client.core.pairing.pairings.keys.includes(topic)) {\n      await this.client.core.pairing.disconnect({ topic });\n    } else {\n      const { message } = getInternalError(\n        \"MISMATCHED_TOPIC\",\n        `Session or pairing topic not found: ${topic}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  public find: IEngine[\"find\"] = (params) => {\n    this.isInitialized();\n    return this.client.session.getAll().filter((session) => isSessionCompatible(session, params));\n  };\n\n  public getPendingSessionRequests: IEngine[\"getPendingSessionRequests\"] = () => {\n    return this.client.pendingRequest.getAll();\n  };\n\n  // ---------- Auth ------------------------------------------------ //\n\n  public authenticate: IEngine[\"authenticate\"] = async (params, walletUniversalLink) => {\n    this.isInitialized();\n    this.isValidAuthenticate(params);\n\n    const isLinkMode =\n      walletUniversalLink &&\n      this.client.core.linkModeSupportedApps.includes(walletUniversalLink) &&\n      this.client.metadata.redirect?.linkMode;\n\n    const transportType: RelayerTypes.TransportType = isLinkMode\n      ? TRANSPORT_TYPES.link_mode\n      : TRANSPORT_TYPES.relay;\n\n    if (transportType === TRANSPORT_TYPES.relay) {\n      await this.confirmOnlineStateOrThrow();\n    }\n\n    const {\n      chains,\n      statement = \"\",\n      uri,\n      domain,\n      nonce,\n      type,\n      exp,\n      nbf,\n      methods = [],\n      expiry,\n    } = params;\n    // reassign resources to remove reference as the array is modified and might cause side effects\n    const resources = [...(params.resources || [])];\n\n    const { topic: pairingTopic, uri: connectionUri } = await this.client.core.pairing.create({\n      methods: [\"wc_sessionAuthenticate\"],\n      transportType,\n    });\n\n    this.client.logger.info({\n      message: \"Generated new pairing\",\n      pairing: { topic: pairingTopic, uri: connectionUri },\n    });\n\n    const publicKey = await this.client.core.crypto.generateKeyPair();\n    const responseTopic = hashKey(publicKey);\n\n    await Promise.all([\n      this.client.auth.authKeys.set(AUTH_PUBLIC_KEY_NAME, { responseTopic, publicKey }),\n      this.client.auth.pairingTopics.set(responseTopic, { topic: responseTopic, pairingTopic }),\n    ]);\n\n    // Subscribe to response topic\n    await this.client.core.relayer.subscribe(responseTopic, { transportType });\n\n    this.client.logger.info(`sending request to new pairing topic: ${pairingTopic}`);\n\n    if (methods.length > 0) {\n      const { namespace } = parseChainId(chains[0]);\n      let recap = createEncodedRecap(namespace, \"request\", methods);\n      const existingRecap = getRecapFromResources(resources);\n      if (existingRecap) {\n        // per Recaps spec, recap must occupy the last position in the resources array\n        // using .pop to remove the element given we already checked it's a recap and will replace it\n        const mergedRecap = mergeEncodedRecaps(recap, resources.pop() as string);\n        recap = mergedRecap;\n      }\n      resources.push(recap);\n    }\n\n    // Ensure the expiry is greater than the minimum required for the request - currently 1h\n    const authRequestExpiry =\n      expiry && expiry > ENGINE_RPC_OPTS.wc_sessionAuthenticate.req.ttl\n        ? expiry\n        : ENGINE_RPC_OPTS.wc_sessionAuthenticate.req.ttl;\n\n    const request: AuthTypes.SessionAuthenticateRequestParams = {\n      authPayload: {\n        type: type ?? \"caip122\",\n        chains,\n        statement,\n        aud: uri,\n        domain,\n        version: \"1\",\n        nonce,\n        iat: new Date().toISOString(),\n        exp,\n        nbf,\n        resources,\n      },\n      requester: { publicKey, metadata: this.client.metadata },\n      expiryTimestamp: calcExpiry(authRequestExpiry),\n    };\n\n    // ----- build namespaces for fallback session proposal ----- //\n    const namespaces = {\n      eip155: {\n        chains,\n        // request `personal_sign` method by default to allow for fallback siwe\n        methods: [...new Set([\"personal_sign\", ...methods])],\n        events: [\"chainChanged\", \"accountsChanged\"],\n      },\n    };\n\n    const proposal = {\n      requiredNamespaces: {},\n      optionalNamespaces: namespaces,\n      relays: [{ protocol: \"irn\" }],\n      pairingTopic,\n      proposer: {\n        publicKey,\n        metadata: this.client.metadata,\n      },\n      expiryTimestamp: calcExpiry(ENGINE_RPC_OPTS.wc_sessionPropose.req.ttl),\n      id: payloadId(),\n    };\n\n    const { done, resolve, reject } = createDelayedPromise(authRequestExpiry, \"Request expired\");\n\n    const authenticateId = payloadId();\n    const sessionConnectEventTarget = engineEvent(\"session_connect\", proposal.id);\n    const authenticateEventTarget = engineEvent(\"session_request\", authenticateId);\n\n    // handle fallback session proposal response\n    const onSessionConnect = async ({ error, session }: any) => {\n      // cleanup listener for authenticate response\n      this.events.off(authenticateEventTarget, onAuthenticate);\n      if (error) reject(error);\n      else if (session) {\n        resolve({\n          session,\n        });\n      }\n    };\n    // handle session authenticate response\n    const onAuthenticate = async (payload: any) => {\n      // delete this auth request on response\n      // we're using payload from the wallet to establish the session so we don't need to keep this around\n      await this.deletePendingAuthRequest(authenticateId, { message: \"fulfilled\", code: 0 });\n      if (payload.error) {\n        // wallets that do not support wc_sessionAuthenticate will return an error\n        // we should not reject the promise in this case as the fallback session proposal will be used\n        const error = getSdkError(\"WC_METHOD_UNSUPPORTED\", \"wc_sessionAuthenticate\");\n        if (payload.error.code === error.code) return;\n\n        // cleanup listener for fallback response\n        this.events.off(sessionConnectEventTarget, onSessionConnect);\n        return reject(payload.error.message);\n      }\n      // delete fallback proposal on successful authenticate as the proposal will not be responded to\n      await this.deleteProposal(proposal.id);\n      // cleanup listener for fallback response\n      this.events.off(sessionConnectEventTarget, onSessionConnect);\n\n      const {\n        cacaos,\n        responder,\n      }: {\n        cacaos: AuthTypes.SessionAuthenticateResponseParams[\"cacaos\"];\n        responder: AuthTypes.SessionAuthenticateResponseParams[\"responder\"];\n      } = payload.result;\n\n      const approvedMethods: string[] = [];\n      const approvedAccounts: string[] = [];\n      for (const cacao of cacaos) {\n        const isValid = await validateSignedCacao({ cacao, projectId: this.client.core.projectId });\n        if (!isValid) {\n          this.client.logger.error(cacao, \"Signature verification failed\");\n          reject(getSdkError(\"SESSION_SETTLEMENT_FAILED\", \"Signature verification failed\"));\n        }\n\n        const { p: payload } = cacao;\n        const recap = getRecapFromResources(payload.resources);\n\n        const approvedChains: string[] = [getNamespacedDidChainId(payload.iss) as string];\n        const parsedAddress = getDidAddress(payload.iss) as string;\n\n        if (recap) {\n          const methodsfromRecap = getMethodsFromRecap(recap);\n          const chainsFromRecap = getChainsFromRecap(recap);\n          approvedMethods.push(...methodsfromRecap);\n          approvedChains.push(...chainsFromRecap);\n        }\n\n        for (const chain of approvedChains) {\n          approvedAccounts.push(`${chain}:${parsedAddress}`);\n        }\n      }\n      const sessionTopic = await this.client.core.crypto.generateSharedKey(\n        publicKey,\n        responder.publicKey,\n      );\n\n      //create session object\n      let session: SessionTypes.Struct | undefined;\n\n      if (approvedMethods.length > 0) {\n        session = {\n          topic: sessionTopic,\n          acknowledged: true,\n          self: {\n            publicKey,\n            metadata: this.client.metadata,\n          },\n          peer: responder,\n          controller: responder.publicKey,\n          expiry: calcExpiry(SESSION_EXPIRY),\n          requiredNamespaces: {},\n          optionalNamespaces: {},\n          relay: { protocol: \"irn\" },\n          pairingTopic,\n          namespaces: buildNamespacesFromAuth(\n            [...new Set(approvedMethods)],\n            [...new Set(approvedAccounts)],\n          ),\n          transportType,\n        };\n\n        await this.client.core.relayer.subscribe(sessionTopic, { transportType });\n        await this.client.session.set(sessionTopic, session);\n        if (pairingTopic) {\n          await this.client.core.pairing.updateMetadata({\n            topic: pairingTopic,\n            metadata: responder.metadata,\n          });\n        }\n\n        session = this.client.session.get(sessionTopic);\n      }\n\n      if (\n        this.client.metadata.redirect?.linkMode &&\n        responder.metadata.redirect?.linkMode &&\n        responder.metadata.redirect?.universal &&\n        walletUniversalLink\n      ) {\n        // save wallet link in array of apps that support linkMode\n        this.client.core.addLinkModeSupportedApp(responder.metadata.redirect.universal);\n\n        this.client.session.update(sessionTopic, {\n          transportType: TRANSPORT_TYPES.link_mode,\n        });\n      }\n\n      resolve({\n        auths: cacaos,\n        session,\n      });\n    };\n\n    // subscribe to response events\n    this.events.once<\"session_connect\">(sessionConnectEventTarget, onSessionConnect);\n    this.events.once(authenticateEventTarget, onAuthenticate);\n\n    let linkModeURL;\n    try {\n      if (isLinkMode) {\n        const payload = formatJsonRpcRequest(\"wc_sessionAuthenticate\", request, authenticateId);\n        this.client.core.history.set(pairingTopic, payload);\n        const message = await this.client.core.crypto.encode(\"\", payload, {\n          type: TYPE_2,\n          encoding: BASE64URL,\n        });\n        linkModeURL = getLinkModeURL(walletUniversalLink, pairingTopic, message);\n      } else {\n        // send both (main & fallback) requests\n        await Promise.all([\n          this.sendRequest({\n            topic: pairingTopic,\n            method: \"wc_sessionAuthenticate\",\n            params: request,\n            expiry: params.expiry,\n            throwOnFailedPublish: true,\n            clientRpcId: authenticateId,\n          }),\n          this.sendRequest({\n            topic: pairingTopic,\n            method: \"wc_sessionPropose\",\n            params: proposal,\n            expiry: ENGINE_RPC_OPTS.wc_sessionPropose.req.ttl,\n            throwOnFailedPublish: true,\n            clientRpcId: proposal.id,\n          }),\n        ]);\n      }\n    } catch (error) {\n      // cleanup listeners on failed publish\n      this.events.off(sessionConnectEventTarget, onSessionConnect);\n      this.events.off(authenticateEventTarget, onAuthenticate);\n      throw error;\n    }\n\n    await this.setProposal(proposal.id, proposal);\n    await this.setAuthRequest(authenticateId, {\n      request: {\n        ...request,\n        verifyContext: {} as any,\n      },\n      pairingTopic,\n      transportType,\n    });\n\n    return {\n      uri: linkModeURL ?? connectionUri,\n      response: done,\n    } as EngineTypes.SessionAuthenticateResponsePromise;\n  };\n\n  public approveSessionAuthenticate: IEngine[\"approveSessionAuthenticate\"] = async (\n    sessionAuthenticateResponseParams,\n  ) => {\n    const { id, auths } = sessionAuthenticateResponseParams;\n\n    const event = this.client.core.eventClient.createEvent({\n      properties: {\n        topic: id.toString(),\n        trace: [EVENT_CLIENT_AUTHENTICATE_TRACES.authenticated_session_approve_started],\n      },\n    });\n\n    try {\n      this.isInitialized();\n    } catch (error) {\n      event.setError(EVENT_CLIENT_AUTHENTICATE_ERRORS.no_internet_connection);\n      throw error;\n    }\n\n    const pendingRequest = this.getPendingAuthRequest(id);\n\n    if (!pendingRequest) {\n      event.setError(\n        EVENT_CLIENT_AUTHENTICATE_ERRORS.authenticated_session_pending_request_not_found,\n      );\n      throw new Error(`Could not find pending auth request with id ${id}`);\n    }\n\n    const transportType = pendingRequest.transportType || TRANSPORT_TYPES.relay;\n    if (transportType === TRANSPORT_TYPES.relay) {\n      await this.confirmOnlineStateOrThrow();\n    }\n\n    const receiverPublicKey = pendingRequest.requester.publicKey;\n    const senderPublicKey = await this.client.core.crypto.generateKeyPair();\n    const responseTopic = hashKey(receiverPublicKey);\n\n    const encodeOpts = {\n      type: TYPE_1,\n      receiverPublicKey,\n      senderPublicKey,\n    };\n\n    const approvedMethods: string[] = [];\n    const approvedAccounts: string[] = [];\n    for (const cacao of auths) {\n      const isValid = await validateSignedCacao({ cacao, projectId: this.client.core.projectId });\n      if (!isValid) {\n        event.setError(EVENT_CLIENT_AUTHENTICATE_ERRORS.invalid_cacao);\n\n        const invalidErr = getSdkError(\n          \"SESSION_SETTLEMENT_FAILED\",\n          \"Signature verification failed\",\n        );\n\n        await this.sendError({\n          id,\n          topic: responseTopic,\n          error: invalidErr,\n          encodeOpts,\n        });\n\n        throw new Error(invalidErr.message);\n      }\n\n      event.addTrace(EVENT_CLIENT_AUTHENTICATE_TRACES.cacaos_verified);\n\n      const { p: payload } = cacao;\n      const recap = getRecapFromResources(payload.resources);\n\n      const approvedChains: string[] = [getNamespacedDidChainId(payload.iss) as string];\n\n      const parsedAddress = getDidAddress(payload.iss) as string;\n\n      if (recap) {\n        const methodsfromRecap = getMethodsFromRecap(recap);\n        const chainsFromRecap = getChainsFromRecap(recap);\n        approvedMethods.push(...methodsfromRecap);\n        approvedChains.push(...chainsFromRecap);\n      }\n      for (const chain of approvedChains) {\n        approvedAccounts.push(`${chain}:${parsedAddress}`);\n      }\n    }\n\n    const sessionTopic = await this.client.core.crypto.generateSharedKey(\n      senderPublicKey,\n      receiverPublicKey,\n    );\n\n    event.addTrace(EVENT_CLIENT_AUTHENTICATE_TRACES.create_authenticated_session_topic);\n\n    let session: SessionTypes.Struct | undefined;\n    if (approvedMethods?.length > 0) {\n      session = {\n        topic: sessionTopic,\n        acknowledged: true,\n        self: {\n          publicKey: senderPublicKey,\n          metadata: this.client.metadata,\n        },\n        peer: {\n          publicKey: receiverPublicKey,\n          metadata: pendingRequest.requester.metadata,\n        },\n        controller: receiverPublicKey,\n        expiry: calcExpiry(SESSION_EXPIRY),\n        authentication: auths,\n        requiredNamespaces: {},\n        optionalNamespaces: {},\n        relay: { protocol: \"irn\" },\n        pairingTopic: pendingRequest.pairingTopic,\n        namespaces: buildNamespacesFromAuth(\n          [...new Set(approvedMethods)],\n          [...new Set(approvedAccounts)],\n        ),\n        transportType,\n      };\n\n      event.addTrace(EVENT_CLIENT_AUTHENTICATE_TRACES.subscribing_authenticated_session_topic);\n\n      try {\n        await this.client.core.relayer.subscribe(sessionTopic, { transportType });\n      } catch (error) {\n        event.setError(\n          EVENT_CLIENT_AUTHENTICATE_ERRORS.subscribe_authenticated_session_topic_failure,\n        );\n        throw error;\n      }\n\n      event.addTrace(\n        EVENT_CLIENT_AUTHENTICATE_TRACES.subscribe_authenticated_session_topic_success,\n      );\n\n      await this.client.session.set(sessionTopic, session);\n\n      event.addTrace(EVENT_CLIENT_AUTHENTICATE_TRACES.store_authenticated_session);\n\n      await this.client.core.pairing.updateMetadata({\n        topic: pendingRequest.pairingTopic,\n        metadata: pendingRequest.requester.metadata,\n      });\n    }\n\n    event.addTrace(EVENT_CLIENT_AUTHENTICATE_TRACES.publishing_authenticated_session_approve);\n\n    try {\n      await this.sendResult<\"wc_sessionAuthenticate\">({\n        topic: responseTopic,\n        id,\n        result: {\n          cacaos: auths,\n          responder: {\n            publicKey: senderPublicKey,\n            metadata: this.client.metadata,\n          },\n        },\n        encodeOpts,\n        throwOnFailedPublish: true,\n        appLink: this.getAppLinkIfEnabled(pendingRequest.requester.metadata, transportType),\n      });\n    } catch (error) {\n      event.setError(\n        EVENT_CLIENT_AUTHENTICATE_ERRORS.authenticated_session_approve_publish_failure,\n      );\n      throw error;\n    }\n\n    await this.client.auth.requests.delete(id, { message: \"fulfilled\", code: 0 });\n    await this.client.core.pairing.activate({ topic: pendingRequest.pairingTopic });\n    this.client.core.eventClient.deleteEvent({ eventId: event.eventId });\n\n    return { session };\n  };\n\n  public rejectSessionAuthenticate: IEngine[\"rejectSessionAuthenticate\"] = async (params) => {\n    this.isInitialized();\n\n    const { id, reason } = params;\n\n    const pendingRequest = this.getPendingAuthRequest(id);\n\n    if (!pendingRequest) {\n      throw new Error(`Could not find pending auth request with id ${id}`);\n    }\n\n    if (pendingRequest.transportType === TRANSPORT_TYPES.relay) {\n      await this.confirmOnlineStateOrThrow();\n    }\n\n    const receiverPublicKey = pendingRequest.requester.publicKey;\n    const senderPublicKey = await this.client.core.crypto.generateKeyPair();\n    const responseTopic = hashKey(receiverPublicKey);\n\n    const encodeOpts = {\n      type: TYPE_1,\n      receiverPublicKey,\n      senderPublicKey,\n    };\n\n    await this.sendError({\n      id,\n      topic: responseTopic,\n      error: reason,\n      encodeOpts,\n      rpcOpts: ENGINE_RPC_OPTS.wc_sessionAuthenticate.reject,\n      appLink: this.getAppLinkIfEnabled(\n        pendingRequest.requester.metadata,\n        pendingRequest.transportType,\n      ),\n    });\n    await this.client.auth.requests.delete(id, { message: \"rejected\", code: 0 });\n    await this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\"));\n  };\n\n  public formatAuthMessage: IEngine[\"formatAuthMessage\"] = (params) => {\n    this.isInitialized();\n    const { request, iss } = params;\n    return formatMessage(request, iss);\n  };\n\n  public processRelayMessageCache: IEngine[\"processRelayMessageCache\"] = () => {\n    // process the relay messages cache in the next tick to allow event listeners to be registered by the implementing app\n    setTimeout(async () => {\n      if (this.relayMessageCache.length === 0) return;\n      while (this.relayMessageCache.length > 0) {\n        try {\n          const message = this.relayMessageCache.shift();\n          if (message) {\n            await this.onRelayMessage(message);\n          }\n        } catch (error) {\n          this.client.logger.error(error);\n        }\n      }\n    }, 50);\n  };\n\n  // ---------- Private Helpers --------------------------------------- //\n\n  private cleanupDuplicatePairings: EnginePrivate[\"cleanupDuplicatePairings\"] = async (\n    session: SessionTypes.Struct,\n  ) => {\n    // older SDK versions are missing the `pairingTopic` prop thus we need to check for it\n    if (!session.pairingTopic) return;\n\n    try {\n      const pairing = this.client.core.pairing.pairings.get(session.pairingTopic);\n      const allPairings = this.client.core.pairing.pairings.getAll();\n      const duplicates = allPairings.filter(\n        (p) =>\n          p.peerMetadata?.url &&\n          p.peerMetadata?.url === session.peer.metadata.url &&\n          p.topic &&\n          p.topic !== pairing.topic,\n      );\n      if (duplicates.length === 0) return;\n      this.client.logger.info(`Cleaning up ${duplicates.length} duplicate pairing(s)`);\n      await Promise.all(\n        duplicates.map((p) => this.client.core.pairing.disconnect({ topic: p.topic })),\n      );\n      this.client.logger.info(`Duplicate pairings clean up finished`);\n    } catch (error) {\n      this.client.logger.error(error);\n    }\n  };\n\n  private deleteSession: EnginePrivate[\"deleteSession\"] = async (params) => {\n    const { topic, expirerHasDeleted = false, emitEvent = true, id = 0 } = params;\n    const { self } = this.client.session.get(topic);\n    // Await the unsubscribe first to avoid deleting the symKey too early below.\n    await this.client.core.relayer.unsubscribe(topic);\n    await this.client.session.delete(topic, getSdkError(\"USER_DISCONNECTED\"));\n    this.addToRecentlyDeleted(topic, \"session\");\n    if (this.client.core.crypto.keychain.has(self.publicKey)) {\n      await this.client.core.crypto.deleteKeyPair(self.publicKey);\n    }\n    if (this.client.core.crypto.keychain.has(topic)) {\n      await this.client.core.crypto.deleteSymKey(topic);\n    }\n    if (!expirerHasDeleted) this.client.core.expirer.del(topic);\n    // remove any deeplinks from storage after the session is deleted\n    // to avoid navigating to incorrect deeplink later on\n    this.client.core.storage\n      .removeItem(WALLETCONNECT_DEEPLINK_CHOICE)\n      .catch((e) => this.client.logger.warn(e));\n    this.getPendingSessionRequests().forEach((r) => {\n      if (r.topic === topic) {\n        this.deletePendingSessionRequest(r.id, getSdkError(\"USER_DISCONNECTED\"));\n      }\n    });\n    // reset the queue state back to idle if a request for the deleted session is still in the queue\n    if (topic === this.sessionRequestQueue.queue[0]?.topic) {\n      this.sessionRequestQueue.state = ENGINE_QUEUE_STATES.idle;\n    }\n    if (emitEvent) this.client.events.emit(\"session_delete\", { id, topic });\n  };\n\n  private deleteProposal: EnginePrivate[\"deleteProposal\"] = async (id, expirerHasDeleted) => {\n    if (expirerHasDeleted) {\n      try {\n        const proposal = this.client.proposal.get(id);\n        const event = this.client.core.eventClient.getEvent({ topic: proposal.pairingTopic });\n        event?.setError(EVENT_CLIENT_SESSION_ERRORS.proposal_expired);\n      } catch (error) {}\n    }\n    await Promise.all([\n      this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\")),\n      expirerHasDeleted ? Promise.resolve() : this.client.core.expirer.del(id),\n    ]);\n    this.addToRecentlyDeleted(id, \"proposal\");\n  };\n\n  private deletePendingSessionRequest: EnginePrivate[\"deletePendingSessionRequest\"] = async (\n    id,\n    reason,\n    expirerHasDeleted = false,\n  ) => {\n    await Promise.all([\n      this.client.pendingRequest.delete(id, reason),\n      expirerHasDeleted ? Promise.resolve() : this.client.core.expirer.del(id),\n    ]);\n    this.addToRecentlyDeleted(id, \"request\");\n    this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((r) => r.id !== id);\n    if (expirerHasDeleted) {\n      this.sessionRequestQueue.state = ENGINE_QUEUE_STATES.idle;\n      this.client.events.emit(\"session_request_expire\", { id });\n    }\n  };\n\n  private deletePendingAuthRequest: EnginePrivate[\"deletePendingAuthRequest\"] = async (\n    id,\n    reason,\n    expirerHasDeleted = false,\n  ) => {\n    await Promise.all([\n      this.client.auth.requests.delete(id, reason),\n      expirerHasDeleted ? Promise.resolve() : this.client.core.expirer.del(id),\n    ]);\n  };\n\n  private setExpiry: EnginePrivate[\"setExpiry\"] = async (topic, expiry) => {\n    if (!this.client.session.keys.includes(topic)) return;\n    this.client.core.expirer.set(topic, expiry);\n    await this.client.session.update(topic, { expiry });\n  };\n\n  private setProposal: EnginePrivate[\"setProposal\"] = async (id, proposal) => {\n    this.client.core.expirer.set(id, calcExpiry(ENGINE_RPC_OPTS.wc_sessionPropose.req.ttl));\n    await this.client.proposal.set(id, proposal);\n  };\n\n  private setAuthRequest: EnginePrivate[\"setAuthRequest\"] = async (id, params) => {\n    const { request, pairingTopic, transportType = TRANSPORT_TYPES.relay } = params;\n    this.client.core.expirer.set(id, request.expiryTimestamp);\n    await this.client.auth.requests.set(id, {\n      authPayload: request.authPayload,\n      requester: request.requester,\n      expiryTimestamp: request.expiryTimestamp,\n      id,\n      pairingTopic,\n      verifyContext: request.verifyContext,\n      transportType,\n    });\n  };\n\n  private setPendingSessionRequest: EnginePrivate[\"setPendingSessionRequest\"] = async (\n    pendingRequest: PendingRequestTypes.Struct,\n  ) => {\n    const { id, topic, params, verifyContext } = pendingRequest;\n    const expiry =\n      params.request.expiryTimestamp || calcExpiry(ENGINE_RPC_OPTS.wc_sessionRequest.req.ttl);\n    this.client.core.expirer.set(id, expiry);\n    await this.client.pendingRequest.set(id, {\n      id,\n      topic,\n      params,\n      verifyContext,\n    });\n  };\n\n  private sendRequest: EnginePrivate[\"sendRequest\"] = async (args) => {\n    const {\n      topic,\n      method,\n      params,\n      expiry,\n      relayRpcId,\n      clientRpcId,\n      throwOnFailedPublish,\n      appLink,\n      tvf,\n    } = args;\n    const payload = formatJsonRpcRequest(method, params, clientRpcId);\n\n    let message: string;\n    const isLinkMode = !!appLink;\n\n    try {\n      const encoding = isLinkMode ? BASE64URL : BASE64;\n      message = await this.client.core.crypto.encode(topic, payload, { encoding });\n    } catch (error) {\n      await this.cleanup();\n      this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${topic} failed`);\n      throw error;\n    }\n\n    let attestation: string | undefined;\n    if (METHODS_TO_VERIFY.includes(method)) {\n      const decryptedId = hashMessage(JSON.stringify(payload));\n      const id = hashMessage(message);\n      attestation = await this.client.core.verify.register({ id, decryptedId });\n    }\n    const opts = ENGINE_RPC_OPTS[method].req;\n    opts.attestation = attestation;\n    if (expiry) opts.ttl = expiry;\n    if (relayRpcId) opts.id = relayRpcId;\n    this.client.core.history.set(topic, payload);\n\n    if (isLinkMode) {\n      const redirectURL = getLinkModeURL(appLink, topic, message);\n      await (global as any).Linking.openURL(redirectURL, this.client.name);\n    } else {\n      const opts = ENGINE_RPC_OPTS[method].req;\n      if (expiry) opts.ttl = expiry;\n      if (relayRpcId) opts.id = relayRpcId;\n\n      opts.tvf = {\n        ...tvf,\n        correlationId: payload.id,\n      };\n\n      if (throwOnFailedPublish) {\n        opts.internal = {\n          ...opts.internal,\n          throwOnFailedPublish: true,\n        };\n        await this.client.core.relayer.publish(topic, message, opts);\n      } else {\n        this.client.core.relayer\n          .publish(topic, message, opts)\n          .catch((error) => this.client.logger.error(error));\n      }\n    }\n\n    return payload.id;\n  };\n\n  private sendResult: EnginePrivate[\"sendResult\"] = async (args) => {\n    const { id, topic, result, throwOnFailedPublish, encodeOpts, appLink } = args;\n    const payload = formatJsonRpcResult(id, result);\n    let message;\n    const isLinkMode = appLink && typeof (global as any)?.Linking !== \"undefined\";\n\n    try {\n      const encoding = isLinkMode ? BASE64URL : BASE64;\n      message = await this.client.core.crypto.encode(topic, payload, {\n        ...(encodeOpts || {}),\n        encoding,\n      });\n    } catch (error) {\n      // if encoding fails e.g. due to missing keychain, we want to cleanup all related data as its unusable\n      await this.cleanup();\n      this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${topic} failed`);\n      throw error;\n    }\n    let record;\n    let tvf;\n    try {\n      record = await this.client.core.history.get(topic, id);\n      const request = record.request;\n      try {\n        if (this.shouldSetTVF(request.method as JsonRpcTypes.WcMethod, request.params)) {\n          tvf = this.getTVFParams(id, request.params, result);\n        }\n      } catch (error) {\n        this.client.logger.warn(`sendResult() -> getTVFParams() failed`, error);\n      }\n    } catch (error) {\n      this.client.logger.error(`sendResult() -> history.get(${topic}, ${id}) failed`);\n      throw error;\n    }\n\n    if (isLinkMode) {\n      const redirectURL = getLinkModeURL(appLink, topic, message);\n      await (global as any).Linking.openURL(redirectURL, this.client.name);\n    } else {\n      const method = record.request.method as JsonRpcTypes.WcMethod;\n      const opts = ENGINE_RPC_OPTS[method].res;\n\n      opts.tvf = {\n        ...tvf,\n        correlationId: id,\n      };\n\n      if (throwOnFailedPublish) {\n        opts.internal = {\n          ...opts.internal,\n          throwOnFailedPublish: true,\n        };\n        await this.client.core.relayer.publish(topic, message, opts);\n      } else {\n        this.client.core.relayer\n          .publish(topic, message, opts)\n          .catch((error) => this.client.logger.error(error));\n      }\n    }\n\n    await this.client.core.history.resolve(payload);\n  };\n\n  private sendError: EnginePrivate[\"sendError\"] = async (params) => {\n    const { id, topic, error, encodeOpts, rpcOpts, appLink } = params;\n    const payload = formatJsonRpcError(id, error);\n    let message;\n    const isLinkMode = appLink && typeof (global as any)?.Linking !== \"undefined\";\n    try {\n      const encoding = isLinkMode ? BASE64URL : BASE64;\n      message = await this.client.core.crypto.encode(topic, payload, {\n        ...(encodeOpts || {}),\n        encoding,\n      });\n    } catch (error) {\n      await this.cleanup();\n      this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${topic} failed`);\n      throw error;\n    }\n    let record;\n    try {\n      record = await this.client.core.history.get(topic, id);\n    } catch (error) {\n      this.client.logger.error(`sendError() -> history.get(${topic}, ${id}) failed`);\n      throw error;\n    }\n\n    if (isLinkMode) {\n      const redirectURL = getLinkModeURL(appLink, topic, message);\n      await (global as any).Linking.openURL(redirectURL, this.client.name);\n    } else {\n      const method = record.request.method as JsonRpcTypes.WcMethod;\n      const opts = rpcOpts || ENGINE_RPC_OPTS[method].res;\n      // await is intentionally omitted to speed up performance\n      this.client.core.relayer.publish(topic, message, opts);\n    }\n\n    await this.client.core.history.resolve(payload);\n  };\n\n  private cleanup: EnginePrivate[\"cleanup\"] = async () => {\n    const sessionTopics: string[] = [];\n    const proposalIds: number[] = [];\n    this.client.session.getAll().forEach((session) => {\n      let toCleanup = false;\n      if (isExpired(session.expiry)) toCleanup = true;\n      if (!this.client.core.crypto.keychain.has(session.topic)) toCleanup = true;\n      if (toCleanup) sessionTopics.push(session.topic);\n    });\n    this.client.proposal.getAll().forEach((proposal) => {\n      if (isExpired(proposal.expiryTimestamp)) proposalIds.push(proposal.id);\n    });\n    await Promise.all([\n      ...sessionTopics.map((topic) => this.deleteSession({ topic })),\n      ...proposalIds.map((id) => this.deleteProposal(id)),\n    ]);\n  };\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n\n  private async confirmOnlineStateOrThrow() {\n    await this.client.core.relayer.confirmOnlineStateOrThrow();\n  }\n\n  // ---------- Relay Events Router ----------------------------------- //\n\n  private registerRelayerEvents() {\n    this.client.core.relayer.on(RELAYER_EVENTS.message, (event: RelayerTypes.MessageEvent) => {\n      this.onProviderMessageEvent(event);\n    });\n  }\n\n  private onProviderMessageEvent = async (event: RelayerTypes.MessageEvent) => {\n    // capture any messages that arrive before the client is initialized so we can process them after initialization is complete\n    if (!this.initialized || this.relayMessageCache.length > 0) {\n      this.relayMessageCache.push(event);\n    } else {\n      await this.onRelayMessage(event);\n    }\n  };\n\n  private async onRelayMessage(event: RelayerTypes.MessageEvent) {\n    const { topic, message, attestation, transportType } = event;\n\n    // Retrieve the public key (if defined) to decrypt possible `auth_request` response\n    const { publicKey } = this.client.auth.authKeys.keys.includes(AUTH_PUBLIC_KEY_NAME)\n      ? this.client.auth.authKeys.get(AUTH_PUBLIC_KEY_NAME)\n      : ({ responseTopic: undefined, publicKey: undefined } as any);\n\n    try {\n      const payload = await this.client.core.crypto.decode(topic, message, {\n        receiverPublicKey: publicKey,\n        encoding: transportType === TRANSPORT_TYPES.link_mode ? BASE64URL : BASE64,\n      });\n\n      if (isJsonRpcRequest(payload)) {\n        this.client.core.history.set(topic, payload);\n        await this.onRelayEventRequest({\n          topic,\n          payload,\n          attestation,\n          transportType,\n          encryptedId: hashMessage(message),\n        });\n      } else if (isJsonRpcResponse(payload)) {\n        await this.client.core.history.resolve(payload);\n        await this.onRelayEventResponse({ topic, payload, transportType });\n        this.client.core.history.delete(topic, payload.id);\n      } else {\n        await this.onRelayEventUnknownPayload({ topic, payload, transportType });\n      }\n      await this.client.core.relayer.messages.ack(topic, message);\n    } catch (error) {\n      this.client.logger.error(error);\n    }\n  }\n\n  private onRelayEventRequest: EnginePrivate[\"onRelayEventRequest\"] = async (event) => {\n    this.requestQueue.queue.push(event);\n    await this.processRequestsQueue();\n  };\n\n  private processRequestsQueue = async () => {\n    if (this.requestQueue.state === ENGINE_QUEUE_STATES.active) {\n      this.client.logger.info(`Request queue already active, skipping...`);\n      return;\n    }\n\n    this.client.logger.info(\n      `Request queue starting with ${this.requestQueue.queue.length} requests`,\n    );\n\n    while (this.requestQueue.queue.length > 0) {\n      this.requestQueue.state = ENGINE_QUEUE_STATES.active;\n      const request = this.requestQueue.queue.shift();\n      if (!request) continue;\n\n      try {\n        await this.processRequest(request);\n      } catch (error) {\n        this.client.logger.warn(error);\n      }\n    }\n    this.requestQueue.state = ENGINE_QUEUE_STATES.idle;\n  };\n\n  private processRequest: EnginePrivate[\"onRelayEventRequest\"] = async (event) => {\n    const { topic, payload, attestation, transportType, encryptedId } = event;\n\n    const reqMethod = payload.method as JsonRpcTypes.WcMethod;\n\n    if (this.shouldIgnorePairingRequest({ topic, requestMethod: reqMethod })) {\n      return;\n    }\n\n    switch (reqMethod) {\n      case \"wc_sessionPropose\":\n        return await this.onSessionProposeRequest({ topic, payload, attestation, encryptedId });\n      case \"wc_sessionSettle\":\n        return await this.onSessionSettleRequest(topic, payload);\n      case \"wc_sessionUpdate\":\n        return await this.onSessionUpdateRequest(topic, payload);\n      case \"wc_sessionExtend\":\n        return await this.onSessionExtendRequest(topic, payload);\n      case \"wc_sessionPing\":\n        return await this.onSessionPingRequest(topic, payload);\n      case \"wc_sessionDelete\":\n        return await this.onSessionDeleteRequest(topic, payload);\n      case \"wc_sessionRequest\":\n        return await this.onSessionRequest({\n          topic,\n          payload,\n          attestation,\n          encryptedId,\n          transportType,\n        });\n      case \"wc_sessionEvent\":\n        return await this.onSessionEventRequest(topic, payload);\n      case \"wc_sessionAuthenticate\":\n        return await this.onSessionAuthenticateRequest({\n          topic,\n          payload,\n          attestation,\n          encryptedId,\n          transportType,\n        });\n      default:\n        return this.client.logger.info(`Unsupported request method ${reqMethod}`);\n    }\n  };\n\n  private onRelayEventResponse: EnginePrivate[\"onRelayEventResponse\"] = async (event) => {\n    const { topic, payload, transportType } = event;\n    const record = await this.client.core.history.get(topic, payload.id);\n    const resMethod = record.request.method as JsonRpcTypes.WcMethod;\n\n    switch (resMethod) {\n      case \"wc_sessionPropose\":\n        return this.onSessionProposeResponse(topic, payload, transportType);\n      case \"wc_sessionSettle\":\n        return this.onSessionSettleResponse(topic, payload);\n      case \"wc_sessionUpdate\":\n        return this.onSessionUpdateResponse(topic, payload);\n      case \"wc_sessionExtend\":\n        return this.onSessionExtendResponse(topic, payload);\n      case \"wc_sessionPing\":\n        return this.onSessionPingResponse(topic, payload);\n      case \"wc_sessionRequest\":\n        return this.onSessionRequestResponse(topic, payload);\n      case \"wc_sessionAuthenticate\":\n        return this.onSessionAuthenticateResponse(topic, payload);\n      default:\n        return this.client.logger.info(`Unsupported response method ${resMethod}`);\n    }\n  };\n\n  private onRelayEventUnknownPayload: EnginePrivate[\"onRelayEventUnknownPayload\"] = (event) => {\n    const { topic } = event;\n    const { message } = getInternalError(\n      \"MISSING_OR_INVALID\",\n      `Decoded payload on topic ${topic} is not identifiable as a JSON-RPC request or a response.`,\n    );\n    throw new Error(message);\n  };\n\n  private shouldIgnorePairingRequest: EnginePrivate[\"shouldIgnorePairingRequest\"] = (params) => {\n    const { topic, requestMethod } = params;\n    const expectedMethods = this.expectedPairingMethodMap.get(topic);\n    // check if the request method matches the expected method\n    if (!expectedMethods) return false;\n    if (expectedMethods.includes(requestMethod)) return false;\n\n    /**\n     * we want to make sure fallback session proposal is ignored only if there are subscribers\n     * for the `session_authenticate` event, otherwise this would result in no-op for the user\n     */\n    if (expectedMethods.includes(\"wc_sessionAuthenticate\")) {\n      if (this.client.events.listenerCount(\"session_authenticate\") > 0) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  // ---------- Relay Events Handlers --------------------------------- //\n\n  private onSessionProposeRequest: EnginePrivate[\"onSessionProposeRequest\"] = async (args) => {\n    const { topic, payload, attestation, encryptedId } = args;\n    const { params, id } = payload;\n    try {\n      const event = this.client.core.eventClient.getEvent({ topic });\n\n      if (this.client.events.listenerCount(\"session_proposal\") === 0) {\n        console.warn(\"No listener for session_proposal event\");\n        event?.setError(EVENT_CLIENT_PAIRING_ERRORS.proposal_listener_not_found);\n      }\n\n      this.isValidConnect({ ...payload.params });\n      const expiryTimestamp =\n        params.expiryTimestamp || calcExpiry(ENGINE_RPC_OPTS.wc_sessionPropose.req.ttl);\n      const proposal = { id, pairingTopic: topic, expiryTimestamp, ...params };\n      await this.setProposal(id, proposal);\n\n      const verifyContext = await this.getVerifyContext({\n        attestationId: attestation,\n        hash: hashMessage(JSON.stringify(payload)),\n        encryptedId,\n        metadata: proposal.proposer.metadata,\n      });\n\n      event?.addTrace(EVENT_CLIENT_PAIRING_TRACES.emit_session_proposal);\n\n      this.client.events.emit(\"session_proposal\", { id, params: proposal, verifyContext });\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n        rpcOpts: ENGINE_RPC_OPTS.wc_sessionPropose.autoReject,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionProposeResponse: EnginePrivate[\"onSessionProposeResponse\"] = async (\n    topic,\n    payload,\n    transportType,\n  ) => {\n    const { id } = payload;\n    if (isJsonRpcResult(payload)) {\n      const { result } = payload;\n      this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", result });\n      const proposal = this.client.proposal.get(id);\n      this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", proposal });\n      const selfPublicKey = proposal.proposer.publicKey;\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        selfPublicKey,\n      });\n      const peerPublicKey = result.responderPublicKey;\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        peerPublicKey,\n      });\n      const sessionTopic = await this.client.core.crypto.generateSharedKey(\n        selfPublicKey,\n        peerPublicKey,\n      );\n      this.pendingSessions.set(id, {\n        sessionTopic,\n        pairingTopic: topic,\n        proposalId: id,\n        publicKey: selfPublicKey,\n      });\n\n      const subscriptionId = await this.client.core.relayer.subscribe(sessionTopic, {\n        transportType,\n      });\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        subscriptionId,\n      });\n      await this.client.core.pairing.activate({ topic });\n    } else if (isJsonRpcError(payload)) {\n      await this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\"));\n      const target = engineEvent(\"session_connect\", id);\n      const listeners = this.events.listenerCount(target);\n      if (listeners === 0) {\n        throw new Error(`emitting ${target} without any listeners, 954`);\n      }\n      this.events.emit(target, { error: payload.error });\n    }\n  };\n\n  private onSessionSettleRequest: EnginePrivate[\"onSessionSettleRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id, params } = payload;\n    try {\n      this.isValidSessionSettleRequest(params);\n      const {\n        relay,\n        controller,\n        expiry,\n        namespaces,\n        sessionProperties,\n        scopedProperties,\n        sessionConfig,\n      } = payload.params;\n      const pendingSession = [...this.pendingSessions.values()].find(\n        (s) => s.sessionTopic === topic,\n      );\n\n      if (!pendingSession) {\n        return this.client.logger.error(`Pending session not found for topic ${topic}`);\n      }\n\n      const proposal = this.client.proposal.get(pendingSession.proposalId);\n\n      const session: SessionTypes.Struct = {\n        topic,\n        relay,\n        expiry,\n        namespaces,\n        acknowledged: true,\n        pairingTopic: pendingSession.pairingTopic,\n        requiredNamespaces: proposal.requiredNamespaces,\n        optionalNamespaces: proposal.optionalNamespaces,\n        controller: controller.publicKey,\n        self: {\n          publicKey: pendingSession.publicKey,\n          metadata: this.client.metadata,\n        },\n        peer: {\n          publicKey: controller.publicKey,\n          metadata: controller.metadata,\n        },\n        ...(sessionProperties && { sessionProperties }),\n        ...(scopedProperties && { scopedProperties }),\n        ...(sessionConfig && { sessionConfig }),\n        transportType: TRANSPORT_TYPES.relay,\n      };\n\n      await this.client.session.set(session.topic, session);\n      await this.setExpiry(session.topic, session.expiry);\n\n      await this.client.core.pairing.updateMetadata({\n        topic: pendingSession.pairingTopic,\n        metadata: session.peer.metadata,\n      });\n\n      this.client.events.emit(\"session_connect\", { session });\n      this.events.emit(engineEvent(\"session_connect\", pendingSession.proposalId), { session });\n\n      this.pendingSessions.delete(pendingSession.proposalId);\n      this.deleteProposal(pendingSession.proposalId, false);\n      this.cleanupDuplicatePairings(session);\n\n      await this.sendResult<\"wc_sessionSettle\">({\n        id: payload.id,\n        topic,\n        result: true,\n        throwOnFailedPublish: true,\n      });\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionSettleResponse: EnginePrivate[\"onSessionSettleResponse\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    if (isJsonRpcResult(payload)) {\n      await this.client.session.update(topic, { acknowledged: true });\n      this.events.emit(engineEvent(\"session_approve\", id), {});\n    } else if (isJsonRpcError(payload)) {\n      await this.client.session.delete(topic, getSdkError(\"USER_DISCONNECTED\"));\n      this.events.emit(engineEvent(\"session_approve\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionUpdateRequest: EnginePrivate[\"onSessionUpdateRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { params, id } = payload;\n    try {\n      const memoryKey = `${topic}_session_update`;\n      // compare the current request id with the last processed session update\n      // we want to update only if the request is newer than the last processed one\n      const lastSessionUpdateId = MemoryStore.get<number>(memoryKey);\n\n      if (lastSessionUpdateId && this.isRequestOutOfSync(lastSessionUpdateId, id)) {\n        this.client.logger.warn(`Discarding out of sync request - ${id}`);\n        this.sendError({ id, topic, error: getSdkError(\"INVALID_UPDATE_REQUEST\") });\n        return;\n      }\n      this.isValidUpdate({ topic, ...params });\n      try {\n        MemoryStore.set(memoryKey, id);\n        await this.client.session.update(topic, { namespaces: params.namespaces });\n        await this.sendResult<\"wc_sessionUpdate\">({\n          id,\n          topic,\n          result: true,\n          throwOnFailedPublish: true,\n        });\n      } catch (e) {\n        MemoryStore.delete(memoryKey);\n        throw e;\n      }\n\n      this.client.events.emit(\"session_update\", { id, topic, params });\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  // compares the timestamp of the last processed request with the current request\n  // client <-> client rpc ID is timestamp + 3 random digits\n  private isRequestOutOfSync = (lastId: number, currentId: number) => {\n    return currentId.toString().slice(0, -3) < lastId.toString().slice(0, -3);\n  };\n\n  private onSessionUpdateResponse: EnginePrivate[\"onSessionUpdateResponse\"] = (_topic, payload) => {\n    const { id } = payload;\n    const target = engineEvent(\"session_update\", id);\n    const listeners = this.events.listenerCount(target);\n    if (listeners === 0) {\n      throw new Error(`emitting ${target} without any listeners`);\n    }\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_update\", id), {});\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_update\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionExtendRequest: EnginePrivate[\"onSessionExtendRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    try {\n      this.isValidExtend({ topic });\n      await this.setExpiry(topic, calcExpiry(SESSION_EXPIRY));\n      await this.sendResult<\"wc_sessionExtend\">({\n        id,\n        topic,\n        result: true,\n        throwOnFailedPublish: true,\n      });\n      this.client.events.emit(\"session_extend\", { id, topic });\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionExtendResponse: EnginePrivate[\"onSessionExtendResponse\"] = (_topic, payload) => {\n    const { id } = payload;\n    const target = engineEvent(\"session_extend\", id);\n    const listeners = this.events.listenerCount(target);\n    if (listeners === 0) {\n      throw new Error(`emitting ${target} without any listeners`);\n    }\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_extend\", id), {});\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_extend\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionPingRequest: EnginePrivate[\"onSessionPingRequest\"] = async (topic, payload) => {\n    const { id } = payload;\n    try {\n      this.isValidPing({ topic });\n      await this.sendResult<\"wc_sessionPing\">({\n        id,\n        topic,\n        result: true,\n        throwOnFailedPublish: true,\n      });\n      this.client.events.emit(\"session_ping\", { id, topic });\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionPingResponse: EnginePrivate[\"onSessionPingResponse\"] = (_topic, payload) => {\n    const { id } = payload;\n    const target = engineEvent(\"session_ping\", id);\n\n    // put at the end of the stack to avoid a race condition\n    // where session_ping listener is not yet initialized\n    setTimeout(() => {\n      const listeners = this.events.listenerCount(target);\n      if (listeners === 0) {\n        throw new Error(`emitting ${target} without any listeners 2176`);\n      }\n\n      if (isJsonRpcResult(payload)) {\n        this.events.emit(engineEvent(\"session_ping\", id), {});\n      } else if (isJsonRpcError(payload)) {\n        this.events.emit(engineEvent(\"session_ping\", id), { error: payload.error });\n      }\n    }, 500);\n  };\n\n  private onSessionDeleteRequest: EnginePrivate[\"onSessionDeleteRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    try {\n      this.isValidDisconnect({ topic, reason: payload.params });\n      Promise.all([\n        new Promise((resolve) => {\n          // RPC request needs to happen before deletion as it utalises session encryption\n          this.client.core.relayer.once(RELAYER_EVENTS.publish, async () => {\n            resolve(await this.deleteSession({ topic, id }));\n          });\n        }),\n        this.sendResult<\"wc_sessionDelete\">({\n          id,\n          topic,\n          result: true,\n          throwOnFailedPublish: true,\n        }),\n        this.cleanupPendingSentRequestsForTopic({ topic, error: getSdkError(\"USER_DISCONNECTED\") }),\n      ]).catch((err) => this.client.logger.error(err));\n    } catch (err: any) {\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionRequest: EnginePrivate[\"onSessionRequest\"] = async (args) => {\n    const { topic, payload, attestation, encryptedId, transportType } = args;\n    const { id, params } = payload;\n    try {\n      await this.isValidRequest({ topic, ...params });\n      const session = this.client.session.get(topic);\n      const verifyContext = await this.getVerifyContext({\n        attestationId: attestation,\n        hash: hashMessage(JSON.stringify(formatJsonRpcRequest(\"wc_sessionRequest\", params, id))),\n        encryptedId,\n        metadata: session.peer.metadata,\n        transportType,\n      });\n      const request = {\n        id,\n        topic,\n        params,\n        verifyContext,\n      };\n      await this.setPendingSessionRequest(request);\n\n      if (\n        transportType === TRANSPORT_TYPES.link_mode &&\n        session.peer.metadata.redirect?.universal\n      ) {\n        // save app as supported for link mode\n        this.client.core.addLinkModeSupportedApp(session.peer.metadata.redirect?.universal);\n      }\n\n      if (this.client.signConfig?.disableRequestQueue) {\n        this.emitSessionRequest(request);\n      } else {\n        this.addSessionRequestToSessionRequestQueue(request);\n        this.processSessionRequestQueue();\n      }\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionRequestResponse: EnginePrivate[\"onSessionRequestResponse\"] = (\n    _topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    const target = engineEvent(\"session_request\", id);\n    const listeners = this.events.listenerCount(target);\n    if (listeners === 0) {\n      throw new Error(`emitting ${target} without any listeners`);\n    }\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_request\", id), { result: payload.result });\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_request\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionEventRequest: EnginePrivate[\"onSessionEventRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id, params } = payload;\n    try {\n      // similar to session update, we want to discard out of sync requests\n      // additionally we have to check the event type as well e.g. chainChanged/accountsChanged\n      const memoryKey = `${topic}_session_event_${params.event.name}`;\n      // compare the current request id with the last processed session update\n      // we want to update only if the request is newer than the last processed one\n      const lastSessionUpdateId = MemoryStore.get<number>(memoryKey);\n      if (lastSessionUpdateId && this.isRequestOutOfSync(lastSessionUpdateId, id)) {\n        this.client.logger.info(`Discarding out of sync request - ${id}`);\n        return;\n      }\n\n      this.isValidEmit({ topic, ...params });\n      this.client.events.emit(\"session_event\", { id, topic, params });\n      MemoryStore.set(memoryKey, id);\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionAuthenticateResponse: EnginePrivate[\"onSessionAuthenticateResponse\"] = (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    this.client.logger.trace({\n      type: \"method\",\n      method: \"onSessionAuthenticateResponse\",\n      topic,\n      payload,\n    });\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_request\", id), { result: payload.result });\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_request\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionAuthenticateRequest: EnginePrivate[\"onSessionAuthenticateRequest\"] = async (\n    args,\n  ) => {\n    const { topic, payload, attestation, encryptedId, transportType } = args;\n    try {\n      const { requester, authPayload, expiryTimestamp } = payload.params;\n      const verifyContext = await this.getVerifyContext({\n        attestationId: attestation,\n        hash: hashMessage(JSON.stringify(payload)),\n        encryptedId,\n        metadata: requester.metadata,\n        transportType,\n      });\n      const pendingRequest = {\n        requester,\n        pairingTopic: topic,\n        id: payload.id,\n        authPayload,\n        verifyContext,\n        expiryTimestamp,\n      };\n      await this.setAuthRequest(payload.id, {\n        request: pendingRequest,\n        pairingTopic: topic,\n        transportType,\n      });\n\n      if (transportType === TRANSPORT_TYPES.link_mode && requester.metadata.redirect?.universal) {\n        // save app as supported for link mode\n        this.client.core.addLinkModeSupportedApp(requester.metadata.redirect.universal);\n      }\n\n      this.client.events.emit(\"session_authenticate\", {\n        topic,\n        params: payload.params,\n        id: payload.id,\n        verifyContext,\n      });\n    } catch (err: any) {\n      this.client.logger.error(err);\n\n      const receiverPublicKey = payload.params.requester.publicKey;\n      const senderPublicKey = await this.client.core.crypto.generateKeyPair();\n      const appLink = this.getAppLinkIfEnabled(payload.params.requester.metadata, transportType);\n\n      const encodeOpts = {\n        type: TYPE_1,\n        receiverPublicKey,\n        senderPublicKey,\n      };\n      await this.sendError({\n        id: payload.id,\n        topic,\n        error: err,\n        encodeOpts,\n        rpcOpts: ENGINE_RPC_OPTS.wc_sessionAuthenticate.autoReject,\n        appLink,\n      });\n    }\n  };\n\n  private addSessionRequestToSessionRequestQueue = (request: PendingRequestTypes.Struct) => {\n    this.sessionRequestQueue.queue.push(request);\n  };\n\n  private cleanupAfterResponse = (params: EngineTypes.RespondParams) => {\n    this.deletePendingSessionRequest(params.response.id, { message: \"fulfilled\", code: 0 });\n    // intentionally delay the emitting of the next pending request a bit\n    setTimeout(() => {\n      this.sessionRequestQueue.state = ENGINE_QUEUE_STATES.idle;\n      this.processSessionRequestQueue();\n    }, toMiliseconds(this.requestQueueDelay));\n  };\n\n  // Allows for cleanup on any sent pending requests if the peer disconnects the session before responding\n  private cleanupPendingSentRequestsForTopic = ({\n    topic,\n    error,\n  }: {\n    topic: string;\n    error: ErrorResponse;\n  }) => {\n    const pendingRequests = this.client.core.history.pending;\n    if (pendingRequests.length > 0) {\n      const forSession = pendingRequests.filter(\n        (r) => r.topic === topic && r.request.method === \"wc_sessionRequest\",\n      );\n      forSession.forEach((r) => {\n        const id = r.request.id;\n        const target = engineEvent(\"session_request\", id);\n        const listeners = this.events.listenerCount(target);\n        if (listeners === 0) {\n          throw new Error(`emitting ${target} without any listeners`);\n        }\n        // notify .request() handler of the rejection\n        this.events.emit(engineEvent(\"session_request\", r.request.id), {\n          error,\n        });\n      });\n    }\n  };\n\n  private processSessionRequestQueue = () => {\n    if (this.sessionRequestQueue.state === ENGINE_QUEUE_STATES.active) {\n      this.client.logger.info(\"session request queue is already active.\");\n      return;\n    }\n    // Select the first/oldest request in the array to ensure last-in-first-out (LIFO)\n    const request = this.sessionRequestQueue.queue[0];\n    if (!request) {\n      this.client.logger.info(\"session request queue is empty.\");\n      return;\n    }\n\n    try {\n      this.sessionRequestQueue.state = ENGINE_QUEUE_STATES.active;\n      this.emitSessionRequest(request);\n    } catch (error) {\n      this.client.logger.error(error);\n    }\n  };\n\n  private emitSessionRequest = (request: PendingRequestTypes.Struct) => {\n    this.client.events.emit(\"session_request\", request);\n  };\n\n  // ---------- Expirer Events ---------------------------------------- //\n\n  private registerExpirerEvents() {\n    this.client.core.expirer.on(EXPIRER_EVENTS.expired, async (event: ExpirerTypes.Expiration) => {\n      const { topic, id } = parseExpirerTarget(event.target);\n      if (id && this.client.pendingRequest.keys.includes(id)) {\n        return await this.deletePendingSessionRequest(id, getInternalError(\"EXPIRED\"), true);\n      }\n      if (id && this.client.auth.requests.keys.includes(id)) {\n        return await this.deletePendingAuthRequest(id, getInternalError(\"EXPIRED\"), true);\n      }\n\n      if (topic) {\n        if (this.client.session.keys.includes(topic)) {\n          await this.deleteSession({ topic, expirerHasDeleted: true });\n          this.client.events.emit(\"session_expire\", { topic });\n        }\n      } else if (id) {\n        await this.deleteProposal(id, true);\n        this.client.events.emit(\"proposal_expire\", { id });\n      }\n    });\n  }\n\n  // ---------- Pairing Events ---------------------------------------- //\n  private registerPairingEvents() {\n    this.client.core.pairing.events.on(PAIRING_EVENTS.create, (pairing: PairingTypes.Struct) =>\n      this.onPairingCreated(pairing),\n    );\n    this.client.core.pairing.events.on(PAIRING_EVENTS.delete, (pairing: PairingTypes.Struct) => {\n      this.addToRecentlyDeleted(pairing.topic, \"pairing\");\n    });\n  }\n\n  /**\n   * when a pairing is created, we check if there is a pending proposal for it.\n   * if there is, we send it to onSessionProposeRequest to be processed as if it was received from the relay.\n   * It allows QR/URI to be scanned multiple times without having to create new pairing.\n   */\n  private onPairingCreated = (pairing: PairingTypes.Struct) => {\n    if (pairing.methods) {\n      this.expectedPairingMethodMap.set(pairing.topic, pairing.methods);\n    }\n    if (pairing.active) return;\n    const proposals = this.client.proposal.getAll();\n    const proposal = proposals.find((p) => p.pairingTopic === pairing.topic);\n    if (!proposal) return;\n    this.onSessionProposeRequest({\n      topic: pairing.topic,\n      payload: formatJsonRpcRequest(\n        \"wc_sessionPropose\",\n        {\n          ...proposal,\n          requiredNamespaces: proposal.requiredNamespaces,\n          optionalNamespaces: proposal.optionalNamespaces,\n          relays: proposal.relays,\n          proposer: proposal.proposer,\n          sessionProperties: proposal.sessionProperties,\n          scopedProperties: proposal.scopedProperties,\n        },\n        proposal.id,\n      ),\n    });\n  };\n\n  // ---------- Validation Helpers ------------------------------------ //\n  private isValidPairingTopic(topic: any) {\n    if (!isValidString(topic, false)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `pairing topic should be a string: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (!this.client.core.pairing.pairings.keys.includes(topic)) {\n      const { message } = getInternalError(\n        \"NO_MATCHING_KEY\",\n        `pairing topic doesn't exist: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (isExpired(this.client.core.pairing.pairings.get(topic).expiry)) {\n      const { message } = getInternalError(\"EXPIRED\", `pairing topic: ${topic}`);\n      throw new Error(message);\n    }\n  }\n\n  private async isValidSessionTopic(topic: any) {\n    if (!isValidString(topic, false)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `session topic should be a string: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    // Store will throw custom message if topic was recently deleted\n    this.checkRecentlyDeleted(topic);\n    if (!this.client.session.keys.includes(topic)) {\n      const { message } = getInternalError(\n        \"NO_MATCHING_KEY\",\n        `session topic doesn't exist: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (isExpired(this.client.session.get(topic).expiry)) {\n      await this.deleteSession({ topic });\n      const { message } = getInternalError(\"EXPIRED\", `session topic: ${topic}`);\n      throw new Error(message);\n    }\n\n    if (!this.client.core.crypto.keychain.has(topic)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `session topic does not exist in keychain: ${topic}`,\n      );\n      await this.deleteSession({ topic });\n      throw new Error(message);\n    }\n  }\n\n  private async isValidSessionOrPairingTopic(topic: string) {\n    this.checkRecentlyDeleted(topic);\n    if (this.client.session.keys.includes(topic)) {\n      await this.isValidSessionTopic(topic);\n    } else if (this.client.core.pairing.pairings.keys.includes(topic)) {\n      this.isValidPairingTopic(topic);\n    } else if (!isValidString(topic, false)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `session or pairing topic should be a string: ${topic}`,\n      );\n      throw new Error(message);\n    } else {\n      const { message } = getInternalError(\n        \"NO_MATCHING_KEY\",\n        `session or pairing topic doesn't exist: ${topic}`,\n      );\n      throw new Error(message);\n    }\n  }\n\n  private async isValidProposalId(id: any) {\n    if (!isValidId(id)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `proposal id should be a number: ${id}`,\n      );\n      throw new Error(message);\n    }\n    if (!this.client.proposal.keys.includes(id)) {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `proposal id doesn't exist: ${id}`);\n      throw new Error(message);\n    }\n    if (isExpired(this.client.proposal.get(id).expiryTimestamp)) {\n      await this.deleteProposal(id);\n      const { message } = getInternalError(\"EXPIRED\", `proposal id: ${id}`);\n      throw new Error(message);\n    }\n  }\n\n  // ---------- Validation  ------------------------------------------- //\n\n  private isValidConnect: EnginePrivate[\"isValidConnect\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `connect() params: ${JSON.stringify(params)}`,\n      );\n      throw new Error(message);\n    }\n    const {\n      pairingTopic,\n      requiredNamespaces,\n      optionalNamespaces,\n      sessionProperties,\n      scopedProperties,\n      relays,\n    } = params;\n    if (!isUndefined(pairingTopic)) await this.isValidPairingTopic(pairingTopic);\n\n    if (!isValidRelays(relays, true)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `connect() relays: ${relays}`);\n      throw new Error(message);\n    }\n\n    // validate required namespaces only if they are defined\n    if (!isUndefined(requiredNamespaces) && isValidObject(requiredNamespaces) !== 0) {\n      this.validateNamespaces(requiredNamespaces, \"requiredNamespaces\");\n    }\n\n    // validate optional namespaces only if they are defined\n    if (!isUndefined(optionalNamespaces) && isValidObject(optionalNamespaces) !== 0) {\n      this.validateNamespaces(optionalNamespaces, \"optionalNamespaces\");\n    }\n\n    // validate session properties only if they are defined\n    if (!isUndefined(sessionProperties)) {\n      this.validateSessionProps(sessionProperties, \"sessionProperties\");\n    }\n\n    if (!isUndefined(scopedProperties)) {\n      this.validateSessionProps(scopedProperties, \"scopedProperties\");\n\n      const requestedNamespaces = Object.keys(requiredNamespaces || {}).concat(\n        Object.keys(optionalNamespaces || {}),\n      );\n\n      const scopedNamespaces = Object.keys(scopedProperties);\n      const valid = scopedNamespaces.every((ns) => requestedNamespaces.includes(ns));\n      if (!valid) {\n        throw new Error(\n          `Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(\n            scopedProperties,\n          )}, required/optional namespaces: ${JSON.stringify(requestedNamespaces)}`,\n        );\n      }\n    }\n  };\n\n  private validateNamespaces = (\n    namespaces: ProposalTypes.RequiredNamespaces | ProposalTypes.OptionalNamespaces,\n    type: string,\n  ) => {\n    const validRequiredNamespacesError = isValidRequiredNamespaces(namespaces, \"connect()\", type);\n    if (validRequiredNamespacesError) throw new Error(validRequiredNamespacesError.message);\n  };\n\n  private isValidApprove: EnginePrivate[\"isValidApprove\"] = async (params) => {\n    if (!isValidParams(params))\n      throw new Error(\n        getInternalError(\"MISSING_OR_INVALID\", `approve() params: ${params}`).message,\n      );\n    const { id, namespaces, relayProtocol, sessionProperties, scopedProperties } = params;\n\n    this.checkRecentlyDeleted(id);\n    await this.isValidProposalId(id);\n    const proposal = this.client.proposal.get(id);\n    const validNamespacesError = isValidNamespaces(namespaces, \"approve()\");\n    if (validNamespacesError) throw new Error(validNamespacesError.message);\n    const conformingNamespacesError = isConformingNamespaces(\n      proposal.requiredNamespaces,\n      namespaces,\n      \"approve()\",\n    );\n    if (conformingNamespacesError) throw new Error(conformingNamespacesError.message);\n    if (!isValidString(relayProtocol, true)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `approve() relayProtocol: ${relayProtocol}`,\n      );\n      throw new Error(message);\n    }\n\n    if (!isUndefined(sessionProperties)) {\n      this.validateSessionProps(sessionProperties, \"sessionProperties\");\n    }\n\n    if (!isUndefined(scopedProperties)) {\n      this.validateSessionProps(scopedProperties, \"scopedProperties\");\n\n      const approvedNamespaces = new Set(Object.keys(namespaces));\n      const scopedNamespaces = Object.keys(scopedProperties);\n\n      // the approved scoped namespaces must be a subset of the approved namespaces\n      const valid = scopedNamespaces.every((ns) => approvedNamespaces.has(ns));\n      if (!valid) {\n        throw new Error(\n          `Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(\n            scopedProperties,\n          )}, approved namespaces: ${Array.from(approvedNamespaces).join(\", \")}`,\n        );\n      }\n    }\n  };\n\n  private isValidReject: EnginePrivate[\"isValidReject\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `reject() params: ${params}`);\n      throw new Error(message);\n    }\n    const { id, reason } = params;\n    this.checkRecentlyDeleted(id);\n    await this.isValidProposalId(id);\n    if (!isValidErrorReason(reason)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `reject() reason: ${JSON.stringify(reason)}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidSessionSettleRequest: EnginePrivate[\"isValidSessionSettleRequest\"] = (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `onSessionSettleRequest() params: ${params}`,\n      );\n      throw new Error(message);\n    }\n    const { relay, controller, namespaces, expiry } = params;\n    if (!isValidRelay(relay)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `onSessionSettleRequest() relay protocol should be a string`,\n      );\n      throw new Error(message);\n    }\n    const validControllerError = isValidController(controller, \"onSessionSettleRequest()\");\n    if (validControllerError) throw new Error(validControllerError.message);\n    const validNamespacesError = isValidNamespaces(namespaces, \"onSessionSettleRequest()\");\n    if (validNamespacesError) throw new Error(validNamespacesError.message);\n    if (isExpired(expiry)) {\n      const { message } = getInternalError(\"EXPIRED\", `onSessionSettleRequest()`);\n      throw new Error(message);\n    }\n  };\n\n  private isValidUpdate: EnginePrivate[\"isValidUpdate\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `update() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, namespaces } = params;\n\n    this.checkRecentlyDeleted(topic);\n    await this.isValidSessionTopic(topic);\n    const session = this.client.session.get(topic);\n    const validNamespacesError = isValidNamespaces(namespaces, \"update()\");\n    if (validNamespacesError) throw new Error(validNamespacesError.message);\n    const conformingNamespacesError = isConformingNamespaces(\n      session.requiredNamespaces,\n      namespaces,\n      \"update()\",\n    );\n    if (conformingNamespacesError) throw new Error(conformingNamespacesError.message);\n    // TODO(ilja) - check if wallet\n  };\n\n  private isValidExtend: EnginePrivate[\"isValidExtend\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `extend() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n\n    this.checkRecentlyDeleted(topic);\n    await this.isValidSessionTopic(topic);\n  };\n\n  private isValidRequest: EnginePrivate[\"isValidRequest\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `request() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, request, chainId, expiry } = params;\n    this.checkRecentlyDeleted(topic);\n    await this.isValidSessionTopic(topic);\n    const { namespaces } = this.client.session.get(topic);\n    if (!isValidNamespacesChainId(namespaces, chainId)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `request() chainId: ${chainId}`);\n      throw new Error(message);\n    }\n    if (!isValidRequest(request)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `request() ${JSON.stringify(request)}`,\n      );\n      throw new Error(message);\n    }\n    if (!isValidNamespacesRequest(namespaces, chainId, request.method)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `request() method: ${request.method}`,\n      );\n      throw new Error(message);\n    }\n    if (expiry && !isValidRequestExpiry(expiry, SESSION_REQUEST_EXPIRY_BOUNDARIES)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `request() expiry: ${expiry}. Expiry must be a number (in seconds) between ${SESSION_REQUEST_EXPIRY_BOUNDARIES.min} and ${SESSION_REQUEST_EXPIRY_BOUNDARIES.max}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidRespond: EnginePrivate[\"isValidRespond\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `respond() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, response } = params;\n    try {\n      // if the session is already disconnected, we can't respond to the request so we need to delete it\n      await this.isValidSessionTopic(topic);\n    } catch (error) {\n      if (params?.response?.id) this.cleanupAfterResponse(params);\n      throw error;\n    }\n    if (!isValidResponse(response)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `respond() response: ${JSON.stringify(response)}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidPing: EnginePrivate[\"isValidPing\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `ping() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n    await this.isValidSessionOrPairingTopic(topic);\n  };\n\n  private isValidEmit: EnginePrivate[\"isValidEmit\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `emit() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, event, chainId } = params;\n    await this.isValidSessionTopic(topic);\n    const { namespaces } = this.client.session.get(topic);\n    if (!isValidNamespacesChainId(namespaces, chainId)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `emit() chainId: ${chainId}`);\n      throw new Error(message);\n    }\n    if (!isValidEvent(event)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `emit() event: ${JSON.stringify(event)}`,\n      );\n      throw new Error(message);\n    }\n    if (!isValidNamespacesEvent(namespaces, chainId, event.name)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `emit() event: ${JSON.stringify(event)}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidDisconnect: EnginePrivate[\"isValidDisconnect\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `disconnect() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n    await this.isValidSessionOrPairingTopic(topic);\n  };\n\n  private isValidAuthenticate = (params: AuthTypes.SessionAuthenticateParams) => {\n    const { chains, uri, domain, nonce } = params;\n\n    // ----- validate params ----- //\n    if (!Array.isArray(chains) || chains.length === 0) {\n      throw new Error(\"chains is required and must be a non-empty array\");\n    }\n    if (!isValidString(uri, false)) {\n      throw new Error(\"uri is required parameter\");\n    }\n    if (!isValidString(domain, false)) {\n      throw new Error(\"domain is required parameter\");\n    }\n    if (!isValidString(nonce, false)) {\n      throw new Error(\"nonce is required parameter\");\n    }\n\n    // ----- reject multi namespaces ----- //\n    const uniqueNamespaces = [...new Set(chains.map((chain) => parseChainId(chain).namespace))];\n    if (uniqueNamespaces.length > 1) {\n      throw new Error(\n        \"Multi-namespace requests are not supported. Please request single namespace only.\",\n      );\n    }\n\n    const { namespace } = parseChainId(chains[0]);\n    if (namespace !== \"eip155\") {\n      throw new Error(\n        \"Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.\",\n      );\n    }\n  };\n\n  private getVerifyContext = async (params: {\n    attestationId?: string;\n    hash?: string;\n    encryptedId?: string;\n    metadata: CoreTypes.Metadata;\n    transportType?: RelayerTypes.TransportType;\n  }) => {\n    const { attestationId, hash, encryptedId, metadata, transportType } = params;\n    const context: Verify.Context = {\n      verified: {\n        verifyUrl: metadata.verifyUrl || VERIFY_SERVER,\n        validation: \"UNKNOWN\",\n        origin: metadata.url || \"\",\n      },\n    };\n\n    try {\n      if (transportType === TRANSPORT_TYPES.link_mode) {\n        const applink = this.getAppLinkIfEnabled(metadata, transportType);\n        context.verified.validation =\n          applink && new URL(applink).origin === new URL(metadata.url).origin ? \"VALID\" : \"INVALID\";\n        return context;\n      }\n      const result = await this.client.core.verify.resolve({\n        attestationId,\n        hash,\n        encryptedId,\n        verifyUrl: metadata.verifyUrl,\n      });\n      if (result) {\n        context.verified.origin = result.origin;\n        context.verified.isScam = result.isScam;\n        context.verified.validation =\n          result.origin === new URL(metadata.url).origin ? \"VALID\" : \"INVALID\";\n      }\n    } catch (e) {\n      this.client.logger.warn(e);\n    }\n\n    this.client.logger.debug(`Verify context: ${JSON.stringify(context)}`);\n    return context;\n  };\n\n  private validateSessionProps = (properties: SessionTypes.ScopedProperties, type: string) => {\n    Object.values(properties).forEach((property, index) => {\n      if (property === null || property === undefined) {\n        const { message } = getInternalError(\n          \"MISSING_OR_INVALID\",\n          `${type} must contain an existing value for each key. Received: ${property} for key ${\n            Object.keys(properties)[index]\n          }`,\n        );\n        throw new Error(message);\n      }\n    });\n  };\n\n  private getPendingAuthRequest = (id: number) => {\n    const request = this.client.auth.requests.get(id);\n    return typeof request === \"object\" ? request : undefined;\n  };\n\n  private addToRecentlyDeleted = (\n    id: string | number,\n    type: \"pairing\" | \"session\" | \"proposal\" | \"request\",\n  ) => {\n    this.recentlyDeletedMap.set(id, type);\n    // remove first half of the map if it exceeds the limit\n    if (this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {\n      let i = 0;\n      const numItemsToDelete = this.recentlyDeletedLimit / 2;\n      for (const k of this.recentlyDeletedMap.keys()) {\n        if (i++ >= numItemsToDelete) {\n          break;\n        }\n        this.recentlyDeletedMap.delete(k);\n      }\n    }\n  };\n\n  private checkRecentlyDeleted = (id: string | number) => {\n    const deletedRecord = this.recentlyDeletedMap.get(id);\n    if (deletedRecord) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `Record was recently deleted - ${deletedRecord}: ${id}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isLinkModeEnabled = (\n    peerMetadata?: CoreTypes.Metadata,\n    transportType?: RelayerTypes.TransportType,\n  ): boolean => {\n    if (!peerMetadata || transportType !== TRANSPORT_TYPES.link_mode) return false;\n\n    return (\n      this.client.metadata?.redirect?.linkMode === true &&\n      this.client.metadata?.redirect?.universal !== undefined &&\n      this.client.metadata?.redirect?.universal !== \"\" &&\n      peerMetadata?.redirect?.universal !== undefined &&\n      peerMetadata?.redirect?.universal !== \"\" &&\n      peerMetadata?.redirect?.linkMode === true &&\n      this.client.core.linkModeSupportedApps.includes(peerMetadata.redirect.universal) &&\n      typeof (global as any)?.Linking !== \"undefined\"\n    );\n  };\n\n  private getAppLinkIfEnabled = (\n    peerMetadata?: CoreTypes.Metadata,\n    transportType?: RelayerTypes.TransportType,\n  ): string | undefined => {\n    return this.isLinkModeEnabled(peerMetadata, transportType)\n      ? peerMetadata?.redirect?.universal\n      : undefined;\n  };\n\n  private handleLinkModeMessage = ({ url }: { url: string }) => {\n    if (!url || !url.includes(\"wc_ev\") || !url.includes(\"topic\")) return;\n\n    const topic = getSearchParamFromURL(url, \"topic\") || \"\";\n    const message = decodeURIComponent(getSearchParamFromURL(url, \"wc_ev\") || \"\");\n\n    const sessionExists = this.client.session.keys.includes(topic);\n\n    if (sessionExists) {\n      this.client.session.update(topic, { transportType: TRANSPORT_TYPES.link_mode });\n    }\n\n    this.client.core.dispatchEnvelope({ topic, message, sessionExists });\n  };\n\n  private registerLinkModeListeners = async () => {\n    if (isTestRun() || (isReactNative() && this.client.metadata.redirect?.linkMode)) {\n      const linking = (global as any)?.Linking;\n      // global.Linking is set by react-native-compat\n      if (typeof linking !== \"undefined\") {\n        // set URL listener\n        linking.addEventListener(\"url\", this.handleLinkModeMessage, this.client.name);\n\n        // check for initial URL -> cold boots\n        const initialUrl = await linking.getInitialURL();\n        if (initialUrl) {\n          // wait to process the message to allow event listeners to be registered by the implementing app\n          setTimeout(() => {\n            this.handleLinkModeMessage({ url: initialUrl });\n          }, 50);\n        }\n      }\n    }\n  };\n\n  private shouldSetTVF = (\n    protocolMethod: JsonRpcTypes.WcMethod,\n    params: JsonRpcTypes.RequestParams[\"wc_sessionRequest\"],\n  ) => {\n    if (!params) return false;\n    if (protocolMethod !== \"wc_sessionRequest\") return false;\n    const { request } = params;\n    return Object.keys(TVF_METHODS).includes(request.method);\n  };\n\n  private getTVFParams = (\n    id: number,\n    params: JsonRpcTypes.RequestParams[\"wc_sessionRequest\"],\n    result?: any,\n  ) => {\n    try {\n      const requestMethod = params.request.method;\n      const txHashes = this.extractTxHashesFromResult(requestMethod, result);\n      const tvf: RelayerTypes.ITVF = {\n        correlationId: id,\n        rpcMethods: [requestMethod],\n        chainId: params.chainId,\n        ...(this.isValidContractData(params.request.params) && {\n          // initially only get contractAddresses from EVM txs\n          contractAddresses: [params.request.params?.[0]?.to],\n        }),\n        txHashes,\n      };\n      return tvf;\n    } catch (e) {\n      this.client.logger.warn(\"Error getting TVF params\", e);\n    }\n    return {};\n  };\n\n  private isValidContractData = (params: any) => {\n    if (!params) return false;\n    try {\n      const data = params?.data || params?.[0]?.data;\n\n      if (!data.startsWith(\"0x\")) return false;\n\n      const hexPart = data.slice(2);\n      if (!/^[0-9a-fA-F]*$/.test(hexPart)) return false;\n\n      return hexPart.length % 2 === 0;\n    } catch (e) {}\n    return false;\n  };\n\n  private extractTxHashesFromResult = (method: string, result: any): string[] => {\n    try {\n      const methodConfig = TVF_METHODS[method as keyof typeof TVF_METHODS];\n      // result = 0x...\n      if (typeof result === \"string\") {\n        return [result];\n      }\n\n      // result = { key: [0x...] } or { key: 0x... }\n      const hashes: string[] = result[methodConfig.key];\n\n      // result = { key: [0x...] }\n      if (isValidArray(hashes)) {\n        if (method === \"solana_signAllTransactions\") {\n          return hashes.map((hash) => extractSolanaTransactionId(hash));\n        }\n\n        return hashes;\n\n        // result = { key: 0x... }\n      } else if (typeof hashes === \"string\") {\n        return [hashes];\n      }\n    } catch (e) {\n      this.client.logger.warn(\"Error extracting tx hashes from result\", e);\n    }\n    return [];\n  };\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore, ProposalTypes } from \"@walletconnect/types\";\n\nimport { SIGN_CLIENT_STORAGE_PREFIX, PROPOSAL_CONTEXT } from \"../constants\";\n\nexport class Proposal extends Store<number, ProposalTypes.Struct> {\n  constructor(public core: ICore, public logger: Logger) {\n    super(core, logger, PROPOSAL_CONTEXT, SIGN_CLIENT_STORAGE_PREFIX);\n  }\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore, SessionTypes } from \"@walletconnect/types\";\n\nimport { SIGN_CLIENT_STORAGE_PREFIX, SESSION_CONTEXT } from \"../constants\";\n\nexport class Session extends Store<string, SessionTypes.Struct> {\n  constructor(public core: ICore, public logger: Logger) {\n    super(core, logger, SESSION_CONTEXT, SIGN_CLIENT_STORAGE_PREFIX);\n  }\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore, PendingRequestTypes } from \"@walletconnect/types\";\nimport { REQUEST_CONTEXT, SIGN_CLIENT_STORAGE_PREFIX } from \"../constants\";\n\nexport class PendingRequest extends Store<number, PendingRequestTypes.Struct> {\n  constructor(public core: ICore, public logger: Logger) {\n    super(\n      core,\n      logger,\n      REQUEST_CONTEXT,\n      SIGN_CLIENT_STORAGE_PREFIX,\n      (val: PendingRequestTypes.Struct) => val.id,\n    );\n  }\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"@walletconnect/types\";\n\nimport { AUTH_KEYS_CONTEXT, AUTH_STORAGE_PREFIX, AUTH_PUBLIC_KEY_NAME } from \"../constants\";\n\nexport class AuthKey extends Store<string, { responseTopic: string; publicKey: string }> {\n  constructor(public core: ICore, public logger: Logger) {\n    super(core, logger, AUTH_KEYS_CONTEXT, AUTH_STORAGE_PREFIX, () => AUTH_PUBLIC_KEY_NAME);\n  }\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"@walletconnect/types\";\n\nimport { AUTH_PAIRING_TOPIC_CONTEXT, AUTH_STORAGE_PREFIX } from \"../constants\";\n\nexport class AuthPairingTopic extends Store<string, { topic: string; pairingTopic: string }> {\n  constructor(public core: ICore, public logger: Logger) {\n    super(core, logger, AUTH_PAIRING_TOPIC_CONTEXT, AUTH_STORAGE_PREFIX);\n  }\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { AuthTypes, ICore } from \"@walletconnect/types\";\n\nimport { AUTH_STORAGE_PREFIX, AUTH_REQUEST_CONTEXT } from \"../constants\";\n\nexport class AuthRequest extends Store<number, AuthTypes.PendingRequest> {\n  constructor(public core: ICore, public logger: Logger) {\n    super(\n      core,\n      logger,\n      AUTH_REQUEST_CONTEXT,\n      AUTH_STORAGE_PREFIX,\n      (val: AuthTypes.PendingRequest) => val.id,\n    );\n  }\n}\n","import { Logger } from \"@walletconnect/logger\";\nimport { IAuth, ICore } from \"@walletconnect/types\";\nimport { AuthPairingTopic } from \"./authPairingTopic\";\nimport { AuthRequest } from \"./authRequest\";\nimport { AuthKey } from \"./authKey\";\n\nexport class AuthStore {\n  public authKeys: IAuth[\"authKeys\"];\n  public pairingTopics: IAuth[\"pairingTopics\"];\n  public requests: IAuth[\"requests\"];\n\n  constructor(public core: ICore, public logger: Logger) {\n    this.authKeys = new AuthKey(this.core, this.logger);\n    this.pairingTopics = new AuthPairingTopic(this.core, this.logger);\n    this.requests = new AuthRequest(this.core, this.logger);\n  }\n\n  public async init() {\n    await this.authKeys.init();\n    await this.pairingTopics.init();\n    await this.requests.init();\n  }\n}\n","import { Core } from \"@walletconnect/core\";\nimport {\n  generateChildLogger,\n  getDefaultLoggerOptions,\n  getLoggerContext,\n  pino,\n} from \"@walletconnect/logger\";\nimport { SignClientTypes, ISignClient, ISignClientEvents, EngineTypes } from \"@walletconnect/types\";\nimport { ONE_SECOND, toMiliseconds } from \"@walletconnect/time\";\nimport { getAppMetadata } from \"@walletconnect/utils\";\nimport { EventEmitter } from \"events\";\nimport { SIGN_CLIENT_DEFAULT, SIGN_CLIENT_PROTOCOL, SIGN_CLIENT_VERSION } from \"./constants\";\nimport { AuthStore, Engine, PendingRequest, Proposal, Session } from \"./controllers\";\n\nexport class SignClient extends ISignClient {\n  public readonly protocol = SIGN_CLIENT_PROTOCOL;\n  public readonly version = SIGN_CLIENT_VERSION;\n  public readonly name: ISignClient[\"name\"] = SIGN_CLIENT_DEFAULT.name;\n  public readonly metadata: ISignClient[\"metadata\"];\n\n  public core: ISignClient[\"core\"];\n  public logger: ISignClient[\"logger\"];\n  public events: ISignClient[\"events\"] = new EventEmitter();\n  public engine: ISignClient[\"engine\"];\n  public session: ISignClient[\"session\"];\n  public proposal: ISignClient[\"proposal\"];\n  public pendingRequest: ISignClient[\"pendingRequest\"];\n  public auth: ISignClient[\"auth\"];\n  public signConfig?: ISignClient[\"signConfig\"];\n\n  static async init(opts?: SignClientTypes.Options) {\n    const client = new SignClient(opts);\n    await client.initialize();\n\n    return client;\n  }\n\n  constructor(opts?: SignClientTypes.Options) {\n    super(opts);\n\n    this.name = opts?.name || SIGN_CLIENT_DEFAULT.name;\n    this.metadata = opts?.metadata || getAppMetadata();\n    this.signConfig = opts?.signConfig;\n\n    const logger =\n      typeof opts?.logger !== \"undefined\" && typeof opts?.logger !== \"string\"\n        ? opts.logger\n        : pino(getDefaultLoggerOptions({ level: opts?.logger || SIGN_CLIENT_DEFAULT.logger }));\n\n    this.core = opts?.core || new Core(opts);\n    this.logger = generateChildLogger(logger, this.name);\n    this.session = new Session(this.core, this.logger);\n    this.proposal = new Proposal(this.core, this.logger);\n    this.pendingRequest = new PendingRequest(this.core, this.logger);\n    this.engine = new Engine(this);\n    this.auth = new AuthStore(this.core, this.logger);\n  }\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  get pairing() {\n    return this.core.pairing.pairings;\n  }\n\n  // ---------- Events ----------------------------------------------- //\n\n  public on: ISignClientEvents[\"on\"] = (name, listener) => {\n    return this.events.on(name, listener);\n  };\n\n  public once: ISignClientEvents[\"once\"] = (name, listener) => {\n    return this.events.once(name, listener);\n  };\n\n  public off: ISignClientEvents[\"off\"] = (name, listener) => {\n    return this.events.off(name, listener);\n  };\n\n  public removeListener: ISignClientEvents[\"removeListener\"] = (name, listener) => {\n    return this.events.removeListener(name, listener);\n  };\n\n  public removeAllListeners: ISignClientEvents[\"removeAllListeners\"] = (name) => {\n    return this.events.removeAllListeners(name);\n  };\n\n  // ---------- Engine ----------------------------------------------- //\n\n  public connect: ISignClient[\"connect\"] = async (params) => {\n    try {\n      return await this.engine.connect(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public pair: ISignClient[\"pair\"] = async (params) => {\n    try {\n      return await this.engine.pair(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public approve: ISignClient[\"approve\"] = async (params) => {\n    try {\n      return await this.engine.approve(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public reject: ISignClient[\"reject\"] = async (params) => {\n    try {\n      return await this.engine.reject(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public update: ISignClient[\"update\"] = async (params) => {\n    try {\n      return await this.engine.update(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public extend: ISignClient[\"extend\"] = async (params) => {\n    try {\n      return await this.engine.extend(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public request: ISignClient[\"request\"] = async <T>(params: EngineTypes.RequestParams) => {\n    try {\n      return await this.engine.request<T>(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public respond: ISignClient[\"respond\"] = async (params) => {\n    try {\n      return await this.engine.respond(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public ping: ISignClient[\"ping\"] = async (params) => {\n    try {\n      return await this.engine.ping(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public emit: ISignClient[\"emit\"] = async (params) => {\n    try {\n      return await this.engine.emit(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public disconnect: ISignClient[\"disconnect\"] = async (params) => {\n    try {\n      return await this.engine.disconnect(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public find: ISignClient[\"find\"] = (params) => {\n    try {\n      return this.engine.find(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public getPendingSessionRequests: ISignClient[\"getPendingSessionRequests\"] = () => {\n    try {\n      return this.engine.getPendingSessionRequests();\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public authenticate: ISignClient[\"authenticate\"] = async (params, walletUniversalLink) => {\n    try {\n      return await this.engine.authenticate(params, walletUniversalLink);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public formatAuthMessage: ISignClient[\"formatAuthMessage\"] = (params) => {\n    try {\n      return this.engine.formatAuthMessage(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public approveSessionAuthenticate: ISignClient[\"approveSessionAuthenticate\"] = async (params) => {\n    try {\n      return await this.engine.approveSessionAuthenticate(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public rejectSessionAuthenticate: ISignClient[\"rejectSessionAuthenticate\"] = async (params) => {\n    try {\n      return await this.engine.rejectSessionAuthenticate(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async initialize() {\n    this.logger.trace(`Initialized`);\n    try {\n      await this.core.start();\n      await this.session.init();\n      await this.proposal.init();\n      await this.pendingRequest.init();\n      await this.auth.init();\n      await this.engine.init();\n      this.logger.info(`SignClient Initialization Success`);\n      setTimeout(() => {\n        this.engine.processRelayMessageCache();\n      }, toMiliseconds(ONE_SECOND));\n    } catch (error: any) {\n      this.logger.info(`SignClient Initialization Failure`);\n      this.logger.error(error.message);\n      throw error;\n    }\n  }\n}\n","import { SignClient as Client } from \"./client\";\nimport { Session } from \"./controllers/session\";\nexport * from \"./constants\";\n\nexport const SessionStore = Session;\nexport const SignClient = Client;\nexport default Client;\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}