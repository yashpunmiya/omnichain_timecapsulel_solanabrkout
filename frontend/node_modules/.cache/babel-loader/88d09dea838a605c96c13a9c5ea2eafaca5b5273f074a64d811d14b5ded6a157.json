{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst assert_1 = __importDefault(require(\"assert\"));\nconst utils_1 = require(\"./utils\");\nconst bytewords = 'ableacidalsoapexaquaarchatomauntawayaxisbackbaldbarnbeltbetabiasbluebodybragbrewbulbbuzzcalmcashcatschefcityclawcodecolacookcostcruxcurlcuspcyandarkdatadaysdelidicedietdoordowndrawdropdrumdulldutyeacheasyechoedgeepicevenexamexiteyesfactfairfernfigsfilmfishfizzflapflewfluxfoxyfreefrogfuelfundgalagamegeargemsgiftgirlglowgoodgraygrimgurugushgyrohalfhanghardhawkheathelphighhillholyhopehornhutsicedideaidleinchinkyintoirisironitemjadejazzjoinjoltjowljudojugsjumpjunkjurykeepkenokeptkeyskickkilnkingkitekiwiknoblamblavalazyleaflegsliarlimplionlistlogoloudloveluaulucklungmainmanymathmazememomenumeowmildmintmissmonknailnavyneednewsnextnoonnotenumbobeyoboeomitonyxopenovalowlspaidpartpeckplaypluspoempoolposepuffpumapurrquadquizraceramprealredorichroadrockroofrubyruinrunsrustsafesagascarsetssilkskewslotsoapsolosongstubsurfswantacotasktaxitenttiedtimetinytoiltombtoystriptunatwinuglyundouniturgeuservastveryvetovialvibeviewvisavoidvowswallwandwarmwaspwavewaxywebswhatwhenwhizwolfworkyankyawnyellyogayurtzapszerozestzinczonezoom';\nlet bytewordsLookUpTable = [];\nconst BYTEWORDS_NUM = 256;\nconst BYTEWORD_LENGTH = 4;\nconst MINIMAL_BYTEWORD_LENGTH = 2;\nvar STYLES;\n(function (STYLES) {\n  STYLES[\"STANDARD\"] = \"standard\";\n  STYLES[\"URI\"] = \"uri\";\n  STYLES[\"MINIMAL\"] = \"minimal\";\n})(STYLES || (STYLES = {}));\nconst getWord = index => {\n  return bytewords.slice(index * BYTEWORD_LENGTH, index * BYTEWORD_LENGTH + BYTEWORD_LENGTH);\n};\nconst getMinimalWord = index => {\n  const byteword = getWord(index);\n  return `${byteword[0]}${byteword[BYTEWORD_LENGTH - 1]}`;\n};\nconst addCRC = string => {\n  const crc = utils_1.getCRCHex(Buffer.from(string, 'hex'));\n  return `${string}${crc}`;\n};\nconst encodeWithSeparator = (word, separator) => {\n  const crcAppendedWord = addCRC(word);\n  const crcWordBuff = Buffer.from(crcAppendedWord, 'hex');\n  const result = crcWordBuff.reduce((result, w) => [...result, getWord(w)], []);\n  return result.join(separator);\n};\nconst encodeMinimal = word => {\n  const crcAppendedWord = addCRC(word);\n  const crcWordBuff = Buffer.from(crcAppendedWord, 'hex');\n  const result = crcWordBuff.reduce((result, w) => result + getMinimalWord(w), '');\n  return result;\n};\nconst decodeWord = (word, wordLength) => {\n  assert_1.default(word.length === wordLength, 'Invalid Bytewords: word.length does not match wordLength provided');\n  const dim = 26;\n  // Since the first and last letters of each Byteword are unique,\n  // we can use them as indexes into a two-dimensional lookup table.\n  // This table is generated lazily.\n  if (bytewordsLookUpTable.length === 0) {\n    const array_len = dim * dim;\n    bytewordsLookUpTable = [...new Array(array_len)].map(() => -1);\n    for (let i = 0; i < BYTEWORDS_NUM; i++) {\n      const byteword = getWord(i);\n      let x = byteword[0].charCodeAt(0) - 'a'.charCodeAt(0);\n      let y = byteword[3].charCodeAt(0) - 'a'.charCodeAt(0);\n      let offset = y * dim + x;\n      bytewordsLookUpTable[offset] = i;\n    }\n  }\n  // If the coordinates generated by the first and last letters are out of bounds,\n  // or the lookup table contains -1 at the coordinates, then the word is not valid.\n  let x = word[0].toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0);\n  let y = word[wordLength == 4 ? 3 : 1].toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0);\n  assert_1.default(0 <= x && x < dim && 0 <= y && y < dim, 'Invalid Bytewords: invalid word');\n  let offset = y * dim + x;\n  let value = bytewordsLookUpTable[offset];\n  assert_1.default(value !== -1, 'Invalid Bytewords: value not in lookup table');\n  // If we're decoding a full four-letter word, verify that the two middle letters are correct.\n  if (wordLength == BYTEWORD_LENGTH) {\n    const byteword = getWord(value);\n    let c1 = word[1].toLowerCase();\n    let c2 = word[2].toLowerCase();\n    assert_1.default(c1 === byteword[1] && c2 === byteword[2], 'Invalid Bytewords: invalid middle letters of word');\n  }\n  // Successful decode.\n  return Buffer.from([value]).toString('hex');\n};\nconst _decode = (string, separator, wordLength) => {\n  const words = wordLength == BYTEWORD_LENGTH ? string.split(separator) : utils_1.partition(string, 2);\n  const decodedString = words.map(word => decodeWord(word, wordLength)).join('');\n  assert_1.default(decodedString.length >= 5, 'Invalid Bytewords: invalid decoded string length');\n  const [body, bodyChecksum] = utils_1.split(Buffer.from(decodedString, 'hex'), 4);\n  const checksum = utils_1.getCRCHex(body); // convert to hex\n  assert_1.default(checksum === bodyChecksum.toString('hex'), 'Invalid Checksum');\n  return body.toString('hex');\n};\nconst decode = (string, style = STYLES.MINIMAL) => {\n  switch (style) {\n    case STYLES.STANDARD:\n      return _decode(string, ' ', BYTEWORD_LENGTH);\n    case STYLES.URI:\n      return _decode(string, '-', BYTEWORD_LENGTH);\n    case STYLES.MINIMAL:\n      return _decode(string, '', MINIMAL_BYTEWORD_LENGTH);\n    default:\n      throw new Error(`Invalid style ${style}`);\n  }\n};\nconst encode = (string, style = STYLES.MINIMAL) => {\n  switch (style) {\n    case STYLES.STANDARD:\n      return encodeWithSeparator(string, ' ');\n    case STYLES.URI:\n      return encodeWithSeparator(string, '-');\n    case STYLES.MINIMAL:\n      return encodeMinimal(string);\n    default:\n      throw new Error(`Invalid style ${style}`);\n  }\n};\nexports.default = {\n  decode,\n  encode,\n  STYLES\n};","map":{"version":3,"names":["assert_1","__importDefault","require","utils_1","bytewords","bytewordsLookUpTable","BYTEWORDS_NUM","BYTEWORD_LENGTH","MINIMAL_BYTEWORD_LENGTH","STYLES","getWord","index","slice","getMinimalWord","byteword","addCRC","string","crc","getCRCHex","Buffer","from","encodeWithSeparator","word","separator","crcAppendedWord","crcWordBuff","result","reduce","w","join","encodeMinimal","decodeWord","wordLength","default","length","dim","array_len","Array","map","i","x","charCodeAt","y","offset","toLowerCase","value","c1","c2","toString","_decode","words","split","partition","decodedString","body","bodyChecksum","checksum","decode","style","MINIMAL","STANDARD","URI","Error","encode","exports"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@ngraveio\\bc-ur\\src\\bytewords.ts"],"sourcesContent":["import assert from \"assert\";\nimport { getCRCHex, partition, split } from \"./utils\";\n\nconst bytewords = 'ableacidalsoapexaquaarchatomauntawayaxisbackbaldbarnbeltbetabiasbluebodybragbrewbulbbuzzcalmcashcatschefcityclawcodecolacookcostcruxcurlcuspcyandarkdatadaysdelidicedietdoordowndrawdropdrumdulldutyeacheasyechoedgeepicevenexamexiteyesfactfairfernfigsfilmfishfizzflapflewfluxfoxyfreefrogfuelfundgalagamegeargemsgiftgirlglowgoodgraygrimgurugushgyrohalfhanghardhawkheathelphighhillholyhopehornhutsicedideaidleinchinkyintoirisironitemjadejazzjoinjoltjowljudojugsjumpjunkjurykeepkenokeptkeyskickkilnkingkitekiwiknoblamblavalazyleaflegsliarlimplionlistlogoloudloveluaulucklungmainmanymathmazememomenumeowmildmintmissmonknailnavyneednewsnextnoonnotenumbobeyoboeomitonyxopenovalowlspaidpartpeckplaypluspoempoolposepuffpumapurrquadquizraceramprealredorichroadrockroofrubyruinrunsrustsafesagascarsetssilkskewslotsoapsolosongstubsurfswantacotasktaxitenttiedtimetinytoiltombtoystriptunatwinuglyundouniturgeuservastveryvetovialvibeviewvisavoidvowswallwandwarmwaspwavewaxywebswhatwhenwhizwolfworkyankyawnyellyogayurtzapszerozestzinczonezoom';\nlet bytewordsLookUpTable: number[] = [];\nconst BYTEWORDS_NUM = 256;\nconst BYTEWORD_LENGTH = 4;\nconst MINIMAL_BYTEWORD_LENGTH = 2;\n\nenum STYLES {\n  STANDARD = 'standard',\n  URI = 'uri',\n  MINIMAL = 'minimal'\n}\n\nconst getWord = (index: number): string => {\n  return bytewords.slice(index * BYTEWORD_LENGTH, (index * BYTEWORD_LENGTH) + BYTEWORD_LENGTH)\n}\n\nconst getMinimalWord = (index: number): string => {\n  const byteword = getWord(index);\n\n  return `${byteword[0]}${byteword[BYTEWORD_LENGTH - 1]}`\n}\n\nconst addCRC = (string: string): string => {\n  const crc = getCRCHex(Buffer.from(string, 'hex'));\n\n  return `${string}${crc}`;\n}\n\nconst encodeWithSeparator = (word: string, separator: string): string => {\n  const crcAppendedWord = addCRC(word);\n  const crcWordBuff = Buffer.from(crcAppendedWord, 'hex');\n  const result = crcWordBuff.reduce((result: string[], w) => ([...result, getWord(w)]), []);\n\n  return result.join(separator);\n}\n\nconst encodeMinimal = (word: string): string => {\n  const crcAppendedWord = addCRC(word);\n  const crcWordBuff = Buffer.from(crcAppendedWord, 'hex');\n  const result = crcWordBuff.reduce((result, w) => result + getMinimalWord(w), '');\n\n  return result;\n}\n\nconst decodeWord = (word: string, wordLength: number): string => {\n  assert(word.length === wordLength, 'Invalid Bytewords: word.length does not match wordLength provided');\n\n  const dim = 26;\n\n  // Since the first and last letters of each Byteword are unique,\n  // we can use them as indexes into a two-dimensional lookup table.\n  // This table is generated lazily.\n  if (bytewordsLookUpTable.length === 0) {\n    const array_len = dim * dim;\n    bytewordsLookUpTable = [...new Array(array_len)].map(() => -1)\n\n    for (let i = 0; i < BYTEWORDS_NUM; i++) {\n      const byteword = getWord(i);\n      let x = byteword[0].charCodeAt(0) - 'a'.charCodeAt(0);\n      let y = byteword[3].charCodeAt(0) - 'a'.charCodeAt(0);\n      let offset = y * dim + x;\n      bytewordsLookUpTable[offset] = i;\n    }\n  }\n\n  // If the coordinates generated by the first and last letters are out of bounds,\n  // or the lookup table contains -1 at the coordinates, then the word is not valid.\n  let x = (word[0]).toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0);\n  let y = (word[wordLength == 4 ? 3 : 1]).toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0);\n\n  assert(0 <= x && x < dim && 0 <= y && y < dim, 'Invalid Bytewords: invalid word');\n\n  let offset = y * dim + x;\n  let value = bytewordsLookUpTable[offset];\n\n  assert(value !== -1, 'Invalid Bytewords: value not in lookup table');\n\n  // If we're decoding a full four-letter word, verify that the two middle letters are correct.\n  if (wordLength == BYTEWORD_LENGTH) {\n    const byteword = getWord(value)\n    let c1 = word[1].toLowerCase();\n    let c2 = word[2].toLowerCase();\n\n    assert(c1 === byteword[1] && c2 === byteword[2], 'Invalid Bytewords: invalid middle letters of word');\n  }\n\n  // Successful decode.\n  return Buffer.from([value]).toString('hex')\n}\n\nconst _decode = (string: string, separator: string, wordLength: number): string => {\n  const words = wordLength == BYTEWORD_LENGTH ? string.split(separator) : partition(string, 2)\n  const decodedString = words.map((word: string) => decodeWord(word, wordLength)).join('');\n\n  assert(decodedString.length >= 5, 'Invalid Bytewords: invalid decoded string length');\n\n  const [body, bodyChecksum] = split(Buffer.from(decodedString, 'hex'), 4)\n  const checksum = getCRCHex(body)// convert to hex\n\n  assert(checksum === bodyChecksum.toString('hex'), 'Invalid Checksum');\n\n  return body.toString('hex');\n}\n\n\nconst decode = (string: string, style: STYLES = STYLES.MINIMAL): string => {\n  switch (style) {\n    case STYLES.STANDARD:\n      return _decode(string, ' ', BYTEWORD_LENGTH);\n    case STYLES.URI:\n      return _decode(string, '-', BYTEWORD_LENGTH);\n    case STYLES.MINIMAL:\n      return _decode(string, '', MINIMAL_BYTEWORD_LENGTH);\n    default:\n      throw new Error(`Invalid style ${style}`)\n  }\n}\n\nconst encode = (string: string, style: STYLES = STYLES.MINIMAL): string => {\n  switch (style) {\n    case STYLES.STANDARD:\n      return encodeWithSeparator(string, ' ');\n    case STYLES.URI:\n      return encodeWithSeparator(string, '-');\n    case STYLES.MINIMAL:\n      return encodeMinimal(string);\n    default:\n      throw new Error(`Invalid style ${style}`)\n  }\n}\n\nexport default {\n  decode,\n  encode,\n  STYLES\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}