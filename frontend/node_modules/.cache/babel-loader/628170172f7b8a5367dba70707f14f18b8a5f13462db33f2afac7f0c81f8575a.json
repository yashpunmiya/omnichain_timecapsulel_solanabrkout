{"ast":null,"code":"var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar _ReadonlyWalletAccount_address, _ReadonlyWalletAccount_publicKey, _ReadonlyWalletAccount_chains, _ReadonlyWalletAccount_features, _ReadonlyWalletAccount_label, _ReadonlyWalletAccount_icon;\n/**\n * Base implementation of a {@link \"@wallet-standard/base\".WalletAccount} to be used or extended by a\n * {@link \"@wallet-standard/base\".Wallet}.\n *\n * `WalletAccount` properties must be read-only. This class enforces this by making all properties\n * [truly private](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields) and\n * read-only, using getters for access, returning copies instead of references, and calling\n * [Object.freeze](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)\n * on the instance.\n *\n * @group Account\n */\nexport class ReadonlyWalletAccount {\n  /** Implementation of {@link \"@wallet-standard/base\".WalletAccount.address | WalletAccount::address} */\n  get address() {\n    return __classPrivateFieldGet(this, _ReadonlyWalletAccount_address, \"f\");\n  }\n  /** Implementation of {@link \"@wallet-standard/base\".WalletAccount.publicKey | WalletAccount::publicKey} */\n  get publicKey() {\n    return __classPrivateFieldGet(this, _ReadonlyWalletAccount_publicKey, \"f\").slice();\n  }\n  /** Implementation of {@link \"@wallet-standard/base\".WalletAccount.chains | WalletAccount::chains} */\n  get chains() {\n    return __classPrivateFieldGet(this, _ReadonlyWalletAccount_chains, \"f\").slice();\n  }\n  /** Implementation of {@link \"@wallet-standard/base\".WalletAccount.features | WalletAccount::features} */\n  get features() {\n    return __classPrivateFieldGet(this, _ReadonlyWalletAccount_features, \"f\").slice();\n  }\n  /** Implementation of {@link \"@wallet-standard/base\".WalletAccount.label | WalletAccount::label} */\n  get label() {\n    return __classPrivateFieldGet(this, _ReadonlyWalletAccount_label, \"f\");\n  }\n  /** Implementation of {@link \"@wallet-standard/base\".WalletAccount.icon | WalletAccount::icon} */\n  get icon() {\n    return __classPrivateFieldGet(this, _ReadonlyWalletAccount_icon, \"f\");\n  }\n  /**\n   * Create and freeze a read-only account.\n   *\n   * @param account Account to copy properties from.\n   */\n  constructor(account) {\n    _ReadonlyWalletAccount_address.set(this, void 0);\n    _ReadonlyWalletAccount_publicKey.set(this, void 0);\n    _ReadonlyWalletAccount_chains.set(this, void 0);\n    _ReadonlyWalletAccount_features.set(this, void 0);\n    _ReadonlyWalletAccount_label.set(this, void 0);\n    _ReadonlyWalletAccount_icon.set(this, void 0);\n    if (new.target === ReadonlyWalletAccount) {\n      Object.freeze(this);\n    }\n    __classPrivateFieldSet(this, _ReadonlyWalletAccount_address, account.address, \"f\");\n    __classPrivateFieldSet(this, _ReadonlyWalletAccount_publicKey, account.publicKey.slice(), \"f\");\n    __classPrivateFieldSet(this, _ReadonlyWalletAccount_chains, account.chains.slice(), \"f\");\n    __classPrivateFieldSet(this, _ReadonlyWalletAccount_features, account.features.slice(), \"f\");\n    __classPrivateFieldSet(this, _ReadonlyWalletAccount_label, account.label, \"f\");\n    __classPrivateFieldSet(this, _ReadonlyWalletAccount_icon, account.icon, \"f\");\n  }\n}\n_ReadonlyWalletAccount_address = new WeakMap(), _ReadonlyWalletAccount_publicKey = new WeakMap(), _ReadonlyWalletAccount_chains = new WeakMap(), _ReadonlyWalletAccount_features = new WeakMap(), _ReadonlyWalletAccount_label = new WeakMap(), _ReadonlyWalletAccount_icon = new WeakMap();\n/**\n * Efficiently compare {@link Indexed} arrays (e.g. `Array` and `Uint8Array`).\n *\n * @param a An array.\n * @param b Another array.\n *\n * @return `true` if the arrays have the same length and elements, `false` otherwise.\n *\n * @group Util\n */\nexport function arraysEqual(a, b) {\n  if (a === b) return true;\n  const length = a.length;\n  if (length !== b.length) return false;\n  for (let i = 0; i < length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\n/**\n * Efficiently compare byte arrays, using {@link arraysEqual}.\n *\n * @param a A byte array.\n * @param b Another byte array.\n *\n * @return `true` if the byte arrays have the same length and bytes, `false` otherwise.\n *\n * @group Util\n */\nexport function bytesEqual(a, b) {\n  return arraysEqual(a, b);\n}\n/**\n * Efficiently concatenate byte arrays without modifying them.\n *\n * @param first  A byte array.\n * @param others Additional byte arrays.\n *\n * @return New byte array containing the concatenation of all the byte arrays.\n *\n * @group Util\n */\nexport function concatBytes(first, ...others) {\n  const length = others.reduce((length, bytes) => length + bytes.length, first.length);\n  const bytes = new Uint8Array(length);\n  bytes.set(first, 0);\n  for (const other of others) {\n    bytes.set(other, bytes.length);\n  }\n  return bytes;\n}\n/**\n * Create a new object with a subset of fields from a source object.\n *\n * @param source Object to pick fields from.\n * @param keys   Names of fields to pick.\n *\n * @return New object with only the picked fields.\n *\n * @group Util\n */\nexport function pick(source, ...keys) {\n  const picked = {};\n  for (const key of keys) {\n    picked[key] = source[key];\n  }\n  return picked;\n}\n/**\n * Call a callback function, catch an error if it throws, and log the error without rethrowing.\n *\n * @param callback Function to call.\n *\n * @group Util\n */\nexport function guard(callback) {\n  try {\n    callback();\n  } catch (error) {\n    console.error(error);\n  }\n}\n//# sourceMappingURL=util.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}