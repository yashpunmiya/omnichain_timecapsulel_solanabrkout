{"ast":null,"code":"import { hexToBigInt } from '../../utils/encoding/fromHex.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { observe } from '../../utils/observe.js';\nimport { poll } from '../../utils/poll.js';\nimport { stringify } from '../../utils/stringify.js';\nimport { getBlockNumber } from './getBlockNumber.js';\n/**\n * Watches and returns incoming block numbers.\n *\n * - Docs: https://viem.sh/docs/actions/public/watchBlockNumber\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks_watching-blocks\n * - JSON-RPC Methods:\n *   - When `poll: true`, calls [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber) on a polling interval.\n *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `\"newHeads\"` event.\n *\n * @param client - Client to use\n * @param parameters - {@link WatchBlockNumberParameters}\n * @returns A function that can be invoked to stop watching for new block numbers. {@link WatchBlockNumberReturnType}\n *\n * @example\n * import { createPublicClient, watchBlockNumber, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = watchBlockNumber(client, {\n *   onBlockNumber: (blockNumber) => console.log(blockNumber),\n * })\n */\nexport function watchBlockNumber(client, {\n  emitOnBegin = false,\n  emitMissed = false,\n  onBlockNumber,\n  onError,\n  poll: poll_,\n  pollingInterval = client.pollingInterval\n}) {\n  const enablePolling = (() => {\n    if (typeof poll_ !== 'undefined') return poll_;\n    if (client.transport.type === 'webSocket') return false;\n    if (client.transport.type === 'fallback' && client.transport.transports[0].config.type === 'webSocket') return false;\n    return true;\n  })();\n  let prevBlockNumber;\n  const pollBlockNumber = () => {\n    const observerId = stringify(['watchBlockNumber', client.uid, emitOnBegin, emitMissed, pollingInterval]);\n    return observe(observerId, {\n      onBlockNumber,\n      onError\n    }, emit => poll(async () => {\n      try {\n        const blockNumber = await getAction(client, getBlockNumber, 'getBlockNumber')({\n          cacheTime: 0\n        });\n        if (prevBlockNumber) {\n          // If the current block number is the same as the previous,\n          // we can skip.\n          if (blockNumber === prevBlockNumber) return;\n          // If we have missed out on some previous blocks, and the\n          // `emitMissed` flag is truthy, let's emit those blocks.\n          if (blockNumber - prevBlockNumber > 1 && emitMissed) {\n            for (let i = prevBlockNumber + 1n; i < blockNumber; i++) {\n              emit.onBlockNumber(i, prevBlockNumber);\n              prevBlockNumber = i;\n            }\n          }\n        }\n        // If the next block number is greater than the previous,\n        // it is not in the past, and we can emit the new block number.\n        if (!prevBlockNumber || blockNumber > prevBlockNumber) {\n          emit.onBlockNumber(blockNumber, prevBlockNumber);\n          prevBlockNumber = blockNumber;\n        }\n      } catch (err) {\n        emit.onError?.(err);\n      }\n    }, {\n      emitOnBegin,\n      interval: pollingInterval\n    }));\n  };\n  const subscribeBlockNumber = () => {\n    const observerId = stringify(['watchBlockNumber', client.uid, emitOnBegin, emitMissed]);\n    return observe(observerId, {\n      onBlockNumber,\n      onError\n    }, emit => {\n      let active = true;\n      let unsubscribe = () => active = false;\n      (async () => {\n        try {\n          const transport = (() => {\n            if (client.transport.type === 'fallback') {\n              const transport = client.transport.transports.find(transport => transport.config.type === 'webSocket');\n              if (!transport) return client.transport;\n              return transport.value;\n            }\n            return client.transport;\n          })();\n          const {\n            unsubscribe: unsubscribe_\n          } = await transport.subscribe({\n            params: ['newHeads'],\n            onData(data) {\n              if (!active) return;\n              const blockNumber = hexToBigInt(data.result?.number);\n              emit.onBlockNumber(blockNumber, prevBlockNumber);\n              prevBlockNumber = blockNumber;\n            },\n            onError(error) {\n              emit.onError?.(error);\n            }\n          });\n          unsubscribe = unsubscribe_;\n          if (!active) unsubscribe();\n        } catch (err) {\n          onError?.(err);\n        }\n      })();\n      return () => unsubscribe();\n    });\n  };\n  return enablePolling ? pollBlockNumber() : subscribeBlockNumber();\n}\n//# sourceMappingURL=watchBlockNumber.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}