{"ast":null,"code":"import { bigIntToBytes, bytesToHex, concatBytes, int32ToBytes, intToBytes, setLengthLeft, setLengthRight, toBytes } from './bytes.js';\n/**\n * @dev Returns the 31-bytes verkle tree stem for a given address and tree index.\n * @dev Assumes that the verkle node width = 256\n * @param ffi The verkle ffi object from verkle-crypotography-wasm.\n * @param address The address to generate the tree key for.\n * @param treeIndex The index of the tree to generate the key for. Defaults to 0.\n * @return The 31-bytes verkle tree stem as a Uint8Array.\n */\nexport function getVerkleStem(ffi, address, treeIndex = 0) {\n  const address32 = setLengthLeft(address.toBytes(), 32);\n  let treeIndexBytes;\n  if (typeof treeIndex === 'number') {\n    treeIndexBytes = setLengthRight(int32ToBytes(Number(treeIndex), true), 32);\n  } else {\n    treeIndexBytes = setLengthRight(bigIntToBytes(BigInt(treeIndex), true).slice(0, 32), 32);\n  }\n  const treeStem = ffi.getTreeKey(address32, treeIndexBytes, 0).slice(0, 31);\n  return treeStem;\n}\n/**\n * Verifies that the executionWitness is valid for the given prestateRoot.\n * @param ffi The verkle ffi object from verkle-crypotography-wasm.\n * @param prestateRoot The prestateRoot matching the executionWitness.\n * @param executionWitness The verkle execution witness.\n * @returns {boolean} Whether or not the executionWitness belongs to the prestateRoot.\n */\nexport function verifyVerkleProof(ffi, prestateRoot, executionWitness) {\n  return ffi.verifyExecutionWitnessPreState(bytesToHex(prestateRoot), JSON.stringify(executionWitness));\n}\nexport var VerkleLeafType;\n(function (VerkleLeafType) {\n  VerkleLeafType[VerkleLeafType[\"Version\"] = 0] = \"Version\";\n  VerkleLeafType[VerkleLeafType[\"Balance\"] = 1] = \"Balance\";\n  VerkleLeafType[VerkleLeafType[\"Nonce\"] = 2] = \"Nonce\";\n  VerkleLeafType[VerkleLeafType[\"CodeHash\"] = 3] = \"CodeHash\";\n  VerkleLeafType[VerkleLeafType[\"CodeSize\"] = 4] = \"CodeSize\";\n})(VerkleLeafType || (VerkleLeafType = {}));\nexport const VERKLE_VERSION_LEAF_KEY = intToBytes(VerkleLeafType.Version);\nexport const VERKLE_BALANCE_LEAF_KEY = intToBytes(VerkleLeafType.Balance);\nexport const VERKLE_NONCE_LEAF_KEY = intToBytes(VerkleLeafType.Nonce);\nexport const VERKLE_CODE_HASH_LEAF_KEY = intToBytes(VerkleLeafType.CodeHash);\nexport const VERKLE_CODE_SIZE_LEAF_KEY = intToBytes(VerkleLeafType.CodeSize);\nexport const VERKLE_HEADER_STORAGE_OFFSET = 64;\nexport const VERKLE_CODE_OFFSET = 128;\nexport const VERKLE_NODE_WIDTH = 256;\nexport const VERKLE_MAIN_STORAGE_OFFSET = BigInt(256) ** BigInt(31);\n/**\n * @dev Returns the tree key for a given verkle tree stem, and sub index.\n * @dev Assumes that the verkle node width = 256\n * @param stem The 31-bytes verkle tree stem as a Uint8Array.\n * @param subIndex The sub index of the tree to generate the key for as a Uint8Array.\n * @return The tree key as a Uint8Array.\n */\nexport const getVerkleKey = (stem, leaf) => {\n  switch (leaf) {\n    case VerkleLeafType.Version:\n      return concatBytes(stem, VERKLE_VERSION_LEAF_KEY);\n    case VerkleLeafType.Balance:\n      return concatBytes(stem, VERKLE_BALANCE_LEAF_KEY);\n    case VerkleLeafType.Nonce:\n      return concatBytes(stem, VERKLE_NONCE_LEAF_KEY);\n    case VerkleLeafType.CodeHash:\n      return concatBytes(stem, VERKLE_CODE_HASH_LEAF_KEY);\n    case VerkleLeafType.CodeSize:\n      return concatBytes(stem, VERKLE_CODE_SIZE_LEAF_KEY);\n    default:\n      return concatBytes(stem, leaf);\n  }\n};\nexport function getVerkleTreeIndexesForStorageSlot(storageKey) {\n  let position;\n  if (storageKey < VERKLE_CODE_OFFSET - VERKLE_HEADER_STORAGE_OFFSET) {\n    position = BigInt(VERKLE_HEADER_STORAGE_OFFSET) + storageKey;\n  } else {\n    position = VERKLE_MAIN_STORAGE_OFFSET + storageKey;\n  }\n  const treeIndex = position / BigInt(VERKLE_NODE_WIDTH);\n  const subIndex = Number(position % BigInt(VERKLE_NODE_WIDTH));\n  return {\n    treeIndex,\n    subIndex\n  };\n}\nexport function getVerkleTreeIndicesForCodeChunk(chunkId) {\n  const treeIndex = Math.floor((VERKLE_CODE_OFFSET + chunkId) / VERKLE_NODE_WIDTH);\n  const subIndex = (VERKLE_CODE_OFFSET + chunkId) % VERKLE_NODE_WIDTH;\n  return {\n    treeIndex,\n    subIndex\n  };\n}\nexport const getVerkleTreeKeyForCodeChunk = async (address, chunkId, verkleCrypto) => {\n  const {\n    treeIndex,\n    subIndex\n  } = getVerkleTreeIndicesForCodeChunk(chunkId);\n  return concatBytes(getVerkleStem(verkleCrypto, address, treeIndex), toBytes(subIndex));\n};\nexport const chunkifyCode = code => {\n  // Pad code to multiple of 31 bytes\n  if (code.length % 31 !== 0) {\n    const paddingLength = 31 - code.length % 31;\n    code = setLengthRight(code, code.length + paddingLength);\n  }\n  throw new Error('Not implemented');\n};\nexport const getVerkleTreeKeyForStorageSlot = async (address, storageKey, verkleCrypto) => {\n  const {\n    treeIndex,\n    subIndex\n  } = getVerkleTreeIndexesForStorageSlot(storageKey);\n  return concatBytes(getVerkleStem(verkleCrypto, address, treeIndex), toBytes(subIndex));\n};\n//# sourceMappingURL=verkle.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}