{"ast":null,"code":"/**\n * Utility function that works like `Object.apply`, but copies getters and setters properly as well.  Additionally gives\n * the option to exclude properties by name.\n */\nconst copyProps = (dest, src, exclude = []) => {\n  const props = Object.getOwnPropertyDescriptors(src);\n  for (let prop of exclude) delete props[prop];\n  Object.defineProperties(dest, props);\n};\n/**\n * Returns the full chain of prototypes up until Object.prototype given a starting object.  The order of prototypes will\n * be closest to farthest in the chain.\n */\nconst protoChain = (obj, currentChain = [obj]) => {\n  const proto = Object.getPrototypeOf(obj);\n  if (proto === null) return currentChain;\n  return protoChain(proto, [...currentChain, proto]);\n};\n/**\n * Identifies the nearest ancestor common to all the given objects in their prototype chains.  For most unrelated\n * objects, this function should return Object.prototype.\n */\nconst nearestCommonProto = (...objs) => {\n  if (objs.length === 0) return undefined;\n  let commonProto = undefined;\n  const protoChains = objs.map(obj => protoChain(obj));\n  while (protoChains.every(protoChain => protoChain.length > 0)) {\n    const protos = protoChains.map(protoChain => protoChain.pop());\n    const potentialCommonProto = protos[0];\n    if (protos.every(proto => proto === potentialCommonProto)) commonProto = potentialCommonProto;else break;\n  }\n  return commonProto;\n};\n/**\n * Creates a new prototype object that is a mixture of the given prototypes.  The mixing is achieved by first\n * identifying the nearest common ancestor and using it as the prototype for a new object.  Then all properties/methods\n * downstream of this prototype (ONLY downstream) are copied into the new object.\n *\n * The resulting prototype is more performant than softMixProtos(...), as well as ES5 compatible.  However, it's not as\n * flexible as updates to the source prototypes aren't captured by the mixed result.  See softMixProtos for why you may\n * want to use that instead.\n */\nconst hardMixProtos = (ingredients, constructor, exclude = []) => {\n  var _a;\n  const base = (_a = nearestCommonProto(...ingredients)) !== null && _a !== void 0 ? _a : Object.prototype;\n  const mixedProto = Object.create(base);\n  // Keeps track of prototypes we've already visited to avoid copying the same properties multiple times.  We init the\n  // list with the proto chain below the nearest common ancestor because we don't want any of those methods mixed in\n  // when they will already be accessible via prototype access.\n  const visitedProtos = protoChain(base);\n  for (let prototype of ingredients) {\n    let protos = protoChain(prototype);\n    // Apply the prototype chain in reverse order so that old methods don't override newer ones.\n    for (let i = protos.length - 1; i >= 0; i--) {\n      let newProto = protos[i];\n      if (visitedProtos.indexOf(newProto) === -1) {\n        copyProps(mixedProto, newProto, ['constructor', ...exclude]);\n        visitedProtos.push(newProto);\n      }\n    }\n  }\n  mixedProto.constructor = constructor;\n  return mixedProto;\n};\nconst unique = arr => arr.filter((e, i) => arr.indexOf(e) == i);\n\n/**\n * Finds the ingredient with the given prop, searching in reverse order and breadth-first if searching ingredient\n * prototypes is required.\n */\nconst getIngredientWithProp = (prop, ingredients) => {\n  const protoChains = ingredients.map(ingredient => protoChain(ingredient));\n  // since we search breadth-first, we need to keep track of our depth in the prototype chains\n  let protoDepth = 0;\n  // not all prototype chains are the same depth, so this remains true as long as at least one of the ingredients'\n  // prototype chains has an object at this depth\n  let protosAreLeftToSearch = true;\n  while (protosAreLeftToSearch) {\n    // with the start of each horizontal slice, we assume this is the one that's deeper than any of the proto chains\n    protosAreLeftToSearch = false;\n    // scan through the ingredients right to left\n    for (let i = ingredients.length - 1; i >= 0; i--) {\n      const searchTarget = protoChains[i][protoDepth];\n      if (searchTarget !== undefined && searchTarget !== null) {\n        // if we find something, this is proof that this horizontal slice potentially more objects to search\n        protosAreLeftToSearch = true;\n        // eureka, we found it\n        if (Object.getOwnPropertyDescriptor(searchTarget, prop) != undefined) {\n          return protoChains[i][0];\n        }\n      }\n    }\n    protoDepth++;\n  }\n  return undefined;\n};\n/**\n * \"Mixes\" ingredients by wrapping them in a Proxy.  The optional prototype argument allows the mixed object to sit\n * downstream of an existing prototype chain.  Note that \"properties\" cannot be added, deleted, or modified.\n */\nconst proxyMix = (ingredients, prototype = Object.prototype) => new Proxy({}, {\n  getPrototypeOf() {\n    return prototype;\n  },\n  setPrototypeOf() {\n    throw Error('Cannot set prototype of Proxies created by ts-mixer');\n  },\n  getOwnPropertyDescriptor(_, prop) {\n    return Object.getOwnPropertyDescriptor(getIngredientWithProp(prop, ingredients) || {}, prop);\n  },\n  defineProperty() {\n    throw new Error('Cannot define new properties on Proxies created by ts-mixer');\n  },\n  has(_, prop) {\n    return getIngredientWithProp(prop, ingredients) !== undefined || prototype[prop] !== undefined;\n  },\n  get(_, prop) {\n    return (getIngredientWithProp(prop, ingredients) || prototype)[prop];\n  },\n  set(_, prop, val) {\n    const ingredientWithProp = getIngredientWithProp(prop, ingredients);\n    if (ingredientWithProp === undefined) throw new Error('Cannot set new properties on Proxies created by ts-mixer');\n    ingredientWithProp[prop] = val;\n    return true;\n  },\n  deleteProperty() {\n    throw new Error('Cannot delete properties on Proxies created by ts-mixer');\n  },\n  ownKeys() {\n    return ingredients.map(Object.getOwnPropertyNames).reduce((prev, curr) => curr.concat(prev.filter(key => curr.indexOf(key) < 0)));\n  }\n});\n/**\n * Creates a new proxy-prototype object that is a \"soft\" mixture of the given prototypes.  The mixing is achieved by\n * proxying all property access to the ingredients.  This is not ES5 compatible and less performant.  However, any\n * changes made to the source prototypes will be reflected in the proxy-prototype, which may be desirable.\n */\nconst softMixProtos = (ingredients, constructor) => proxyMix([...ingredients, {\n  constructor\n}]);\nconst settings = {\n  initFunction: null,\n  staticsStrategy: 'copy',\n  prototypeStrategy: 'copy',\n  decoratorInheritance: 'deep'\n};\n\n// Keeps track of constituent classes for every mixin class created by ts-mixer.\nconst mixins = new WeakMap();\nconst getMixinsForClass = clazz => mixins.get(clazz);\nconst registerMixins = (mixedClass, constituents) => mixins.set(mixedClass, constituents);\nconst hasMixin = (instance, mixin) => {\n  if (instance instanceof mixin) return true;\n  const constructor = instance.constructor;\n  const visited = new Set();\n  let frontier = new Set();\n  frontier.add(constructor);\n  while (frontier.size > 0) {\n    // check if the frontier has the mixin we're looking for.  if not, we can say we visited every item in the frontier\n    if (frontier.has(mixin)) return true;\n    frontier.forEach(item => visited.add(item));\n    // build a new frontier based on the associated mixin classes and prototype chains of each frontier item\n    const newFrontier = new Set();\n    frontier.forEach(item => {\n      var _a;\n      const itemConstituents = (_a = mixins.get(item)) !== null && _a !== void 0 ? _a : protoChain(item.prototype).map(proto => proto.constructor).filter(item => item !== null);\n      if (itemConstituents) itemConstituents.forEach(constituent => {\n        if (!visited.has(constituent) && !frontier.has(constituent)) newFrontier.add(constituent);\n      });\n    });\n    // we have a new frontier, now search again\n    frontier = newFrontier;\n  }\n  // if we get here, we couldn't find the mixin anywhere in the prototype chain or associated mixin classes\n  return false;\n};\nconst mergeObjectsOfDecorators = (o1, o2) => {\n  var _a, _b;\n  const allKeys = unique([...Object.getOwnPropertyNames(o1), ...Object.getOwnPropertyNames(o2)]);\n  const mergedObject = {};\n  for (let key of allKeys) mergedObject[key] = unique([...((_a = o1 === null || o1 === void 0 ? void 0 : o1[key]) !== null && _a !== void 0 ? _a : []), ...((_b = o2 === null || o2 === void 0 ? void 0 : o2[key]) !== null && _b !== void 0 ? _b : [])]);\n  return mergedObject;\n};\nconst mergePropertyAndMethodDecorators = (d1, d2) => {\n  var _a, _b, _c, _d;\n  return {\n    property: mergeObjectsOfDecorators((_a = d1 === null || d1 === void 0 ? void 0 : d1.property) !== null && _a !== void 0 ? _a : {}, (_b = d2 === null || d2 === void 0 ? void 0 : d2.property) !== null && _b !== void 0 ? _b : {}),\n    method: mergeObjectsOfDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.method) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.method) !== null && _d !== void 0 ? _d : {})\n  };\n};\nconst mergeDecorators = (d1, d2) => {\n  var _a, _b, _c, _d, _e, _f;\n  return {\n    class: unique([...((_a = d1 === null || d1 === void 0 ? void 0 : d1.class) !== null && _a !== void 0 ? _a : []), ...((_b = d2 === null || d2 === void 0 ? void 0 : d2.class) !== null && _b !== void 0 ? _b : [])]),\n    static: mergePropertyAndMethodDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.static) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.static) !== null && _d !== void 0 ? _d : {}),\n    instance: mergePropertyAndMethodDecorators((_e = d1 === null || d1 === void 0 ? void 0 : d1.instance) !== null && _e !== void 0 ? _e : {}, (_f = d2 === null || d2 === void 0 ? void 0 : d2.instance) !== null && _f !== void 0 ? _f : {})\n  };\n};\nconst decorators = new Map();\nconst findAllConstituentClasses = (...classes) => {\n  var _a;\n  const allClasses = new Set();\n  const frontier = new Set([...classes]);\n  while (frontier.size > 0) {\n    for (let clazz of frontier) {\n      const protoChainClasses = protoChain(clazz.prototype).map(proto => proto.constructor);\n      const mixinClasses = (_a = getMixinsForClass(clazz)) !== null && _a !== void 0 ? _a : [];\n      const potentiallyNewClasses = [...protoChainClasses, ...mixinClasses];\n      const newClasses = potentiallyNewClasses.filter(c => !allClasses.has(c));\n      for (let newClass of newClasses) frontier.add(newClass);\n      allClasses.add(clazz);\n      frontier.delete(clazz);\n    }\n  }\n  return [...allClasses];\n};\nconst deepDecoratorSearch = (...classes) => {\n  const decoratorsForClassChain = findAllConstituentClasses(...classes).map(clazz => decorators.get(clazz)).filter(decorators => !!decorators);\n  if (decoratorsForClassChain.length == 0) return {};\n  if (decoratorsForClassChain.length == 1) return decoratorsForClassChain[0];\n  return decoratorsForClassChain.reduce((d1, d2) => mergeDecorators(d1, d2));\n};\nconst directDecoratorSearch = (...classes) => {\n  const classDecorators = classes.map(clazz => getDecoratorsForClass(clazz));\n  if (classDecorators.length === 0) return {};\n  if (classDecorators.length === 1) return classDecorators[0];\n  return classDecorators.reduce((d1, d2) => mergeDecorators(d1, d2));\n};\nconst getDecoratorsForClass = clazz => {\n  let decoratorsForClass = decorators.get(clazz);\n  if (!decoratorsForClass) {\n    decoratorsForClass = {};\n    decorators.set(clazz, decoratorsForClass);\n  }\n  return decoratorsForClass;\n};\nconst decorateClass = decorator => clazz => {\n  const decoratorsForClass = getDecoratorsForClass(clazz);\n  let classDecorators = decoratorsForClass.class;\n  if (!classDecorators) {\n    classDecorators = [];\n    decoratorsForClass.class = classDecorators;\n  }\n  classDecorators.push(decorator);\n  return decorator(clazz);\n};\nconst decorateMember = decorator => (object, key, ...otherArgs) => {\n  var _a, _b, _c;\n  const decoratorTargetType = typeof object === 'function' ? 'static' : 'instance';\n  const decoratorType = typeof object[key] === 'function' ? 'method' : 'property';\n  const clazz = decoratorTargetType === 'static' ? object : object.constructor;\n  const decoratorsForClass = getDecoratorsForClass(clazz);\n  const decoratorsForTargetType = (_a = decoratorsForClass === null || decoratorsForClass === void 0 ? void 0 : decoratorsForClass[decoratorTargetType]) !== null && _a !== void 0 ? _a : {};\n  decoratorsForClass[decoratorTargetType] = decoratorsForTargetType;\n  let decoratorsForType = (_b = decoratorsForTargetType === null || decoratorsForTargetType === void 0 ? void 0 : decoratorsForTargetType[decoratorType]) !== null && _b !== void 0 ? _b : {};\n  decoratorsForTargetType[decoratorType] = decoratorsForType;\n  let decoratorsForKey = (_c = decoratorsForType === null || decoratorsForType === void 0 ? void 0 : decoratorsForType[key]) !== null && _c !== void 0 ? _c : [];\n  decoratorsForType[key] = decoratorsForKey;\n  // @ts-ignore: array is type `A[] | B[]` and item is type `A | B`, so technically a type error, but it's fine\n  decoratorsForKey.push(decorator);\n  // @ts-ignore\n  return decorator(object, key, ...otherArgs);\n};\nconst decorate = decorator => (...args) => {\n  if (args.length === 1) return decorateClass(decorator)(args[0]);\n  return decorateMember(decorator)(...args);\n};\nfunction Mixin(...constructors) {\n  var _a, _b, _c;\n  const prototypes = constructors.map(constructor => constructor.prototype);\n  // Here we gather up the init functions of the ingredient prototypes, combine them into one init function, and\n  // attach it to the mixed class prototype.  The reason we do this is because we want the init functions to mix\n  // similarly to constructors -- not methods, which simply override each other.\n  const initFunctionName = settings.initFunction;\n  if (initFunctionName !== null) {\n    const initFunctions = prototypes.map(proto => proto[initFunctionName]).filter(func => typeof func === 'function');\n    const combinedInitFunction = function (...args) {\n      for (let initFunction of initFunctions) initFunction.apply(this, args);\n    };\n    const extraProto = {\n      [initFunctionName]: combinedInitFunction\n    };\n    prototypes.push(extraProto);\n  }\n  function MixedClass(...args) {\n    for (const constructor of constructors)\n    // @ts-ignore: potentially abstract class\n    copyProps(this, new constructor(...args));\n    if (initFunctionName !== null && typeof this[initFunctionName] === 'function') this[initFunctionName].apply(this, args);\n  }\n  MixedClass.prototype = settings.prototypeStrategy === 'copy' ? hardMixProtos(prototypes, MixedClass) : softMixProtos(prototypes, MixedClass);\n  Object.setPrototypeOf(MixedClass, settings.staticsStrategy === 'copy' ? hardMixProtos(constructors, null, ['prototype']) : proxyMix(constructors, Function.prototype));\n  let DecoratedMixedClass = MixedClass;\n  if (settings.decoratorInheritance !== 'none') {\n    const classDecorators = settings.decoratorInheritance === 'deep' ? deepDecoratorSearch(...constructors) : directDecoratorSearch(...constructors);\n    for (let decorator of (_a = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.class) !== null && _a !== void 0 ? _a : []) {\n      const result = decorator(DecoratedMixedClass);\n      if (result) {\n        DecoratedMixedClass = result;\n      }\n    }\n    applyPropAndMethodDecorators((_b = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.static) !== null && _b !== void 0 ? _b : {}, DecoratedMixedClass);\n    applyPropAndMethodDecorators((_c = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.instance) !== null && _c !== void 0 ? _c : {}, DecoratedMixedClass.prototype);\n  }\n  registerMixins(DecoratedMixedClass, constructors);\n  return DecoratedMixedClass;\n}\nconst applyPropAndMethodDecorators = (propAndMethodDecorators, target) => {\n  const propDecorators = propAndMethodDecorators.property;\n  const methodDecorators = propAndMethodDecorators.method;\n  if (propDecorators) for (let key in propDecorators) for (let decorator of propDecorators[key]) decorator(target, key);\n  if (methodDecorators) for (let key in methodDecorators) for (let decorator of methodDecorators[key]) decorator(target, key, Object.getOwnPropertyDescriptor(target, key));\n};\n/**\n * A decorator version of the `Mixin` function.  You'll want to use this instead of `Mixin` for mixing generic classes.\n */\nconst mix = (...ingredients) => decoratedClass => {\n  // @ts-ignore\n  const mixedClass = Mixin(...ingredients.concat([decoratedClass]));\n  Object.defineProperty(mixedClass, 'name', {\n    value: decoratedClass.name,\n    writable: false\n  });\n  return mixedClass;\n};\nexport { Mixin, decorate, hasMixin, mix, settings };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}