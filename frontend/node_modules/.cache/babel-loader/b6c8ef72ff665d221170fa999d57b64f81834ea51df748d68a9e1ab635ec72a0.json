{"ast":null,"code":"import { parseAccount } from '../accounts/utils/parseAccount.js';\nimport { panicReasons } from '../constants/solidity.js';\nimport { decodeErrorResult } from '../utils/abi/decodeErrorResult.js';\nimport { formatAbiItem } from '../utils/abi/formatAbiItem.js';\nimport { formatAbiItemWithArgs } from '../utils/abi/formatAbiItemWithArgs.js';\nimport { getAbiItem } from '../utils/abi/getAbiItem.js';\nimport { formatEther } from '../utils/unit/formatEther.js';\nimport { formatGwei } from '../utils/unit/formatGwei.js';\nimport { AbiErrorSignatureNotFoundError } from './abi.js';\nimport { BaseError } from './base.js';\nimport { prettyStateOverride } from './stateOverride.js';\nimport { prettyPrint } from './transaction.js';\nimport { getContractAddress } from './utils.js';\nexport class CallExecutionError extends BaseError {\n  constructor(cause, {\n    account: account_,\n    docsPath,\n    chain,\n    data,\n    gas,\n    gasPrice,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    to,\n    value,\n    stateOverride\n  }) {\n    const account = account_ ? parseAccount(account_) : undefined;\n    let prettyArgs = prettyPrint({\n      from: account?.address,\n      to,\n      value: typeof value !== 'undefined' && `${formatEther(value)} ${chain?.nativeCurrency?.symbol || 'ETH'}`,\n      data,\n      gas,\n      gasPrice: typeof gasPrice !== 'undefined' && `${formatGwei(gasPrice)} gwei`,\n      maxFeePerGas: typeof maxFeePerGas !== 'undefined' && `${formatGwei(maxFeePerGas)} gwei`,\n      maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== 'undefined' && `${formatGwei(maxPriorityFeePerGas)} gwei`,\n      nonce\n    });\n    if (stateOverride) {\n      prettyArgs += `\\n${prettyStateOverride(stateOverride)}`;\n    }\n    super(cause.shortMessage, {\n      cause,\n      docsPath,\n      metaMessages: [...(cause.metaMessages ? [...cause.metaMessages, ' '] : []), 'Raw Call Arguments:', prettyArgs].filter(Boolean),\n      name: 'CallExecutionError'\n    });\n    Object.defineProperty(this, \"cause\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.cause = cause;\n  }\n}\nexport class ContractFunctionExecutionError extends BaseError {\n  constructor(cause, {\n    abi,\n    args,\n    contractAddress,\n    docsPath,\n    functionName,\n    sender\n  }) {\n    const abiItem = getAbiItem({\n      abi,\n      args,\n      name: functionName\n    });\n    const formattedArgs = abiItem ? formatAbiItemWithArgs({\n      abiItem,\n      args,\n      includeFunctionName: false,\n      includeName: false\n    }) : undefined;\n    const functionWithParams = abiItem ? formatAbiItem(abiItem, {\n      includeName: true\n    }) : undefined;\n    const prettyArgs = prettyPrint({\n      address: contractAddress && getContractAddress(contractAddress),\n      function: functionWithParams,\n      args: formattedArgs && formattedArgs !== '()' && `${[...Array(functionName?.length ?? 0).keys()].map(() => ' ').join('')}${formattedArgs}`,\n      sender\n    });\n    super(cause.shortMessage || `An unknown error occurred while executing the contract function \"${functionName}\".`, {\n      cause,\n      docsPath,\n      metaMessages: [...(cause.metaMessages ? [...cause.metaMessages, ' '] : []), prettyArgs && 'Contract Call:', prettyArgs].filter(Boolean),\n      name: 'ContractFunctionExecutionError'\n    });\n    Object.defineProperty(this, \"abi\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"args\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"cause\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"contractAddress\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"formattedArgs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"functionName\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"sender\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.abi = abi;\n    this.args = args;\n    this.cause = cause;\n    this.contractAddress = contractAddress;\n    this.functionName = functionName;\n    this.sender = sender;\n  }\n}\nexport class ContractFunctionRevertedError extends BaseError {\n  constructor({\n    abi,\n    data,\n    functionName,\n    message\n  }) {\n    let cause;\n    let decodedData = undefined;\n    let metaMessages;\n    let reason;\n    if (data && data !== '0x') {\n      try {\n        decodedData = decodeErrorResult({\n          abi,\n          data\n        });\n        const {\n          abiItem,\n          errorName,\n          args: errorArgs\n        } = decodedData;\n        if (errorName === 'Error') {\n          reason = errorArgs[0];\n        } else if (errorName === 'Panic') {\n          const [firstArg] = errorArgs;\n          reason = panicReasons[firstArg];\n        } else {\n          const errorWithParams = abiItem ? formatAbiItem(abiItem, {\n            includeName: true\n          }) : undefined;\n          const formattedArgs = abiItem && errorArgs ? formatAbiItemWithArgs({\n            abiItem,\n            args: errorArgs,\n            includeFunctionName: false,\n            includeName: false\n          }) : undefined;\n          metaMessages = [errorWithParams ? `Error: ${errorWithParams}` : '', formattedArgs && formattedArgs !== '()' ? `       ${[...Array(errorName?.length ?? 0).keys()].map(() => ' ').join('')}${formattedArgs}` : ''];\n        }\n      } catch (err) {\n        cause = err;\n      }\n    } else if (message) reason = message;\n    let signature;\n    if (cause instanceof AbiErrorSignatureNotFoundError) {\n      signature = cause.signature;\n      metaMessages = [`Unable to decode signature \"${signature}\" as it was not found on the provided ABI.`, 'Make sure you are using the correct ABI and that the error exists on it.', `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`];\n    }\n    super(reason && reason !== 'execution reverted' || signature ? [`The contract function \"${functionName}\" reverted with the following ${signature ? 'signature' : 'reason'}:`, reason || signature].join('\\n') : `The contract function \"${functionName}\" reverted.`, {\n      cause,\n      metaMessages,\n      name: 'ContractFunctionRevertedError'\n    });\n    Object.defineProperty(this, \"data\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"raw\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"reason\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"signature\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.data = decodedData;\n    this.raw = data;\n    this.reason = reason;\n    this.signature = signature;\n  }\n}\nexport class ContractFunctionZeroDataError extends BaseError {\n  constructor({\n    functionName\n  }) {\n    super(`The contract function \"${functionName}\" returned no data (\"0x\").`, {\n      metaMessages: ['This could be due to any of the following:', `  - The contract does not have the function \"${functionName}\",`, '  - The parameters passed to the contract function may be invalid, or', '  - The address is not a contract.'],\n      name: 'ContractFunctionZeroDataError'\n    });\n  }\n}\nexport class CounterfactualDeploymentFailedError extends BaseError {\n  constructor({\n    factory\n  }) {\n    super(`Deployment for counterfactual contract call failed${factory ? ` for factory \"${factory}\".` : ''}`, {\n      metaMessages: ['Please ensure:', '- The `factory` is a valid contract deployment factory (ie. Create2 Factory, ERC-4337 Factory, etc).', '- The `factoryData` is a valid encoded function call for contract deployment function on the factory.'],\n      name: 'CounterfactualDeploymentFailedError'\n    });\n  }\n}\nexport class RawContractError extends BaseError {\n  constructor({\n    data,\n    message\n  }) {\n    super(message || '', {\n      name: 'RawContractError'\n    });\n    Object.defineProperty(this, \"code\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 3\n    });\n    Object.defineProperty(this, \"data\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.data = data;\n  }\n}\n//# sourceMappingURL=contract.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}