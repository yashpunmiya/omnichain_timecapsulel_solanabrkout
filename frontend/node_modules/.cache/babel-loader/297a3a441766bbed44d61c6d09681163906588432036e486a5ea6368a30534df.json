{"ast":null,"code":"import { EventEmitter as m } from \"events\";\nimport o from \"cross-fetch\";\nimport { safeJsonStringify as a, safeJsonParse as y } from \"@walletconnect/safe-json\";\nimport { isHttpUrl as h, formatJsonRpcError as b, parseConnectionError as u } from \"@walletconnect/jsonrpc-utils\";\nvar P = Object.defineProperty,\n  w = Object.defineProperties,\n  E = Object.getOwnPropertyDescriptors,\n  c = Object.getOwnPropertySymbols,\n  L = Object.prototype.hasOwnProperty,\n  O = Object.prototype.propertyIsEnumerable,\n  l = (r, t, e) => t in r ? P(r, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : r[t] = e,\n  p = (r, t) => {\n    for (var e in t || (t = {})) L.call(t, e) && l(r, e, t[e]);\n    if (c) for (var e of c(t)) O.call(t, e) && l(r, e, t[e]);\n    return r;\n  },\n  v = (r, t) => w(r, E(t));\nconst j = {\n    Accept: \"application/json\",\n    \"Content-Type\": \"application/json\"\n  },\n  T = \"POST\",\n  d = {\n    headers: j,\n    method: T\n  },\n  g = 10;\nclass f {\n  constructor(t, e = !1) {\n    if (this.url = t, this.disableProviderPing = e, this.events = new m(), this.isAvailable = !1, this.registering = !1, !h(t)) throw new Error(`Provided URL is not compatible with HTTP connection: ${t}`);\n    this.url = t, this.disableProviderPing = e;\n  }\n  get connected() {\n    return this.isAvailable;\n  }\n  get connecting() {\n    return this.registering;\n  }\n  on(t, e) {\n    this.events.on(t, e);\n  }\n  once(t, e) {\n    this.events.once(t, e);\n  }\n  off(t, e) {\n    this.events.off(t, e);\n  }\n  removeListener(t, e) {\n    this.events.removeListener(t, e);\n  }\n  async open(t = this.url) {\n    await this.register(t);\n  }\n  async close() {\n    if (!this.isAvailable) throw new Error(\"Connection already closed\");\n    this.onClose();\n  }\n  async send(t) {\n    this.isAvailable || (await this.register());\n    try {\n      const e = a(t),\n        s = await (await o(this.url, v(p({}, d), {\n          body: e\n        }))).json();\n      this.onPayload({\n        data: s\n      });\n    } catch (e) {\n      this.onError(t.id, e);\n    }\n  }\n  async register(t = this.url) {\n    if (!h(t)) throw new Error(`Provided URL is not compatible with HTTP connection: ${t}`);\n    if (this.registering) {\n      const e = this.events.getMaxListeners();\n      return (this.events.listenerCount(\"register_error\") >= e || this.events.listenerCount(\"open\") >= e) && this.events.setMaxListeners(e + 1), new Promise((s, i) => {\n        this.events.once(\"register_error\", n => {\n          this.resetMaxListeners(), i(n);\n        }), this.events.once(\"open\", () => {\n          if (this.resetMaxListeners(), typeof this.isAvailable > \"u\") return i(new Error(\"HTTP connection is missing or invalid\"));\n          s();\n        });\n      });\n    }\n    this.url = t, this.registering = !0;\n    try {\n      if (!this.disableProviderPing) {\n        const e = a({\n          id: 1,\n          jsonrpc: \"2.0\",\n          method: \"test\",\n          params: []\n        });\n        await o(t, v(p({}, d), {\n          body: e\n        }));\n      }\n      this.onOpen();\n    } catch (e) {\n      const s = this.parseError(e);\n      throw this.events.emit(\"register_error\", s), this.onClose(), s;\n    }\n  }\n  onOpen() {\n    this.isAvailable = !0, this.registering = !1, this.events.emit(\"open\");\n  }\n  onClose() {\n    this.isAvailable = !1, this.registering = !1, this.events.emit(\"close\");\n  }\n  onPayload(t) {\n    if (typeof t.data > \"u\") return;\n    const e = typeof t.data == \"string\" ? y(t.data) : t.data;\n    this.events.emit(\"payload\", e);\n  }\n  onError(t, e) {\n    const s = this.parseError(e),\n      i = s.message || s.toString(),\n      n = b(t, i);\n    this.events.emit(\"payload\", n);\n  }\n  parseError(t, e = this.url) {\n    return u(t, e, \"HTTP\");\n  }\n  resetMaxListeners() {\n    this.events.getMaxListeners() > g && this.events.setMaxListeners(g);\n  }\n}\nexport { f as HttpConnection, f as default };\n//# sourceMappingURL=index.es.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}