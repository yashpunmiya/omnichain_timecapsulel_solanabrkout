{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ValueCheckUnknownTypeError = void 0;\nexports.Check = Check;\nconst index_1 = require(\"../../system/index\");\nconst index_2 = require(\"../deref/index\");\nconst index_3 = require(\"../hash/index\");\nconst index_4 = require(\"../../type/symbols/index\");\nconst index_5 = require(\"../../type/keyof/index\");\nconst index_6 = require(\"../../type/extends/index\");\nconst index_7 = require(\"../../type/registry/index\");\nconst index_8 = require(\"../../type/error/index\");\nconst index_9 = require(\"../../type/never/index\");\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\nconst index_10 = require(\"../guard/index\");\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nconst type_1 = require(\"../../type/guard/type\");\n// ------------------------------------------------------------------\n// Errors\n// ------------------------------------------------------------------\nclass ValueCheckUnknownTypeError extends index_8.TypeBoxError {\n  constructor(schema) {\n    super(`Unknown type`);\n    this.schema = schema;\n  }\n}\nexports.ValueCheckUnknownTypeError = ValueCheckUnknownTypeError;\n// ------------------------------------------------------------------\n// TypeGuards\n// ------------------------------------------------------------------\nfunction IsAnyOrUnknown(schema) {\n  return schema[index_4.Kind] === 'Any' || schema[index_4.Kind] === 'Unknown';\n}\n// ------------------------------------------------------------------\n// Guards\n// ------------------------------------------------------------------\nfunction IsDefined(value) {\n  return value !== undefined;\n}\n// ------------------------------------------------------------------\n// Types\n// ------------------------------------------------------------------\nfunction FromAny(schema, references, value) {\n  return true;\n}\nfunction FromArray(schema, references, value) {\n  if (!(0, index_10.IsArray)(value)) return false;\n  if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {\n    return false;\n  }\n  if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {\n    return false;\n  }\n  if (!value.every(value => Visit(schema.items, references, value))) {\n    return false;\n  }\n  // prettier-ignore\n  if (schema.uniqueItems === true && !function () {\n    const set = new Set();\n    for (const element of value) {\n      const hashed = (0, index_3.Hash)(element);\n      if (set.has(hashed)) {\n        return false;\n      } else {\n        set.add(hashed);\n      }\n    }\n    return true;\n  }()) {\n    return false;\n  }\n  // contains\n  if (!(IsDefined(schema.contains) || (0, index_10.IsNumber)(schema.minContains) || (0, index_10.IsNumber)(schema.maxContains))) {\n    return true; // exit\n  }\n  const containsSchema = IsDefined(schema.contains) ? schema.contains : (0, index_9.Never)();\n  const containsCount = value.reduce((acc, value) => Visit(containsSchema, references, value) ? acc + 1 : acc, 0);\n  if (containsCount === 0) {\n    return false;\n  }\n  if ((0, index_10.IsNumber)(schema.minContains) && containsCount < schema.minContains) {\n    return false;\n  }\n  if ((0, index_10.IsNumber)(schema.maxContains) && containsCount > schema.maxContains) {\n    return false;\n  }\n  return true;\n}\nfunction FromAsyncIterator(schema, references, value) {\n  return (0, index_10.IsAsyncIterator)(value);\n}\nfunction FromBigInt(schema, references, value) {\n  if (!(0, index_10.IsBigInt)(value)) return false;\n  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n    return false;\n  }\n  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n    return false;\n  }\n  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n    return false;\n  }\n  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n    return false;\n  }\n  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {\n    return false;\n  }\n  return true;\n}\nfunction FromBoolean(schema, references, value) {\n  return (0, index_10.IsBoolean)(value);\n}\nfunction FromConstructor(schema, references, value) {\n  return Visit(schema.returns, references, value.prototype);\n}\nfunction FromDate(schema, references, value) {\n  if (!(0, index_10.IsDate)(value)) return false;\n  if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {\n    return false;\n  }\n  if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {\n    return false;\n  }\n  if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {\n    return false;\n  }\n  if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {\n    return false;\n  }\n  if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {\n    return false;\n  }\n  return true;\n}\nfunction FromFunction(schema, references, value) {\n  return (0, index_10.IsFunction)(value);\n}\nfunction FromInteger(schema, references, value) {\n  if (!(0, index_10.IsInteger)(value)) {\n    return false;\n  }\n  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n    return false;\n  }\n  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n    return false;\n  }\n  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n    return false;\n  }\n  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n    return false;\n  }\n  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n    return false;\n  }\n  return true;\n}\nfunction FromIntersect(schema, references, value) {\n  const check1 = schema.allOf.every(schema => Visit(schema, references, value));\n  if (schema.unevaluatedProperties === false) {\n    const keyPattern = new RegExp((0, index_5.KeyOfPattern)(schema));\n    const check2 = Object.getOwnPropertyNames(value).every(key => keyPattern.test(key));\n    return check1 && check2;\n  } else if ((0, type_1.IsSchema)(schema.unevaluatedProperties)) {\n    const keyCheck = new RegExp((0, index_5.KeyOfPattern)(schema));\n    const check2 = Object.getOwnPropertyNames(value).every(key => keyCheck.test(key) || Visit(schema.unevaluatedProperties, references, value[key]));\n    return check1 && check2;\n  } else {\n    return check1;\n  }\n}\nfunction FromIterator(schema, references, value) {\n  return (0, index_10.IsIterator)(value);\n}\nfunction FromLiteral(schema, references, value) {\n  return value === schema.const;\n}\nfunction FromNever(schema, references, value) {\n  return false;\n}\nfunction FromNot(schema, references, value) {\n  return !Visit(schema.not, references, value);\n}\nfunction FromNull(schema, references, value) {\n  return (0, index_10.IsNull)(value);\n}\nfunction FromNumber(schema, references, value) {\n  if (!index_1.TypeSystemPolicy.IsNumberLike(value)) return false;\n  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n    return false;\n  }\n  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n    return false;\n  }\n  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n    return false;\n  }\n  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n    return false;\n  }\n  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n    return false;\n  }\n  return true;\n}\nfunction FromObject(schema, references, value) {\n  if (!index_1.TypeSystemPolicy.IsObjectLike(value)) return false;\n  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n    return false;\n  }\n  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n    return false;\n  }\n  const knownKeys = Object.getOwnPropertyNames(schema.properties);\n  for (const knownKey of knownKeys) {\n    const property = schema.properties[knownKey];\n    if (schema.required && schema.required.includes(knownKey)) {\n      if (!Visit(property, references, value[knownKey])) {\n        return false;\n      }\n      if (((0, index_6.ExtendsUndefinedCheck)(property) || IsAnyOrUnknown(property)) && !(knownKey in value)) {\n        return false;\n      }\n    } else {\n      if (index_1.TypeSystemPolicy.IsExactOptionalProperty(value, knownKey) && !Visit(property, references, value[knownKey])) {\n        return false;\n      }\n    }\n  }\n  if (schema.additionalProperties === false) {\n    const valueKeys = Object.getOwnPropertyNames(value);\n    // optimization: value is valid if schemaKey length matches the valueKey length\n    if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {\n      return true;\n    } else {\n      return valueKeys.every(valueKey => knownKeys.includes(valueKey));\n    }\n  } else if (typeof schema.additionalProperties === 'object') {\n    const valueKeys = Object.getOwnPropertyNames(value);\n    return valueKeys.every(key => knownKeys.includes(key) || Visit(schema.additionalProperties, references, value[key]));\n  } else {\n    return true;\n  }\n}\nfunction FromPromise(schema, references, value) {\n  return (0, index_10.IsPromise)(value);\n}\nfunction FromRecord(schema, references, value) {\n  if (!index_1.TypeSystemPolicy.IsRecordLike(value)) {\n    return false;\n  }\n  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n    return false;\n  }\n  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n    return false;\n  }\n  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];\n  const regex = new RegExp(patternKey);\n  // prettier-ignore\n  const check1 = Object.entries(value).every(([key, value]) => {\n    return regex.test(key) ? Visit(patternSchema, references, value) : true;\n  });\n  // prettier-ignore\n  const check2 = typeof schema.additionalProperties === 'object' ? Object.entries(value).every(([key, value]) => {\n    return !regex.test(key) ? Visit(schema.additionalProperties, references, value) : true;\n  }) : true;\n  const check3 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value).every(key => {\n    return regex.test(key);\n  }) : true;\n  return check1 && check2 && check3;\n}\nfunction FromRef(schema, references, value) {\n  return Visit((0, index_2.Deref)(schema, references), references, value);\n}\nfunction FromRegExp(schema, references, value) {\n  const regex = new RegExp(schema.source, schema.flags);\n  if (IsDefined(schema.minLength)) {\n    if (!(value.length >= schema.minLength)) return false;\n  }\n  if (IsDefined(schema.maxLength)) {\n    if (!(value.length <= schema.maxLength)) return false;\n  }\n  return regex.test(value);\n}\nfunction FromString(schema, references, value) {\n  if (!(0, index_10.IsString)(value)) {\n    return false;\n  }\n  if (IsDefined(schema.minLength)) {\n    if (!(value.length >= schema.minLength)) return false;\n  }\n  if (IsDefined(schema.maxLength)) {\n    if (!(value.length <= schema.maxLength)) return false;\n  }\n  if (IsDefined(schema.pattern)) {\n    const regex = new RegExp(schema.pattern);\n    if (!regex.test(value)) return false;\n  }\n  if (IsDefined(schema.format)) {\n    if (!index_7.FormatRegistry.Has(schema.format)) return false;\n    const func = index_7.FormatRegistry.Get(schema.format);\n    return func(value);\n  }\n  return true;\n}\nfunction FromSymbol(schema, references, value) {\n  return (0, index_10.IsSymbol)(value);\n}\nfunction FromTemplateLiteral(schema, references, value) {\n  return (0, index_10.IsString)(value) && new RegExp(schema.pattern).test(value);\n}\nfunction FromThis(schema, references, value) {\n  return Visit((0, index_2.Deref)(schema, references), references, value);\n}\nfunction FromTuple(schema, references, value) {\n  if (!(0, index_10.IsArray)(value)) {\n    return false;\n  }\n  if (schema.items === undefined && !(value.length === 0)) {\n    return false;\n  }\n  if (!(value.length === schema.maxItems)) {\n    return false;\n  }\n  if (!schema.items) {\n    return true;\n  }\n  for (let i = 0; i < schema.items.length; i++) {\n    if (!Visit(schema.items[i], references, value[i])) return false;\n  }\n  return true;\n}\nfunction FromUndefined(schema, references, value) {\n  return (0, index_10.IsUndefined)(value);\n}\nfunction FromUnion(schema, references, value) {\n  return schema.anyOf.some(inner => Visit(inner, references, value));\n}\nfunction FromUint8Array(schema, references, value) {\n  if (!(0, index_10.IsUint8Array)(value)) {\n    return false;\n  }\n  if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {\n    return false;\n  }\n  if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {\n    return false;\n  }\n  return true;\n}\nfunction FromUnknown(schema, references, value) {\n  return true;\n}\nfunction FromVoid(schema, references, value) {\n  return index_1.TypeSystemPolicy.IsVoidLike(value);\n}\nfunction FromKind(schema, references, value) {\n  if (!index_7.TypeRegistry.Has(schema[index_4.Kind])) return false;\n  const func = index_7.TypeRegistry.Get(schema[index_4.Kind]);\n  return func(schema, value);\n}\nfunction Visit(schema, references, value) {\n  const references_ = IsDefined(schema.$id) ? [...references, schema] : references;\n  const schema_ = schema;\n  switch (schema_[index_4.Kind]) {\n    case 'Any':\n      return FromAny(schema_, references_, value);\n    case 'Array':\n      return FromArray(schema_, references_, value);\n    case 'AsyncIterator':\n      return FromAsyncIterator(schema_, references_, value);\n    case 'BigInt':\n      return FromBigInt(schema_, references_, value);\n    case 'Boolean':\n      return FromBoolean(schema_, references_, value);\n    case 'Constructor':\n      return FromConstructor(schema_, references_, value);\n    case 'Date':\n      return FromDate(schema_, references_, value);\n    case 'Function':\n      return FromFunction(schema_, references_, value);\n    case 'Integer':\n      return FromInteger(schema_, references_, value);\n    case 'Intersect':\n      return FromIntersect(schema_, references_, value);\n    case 'Iterator':\n      return FromIterator(schema_, references_, value);\n    case 'Literal':\n      return FromLiteral(schema_, references_, value);\n    case 'Never':\n      return FromNever(schema_, references_, value);\n    case 'Not':\n      return FromNot(schema_, references_, value);\n    case 'Null':\n      return FromNull(schema_, references_, value);\n    case 'Number':\n      return FromNumber(schema_, references_, value);\n    case 'Object':\n      return FromObject(schema_, references_, value);\n    case 'Promise':\n      return FromPromise(schema_, references_, value);\n    case 'Record':\n      return FromRecord(schema_, references_, value);\n    case 'Ref':\n      return FromRef(schema_, references_, value);\n    case 'RegExp':\n      return FromRegExp(schema_, references_, value);\n    case 'String':\n      return FromString(schema_, references_, value);\n    case 'Symbol':\n      return FromSymbol(schema_, references_, value);\n    case 'TemplateLiteral':\n      return FromTemplateLiteral(schema_, references_, value);\n    case 'This':\n      return FromThis(schema_, references_, value);\n    case 'Tuple':\n      return FromTuple(schema_, references_, value);\n    case 'Undefined':\n      return FromUndefined(schema_, references_, value);\n    case 'Union':\n      return FromUnion(schema_, references_, value);\n    case 'Uint8Array':\n      return FromUint8Array(schema_, references_, value);\n    case 'Unknown':\n      return FromUnknown(schema_, references_, value);\n    case 'Void':\n      return FromVoid(schema_, references_, value);\n    default:\n      if (!index_7.TypeRegistry.Has(schema_[index_4.Kind])) throw new ValueCheckUnknownTypeError(schema_);\n      return FromKind(schema_, references_, value);\n  }\n}\n/** Returns true if the value matches the given type. */\nfunction Check(...args) {\n  return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}