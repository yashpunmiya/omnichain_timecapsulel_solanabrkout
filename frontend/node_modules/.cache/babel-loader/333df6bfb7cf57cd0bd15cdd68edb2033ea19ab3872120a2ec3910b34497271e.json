{"ast":null,"code":"import { EventEmitter as m } from \"events\";\nimport o from \"cross-fetch\";\nimport { safeJsonStringify as a, safeJsonParse as y } from \"@walletconnect/safe-json\";\nimport { isHttpUrl as h, formatJsonRpcError as b, parseConnectionError as u } from \"@walletconnect/jsonrpc-utils\";\nvar P = Object.defineProperty,\n  w = Object.defineProperties,\n  E = Object.getOwnPropertyDescriptors,\n  c = Object.getOwnPropertySymbols,\n  L = Object.prototype.hasOwnProperty,\n  O = Object.prototype.propertyIsEnumerable,\n  l = (r, t, e) => t in r ? P(r, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : r[t] = e,\n  p = (r, t) => {\n    for (var e in t || (t = {})) L.call(t, e) && l(r, e, t[e]);\n    if (c) for (var e of c(t)) O.call(t, e) && l(r, e, t[e]);\n    return r;\n  },\n  v = (r, t) => w(r, E(t));\nconst j = {\n    Accept: \"application/json\",\n    \"Content-Type\": \"application/json\"\n  },\n  T = \"POST\",\n  d = {\n    headers: j,\n    method: T\n  },\n  g = 10;\nclass f {\n  constructor(t, e = !1) {\n    if (this.url = t, this.disableProviderPing = e, this.events = new m(), this.isAvailable = !1, this.registering = !1, !h(t)) throw new Error(`Provided URL is not compatible with HTTP connection: ${t}`);\n    this.url = t, this.disableProviderPing = e;\n  }\n  get connected() {\n    return this.isAvailable;\n  }\n  get connecting() {\n    return this.registering;\n  }\n  on(t, e) {\n    this.events.on(t, e);\n  }\n  once(t, e) {\n    this.events.once(t, e);\n  }\n  off(t, e) {\n    this.events.off(t, e);\n  }\n  removeListener(t, e) {\n    this.events.removeListener(t, e);\n  }\n  async open(t = this.url) {\n    await this.register(t);\n  }\n  async close() {\n    if (!this.isAvailable) throw new Error(\"Connection already closed\");\n    this.onClose();\n  }\n  async send(t) {\n    this.isAvailable || (await this.register());\n    try {\n      const e = a(t),\n        s = await (await o(this.url, v(p({}, d), {\n          body: e\n        }))).json();\n      this.onPayload({\n        data: s\n      });\n    } catch (e) {\n      this.onError(t.id, e);\n    }\n  }\n  async register(t = this.url) {\n    if (!h(t)) throw new Error(`Provided URL is not compatible with HTTP connection: ${t}`);\n    if (this.registering) {\n      const e = this.events.getMaxListeners();\n      return (this.events.listenerCount(\"register_error\") >= e || this.events.listenerCount(\"open\") >= e) && this.events.setMaxListeners(e + 1), new Promise((s, i) => {\n        this.events.once(\"register_error\", n => {\n          this.resetMaxListeners(), i(n);\n        }), this.events.once(\"open\", () => {\n          if (this.resetMaxListeners(), typeof this.isAvailable > \"u\") return i(new Error(\"HTTP connection is missing or invalid\"));\n          s();\n        });\n      });\n    }\n    this.url = t, this.registering = !0;\n    try {\n      if (!this.disableProviderPing) {\n        const e = a({\n          id: 1,\n          jsonrpc: \"2.0\",\n          method: \"test\",\n          params: []\n        });\n        await o(t, v(p({}, d), {\n          body: e\n        }));\n      }\n      this.onOpen();\n    } catch (e) {\n      const s = this.parseError(e);\n      throw this.events.emit(\"register_error\", s), this.onClose(), s;\n    }\n  }\n  onOpen() {\n    this.isAvailable = !0, this.registering = !1, this.events.emit(\"open\");\n  }\n  onClose() {\n    this.isAvailable = !1, this.registering = !1, this.events.emit(\"close\");\n  }\n  onPayload(t) {\n    if (typeof t.data > \"u\") return;\n    const e = typeof t.data == \"string\" ? y(t.data) : t.data;\n    this.events.emit(\"payload\", e);\n  }\n  onError(t, e) {\n    const s = this.parseError(e),\n      i = s.message || s.toString(),\n      n = b(t, i);\n    this.events.emit(\"payload\", n);\n  }\n  parseError(t, e = this.url) {\n    return u(t, e, \"HTTP\");\n  }\n  resetMaxListeners() {\n    this.events.getMaxListeners() > g && this.events.setMaxListeners(g);\n  }\n}\nexport { f as HttpConnection, f as default };","map":{"version":3,"names":[],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\jsonrpc-http-connection\\src\\http.ts"],"sourcesContent":["import { EventEmitter } from \"events\";\nimport fetch from \"cross-fetch\";\nimport { safeJsonParse, safeJsonStringify } from \"@walletconnect/safe-json\";\nimport {\n  formatJsonRpcError,\n  IJsonRpcConnection,\n  JsonRpcPayload,\n  isHttpUrl,\n  parseConnectionError,\n} from \"@walletconnect/jsonrpc-utils\";\n\nconst DEFAULT_HTTP_HEADERS = {\n  Accept: \"application/json\",\n  \"Content-Type\": \"application/json\",\n};\n\nconst DEFAULT_HTTP_METHOD = \"POST\";\n\nconst DEFAULT_FETCH_OPTS = {\n  headers: DEFAULT_HTTP_HEADERS,\n  method: DEFAULT_HTTP_METHOD,\n};\n\n// Source: https://nodejs.org/api/events.html#emittersetmaxlistenersn\nconst EVENT_EMITTER_MAX_LISTENERS_DEFAULT = 10;\n\nexport class HttpConnection implements IJsonRpcConnection {\n  public events = new EventEmitter();\n\n  private isAvailable = false;\n\n  private registering = false;\n\n  constructor(public url: string, public disableProviderPing = false) {\n    if (!isHttpUrl(url)) {\n      throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);\n    }\n    this.url = url;\n    this.disableProviderPing = disableProviderPing;\n  }\n\n  get connected(): boolean {\n    return this.isAvailable;\n  }\n\n  get connecting(): boolean {\n    return this.registering;\n  }\n\n  public on(event: string, listener: any): void {\n    this.events.on(event, listener);\n  }\n\n  public once(event: string, listener: any): void {\n    this.events.once(event, listener);\n  }\n\n  public off(event: string, listener: any): void {\n    this.events.off(event, listener);\n  }\n\n  public removeListener(event: string, listener: any): void {\n    this.events.removeListener(event, listener);\n  }\n\n  public async open(url: string = this.url): Promise<void> {\n    await this.register(url);\n  }\n\n  public async close(): Promise<void> {\n    if (!this.isAvailable) {\n      throw new Error(\"Connection already closed\");\n    }\n    this.onClose();\n  }\n\n  public async send(payload: JsonRpcPayload): Promise<void> {\n    if (!this.isAvailable) {\n      await this.register();\n    }\n    try {\n      const body = safeJsonStringify(payload);\n      const res = await fetch(this.url, { ...DEFAULT_FETCH_OPTS, body });\n      const data = await res.json();\n      this.onPayload({ data });\n    } catch (e) {\n      this.onError(payload.id, e as any);\n    }\n  }\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async register(url = this.url): Promise<void> {\n    if (!isHttpUrl(url)) {\n      throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);\n    }\n    if (this.registering) {\n      const currentMaxListeners = this.events.getMaxListeners();\n      if (\n        this.events.listenerCount(\"register_error\") >= currentMaxListeners ||\n        this.events.listenerCount(\"open\") >= currentMaxListeners\n      ) {\n        this.events.setMaxListeners(currentMaxListeners + 1);\n      }\n      return new Promise((resolve, reject) => {\n        this.events.once(\"register_error\", (error) => {\n          this.resetMaxListeners();\n          reject(error);\n        });\n        this.events.once(\"open\", () => {\n          this.resetMaxListeners();\n          if (typeof this.isAvailable === \"undefined\") {\n            return reject(new Error(\"HTTP connection is missing or invalid\"));\n          }\n          resolve();\n        });\n      });\n    }\n    this.url = url;\n    this.registering = true;\n    try {\n      if (!this.disableProviderPing) {\n        const body = safeJsonStringify({ id: 1, jsonrpc: \"2.0\", method: \"test\", params: [] });\n        await fetch(url, { ...DEFAULT_FETCH_OPTS, body });\n      }\n      this.onOpen();\n    } catch (e) {\n      const error = this.parseError(e as any);\n      this.events.emit(\"register_error\", error);\n      this.onClose();\n      throw error;\n    }\n  }\n\n  private onOpen() {\n    this.isAvailable = true;\n    this.registering = false;\n    this.events.emit(\"open\");\n  }\n\n  private onClose() {\n    this.isAvailable = false;\n    this.registering = false;\n    this.events.emit(\"close\");\n  }\n\n  private onPayload(e: { data: any }) {\n    if (typeof e.data === \"undefined\") return;\n    const payload: JsonRpcPayload = typeof e.data === \"string\" ? safeJsonParse(e.data) : e.data;\n    this.events.emit(\"payload\", payload);\n  }\n\n  private onError(id: number, e: Error) {\n    const error = this.parseError(e);\n    const message = error.message || error.toString();\n    const payload = formatJsonRpcError(id, message);\n    this.events.emit(\"payload\", payload);\n  }\n\n  private parseError(e: Error, url = this.url) {\n    return parseConnectionError(e, url, \"HTTP\");\n  }\n\n  private resetMaxListeners() {\n    if (this.events.getMaxListeners() > EVENT_EMITTER_MAX_LISTENERS_DEFAULT) {\n      this.events.setMaxListeners(EVENT_EMITTER_MAX_LISTENERS_DEFAULT);\n    }\n  }\n}\n\nexport default HttpConnection;\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}