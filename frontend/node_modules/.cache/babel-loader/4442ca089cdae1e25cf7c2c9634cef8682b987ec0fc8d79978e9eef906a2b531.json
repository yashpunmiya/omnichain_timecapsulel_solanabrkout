{"ast":null,"code":"import { InvalidBytesBooleanError } from '../../errors/encoding.js';\nimport { trim } from '../data/trim.js';\nimport { assertSize, hexToBigInt, hexToNumber } from './fromHex.js';\nimport { bytesToHex } from './toHex.js';\n/**\n * Decodes a byte array into a UTF-8 string, hex value, number, bigint or boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes\n * - Example: https://viem.sh/docs/utilities/fromBytes#usage\n *\n * @param bytes Byte array to decode.\n * @param toOrOpts Type to convert to or options.\n * @returns Decoded value.\n *\n * @example\n * import { fromBytes } from 'viem'\n * const data = fromBytes(new Uint8Array([1, 164]), 'number')\n * // 420\n *\n * @example\n * import { fromBytes } from 'viem'\n * const data = fromBytes(\n *   new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]),\n *   'string'\n * )\n * // 'Hello world'\n */\nexport function fromBytes(bytes, toOrOpts) {\n  const opts = typeof toOrOpts === 'string' ? {\n    to: toOrOpts\n  } : toOrOpts;\n  const to = opts.to;\n  if (to === 'number') return bytesToNumber(bytes, opts);\n  if (to === 'bigint') return bytesToBigInt(bytes, opts);\n  if (to === 'boolean') return bytesToBool(bytes, opts);\n  if (to === 'string') return bytesToString(bytes, opts);\n  return bytesToHex(bytes, opts);\n}\n/**\n * Decodes a byte array into a bigint.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestobigint\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns BigInt value.\n *\n * @example\n * import { bytesToBigInt } from 'viem'\n * const data = bytesToBigInt(new Uint8Array([1, 164]))\n * // 420n\n */\nexport function bytesToBigInt(bytes, opts = {}) {\n  if (typeof opts.size !== 'undefined') assertSize(bytes, {\n    size: opts.size\n  });\n  const hex = bytesToHex(bytes, opts);\n  return hexToBigInt(hex, opts);\n}\n/**\n * Decodes a byte array into a boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestobool\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns Boolean value.\n *\n * @example\n * import { bytesToBool } from 'viem'\n * const data = bytesToBool(new Uint8Array([1]))\n * // true\n */\nexport function bytesToBool(bytes_, opts = {}) {\n  let bytes = bytes_;\n  if (typeof opts.size !== 'undefined') {\n    assertSize(bytes, {\n      size: opts.size\n    });\n    bytes = trim(bytes);\n  }\n  if (bytes.length > 1 || bytes[0] > 1) throw new InvalidBytesBooleanError(bytes);\n  return Boolean(bytes[0]);\n}\n/**\n * Decodes a byte array into a number.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestonumber\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns Number value.\n *\n * @example\n * import { bytesToNumber } from 'viem'\n * const data = bytesToNumber(new Uint8Array([1, 164]))\n * // 420\n */\nexport function bytesToNumber(bytes, opts = {}) {\n  if (typeof opts.size !== 'undefined') assertSize(bytes, {\n    size: opts.size\n  });\n  const hex = bytesToHex(bytes, opts);\n  return hexToNumber(hex, opts);\n}\n/**\n * Decodes a byte array into a UTF-8 string.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestostring\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns String value.\n *\n * @example\n * import { bytesToString } from 'viem'\n * const data = bytesToString(new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // 'Hello world'\n */\nexport function bytesToString(bytes_, opts = {}) {\n  let bytes = bytes_;\n  if (typeof opts.size !== 'undefined') {\n    assertSize(bytes, {\n      size: opts.size\n    });\n    bytes = trim(bytes, {\n      dir: 'right'\n    });\n  }\n  return new TextDecoder().decode(bytes);\n}\n//# sourceMappingURL=fromBytes.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}