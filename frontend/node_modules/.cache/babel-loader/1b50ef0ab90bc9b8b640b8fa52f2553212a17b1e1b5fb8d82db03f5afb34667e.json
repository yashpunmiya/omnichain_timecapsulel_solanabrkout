{"ast":null,"code":"import { BaseMessageSignerWalletAdapter, isVersionedTransaction, scopePollingDetectionStrategy, WalletAccountError, WalletConnectionError, WalletDisconnectedError, WalletDisconnectionError, WalletError, WalletNotConnectedError, WalletNotReadyError, WalletPublicKeyError, WalletReadyState, WalletSendTransactionError, WalletSignTransactionError } from '@solana/wallet-adapter-base';\nimport { PublicKey } from '@solana/web3.js';\nexport const CoinbaseWalletName = 'Coinbase Wallet';\nexport class CoinbaseWalletAdapter extends BaseMessageSignerWalletAdapter {\n  constructor(config = {}) {\n    super();\n    this.name = CoinbaseWalletName;\n    this.url = 'https://chrome.google.com/webstore/detail/coinbase-wallet-extension/hnfanknocfeofbddgcijnmhnfnkdnaad';\n    this.icon = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyNCIgaGVpZ2h0PSIxMDI0IiB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8Y2lyY2xlIGN4PSI1MTIiIGN5PSI1MTIiIHI9IjUxMiIgZmlsbD0iIzAwNTJGRiIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE1MiA1MTJDMTUyIDcxMC44MjMgMzEzLjE3NyA4NzIgNTEyIDg3MkM3MTAuODIzIDg3MiA4NzIgNzEwLjgyMyA4NzIgNTEyQzg3MiAzMTMuMTc3IDcxMC44MjMgMTUyIDUxMiAxNTJDMzEzLjE3NyAxNTIgMTUyIDMxMy4xNzcgMTUyIDUxMlpNNDIwIDM5NkM0MDYuNzQ1IDM5NiAzOTYgNDA2Ljc0NSAzOTYgNDIwVjYwNEMzOTYgNjE3LjI1NSA0MDYuNzQ1IDYyOCA0MjAgNjI4SDYwNEM2MTcuMjU1IDYyOCA2MjggNjE3LjI1NSA2MjggNjA0VjQyMEM2MjggNDA2Ljc0NSA2MTcuMjU1IDM5NiA2MDQgMzk2SDQyMFoiIGZpbGw9IndoaXRlIi8+Cjwvc3ZnPgo=';\n    this.supportedTransactionVersions = new Set(['legacy', 0]);\n    this._readyState = typeof window === 'undefined' || typeof document === 'undefined' ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;\n    this._disconnected = () => {\n      const wallet = this._wallet;\n      if (wallet) {\n        wallet.off('disconnect', this._disconnected);\n        this._wallet = null;\n        this._publicKey = null;\n        this.emit('error', new WalletDisconnectedError());\n        this.emit('disconnect');\n      }\n    };\n    this._connecting = false;\n    this._wallet = null;\n    this._publicKey = null;\n    if (this._readyState !== WalletReadyState.Unsupported) {\n      scopePollingDetectionStrategy(() => {\n        if (window?.coinbaseSolana) {\n          this._readyState = WalletReadyState.Installed;\n          this.emit('readyStateChange', this._readyState);\n          return true;\n        }\n        return false;\n      });\n    }\n  }\n  get publicKey() {\n    return this._publicKey;\n  }\n  get connecting() {\n    return this._connecting;\n  }\n  get readyState() {\n    return this._readyState;\n  }\n  async connect() {\n    try {\n      if (this.connected || this.connecting) return;\n      if (this._readyState !== WalletReadyState.Installed) throw new WalletNotReadyError();\n      this._connecting = true;\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const wallet = window.coinbaseSolana;\n      try {\n        await wallet.connect();\n      } catch (error) {\n        throw new WalletConnectionError(error?.message, error);\n      }\n      if (!wallet.publicKey) throw new WalletAccountError();\n      let publicKey;\n      try {\n        publicKey = new PublicKey(wallet.publicKey.toBytes());\n      } catch (error) {\n        throw new WalletPublicKeyError(error?.message, error);\n      }\n      wallet.on('disconnect', this._disconnected);\n      this._wallet = wallet;\n      this._publicKey = publicKey;\n      this.emit('connect', publicKey);\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    } finally {\n      this._connecting = false;\n    }\n  }\n  async disconnect() {\n    const wallet = this._wallet;\n    if (wallet) {\n      wallet.off('disconnect', this._disconnected);\n      this._wallet = null;\n      this._publicKey = null;\n      try {\n        await wallet.disconnect();\n      } catch (error) {\n        this.emit('error', new WalletDisconnectionError(error?.message, error));\n      }\n    }\n    this.emit('disconnect');\n  }\n  async sendTransaction(transaction, connection, options = {}) {\n    try {\n      const wallet = this._wallet;\n      if (!wallet) throw new WalletNotConnectedError();\n      try {\n        const {\n          signers,\n          ...sendOptions\n        } = options;\n        if (isVersionedTransaction(transaction)) {\n          signers?.length && transaction.sign(signers);\n        } else {\n          transaction = await this.prepareTransaction(transaction, connection, sendOptions);\n          signers?.length && transaction.partialSign(...signers);\n        }\n        sendOptions.preflightCommitment = sendOptions.preflightCommitment || connection.commitment;\n        const {\n          signature\n        } = await wallet.signAndSendTransaction(transaction, sendOptions);\n        return signature;\n      } catch (error) {\n        if (error instanceof WalletError) throw error;\n        throw new WalletSendTransactionError(error?.message, error);\n      }\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n  async signTransaction(transaction) {\n    try {\n      const wallet = this._wallet;\n      if (!wallet) throw new WalletNotConnectedError();\n      try {\n        return (await wallet.signTransaction(transaction)) || transaction;\n      } catch (error) {\n        throw new WalletSignTransactionError(error?.message, error);\n      }\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n  async signAllTransactions(transactions) {\n    try {\n      const wallet = this._wallet;\n      if (!wallet) throw new WalletNotConnectedError();\n      try {\n        return (await wallet.signAllTransactions(transactions)) || transactions;\n      } catch (error) {\n        throw new WalletSignTransactionError(error?.message, error);\n      }\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n  async signMessage(message) {\n    try {\n      const wallet = this._wallet;\n      if (!wallet) throw new WalletNotConnectedError();\n      try {\n        const {\n          signature\n        } = await wallet.signMessage(message);\n        return signature;\n      } catch (error) {\n        throw new WalletSignTransactionError(error?.message, error);\n      }\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n}\n//# sourceMappingURL=adapter.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}