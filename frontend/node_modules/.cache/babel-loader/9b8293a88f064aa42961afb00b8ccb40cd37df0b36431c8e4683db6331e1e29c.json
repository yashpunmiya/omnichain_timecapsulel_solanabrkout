{"ast":null,"code":"import { stringify } from '../utils/stringify.js';\nimport { BaseError } from './base.js';\nimport { getUrl } from './utils.js';\nexport class OffchainLookupError extends BaseError {\n  constructor({\n    callbackSelector,\n    cause,\n    data,\n    extraData,\n    sender,\n    urls\n  }) {\n    super(cause.shortMessage || 'An error occurred while fetching for an offchain result.', {\n      cause,\n      metaMessages: [...(cause.metaMessages || []), cause.metaMessages?.length ? '' : [], 'Offchain Gateway Call:', urls && ['  Gateway URL(s):', ...urls.map(url => `    ${getUrl(url)}`)], `  Sender: ${sender}`, `  Data: ${data}`, `  Callback selector: ${callbackSelector}`, `  Extra data: ${extraData}`].flat(),\n      name: 'OffchainLookupError'\n    });\n  }\n}\nexport class OffchainLookupResponseMalformedError extends BaseError {\n  constructor({\n    result,\n    url\n  }) {\n    super('Offchain gateway response is malformed. Response data must be a hex value.', {\n      metaMessages: [`Gateway URL: ${getUrl(url)}`, `Response: ${stringify(result)}`],\n      name: 'OffchainLookupResponseMalformedError'\n    });\n  }\n}\nexport class OffchainLookupSenderMismatchError extends BaseError {\n  constructor({\n    sender,\n    to\n  }) {\n    super('Reverted sender address does not match target contract address (`to`).', {\n      metaMessages: [`Contract address: ${to}`, `OffchainLookup sender address: ${sender}`],\n      name: 'OffchainLookupSenderMismatchError'\n    });\n  }\n}\n//# sourceMappingURL=ccip.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}