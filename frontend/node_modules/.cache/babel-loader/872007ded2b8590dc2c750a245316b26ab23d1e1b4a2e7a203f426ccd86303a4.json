{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FountainEncoderPart = void 0;\nconst assert_1 = __importDefault(require(\"assert\"));\nconst utils_1 = require(\"./utils\");\nconst fountainUtils_1 = require(\"./fountainUtils\");\nconst cbor_1 = require(\"./cbor\");\nclass FountainEncoderPart {\n  constructor(_seqNum, _seqLength, _messageLength, _checksum, _fragment) {\n    this._seqNum = _seqNum;\n    this._seqLength = _seqLength;\n    this._messageLength = _messageLength;\n    this._checksum = _checksum;\n    this._fragment = _fragment;\n  }\n  get messageLength() {\n    return this._messageLength;\n  }\n  get fragment() {\n    return this._fragment;\n  }\n  get seqNum() {\n    return this._seqNum;\n  }\n  get seqLength() {\n    return this._seqLength;\n  }\n  get checksum() {\n    return this._checksum;\n  }\n  cbor() {\n    const result = cbor_1.cborEncode([this._seqNum, this._seqLength, this._messageLength, this._checksum, this._fragment]);\n    return Buffer.from(result);\n  }\n  description() {\n    return `seqNum:${this._seqNum}, seqLen:${this._seqLength}, messageLen:${this._messageLength}, checksum:${this._checksum}, data:${this._fragment.toString('hex')}`;\n  }\n  static fromCBOR(cborPayload) {\n    const [seqNum, seqLength, messageLength, checksum, fragment] = cbor_1.cborDecode(cborPayload);\n    assert_1.default(typeof seqNum === 'number');\n    assert_1.default(typeof seqLength === 'number');\n    assert_1.default(typeof messageLength === 'number');\n    assert_1.default(typeof checksum === 'number');\n    assert_1.default(Buffer.isBuffer(fragment) && fragment.length > 0);\n    return new FountainEncoderPart(seqNum, seqLength, messageLength, checksum, Buffer.from(fragment));\n  }\n}\nexports.FountainEncoderPart = FountainEncoderPart;\nclass FountainEncoder {\n  constructor(message, maxFragmentLength = 100, firstSeqNum = 0, minFragmentLength = 10) {\n    const fragmentLength = FountainEncoder.findNominalFragmentLength(message.length, minFragmentLength, maxFragmentLength);\n    this._messageLength = message.length;\n    this._fragments = FountainEncoder.partitionMessage(message, fragmentLength);\n    this.fragmentLength = fragmentLength;\n    this.seqNum = utils_1.toUint32(firstSeqNum);\n    this.checksum = utils_1.getCRC(message);\n  }\n  get fragmentsLength() {\n    return this._fragments.length;\n  }\n  get fragments() {\n    return this._fragments;\n  }\n  get messageLength() {\n    return this._messageLength;\n  }\n  isComplete() {\n    return this.seqNum >= this._fragments.length;\n  }\n  isSinglePart() {\n    return this._fragments.length === 1;\n  }\n  seqLength() {\n    return this._fragments.length;\n  }\n  mix(indexes) {\n    return indexes.reduce((result, index) => utils_1.bufferXOR(this._fragments[index], result), Buffer.alloc(this.fragmentLength, 0));\n  }\n  nextPart() {\n    this.seqNum = utils_1.toUint32(this.seqNum + 1);\n    const indexes = fountainUtils_1.chooseFragments(this.seqNum, this._fragments.length, this.checksum);\n    const mixed = this.mix(indexes);\n    return new FountainEncoderPart(this.seqNum, this._fragments.length, this._messageLength, this.checksum, mixed);\n  }\n  static findNominalFragmentLength(messageLength, minFragmentLength, maxFragmentLength) {\n    assert_1.default(messageLength > 0);\n    assert_1.default(minFragmentLength > 0);\n    assert_1.default(maxFragmentLength >= minFragmentLength);\n    const maxFragmentCount = Math.ceil(messageLength / minFragmentLength);\n    let fragmentLength = 0;\n    for (let fragmentCount = 1; fragmentCount <= maxFragmentCount; fragmentCount++) {\n      fragmentLength = Math.ceil(messageLength / fragmentCount);\n      if (fragmentLength <= maxFragmentLength) {\n        break;\n      }\n    }\n    return fragmentLength;\n  }\n  static partitionMessage(message, fragmentLength) {\n    let remaining = Buffer.from(message);\n    let fragment;\n    let _fragments = [];\n    while (remaining.length > 0) {\n      [fragment, remaining] = utils_1.split(remaining, -fragmentLength);\n      fragment = Buffer.alloc(fragmentLength, 0) // initialize with 0's to achieve the padding\n      .fill(fragment, 0, fragment.length);\n      _fragments.push(fragment);\n    }\n    return _fragments;\n  }\n}\nexports.default = FountainEncoder;","map":{"version":3,"names":["assert_1","__importDefault","require","utils_1","fountainUtils_1","cbor_1","FountainEncoderPart","constructor","_seqNum","_seqLength","_messageLength","_checksum","_fragment","messageLength","fragment","seqNum","seqLength","checksum","cbor","result","cborEncode","Buffer","from","description","toString","fromCBOR","cborPayload","cborDecode","default","isBuffer","length","exports","FountainEncoder","message","maxFragmentLength","firstSeqNum","minFragmentLength","fragmentLength","findNominalFragmentLength","_fragments","partitionMessage","toUint32","getCRC","fragmentsLength","fragments","isComplete","isSinglePart","mix","indexes","reduce","index","bufferXOR","alloc","nextPart","chooseFragments","mixed","maxFragmentCount","Math","ceil","fragmentCount","remaining","split","fill","push"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@ngraveio\\bc-ur\\src\\fountainEncoder.ts"],"sourcesContent":["import assert from \"assert\";\nimport { bufferXOR, getCRC, split, toUint32 } from \"./utils\";\nimport { chooseFragments } from \"./fountainUtils\";\nimport { cborEncode, cborDecode } from './cbor';\n\nexport class FountainEncoderPart {\n  constructor(\n    private _seqNum: number,\n    private _seqLength: number,\n    private _messageLength: number,\n    private _checksum: number,\n    private _fragment: Buffer,\n  ) { }\n\n  get messageLength() { return this._messageLength; }\n  get fragment() { return this._fragment; }\n  get seqNum() { return this._seqNum; }\n  get seqLength() { return this._seqLength; }\n  get checksum() { return this._checksum; }\n\n  public cbor(): Buffer {\n    const result = cborEncode([\n      this._seqNum,\n      this._seqLength,\n      this._messageLength,\n      this._checksum,\n      this._fragment\n    ])\n\n    return Buffer.from(result);\n  }\n\n  public description(): string {\n    return `seqNum:${this._seqNum}, seqLen:${this._seqLength}, messageLen:${this._messageLength}, checksum:${this._checksum}, data:${this._fragment.toString('hex')}`\n  }\n\n  public static fromCBOR(cborPayload: string | Buffer) {\n    const [\n      seqNum,\n      seqLength,\n      messageLength,\n      checksum,\n      fragment,\n    ] = cborDecode(cborPayload);\n\n    assert(typeof seqNum === 'number');\n    assert(typeof seqLength === 'number');\n    assert(typeof messageLength === 'number');\n    assert(typeof checksum === 'number');\n    assert(Buffer.isBuffer(fragment) && fragment.length > 0);\n\n    return new FountainEncoderPart(\n      seqNum,\n      seqLength,\n      messageLength,\n      checksum,\n      Buffer.from(fragment),\n    )\n  }\n}\n\nexport default class FountainEncoder {\n  private _messageLength: number;\n  private _fragments: Buffer[];\n  private fragmentLength: number;\n  private seqNum: number;\n  private checksum: number;\n\n  constructor(\n    message: Buffer,\n    maxFragmentLength: number = 100,\n    firstSeqNum: number = 0,\n    minFragmentLength: number = 10\n  ) {\n    const fragmentLength = FountainEncoder.findNominalFragmentLength(message.length, minFragmentLength, maxFragmentLength);\n\n    this._messageLength = message.length;\n    this._fragments = FountainEncoder.partitionMessage(message, fragmentLength);\n    this.fragmentLength = fragmentLength;\n    this.seqNum = toUint32(firstSeqNum);\n    this.checksum = getCRC(message)\n  }\n\n  public get fragmentsLength() { return this._fragments.length; }\n  public get fragments() { return this._fragments; }\n  public get messageLength() { return this._messageLength; }\n\n  public isComplete(): boolean {\n    return this.seqNum >= this._fragments.length;\n  }\n\n  public isSinglePart(): boolean {\n    return this._fragments.length === 1;\n  }\n\n  public seqLength(): number {\n    return this._fragments.length;\n  }\n\n  public mix(indexes: number[]) {\n    return indexes.reduce(\n      (result, index) => bufferXOR(this._fragments[index], result),\n      Buffer.alloc(this.fragmentLength, 0)\n    )\n  }\n\n  public nextPart(): FountainEncoderPart {\n    this.seqNum = toUint32(this.seqNum + 1);\n\n    const indexes = chooseFragments(this.seqNum, this._fragments.length, this.checksum);\n    const mixed = this.mix(indexes);\n\n    return new FountainEncoderPart(\n      this.seqNum,\n      this._fragments.length,\n      this._messageLength,\n      this.checksum,\n      mixed\n    )\n  }\n\n  public static findNominalFragmentLength(\n    messageLength: number,\n    minFragmentLength: number,\n    maxFragmentLength: number\n  ): number {\n    assert(messageLength > 0)\n    assert(minFragmentLength > 0)\n    assert(maxFragmentLength >= minFragmentLength)\n\n    const maxFragmentCount = Math.ceil(messageLength / minFragmentLength);\n    let fragmentLength = 0;\n\n    for (let fragmentCount = 1; fragmentCount <= maxFragmentCount; fragmentCount++) {\n      fragmentLength = Math.ceil(messageLength / fragmentCount);\n\n      if (fragmentLength <= maxFragmentLength) {\n        break;\n      }\n    }\n\n    return fragmentLength;\n  }\n\n  public static partitionMessage(message: Buffer, fragmentLength: number): Buffer[] {\n    let remaining = Buffer.from(message);\n    let fragment;\n    let _fragments: Buffer[] = [];\n\n    while (remaining.length > 0) {\n      [fragment, remaining] = split(remaining, -fragmentLength)\n      fragment = Buffer\n        .alloc(fragmentLength, 0) // initialize with 0's to achieve the padding\n        .fill(fragment, 0, fragment.length)\n      _fragments.push(fragment)\n    }\n\n    return _fragments;\n  }\n}\n\n"],"mappings":";;;;;;;;;;;AAAA,MAAAA,QAAA,GAAAC,eAAA,CAAAC,OAAA;AACA,MAAAC,OAAA,GAAAD,OAAA;AACA,MAAAE,eAAA,GAAAF,OAAA;AACA,MAAAG,MAAA,GAAAH,OAAA;AAEA,MAAaI,mBAAmB;EAC9BC,YACUC,OAAe,EACfC,UAAkB,EAClBC,cAAsB,EACtBC,SAAiB,EACjBC,SAAiB;IAJjB,KAAAJ,OAAO,GAAPA,OAAO;IACP,KAAAC,UAAU,GAAVA,UAAU;IACV,KAAAC,cAAc,GAAdA,cAAc;IACd,KAAAC,SAAS,GAATA,SAAS;IACT,KAAAC,SAAS,GAATA,SAAS;EACf;EAEJ,IAAIC,aAAaA,CAAA;IAAK,OAAO,IAAI,CAACH,cAAc;EAAE;EAClD,IAAII,QAAQA,CAAA;IAAK,OAAO,IAAI,CAACF,SAAS;EAAE;EACxC,IAAIG,MAAMA,CAAA;IAAK,OAAO,IAAI,CAACP,OAAO;EAAE;EACpC,IAAIQ,SAASA,CAAA;IAAK,OAAO,IAAI,CAACP,UAAU;EAAE;EAC1C,IAAIQ,QAAQA,CAAA;IAAK,OAAO,IAAI,CAACN,SAAS;EAAE;EAEjCO,IAAIA,CAAA;IACT,MAAMC,MAAM,GAAGd,MAAA,CAAAe,UAAU,CAAC,CACxB,IAAI,CAACZ,OAAO,EACZ,IAAI,CAACC,UAAU,EACf,IAAI,CAACC,cAAc,EACnB,IAAI,CAACC,SAAS,EACd,IAAI,CAACC,SAAS,CACf,CAAC;IAEF,OAAOS,MAAM,CAACC,IAAI,CAACH,MAAM,CAAC;EAC5B;EAEOI,WAAWA,CAAA;IAChB,OAAO,UAAU,IAAI,CAACf,OAAO,YAAY,IAAI,CAACC,UAAU,gBAAgB,IAAI,CAACC,cAAc,cAAc,IAAI,CAACC,SAAS,UAAU,IAAI,CAACC,SAAS,CAACY,QAAQ,CAAC,KAAK,CAAC,EAAE;EACnK;EAEO,OAAOC,QAAQA,CAACC,WAA4B;IACjD,MAAM,CACJX,MAAM,EACNC,SAAS,EACTH,aAAa,EACbI,QAAQ,EACRH,QAAQ,CACT,GAAGT,MAAA,CAAAsB,UAAU,CAACD,WAAW,CAAC;IAE3B1B,QAAA,CAAA4B,OAAM,CAAC,OAAOb,MAAM,KAAK,QAAQ,CAAC;IAClCf,QAAA,CAAA4B,OAAM,CAAC,OAAOZ,SAAS,KAAK,QAAQ,CAAC;IACrChB,QAAA,CAAA4B,OAAM,CAAC,OAAOf,aAAa,KAAK,QAAQ,CAAC;IACzCb,QAAA,CAAA4B,OAAM,CAAC,OAAOX,QAAQ,KAAK,QAAQ,CAAC;IACpCjB,QAAA,CAAA4B,OAAM,CAACP,MAAM,CAACQ,QAAQ,CAACf,QAAQ,CAAC,IAAIA,QAAQ,CAACgB,MAAM,GAAG,CAAC,CAAC;IAExD,OAAO,IAAIxB,mBAAmB,CAC5BS,MAAM,EACNC,SAAS,EACTH,aAAa,EACbI,QAAQ,EACRI,MAAM,CAACC,IAAI,CAACR,QAAQ,CAAC,CACtB;EACH;;AArDFiB,OAAA,CAAAzB,mBAAA,GAAAA,mBAAA;AAwDA,MAAqB0B,eAAe;EAOlCzB,YACE0B,OAAe,EACfC,iBAAA,GAA4B,GAAG,EAC/BC,WAAA,GAAsB,CAAC,EACvBC,iBAAA,GAA4B,EAAE;IAE9B,MAAMC,cAAc,GAAGL,eAAe,CAACM,yBAAyB,CAACL,OAAO,CAACH,MAAM,EAAEM,iBAAiB,EAAEF,iBAAiB,CAAC;IAEtH,IAAI,CAACxB,cAAc,GAAGuB,OAAO,CAACH,MAAM;IACpC,IAAI,CAACS,UAAU,GAAGP,eAAe,CAACQ,gBAAgB,CAACP,OAAO,EAAEI,cAAc,CAAC;IAC3E,IAAI,CAACA,cAAc,GAAGA,cAAc;IACpC,IAAI,CAACtB,MAAM,GAAGZ,OAAA,CAAAsC,QAAQ,CAACN,WAAW,CAAC;IACnC,IAAI,CAAClB,QAAQ,GAAGd,OAAA,CAAAuC,MAAM,CAACT,OAAO,CAAC;EACjC;EAEA,IAAWU,eAAeA,CAAA;IAAK,OAAO,IAAI,CAACJ,UAAU,CAACT,MAAM;EAAE;EAC9D,IAAWc,SAASA,CAAA;IAAK,OAAO,IAAI,CAACL,UAAU;EAAE;EACjD,IAAW1B,aAAaA,CAAA;IAAK,OAAO,IAAI,CAACH,cAAc;EAAE;EAElDmC,UAAUA,CAAA;IACf,OAAO,IAAI,CAAC9B,MAAM,IAAI,IAAI,CAACwB,UAAU,CAACT,MAAM;EAC9C;EAEOgB,YAAYA,CAAA;IACjB,OAAO,IAAI,CAACP,UAAU,CAACT,MAAM,KAAK,CAAC;EACrC;EAEOd,SAASA,CAAA;IACd,OAAO,IAAI,CAACuB,UAAU,CAACT,MAAM;EAC/B;EAEOiB,GAAGA,CAACC,OAAiB;IAC1B,OAAOA,OAAO,CAACC,MAAM,CACnB,CAAC9B,MAAM,EAAE+B,KAAK,KAAK/C,OAAA,CAAAgD,SAAS,CAAC,IAAI,CAACZ,UAAU,CAACW,KAAK,CAAC,EAAE/B,MAAM,CAAC,EAC5DE,MAAM,CAAC+B,KAAK,CAAC,IAAI,CAACf,cAAc,EAAE,CAAC,CAAC,CACrC;EACH;EAEOgB,QAAQA,CAAA;IACb,IAAI,CAACtC,MAAM,GAAGZ,OAAA,CAAAsC,QAAQ,CAAC,IAAI,CAAC1B,MAAM,GAAG,CAAC,CAAC;IAEvC,MAAMiC,OAAO,GAAG5C,eAAA,CAAAkD,eAAe,CAAC,IAAI,CAACvC,MAAM,EAAE,IAAI,CAACwB,UAAU,CAACT,MAAM,EAAE,IAAI,CAACb,QAAQ,CAAC;IACnF,MAAMsC,KAAK,GAAG,IAAI,CAACR,GAAG,CAACC,OAAO,CAAC;IAE/B,OAAO,IAAI1C,mBAAmB,CAC5B,IAAI,CAACS,MAAM,EACX,IAAI,CAACwB,UAAU,CAACT,MAAM,EACtB,IAAI,CAACpB,cAAc,EACnB,IAAI,CAACO,QAAQ,EACbsC,KAAK,CACN;EACH;EAEO,OAAOjB,yBAAyBA,CACrCzB,aAAqB,EACrBuB,iBAAyB,EACzBF,iBAAyB;IAEzBlC,QAAA,CAAA4B,OAAM,CAACf,aAAa,GAAG,CAAC,CAAC;IACzBb,QAAA,CAAA4B,OAAM,CAACQ,iBAAiB,GAAG,CAAC,CAAC;IAC7BpC,QAAA,CAAA4B,OAAM,CAACM,iBAAiB,IAAIE,iBAAiB,CAAC;IAE9C,MAAMoB,gBAAgB,GAAGC,IAAI,CAACC,IAAI,CAAC7C,aAAa,GAAGuB,iBAAiB,CAAC;IACrE,IAAIC,cAAc,GAAG,CAAC;IAEtB,KAAK,IAAIsB,aAAa,GAAG,CAAC,EAAEA,aAAa,IAAIH,gBAAgB,EAAEG,aAAa,EAAE,EAAE;MAC9EtB,cAAc,GAAGoB,IAAI,CAACC,IAAI,CAAC7C,aAAa,GAAG8C,aAAa,CAAC;MAEzD,IAAItB,cAAc,IAAIH,iBAAiB,EAAE;QACvC;;;IAIJ,OAAOG,cAAc;EACvB;EAEO,OAAOG,gBAAgBA,CAACP,OAAe,EAAEI,cAAsB;IACpE,IAAIuB,SAAS,GAAGvC,MAAM,CAACC,IAAI,CAACW,OAAO,CAAC;IACpC,IAAInB,QAAQ;IACZ,IAAIyB,UAAU,GAAa,EAAE;IAE7B,OAAOqB,SAAS,CAAC9B,MAAM,GAAG,CAAC,EAAE;MAC3B,CAAChB,QAAQ,EAAE8C,SAAS,CAAC,GAAGzD,OAAA,CAAA0D,KAAK,CAACD,SAAS,EAAE,CAACvB,cAAc,CAAC;MACzDvB,QAAQ,GAAGO,MAAM,CACd+B,KAAK,CAACf,cAAc,EAAE,CAAC,CAAC,CAAC;MAAA,CACzByB,IAAI,CAAChD,QAAQ,EAAE,CAAC,EAAEA,QAAQ,CAACgB,MAAM,CAAC;MACrCS,UAAU,CAACwB,IAAI,CAACjD,QAAQ,CAAC;;IAG3B,OAAOyB,UAAU;EACnB;;AAjGFR,OAAA,CAAAH,OAAA,GAAAI,eAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}