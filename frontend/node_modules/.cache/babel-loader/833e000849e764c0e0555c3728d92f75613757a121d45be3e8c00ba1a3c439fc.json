{"ast":null,"code":"import { proxy, ref, subscribe as sub } from 'valtio/vanilla';\nimport { subscribeKey as subKey } from 'valtio/vanilla/utils';\nimport { NumberUtil } from '@reown/appkit-common';\nimport { ContractUtil } from '@reown/appkit-common';\nimport { W3mFrameRpcConstants } from '@reown/appkit-wallet/utils';\nimport { ConstantsUtil } from '../utils/ConstantsUtil.js';\nimport { CoreHelperUtil } from '../utils/CoreHelperUtil.js';\nimport { SendApiUtil } from '../utils/SendApiUtil.js';\nimport { AccountController } from './AccountController.js';\nimport { ChainController } from './ChainController.js';\nimport { ConnectionController } from './ConnectionController.js';\nimport { EventsController } from './EventsController.js';\nimport { RouterController } from './RouterController.js';\nimport { SnackController } from './SnackController.js';\n// -- State --------------------------------------------- //\nconst state = proxy({\n  tokenBalances: [],\n  loading: false\n});\n// -- Controller ---------------------------------------- //\nexport const SendController = {\n  state,\n  subscribe(callback) {\n    return sub(state, () => callback(state));\n  },\n  subscribeKey(key, callback) {\n    return subKey(state, key, callback);\n  },\n  setToken(token) {\n    if (token) {\n      state.token = ref(token);\n    }\n  },\n  setTokenAmount(sendTokenAmount) {\n    state.sendTokenAmount = sendTokenAmount;\n  },\n  setReceiverAddress(receiverAddress) {\n    state.receiverAddress = receiverAddress;\n  },\n  setReceiverProfileImageUrl(receiverProfileImageUrl) {\n    state.receiverProfileImageUrl = receiverProfileImageUrl;\n  },\n  setReceiverProfileName(receiverProfileName) {\n    state.receiverProfileName = receiverProfileName;\n  },\n  setGasPrice(gasPrice) {\n    state.gasPrice = gasPrice;\n  },\n  setGasPriceInUsd(gasPriceInUSD) {\n    state.gasPriceInUSD = gasPriceInUSD;\n  },\n  setNetworkBalanceInUsd(networkBalanceInUSD) {\n    state.networkBalanceInUSD = networkBalanceInUSD;\n  },\n  setLoading(loading) {\n    state.loading = loading;\n  },\n  sendToken() {\n    switch (ChainController.state.activeCaipNetwork?.chainNamespace) {\n      case 'eip155':\n        this.sendEvmToken();\n        return;\n      case 'solana':\n        this.sendSolanaToken();\n        return;\n      default:\n        throw new Error('Unsupported chain');\n    }\n  },\n  sendEvmToken() {\n    if (this.state.token?.address && this.state.sendTokenAmount && this.state.receiverAddress) {\n      EventsController.sendEvent({\n        type: 'track',\n        event: 'SEND_INITIATED',\n        properties: {\n          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,\n          token: this.state.token.address,\n          amount: this.state.sendTokenAmount,\n          network: ChainController.state.activeCaipNetwork?.caipNetworkId || ''\n        }\n      });\n      this.sendERC20Token({\n        receiverAddress: this.state.receiverAddress,\n        tokenAddress: this.state.token.address,\n        sendTokenAmount: this.state.sendTokenAmount,\n        decimals: this.state.token.quantity.decimals\n      });\n    } else if (this.state.receiverAddress && this.state.sendTokenAmount && this.state.gasPrice && this.state.token?.quantity.decimals) {\n      EventsController.sendEvent({\n        type: 'track',\n        event: 'SEND_INITIATED',\n        properties: {\n          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,\n          token: this.state.token?.symbol,\n          amount: this.state.sendTokenAmount,\n          network: ChainController.state.activeCaipNetwork?.caipNetworkId || ''\n        }\n      });\n      this.sendNativeToken({\n        receiverAddress: this.state.receiverAddress,\n        sendTokenAmount: this.state.sendTokenAmount,\n        gasPrice: this.state.gasPrice,\n        decimals: this.state.token.quantity.decimals\n      });\n    }\n  },\n  async fetchTokenBalance(onError) {\n    state.loading = true;\n    const chainId = ChainController.state.activeCaipNetwork?.caipNetworkId;\n    const chain = ChainController.state.activeCaipNetwork?.chainNamespace;\n    const caipAddress = ChainController.state.activeCaipAddress;\n    const address = caipAddress ? CoreHelperUtil.getPlainAddress(caipAddress) : undefined;\n    if (state.lastRetry && !CoreHelperUtil.isAllowedRetry(state.lastRetry, 30 * ConstantsUtil.ONE_SEC_MS)) {\n      state.loading = false;\n      return [];\n    }\n    try {\n      if (address && chainId && chain) {\n        const balances = await SendApiUtil.getMyTokensWithBalance();\n        state.tokenBalances = balances;\n        state.lastRetry = undefined;\n        return balances;\n      }\n    } catch (error) {\n      state.lastRetry = Date.now();\n      onError?.(error);\n      SnackController.showError('Token Balance Unavailable');\n    } finally {\n      state.loading = false;\n    }\n    return [];\n  },\n  fetchNetworkBalance() {\n    if (state.tokenBalances.length === 0) {\n      return;\n    }\n    const networkTokenBalances = SendApiUtil.mapBalancesToSwapTokens(state.tokenBalances);\n    if (!networkTokenBalances) {\n      return;\n    }\n    const networkToken = networkTokenBalances.find(token => token.address === ChainController.getActiveNetworkTokenAddress());\n    if (!networkToken) {\n      return;\n    }\n    state.networkBalanceInUSD = networkToken ? NumberUtil.multiply(networkToken.quantity.numeric, networkToken.price).toString() : '0';\n  },\n  isInsufficientNetworkTokenForGas(networkBalanceInUSD, gasPriceInUSD) {\n    const gasPrice = gasPriceInUSD || '0';\n    if (NumberUtil.bigNumber(networkBalanceInUSD).eq(0)) {\n      return true;\n    }\n    return NumberUtil.bigNumber(NumberUtil.bigNumber(gasPrice)).gt(networkBalanceInUSD);\n  },\n  hasInsufficientGasFunds() {\n    let isInsufficientNetworkTokenForGas = true;\n    if (AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT) {\n      // Smart Accounts may pay gas in any ERC20 token\n      isInsufficientNetworkTokenForGas = false;\n    } else if (state.networkBalanceInUSD) {\n      isInsufficientNetworkTokenForGas = this.isInsufficientNetworkTokenForGas(state.networkBalanceInUSD, state.gasPriceInUSD);\n    }\n    return isInsufficientNetworkTokenForGas;\n  },\n  async sendNativeToken(params) {\n    RouterController.pushTransactionStack({\n      view: 'Account',\n      goBack: false\n    });\n    const to = params.receiverAddress;\n    const address = AccountController.state.address;\n    const value = ConnectionController.parseUnits(params.sendTokenAmount.toString(), Number(params.decimals));\n    const data = '0x';\n    try {\n      await ConnectionController.sendTransaction({\n        chainNamespace: 'eip155',\n        to,\n        address,\n        data,\n        value: value ?? BigInt(0),\n        gasPrice: params.gasPrice\n      });\n      SnackController.showSuccess('Transaction started');\n      EventsController.sendEvent({\n        type: 'track',\n        event: 'SEND_SUCCESS',\n        properties: {\n          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,\n          token: this.state.token?.symbol || '',\n          amount: params.sendTokenAmount,\n          network: ChainController.state.activeCaipNetwork?.caipNetworkId || ''\n        }\n      });\n      this.resetSend();\n    } catch (error) {\n      // eslint-disable-next-line no-console\n      console.error('SendController:sendERC20Token - failed to send native token', error);\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      EventsController.sendEvent({\n        type: 'track',\n        event: 'SEND_ERROR',\n        properties: {\n          message: errorMessage,\n          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,\n          token: this.state.token?.symbol || '',\n          amount: params.sendTokenAmount,\n          network: ChainController.state.activeCaipNetwork?.caipNetworkId || ''\n        }\n      });\n      SnackController.showError('Something went wrong');\n    }\n  },\n  async sendERC20Token(params) {\n    RouterController.pushTransactionStack({\n      view: 'Account',\n      goBack: false\n    });\n    const amount = ConnectionController.parseUnits(params.sendTokenAmount.toString(), Number(params.decimals));\n    try {\n      if (AccountController.state.address && params.sendTokenAmount && params.receiverAddress && params.tokenAddress) {\n        const tokenAddress = CoreHelperUtil.getPlainAddress(params.tokenAddress);\n        await ConnectionController.writeContract({\n          fromAddress: AccountController.state.address,\n          tokenAddress,\n          args: [params.receiverAddress, amount ?? BigInt(0)],\n          method: 'transfer',\n          abi: ContractUtil.getERC20Abi(tokenAddress),\n          chainNamespace: 'eip155'\n        });\n        SnackController.showSuccess('Transaction started');\n        this.resetSend();\n      }\n    } catch (error) {\n      // eslint-disable-next-line no-console\n      console.error('SendController:sendERC20Token - failed to send erc20 token', error);\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      EventsController.sendEvent({\n        type: 'track',\n        event: 'SEND_ERROR',\n        properties: {\n          message: errorMessage,\n          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,\n          token: this.state.token?.symbol || '',\n          amount: params.sendTokenAmount,\n          network: ChainController.state.activeCaipNetwork?.caipNetworkId || ''\n        }\n      });\n      SnackController.showError('Something went wrong');\n    }\n  },\n  sendSolanaToken() {\n    if (!this.state.sendTokenAmount || !this.state.receiverAddress) {\n      SnackController.showError('Please enter a valid amount and receiver address');\n      return;\n    }\n    RouterController.pushTransactionStack({\n      view: 'Account',\n      goBack: false\n    });\n    ConnectionController.sendTransaction({\n      chainNamespace: 'solana',\n      to: this.state.receiverAddress,\n      value: this.state.sendTokenAmount\n    }).then(() => {\n      this.resetSend();\n      AccountController.fetchTokenBalance();\n    }).catch(error => {\n      SnackController.showError('Failed to send transaction. Please try again.');\n      // eslint-disable-next-line no-console\n      console.error('SendController:sendToken - failed to send solana transaction', error);\n    });\n  },\n  resetSend() {\n    state.token = undefined;\n    state.sendTokenAmount = undefined;\n    state.receiverAddress = undefined;\n    state.receiverProfileImageUrl = undefined;\n    state.receiverProfileName = undefined;\n    state.loading = false;\n    state.tokenBalances = [];\n  }\n};\n//# sourceMappingURL=SendController.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}