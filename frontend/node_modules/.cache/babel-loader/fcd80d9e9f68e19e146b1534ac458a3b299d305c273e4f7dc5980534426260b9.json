{"ast":null,"code":"import { BaseError } from '../../errors/base.js';\nimport { createCursor } from '../cursor.js';\nimport { hexToBytes } from './toBytes.js';\nimport { bytesToHex } from './toHex.js';\nexport function toRlp(bytes, to = 'hex') {\n  const encodable = getEncodable(bytes);\n  const cursor = createCursor(new Uint8Array(encodable.length));\n  encodable.encode(cursor);\n  if (to === 'hex') return bytesToHex(cursor.bytes);\n  return cursor.bytes;\n}\nexport function bytesToRlp(bytes, to = 'bytes') {\n  return toRlp(bytes, to);\n}\nexport function hexToRlp(hex, to = 'hex') {\n  return toRlp(hex, to);\n}\nfunction getEncodable(bytes) {\n  if (Array.isArray(bytes)) return getEncodableList(bytes.map(x => getEncodable(x)));\n  return getEncodableBytes(bytes);\n}\nfunction getEncodableList(list) {\n  const bodyLength = list.reduce((acc, x) => acc + x.length, 0);\n  const sizeOfBodyLength = getSizeOfLength(bodyLength);\n  const length = (() => {\n    if (bodyLength <= 55) return 1 + bodyLength;\n    return 1 + sizeOfBodyLength + bodyLength;\n  })();\n  return {\n    length,\n    encode(cursor) {\n      if (bodyLength <= 55) {\n        cursor.pushByte(0xc0 + bodyLength);\n      } else {\n        cursor.pushByte(0xc0 + 55 + sizeOfBodyLength);\n        if (sizeOfBodyLength === 1) cursor.pushUint8(bodyLength);else if (sizeOfBodyLength === 2) cursor.pushUint16(bodyLength);else if (sizeOfBodyLength === 3) cursor.pushUint24(bodyLength);else cursor.pushUint32(bodyLength);\n      }\n      for (const {\n        encode\n      } of list) {\n        encode(cursor);\n      }\n    }\n  };\n}\nfunction getEncodableBytes(bytesOrHex) {\n  const bytes = typeof bytesOrHex === 'string' ? hexToBytes(bytesOrHex) : bytesOrHex;\n  const sizeOfBytesLength = getSizeOfLength(bytes.length);\n  const length = (() => {\n    if (bytes.length === 1 && bytes[0] < 0x80) return 1;\n    if (bytes.length <= 55) return 1 + bytes.length;\n    return 1 + sizeOfBytesLength + bytes.length;\n  })();\n  return {\n    length,\n    encode(cursor) {\n      if (bytes.length === 1 && bytes[0] < 0x80) {\n        cursor.pushBytes(bytes);\n      } else if (bytes.length <= 55) {\n        cursor.pushByte(0x80 + bytes.length);\n        cursor.pushBytes(bytes);\n      } else {\n        cursor.pushByte(0x80 + 55 + sizeOfBytesLength);\n        if (sizeOfBytesLength === 1) cursor.pushUint8(bytes.length);else if (sizeOfBytesLength === 2) cursor.pushUint16(bytes.length);else if (sizeOfBytesLength === 3) cursor.pushUint24(bytes.length);else cursor.pushUint32(bytes.length);\n        cursor.pushBytes(bytes);\n      }\n    }\n  };\n}\nfunction getSizeOfLength(length) {\n  if (length < 2 ** 8) return 1;\n  if (length < 2 ** 16) return 2;\n  if (length < 2 ** 24) return 3;\n  if (length < 2 ** 32) return 4;\n  throw new BaseError('Length is too large.');\n}","map":{"version":3,"names":["BaseError","createCursor","hexToBytes","bytesToHex","toRlp","bytes","to","encodable","getEncodable","cursor","Uint8Array","length","encode","bytesToRlp","hexToRlp","hex","Array","isArray","getEncodableList","map","x","getEncodableBytes","list","bodyLength","reduce","acc","sizeOfBodyLength","getSizeOfLength","pushByte","pushUint8","pushUint16","pushUint24","pushUint32","bytesOrHex","sizeOfBytesLength","pushBytes"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\utils\\node_modules\\viem\\utils\\encoding\\toRlp.ts"],"sourcesContent":["import { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport {\n  type CreateCursorErrorType,\n  type Cursor,\n  createCursor,\n} from '../cursor.js'\n\nimport { type HexToBytesErrorType, hexToBytes } from './toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from './toHex.js'\n\nexport type RecursiveArray<T> = T | readonly RecursiveArray<T>[]\n\ntype To = 'hex' | 'bytes'\n\ntype Encodable = {\n  length: number\n  encode(cursor: Cursor): void\n}\n\nexport type ToRlpReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type ToRlpErrorType =\n  | CreateCursorErrorType\n  | BytesToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\nexport function toRlp<to extends To = 'hex'>(\n  bytes: RecursiveArray<ByteArray> | RecursiveArray<Hex>,\n  to: to | To | undefined = 'hex',\n): ToRlpReturnType<to> {\n  const encodable = getEncodable(bytes)\n  const cursor = createCursor(new Uint8Array(encodable.length))\n  encodable.encode(cursor)\n\n  if (to === 'hex') return bytesToHex(cursor.bytes) as ToRlpReturnType<to>\n  return cursor.bytes as ToRlpReturnType<to>\n}\n\nexport type BytesToRlpErrorType = ToRlpErrorType | ErrorType\n\nexport function bytesToRlp<to extends To = 'bytes'>(\n  bytes: RecursiveArray<ByteArray>,\n  to: to | To | undefined = 'bytes',\n): ToRlpReturnType<to> {\n  return toRlp(bytes, to)\n}\n\nexport type HexToRlpErrorType = ToRlpErrorType | ErrorType\n\nexport function hexToRlp<to extends To = 'hex'>(\n  hex: RecursiveArray<Hex>,\n  to: to | To | undefined = 'hex',\n): ToRlpReturnType<to> {\n  return toRlp(hex, to)\n}\n\nfunction getEncodable(\n  bytes: RecursiveArray<ByteArray> | RecursiveArray<Hex>,\n): Encodable {\n  if (Array.isArray(bytes))\n    return getEncodableList(bytes.map((x) => getEncodable(x)))\n  return getEncodableBytes(bytes as any)\n}\n\nfunction getEncodableList(list: Encodable[]): Encodable {\n  const bodyLength = list.reduce((acc, x) => acc + x.length, 0)\n\n  const sizeOfBodyLength = getSizeOfLength(bodyLength)\n  const length = (() => {\n    if (bodyLength <= 55) return 1 + bodyLength\n    return 1 + sizeOfBodyLength + bodyLength\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor) {\n      if (bodyLength <= 55) {\n        cursor.pushByte(0xc0 + bodyLength)\n      } else {\n        cursor.pushByte(0xc0 + 55 + sizeOfBodyLength)\n        if (sizeOfBodyLength === 1) cursor.pushUint8(bodyLength)\n        else if (sizeOfBodyLength === 2) cursor.pushUint16(bodyLength)\n        else if (sizeOfBodyLength === 3) cursor.pushUint24(bodyLength)\n        else cursor.pushUint32(bodyLength)\n      }\n      for (const { encode } of list) {\n        encode(cursor)\n      }\n    },\n  }\n}\n\nfunction getEncodableBytes(bytesOrHex: ByteArray | Hex): Encodable {\n  const bytes =\n    typeof bytesOrHex === 'string' ? hexToBytes(bytesOrHex) : bytesOrHex\n\n  const sizeOfBytesLength = getSizeOfLength(bytes.length)\n  const length = (() => {\n    if (bytes.length === 1 && bytes[0] < 0x80) return 1\n    if (bytes.length <= 55) return 1 + bytes.length\n    return 1 + sizeOfBytesLength + bytes.length\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor) {\n      if (bytes.length === 1 && bytes[0] < 0x80) {\n        cursor.pushBytes(bytes)\n      } else if (bytes.length <= 55) {\n        cursor.pushByte(0x80 + bytes.length)\n        cursor.pushBytes(bytes)\n      } else {\n        cursor.pushByte(0x80 + 55 + sizeOfBytesLength)\n        if (sizeOfBytesLength === 1) cursor.pushUint8(bytes.length)\n        else if (sizeOfBytesLength === 2) cursor.pushUint16(bytes.length)\n        else if (sizeOfBytesLength === 3) cursor.pushUint24(bytes.length)\n        else cursor.pushUint32(bytes.length)\n        cursor.pushBytes(bytes)\n      }\n    },\n  }\n}\n\nfunction getSizeOfLength(length: number) {\n  if (length < 2 ** 8) return 1\n  if (length < 2 ** 16) return 2\n  if (length < 2 ** 24) return 3\n  if (length < 2 ** 32) return 4\n  throw new BaseError('Length is too large.')\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}