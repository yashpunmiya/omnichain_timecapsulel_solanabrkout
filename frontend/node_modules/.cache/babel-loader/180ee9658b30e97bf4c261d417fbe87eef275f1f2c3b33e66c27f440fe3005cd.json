{"ast":null,"code":"import { createStorage as w } from \"unstorage\";\nimport { createStore as I, get as u, set as p, del as b, keys as v, clear as S } from \"idb-keyval\";\nimport { safeJsonStringify as g, safeJsonParse as d } from \"@walletconnect/safe-json\";\nfunction C(i) {\n  return i;\n}\nconst x = \"idb-keyval\";\nvar z = (i = {}) => {\n  const t = i.base && i.base.length > 0 ? `${i.base}:` : \"\",\n    e = s => t + s;\n  let n;\n  return i.dbName && i.storeName && (n = I(i.dbName, i.storeName)), {\n    name: x,\n    options: i,\n    async hasItem(s) {\n      return !(typeof (await u(e(s), n)) > \"u\");\n    },\n    async getItem(s) {\n      return (await u(e(s), n)) ?? null;\n    },\n    setItem(s, a) {\n      return p(e(s), a, n);\n    },\n    removeItem(s) {\n      return b(e(s), n);\n    },\n    getKeys() {\n      return v(n);\n    },\n    clear() {\n      return S(n);\n    }\n  };\n};\nconst D = \"WALLET_CONNECT_V2_INDEXED_DB\",\n  E = \"keyvaluestorage\";\nclass _ {\n  constructor() {\n    this.indexedDb = w({\n      driver: z({\n        dbName: D,\n        storeName: E\n      })\n    });\n  }\n  async getKeys() {\n    return this.indexedDb.getKeys();\n  }\n  async getEntries() {\n    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map(t => [t.key, t.value]);\n  }\n  async getItem(t) {\n    const e = await this.indexedDb.getItem(t);\n    if (e !== null) return e;\n  }\n  async setItem(t, e) {\n    await this.indexedDb.setItem(t, g(e));\n  }\n  async removeItem(t) {\n    await this.indexedDb.removeItem(t);\n  }\n}\nvar l = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof global < \"u\" ? global : typeof self < \"u\" ? self : {},\n  c = {\n    exports: {}\n  };\n(function () {\n  let i;\n  function t() {}\n  i = t, i.prototype.getItem = function (e) {\n    return this.hasOwnProperty(e) ? String(this[e]) : null;\n  }, i.prototype.setItem = function (e, n) {\n    this[e] = String(n);\n  }, i.prototype.removeItem = function (e) {\n    delete this[e];\n  }, i.prototype.clear = function () {\n    const e = this;\n    Object.keys(e).forEach(function (n) {\n      e[n] = void 0, delete e[n];\n    });\n  }, i.prototype.key = function (e) {\n    return e = e || 0, Object.keys(this)[e];\n  }, i.prototype.__defineGetter__(\"length\", function () {\n    return Object.keys(this).length;\n  }), typeof l < \"u\" && l.localStorage ? c.exports = l.localStorage : typeof window < \"u\" && window.localStorage ? c.exports = window.localStorage : c.exports = new t();\n})();\nfunction k(i) {\n  var t;\n  return [i[0], d((t = i[1]) != null ? t : \"\")];\n}\nclass K {\n  constructor() {\n    this.localStorage = c.exports;\n  }\n  async getKeys() {\n    return Object.keys(this.localStorage);\n  }\n  async getEntries() {\n    return Object.entries(this.localStorage).map(k);\n  }\n  async getItem(t) {\n    const e = this.localStorage.getItem(t);\n    if (e !== null) return d(e);\n  }\n  async setItem(t, e) {\n    this.localStorage.setItem(t, g(e));\n  }\n  async removeItem(t) {\n    this.localStorage.removeItem(t);\n  }\n}\nconst N = \"wc_storage_version\",\n  y = 1,\n  O = async (i, t, e) => {\n    const n = N,\n      s = await t.getItem(n);\n    if (s && s >= y) {\n      e(t);\n      return;\n    }\n    const a = await i.getKeys();\n    if (!a.length) {\n      e(t);\n      return;\n    }\n    const m = [];\n    for (; a.length;) {\n      const r = a.shift();\n      if (!r) continue;\n      const o = r.toLowerCase();\n      if (o.includes(\"wc@\") || o.includes(\"walletconnect\") || o.includes(\"wc_\") || o.includes(\"wallet_connect\")) {\n        const f = await i.getItem(r);\n        await t.setItem(r, f), m.push(r);\n      }\n    }\n    await t.setItem(n, y), e(t), j(i, m);\n  },\n  j = async (i, t) => {\n    t.length && t.forEach(async e => {\n      await i.removeItem(e);\n    });\n  };\nclass h {\n  constructor() {\n    this.initialized = !1, this.setInitialized = e => {\n      this.storage = e, this.initialized = !0;\n    };\n    const t = new K();\n    this.storage = t;\n    try {\n      const e = new _();\n      O(t, e, this.setInitialized);\n    } catch {\n      this.initialized = !0;\n    }\n  }\n  async getKeys() {\n    return await this.initialize(), this.storage.getKeys();\n  }\n  async getEntries() {\n    return await this.initialize(), this.storage.getEntries();\n  }\n  async getItem(t) {\n    return await this.initialize(), this.storage.getItem(t);\n  }\n  async setItem(t, e) {\n    return await this.initialize(), this.storage.setItem(t, e);\n  }\n  async removeItem(t) {\n    return await this.initialize(), this.storage.removeItem(t);\n  }\n  async initialize() {\n    this.initialized || (await new Promise(t => {\n      const e = setInterval(() => {\n        this.initialized && (clearInterval(e), t());\n      }, 20);\n    }));\n  }\n}\nexport { h as KeyValueStorage, h as default };","map":{"version":3,"names":[],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\unstorage\\drivers\\utils\\index.mjs","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\unstorage\\drivers\\indexedb.mjs","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\keyvaluestorage\\src\\browser\\lib\\indexedDb.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\keyvaluestorage\\src\\browser\\lib\\localStoragePrototype.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\keyvaluestorage\\src\\shared\\utils.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\keyvaluestorage\\src\\browser\\lib\\localStore.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\keyvaluestorage\\src\\browser\\lib\\browserMigration.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\keyvaluestorage\\src\\browser\\index.ts"],"sourcesContent":["export function defineDriver(factory) {\n  return factory;\n}\nexport function normalizeKey(key) {\n  if (!key) {\n    return \"\";\n  }\n  return key.replace(/[/\\\\]/g, \":\").replace(/^:|:$/g, \"\");\n}\nexport function joinKeys(...keys) {\n  return keys.map(normalizeKey).filter(Boolean).join(\":\");\n}\nexport function createError(driver, message, opts) {\n  const err = new Error(`[unstorage] [${driver}] ${message}`, opts);\n  return err;\n}\nexport function createRequiredError(driver, name) {\n  if (Array.isArray(name)) {\n    return createError(\n      driver,\n      `Missing some of the required options ${name.map((n) => \"`\" + n + \"`\").join(\", \")}`\n    );\n  }\n  return createError(driver, `Missing required option \\`${name}\\`.`);\n}\n","import { defineDriver } from \"./utils/index.mjs\";\nimport {\n  get,\n  set,\n  clear,\n  del,\n  keys,\n  createStore\n} from \"idb-keyval\";\nconst DRIVER_NAME = \"idb-keyval\";\nexport default defineDriver((opts = {}) => {\n  const base = opts.base && opts.base.length > 0 ? `${opts.base}:` : \"\";\n  const makeKey = (key) => base + key;\n  let customStore;\n  if (opts.dbName && opts.storeName) {\n    customStore = createStore(opts.dbName, opts.storeName);\n  }\n  return {\n    name: DRIVER_NAME,\n    options: opts,\n    async hasItem(key) {\n      const item = await get(makeKey(key), customStore);\n      return typeof item === \"undefined\" ? false : true;\n    },\n    async getItem(key) {\n      const item = await get(makeKey(key), customStore);\n      return item ?? null;\n    },\n    setItem(key, value) {\n      return set(makeKey(key), value, customStore);\n    },\n    removeItem(key) {\n      return del(makeKey(key), customStore);\n    },\n    getKeys() {\n      return keys(customStore);\n    },\n    clear() {\n      return clear(customStore);\n    }\n  };\n});\n","import { createStorage } from \"unstorage\";\nimport indexedDbDriver from \"unstorage/drivers/indexedb\";\n\nimport { IKeyValueStorage } from \"../../shared\";\nimport { safeJsonStringify } from \"@walletconnect/safe-json\";\n\nconst DB_NAME = \"WALLET_CONNECT_V2_INDEXED_DB\";\nconst DB_STORE_NAME = \"keyvaluestorage\";\n\nexport class IndexedDb implements IKeyValueStorage {\n  private indexedDb;\n  constructor() {\n    this.indexedDb = createStorage({\n      driver: indexedDbDriver({ dbName: DB_NAME, storeName: DB_STORE_NAME }),\n    });\n  }\n\n  public async getKeys(): Promise<string[]> {\n    return this.indexedDb.getKeys();\n  }\n\n  public async getEntries<T = any>(): Promise<[string, T][]> {\n    const entries = await this.indexedDb.getItems(await this.indexedDb.getKeys());\n    return entries.map((item: any) => [item.key, item.value] as [string, T]);\n  }\n\n  public async getItem<T = any>(key: string): Promise<T | undefined> {\n    const item = await this.indexedDb.getItem(key);\n    if (item === null) {\n      return undefined;\n    }\n    return item as T;\n  }\n\n  public async setItem<T = any>(key: string, value: T): Promise<void> {\n    await this.indexedDb.setItem(key, safeJsonStringify(value));\n  }\n\n  public async removeItem(key: string): Promise<void> {\n    await this.indexedDb.removeItem(key);\n  }\n}\n","/**\n * Source: https://git.coolaj86.com/coolaj86/local-storage.js/src/branch/local-storage/lib/localStorage.js\n */\n\n/* eslint-disable */\n\n(function () {\n  \"use strict\";\n\n  let db;\n\n  function LocalStorage() {}\n  db = LocalStorage;\n\n  db.prototype.getItem = function (key) {\n    if (this.hasOwnProperty(key)) {\n      return String(this[key]);\n    }\n    return null;\n  };\n\n  db.prototype.setItem = function (key, val) {\n    this[key] = String(val);\n  };\n\n  db.prototype.removeItem = function (key) {\n    delete this[key];\n  };\n\n  db.prototype.clear = function () {\n    const self = this;\n    Object.keys(self).forEach(function (key) {\n      self[key] = undefined;\n      delete self[key];\n    });\n  };\n\n  db.prototype.key = function (i) {\n    i = i || 0;\n    return Object.keys(this)[i];\n  };\n\n  db.prototype.__defineGetter__(\"length\", function () {\n    return Object.keys(this).length;\n  });\n\n  if (typeof global !== \"undefined\" && global.localStorage) {\n    module.exports = global.localStorage;\n  } else if (typeof window !== \"undefined\" && window.localStorage) {\n    module.exports = window.localStorage;\n  } else {\n    module.exports = new LocalStorage();\n  }\n})();\n","import { safeJsonParse } from \"@walletconnect/safe-json\";\n\nexport function parseEntry(entry: [string, string | null]): [string, any] {\n  return [entry[0], safeJsonParse(entry[1] ?? \"\")];\n}\n","import { safeJsonParse, safeJsonStringify } from \"@walletconnect/safe-json\";\n// @ts-expect-error\nimport localStorage from \"./localStoragePrototype\";\nimport { IKeyValueStorage, parseEntry } from \"../../shared\";\n\nexport class LocalStore implements IKeyValueStorage {\n  private readonly localStorage: Storage = localStorage;\n\n  public async getKeys(): Promise<string[]> {\n    return Object.keys(this.localStorage);\n  }\n\n  public async getEntries<T = any>(): Promise<[string, T][]> {\n    return Object.entries(this.localStorage).map(parseEntry);\n  }\n\n  public async getItem<T = any>(key: string): Promise<T | undefined> {\n    const item = this.localStorage.getItem(key);\n    if (item === null) {\n      return undefined;\n    }\n    return safeJsonParse(item) as T;\n  }\n\n  public async setItem<T = any>(key: string, value: T): Promise<void> {\n    this.localStorage.setItem(key, safeJsonStringify(value));\n  }\n\n  public async removeItem(key: string): Promise<void> {\n    this.localStorage.removeItem(key);\n  }\n}\n","import { IKeyValueStorage } from \"../../shared\";\n\nconst VERSION_KEY = \"wc_storage_version\";\nconst DB_VERSION = 1;\n\nexport const migrate = async (\n  fromStore: IKeyValueStorage,\n  toStore: IKeyValueStorage,\n  callback: (store: IKeyValueStorage) => void,\n) => {\n  const versionKey = VERSION_KEY;\n  const currentVersion = await toStore.getItem<number>(versionKey);\n  if (currentVersion && currentVersion >= DB_VERSION) {\n    callback(toStore);\n    return;\n  }\n  const keys = await fromStore.getKeys();\n  if (!keys.length) {\n    callback(toStore);\n    return;\n  }\n  const keysToCleanup: string[] = [];\n  while (keys.length) {\n    const key = keys.shift();\n    if (!key) continue;\n    const formattedKey = key.toLowerCase();\n    if (\n      formattedKey.includes(\"wc@\") ||\n      formattedKey.includes(\"walletconnect\") ||\n      formattedKey.includes(\"wc_\") ||\n      formattedKey.includes(\"wallet_connect\")\n    ) {\n      const item = await fromStore.getItem(key);\n      await toStore.setItem(key, item);\n      keysToCleanup.push(key);\n    }\n  }\n\n  await toStore.setItem(versionKey, DB_VERSION);\n  callback(toStore);\n  cleanup(fromStore, keysToCleanup);\n};\n\nconst cleanup = async (store: IKeyValueStorage, keysToCleanup: string[]) => {\n  if (!keysToCleanup.length) {\n    return;\n  }\n\n  keysToCleanup.forEach(async (key: string) => {\n    await store.removeItem(key);\n  });\n};\n","import { IKeyValueStorage } from \"../shared\";\nimport { IndexedDb } from \"./lib/indexedDb\";\nimport { LocalStore } from \"./lib/localStore\";\nimport { migrate } from \"./lib/browserMigration\";\n\nexport class KeyValueStorage implements IKeyValueStorage {\n  private storage: IKeyValueStorage;\n  private initialized = false;\n\n  constructor() {\n    const local = new LocalStore();\n    this.storage = local;\n    try {\n      const indexed = new IndexedDb();\n      migrate(local, indexed, this.setInitialized);\n      // indexedDb isn't available in node env so this will throw\n    } catch (e) {\n      this.initialized = true;\n    }\n  }\n\n  private setInitialized = (store: IKeyValueStorage) => {\n    this.storage = store;\n    this.initialized = true;\n  };\n\n  public async getKeys(): Promise<string[]> {\n    await this.initialize();\n    return this.storage.getKeys();\n  }\n\n  public async getEntries<T = any>(): Promise<[string, T][]> {\n    await this.initialize();\n    return this.storage.getEntries();\n  }\n\n  public async getItem<T = any>(key: string): Promise<T | undefined> {\n    await this.initialize();\n    return this.storage.getItem(key);\n  }\n\n  public async setItem<T = any>(key: string, value: T): Promise<void> {\n    await this.initialize();\n    return this.storage.setItem(key, value);\n  }\n\n  public async removeItem(key: string): Promise<void> {\n    await this.initialize();\n    return this.storage.removeItem(key);\n  }\n\n  private async initialize() {\n    if (this.initialized) {\n      return;\n    }\n    await new Promise<void>((resolve) => {\n      const interval = setInterval(() => {\n        if (this.initialized) {\n          clearInterval(interval);\n          resolve();\n        }\n      }, 20);\n    });\n  }\n}\n\nexport default KeyValueStorage;\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}