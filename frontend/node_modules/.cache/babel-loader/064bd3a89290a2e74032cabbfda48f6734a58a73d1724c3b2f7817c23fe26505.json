{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebsocketClient = exports.WebsocketError = void 0;\nconst tslib_1 = require(\"tslib\");\nconst ws_1 = tslib_1.__importDefault(require(\"ws\"));\nconst utils_1 = require(\"@trezor/utils\");\nconst DEFAULT_TIMEOUT = 20 * 1000;\nconst DEFAULT_PING_TIMEOUT = 50 * 1000;\nclass WebsocketError extends Error {}\nexports.WebsocketError = WebsocketError;\nclass WebsocketClient extends utils_1.TypedEmitter {\n  options;\n  messages;\n  emitter = this;\n  ws;\n  pingTimeout;\n  connectPromise;\n  ping() {\n    return this.sendMessage({\n      type: 'ping'\n    });\n  }\n  constructor(options) {\n    super();\n    this.options = options;\n    this.messages = (0, utils_1.createDeferredManager)({\n      timeout: this.options.timeout || DEFAULT_TIMEOUT,\n      onTimeout: this.onTimeout.bind(this)\n    });\n  }\n  initWebsocket({\n    url,\n    timeout,\n    headers,\n    agent\n  }) {\n    if (typeof url !== 'string') {\n      throw new WebsocketError('websocket_no_url');\n    }\n    if (url.startsWith('http')) {\n      url = url.replace('http', 'ws');\n    }\n    return new ws_1.default(url, {\n      timeout,\n      headers,\n      agent\n    });\n  }\n  setPingTimeout() {\n    clearTimeout(this.pingTimeout);\n    const doPing = () => {\n      if (this.isConnected()) {\n        return this.onPing().catch(() => {});\n      }\n    };\n    this.pingTimeout = this.isConnected() ? setTimeout(doPing, this.options.pingTimeout || DEFAULT_PING_TIMEOUT) : undefined;\n  }\n  onPing() {\n    return this.ping();\n  }\n  onTimeout() {\n    const {\n      ws\n    } = this;\n    if (!ws) return;\n    this.messages.rejectAll(new WebsocketError('websocket_timeout'));\n    ws.close();\n  }\n  onError() {\n    this.onClose();\n  }\n  sendMessage(message, {\n    timeout\n  } = {}) {\n    const {\n      ws\n    } = this;\n    if (!ws || !this.isConnected()) throw new WebsocketError('websocket_not_initialized');\n    const {\n      promiseId,\n      promise\n    } = this.messages.create(timeout);\n    const req = {\n      id: promiseId.toString(),\n      ...message\n    };\n    this.setPingTimeout();\n    this.options.onSending?.(message);\n    ws.send(JSON.stringify(req));\n    return promise;\n  }\n  sendRawMessage(message) {\n    const {\n      ws\n    } = this;\n    if (!ws || !this.isConnected()) throw new WebsocketError('websocket_not_initialized');\n    ws.send(message, {\n      binary: typeof message !== 'string'\n    });\n    this.setPingTimeout();\n  }\n  onMessage(message, messageValidation) {\n    try {\n      const data = JSON.parse(message.toString());\n      const messageId = Number(data.id);\n      try {\n        const payload = messageValidation ? messageValidation(data) : data;\n        if (payload) {\n          this.messages.resolve(messageId, payload);\n        }\n      } catch (error) {\n        this.messages.reject(messageId, error);\n      }\n    } catch {} finally {\n      this.setPingTimeout();\n    }\n  }\n  async connect() {\n    if (this.connectPromise) {\n      return this.connectPromise;\n    }\n    if (this.isConnected()) return Promise.resolve();\n    if (this.ws?.readyState === ws_1.default.CLOSING) {\n      await new Promise(resolve => this.emitter.once('disconnected', resolve));\n    }\n    const dfd = (0, utils_1.createDeferred)();\n    this.connectPromise = dfd.promise;\n    const ws = this.createWebsocket ? this.createWebsocket() : this.initWebsocket(this.options);\n    const connectionTimeout = setTimeout(() => {\n      this.onClose();\n      dfd.reject(new WebsocketError('websocket_timeout'));\n      try {\n        ws.close();\n      } catch {}\n    }, this.options.connectionTimeout || this.options.timeout || DEFAULT_TIMEOUT);\n    ws.once('error', error => {\n      clearTimeout(connectionTimeout);\n      this.onClose();\n      dfd.reject(new WebsocketError(error.message));\n    });\n    ws.on('open', () => {\n      clearTimeout(connectionTimeout);\n      this.init();\n      dfd.resolve();\n    });\n    this.ws = ws;\n    return dfd.promise.finally(() => {\n      this.connectPromise = undefined;\n    });\n  }\n  init() {\n    const {\n      ws\n    } = this;\n    if (!ws || !this.isConnected()) {\n      throw Error('Websocket init cannot be called');\n    }\n    ws.removeAllListeners();\n    ws.on('error', _error => this.onError());\n    ws.on('message', message => this.onMessage(message));\n    ws.on('close', () => {\n      this.emitter.emit('disconnected');\n      this.onClose();\n    });\n  }\n  disconnect() {\n    if (this.isConnected()) {\n      const disconnectPromise = new Promise(resolve => {\n        this.ws?.once('close', resolve);\n      });\n      this.ws?.close();\n      return disconnectPromise;\n    }\n    return Promise.resolve();\n  }\n  isConnected() {\n    return this.ws?.readyState === ws_1.default.OPEN;\n  }\n  onClose() {\n    clearTimeout(this.pingTimeout);\n    this.ws?.removeAllListeners();\n    this.ws?.on('error', () => {});\n    this.messages.rejectAll(new WebsocketError('Websocket closed unexpectedly'));\n  }\n  dispose() {\n    this.removeAllListeners();\n    this.disconnect();\n    this.onClose();\n  }\n}\nexports.WebsocketClient = WebsocketClient;\n//# sourceMappingURL=client.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}