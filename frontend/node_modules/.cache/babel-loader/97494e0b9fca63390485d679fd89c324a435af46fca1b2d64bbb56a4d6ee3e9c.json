{"ast":null,"code":"import { RLP } from '@ethereumjs/rlp';\nimport { keccak256 } from 'ethereum-cryptography/keccak.js';\nimport { secp256k1 } from 'ethereum-cryptography/secp256k1.js';\nimport { bigIntToUnpaddedBytes, bytesToBigInt, bytesToHex, bytesToInt, concatBytes, equalsBytes, hexToBytes, intToUnpaddedBytes, toBytes, utf8ToBytes, zeros } from './bytes.js';\nimport { BIGINT_0, KECCAK256_NULL, KECCAK256_RLP } from './constants.js';\nimport { assertIsBytes, assertIsHexString, assertIsString } from './helpers.js';\nimport { stripHexPrefix } from './internal.js';\n/**\n * Account class to load and maintain the  basic account objects.\n * Supports partial loading and access required for verkle with null\n * as the placeholder.\n *\n * Note: passing undefined in constructor is different from null\n * While undefined leads to default assignment, null is retained\n * to track the information not available/loaded because of partial\n * witness access\n */\nexport class Account {\n  /**\n   * This constructor assigns and validates the values.\n   * Use the static factory methods to assist in creating an Account from varying data types.\n   * undefined get assigned with the defaults present, but null args are retained as is\n   */\n  constructor(nonce = BIGINT_0, balance = BIGINT_0, storageRoot = KECCAK256_RLP, codeHash = KECCAK256_NULL, codeSize = null, version = 0) {\n    this._nonce = null;\n    this._balance = null;\n    this._storageRoot = null;\n    this._codeHash = null;\n    // codeSize and version is separately stored in VKT\n    this._codeSize = null;\n    this._version = null;\n    this._nonce = nonce;\n    this._balance = balance;\n    this._storageRoot = storageRoot;\n    this._codeHash = codeHash;\n    if (codeSize === null && codeHash !== null && !this.isContract()) {\n      codeSize = 0;\n    }\n    this._codeSize = codeSize;\n    this._version = version;\n    this._validate();\n  }\n  get version() {\n    if (this._version !== null) {\n      return this._version;\n    } else {\n      throw Error(`version=${this._version} not loaded`);\n    }\n  }\n  set version(_version) {\n    this._version = _version;\n  }\n  get nonce() {\n    if (this._nonce !== null) {\n      return this._nonce;\n    } else {\n      throw Error(`nonce=${this._nonce} not loaded`);\n    }\n  }\n  set nonce(_nonce) {\n    this._nonce = _nonce;\n  }\n  get balance() {\n    if (this._balance !== null) {\n      return this._balance;\n    } else {\n      throw Error(`balance=${this._balance} not loaded`);\n    }\n  }\n  set balance(_balance) {\n    this._balance = _balance;\n  }\n  get storageRoot() {\n    if (this._storageRoot !== null) {\n      return this._storageRoot;\n    } else {\n      throw Error(`storageRoot=${this._storageRoot} not loaded`);\n    }\n  }\n  set storageRoot(_storageRoot) {\n    this._storageRoot = _storageRoot;\n  }\n  get codeHash() {\n    if (this._codeHash !== null) {\n      return this._codeHash;\n    } else {\n      throw Error(`codeHash=${this._codeHash} not loaded`);\n    }\n  }\n  set codeHash(_codeHash) {\n    this._codeHash = _codeHash;\n  }\n  get codeSize() {\n    if (this._codeSize !== null) {\n      return this._codeSize;\n    } else {\n      throw Error(`codeHash=${this._codeSize} not loaded`);\n    }\n  }\n  set codeSize(_codeSize) {\n    this._codeSize = _codeSize;\n  }\n  static fromAccountData(accountData) {\n    const {\n      nonce,\n      balance,\n      storageRoot,\n      codeHash\n    } = accountData;\n    if (nonce === null || balance === null || storageRoot === null || codeHash === null) {\n      throw Error(`Partial fields not supported in fromAccountData`);\n    }\n    return new Account(nonce !== undefined ? bytesToBigInt(toBytes(nonce)) : undefined, balance !== undefined ? bytesToBigInt(toBytes(balance)) : undefined, storageRoot !== undefined ? toBytes(storageRoot) : undefined, codeHash !== undefined ? toBytes(codeHash) : undefined);\n  }\n  static fromPartialAccountData(partialAccountData) {\n    const {\n      nonce,\n      balance,\n      storageRoot,\n      codeHash,\n      codeSize,\n      version\n    } = partialAccountData;\n    if (nonce === null && balance === null && storageRoot === null && codeHash === null && codeSize === null && version === null) {\n      throw Error(`All partial fields null`);\n    }\n    return new Account(nonce !== undefined && nonce !== null ? bytesToBigInt(toBytes(nonce)) : nonce, balance !== undefined && balance !== null ? bytesToBigInt(toBytes(balance)) : balance, storageRoot !== undefined && storageRoot !== null ? toBytes(storageRoot) : storageRoot, codeHash !== undefined && codeHash !== null ? toBytes(codeHash) : codeHash, codeSize !== undefined && codeSize !== null ? bytesToInt(toBytes(codeSize)) : codeSize, version !== undefined && version !== null ? bytesToInt(toBytes(version)) : version);\n  }\n  static fromRlpSerializedAccount(serialized) {\n    const values = RLP.decode(serialized);\n    if (!Array.isArray(values)) {\n      throw new Error('Invalid serialized account input. Must be array');\n    }\n    return this.fromValuesArray(values);\n  }\n  static fromRlpSerializedPartialAccount(serialized) {\n    const values = RLP.decode(serialized);\n    if (!Array.isArray(values)) {\n      throw new Error('Invalid serialized account input. Must be array');\n    }\n    let nonce = null;\n    if (!Array.isArray(values[0])) {\n      throw new Error('Invalid partial nonce encoding. Must be array');\n    } else {\n      const isNotNullIndicator = bytesToInt(values[0][0]);\n      if (isNotNullIndicator !== 0 && isNotNullIndicator !== 1) {\n        throw new Error(`Invalid isNullIndicator=${isNotNullIndicator} for nonce`);\n      }\n      if (isNotNullIndicator === 1) {\n        nonce = bytesToBigInt(values[0][1]);\n      }\n    }\n    let balance = null;\n    if (!Array.isArray(values[1])) {\n      throw new Error('Invalid partial balance encoding. Must be array');\n    } else {\n      const isNotNullIndicator = bytesToInt(values[1][0]);\n      if (isNotNullIndicator !== 0 && isNotNullIndicator !== 1) {\n        throw new Error(`Invalid isNullIndicator=${isNotNullIndicator} for balance`);\n      }\n      if (isNotNullIndicator === 1) {\n        balance = bytesToBigInt(values[1][1]);\n      }\n    }\n    let storageRoot = null;\n    if (!Array.isArray(values[2])) {\n      throw new Error('Invalid partial storageRoot encoding. Must be array');\n    } else {\n      const isNotNullIndicator = bytesToInt(values[2][0]);\n      if (isNotNullIndicator !== 0 && isNotNullIndicator !== 1) {\n        throw new Error(`Invalid isNullIndicator=${isNotNullIndicator} for storageRoot`);\n      }\n      if (isNotNullIndicator === 1) {\n        storageRoot = values[2][1];\n      }\n    }\n    let codeHash = null;\n    if (!Array.isArray(values[3])) {\n      throw new Error('Invalid partial codeHash encoding. Must be array');\n    } else {\n      const isNotNullIndicator = bytesToInt(values[3][0]);\n      if (isNotNullIndicator !== 0 && isNotNullIndicator !== 1) {\n        throw new Error(`Invalid isNullIndicator=${isNotNullIndicator} for codeHash`);\n      }\n      if (isNotNullIndicator === 1) {\n        codeHash = values[3][1];\n      }\n    }\n    let codeSize = null;\n    if (!Array.isArray(values[4])) {\n      throw new Error('Invalid partial codeSize encoding. Must be array');\n    } else {\n      const isNotNullIndicator = bytesToInt(values[4][0]);\n      if (isNotNullIndicator !== 0 && isNotNullIndicator !== 1) {\n        throw new Error(`Invalid isNullIndicator=${isNotNullIndicator} for codeSize`);\n      }\n      if (isNotNullIndicator === 1) {\n        codeSize = bytesToInt(values[4][1]);\n      }\n    }\n    let version = null;\n    if (!Array.isArray(values[5])) {\n      throw new Error('Invalid partial version encoding. Must be array');\n    } else {\n      const isNotNullIndicator = bytesToInt(values[5][0]);\n      if (isNotNullIndicator !== 0 && isNotNullIndicator !== 1) {\n        throw new Error(`Invalid isNullIndicator=${isNotNullIndicator} for version`);\n      }\n      if (isNotNullIndicator === 1) {\n        version = bytesToInt(values[5][1]);\n      }\n    }\n    return this.fromPartialAccountData({\n      balance,\n      nonce,\n      storageRoot,\n      codeHash,\n      codeSize,\n      version\n    });\n  }\n  static fromValuesArray(values) {\n    const [nonce, balance, storageRoot, codeHash] = values;\n    return new Account(bytesToBigInt(nonce), bytesToBigInt(balance), storageRoot, codeHash);\n  }\n  _validate() {\n    if (this._nonce !== null && this._nonce < BIGINT_0) {\n      throw new Error('nonce must be greater than zero');\n    }\n    if (this._balance !== null && this._balance < BIGINT_0) {\n      throw new Error('balance must be greater than zero');\n    }\n    if (this._storageRoot !== null && this._storageRoot.length !== 32) {\n      throw new Error('storageRoot must have a length of 32');\n    }\n    if (this._codeHash !== null && this._codeHash.length !== 32) {\n      throw new Error('codeHash must have a length of 32');\n    }\n    if (this._codeSize !== null && this._codeSize < BIGINT_0) {\n      throw new Error('codeSize must be greater than zero');\n    }\n  }\n  /**\n   * Returns an array of Uint8Arrays of the raw bytes for the account, in order.\n   */\n  raw() {\n    return [bigIntToUnpaddedBytes(this.nonce), bigIntToUnpaddedBytes(this.balance), this.storageRoot, this.codeHash];\n  }\n  /**\n   * Returns the RLP serialization of the account as a `Uint8Array`.\n   */\n  serialize() {\n    return RLP.encode(this.raw());\n  }\n  serializeWithPartialInfo() {\n    const partialData = [];\n    const zeroEncoded = intToUnpaddedBytes(0);\n    const oneEncoded = intToUnpaddedBytes(1);\n    if (this._nonce !== null) {\n      partialData.push([oneEncoded, bigIntToUnpaddedBytes(this._nonce)]);\n    } else {\n      partialData.push([zeroEncoded]);\n    }\n    if (this._balance !== null) {\n      partialData.push([oneEncoded, bigIntToUnpaddedBytes(this._balance)]);\n    } else {\n      partialData.push([zeroEncoded]);\n    }\n    if (this._storageRoot !== null) {\n      partialData.push([oneEncoded, this._storageRoot]);\n    } else {\n      partialData.push([zeroEncoded]);\n    }\n    if (this._codeHash !== null) {\n      partialData.push([oneEncoded, this._codeHash]);\n    } else {\n      partialData.push([zeroEncoded]);\n    }\n    if (this._codeSize !== null) {\n      partialData.push([oneEncoded, intToUnpaddedBytes(this._codeSize)]);\n    } else {\n      partialData.push([zeroEncoded]);\n    }\n    if (this._version !== null) {\n      partialData.push([oneEncoded, intToUnpaddedBytes(this._version)]);\n    } else {\n      partialData.push([zeroEncoded]);\n    }\n    return RLP.encode(partialData);\n  }\n  /**\n   * Returns a `Boolean` determining if the account is a contract.\n   */\n  isContract() {\n    if (this._codeHash === null && this._codeSize === null) {\n      throw Error(`Insufficient data as codeHash=null and codeSize=null`);\n    }\n    return this._codeHash !== null && !equalsBytes(this._codeHash, KECCAK256_NULL) || this._codeSize !== null && this._codeSize !== 0;\n  }\n  /**\n   * Returns a `Boolean` determining if the account is empty complying to the definition of\n   * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\n   * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\n   */\n  isEmpty() {\n    // helpful for determination in partial accounts\n    if (this._balance !== null && this.balance !== BIGINT_0 || this._nonce === null && this.nonce !== BIGINT_0 || this._codeHash !== null && !equalsBytes(this.codeHash, KECCAK256_NULL)) {\n      return false;\n    }\n    return this.balance === BIGINT_0 && this.nonce === BIGINT_0 && equalsBytes(this.codeHash, KECCAK256_NULL);\n  }\n}\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\nexport const isValidAddress = function (hexAddress) {\n  try {\n    assertIsString(hexAddress);\n  } catch (e) {\n    return false;\n  }\n  return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);\n};\n/**\n * Returns a checksummed address.\n *\n * If an eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\n *\n * WARNING: Checksums with and without the chainId will differ and the EIP-1191 checksum is not\n * backwards compatible to the original widely adopted checksum format standard introduced in\n * [EIP-55](https://eips.ethereum.org/EIPS/eip-55), so this will break in existing applications.\n * Usage of this EIP is therefore discouraged unless you have a very targeted use case.\n */\nexport const toChecksumAddress = function (hexAddress, eip1191ChainId) {\n  assertIsHexString(hexAddress);\n  const address = stripHexPrefix(hexAddress).toLowerCase();\n  let prefix = '';\n  if (eip1191ChainId !== undefined) {\n    const chainId = bytesToBigInt(toBytes(eip1191ChainId));\n    prefix = chainId.toString() + '0x';\n  }\n  const bytes = utf8ToBytes(prefix + address);\n  const hash = bytesToHex(keccak256(bytes)).slice(2);\n  let ret = '';\n  for (let i = 0; i < address.length; i++) {\n    if (parseInt(hash[i], 16) >= 8) {\n      ret += address[i].toUpperCase();\n    } else {\n      ret += address[i];\n    }\n  }\n  return `0x${ret}`;\n};\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\nexport const isValidChecksumAddress = function (hexAddress, eip1191ChainId) {\n  return isValidAddress(hexAddress) && toChecksumAddress(hexAddress, eip1191ChainId) === hexAddress;\n};\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\nexport const generateAddress = function (from, nonce) {\n  assertIsBytes(from);\n  assertIsBytes(nonce);\n  if (bytesToBigInt(nonce) === BIGINT_0) {\n    // in RLP we want to encode null in the case of zero nonce\n    // read the RLP documentation for an answer if you dare\n    return keccak256(RLP.encode([from, Uint8Array.from([])])).subarray(-20);\n  }\n  // Only take the lower 160bits of the hash\n  return keccak256(RLP.encode([from, nonce])).subarray(-20);\n};\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\nexport const generateAddress2 = function (from, salt, initCode) {\n  assertIsBytes(from);\n  assertIsBytes(salt);\n  assertIsBytes(initCode);\n  if (from.length !== 20) {\n    throw new Error('Expected from to be of length 20');\n  }\n  if (salt.length !== 32) {\n    throw new Error('Expected salt to be of length 32');\n  }\n  const address = keccak256(concatBytes(hexToBytes('0xff'), from, salt, keccak256(initCode)));\n  return address.subarray(-20);\n};\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\nexport const isValidPrivate = function (privateKey) {\n  return secp256k1.utils.isValidPrivateKey(privateKey);\n};\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexport const isValidPublic = function (publicKey, sanitize = false) {\n  assertIsBytes(publicKey);\n  if (publicKey.length === 64) {\n    // Convert to SEC1 for secp256k1\n    // Automatically checks whether point is on curve\n    try {\n      secp256k1.ProjectivePoint.fromHex(concatBytes(Uint8Array.from([4]), publicKey));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  if (!sanitize) {\n    return false;\n  }\n  try {\n    secp256k1.ProjectivePoint.fromHex(publicKey);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexport const pubToAddress = function (pubKey, sanitize = false) {\n  assertIsBytes(pubKey);\n  if (sanitize && pubKey.length !== 64) {\n    pubKey = secp256k1.ProjectivePoint.fromHex(pubKey).toRawBytes(false).slice(1);\n  }\n  if (pubKey.length !== 64) {\n    throw new Error('Expected pubKey to be of length 64');\n  }\n  // Only take the lower 160bits of the hash\n  return keccak256(pubKey).subarray(-20);\n};\nexport const publicToAddress = pubToAddress;\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexport const privateToPublic = function (privateKey) {\n  assertIsBytes(privateKey);\n  // skip the type flag and use the X, Y points\n  return secp256k1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(false).slice(1);\n};\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexport const privateToAddress = function (privateKey) {\n  return publicToAddress(privateToPublic(privateKey));\n};\n/**\n * Converts a public key to the Ethereum format.\n */\nexport const importPublic = function (publicKey) {\n  assertIsBytes(publicKey);\n  if (publicKey.length !== 64) {\n    publicKey = secp256k1.ProjectivePoint.fromHex(publicKey).toRawBytes(false).slice(1);\n  }\n  return publicKey;\n};\n/**\n * Returns the zero address.\n */\nexport const zeroAddress = function () {\n  const addressLength = 20;\n  const addr = zeros(addressLength);\n  return bytesToHex(addr);\n};\n/**\n * Checks if a given address is the zero address.\n */\nexport const isZeroAddress = function (hexAddress) {\n  try {\n    assertIsString(hexAddress);\n  } catch (e) {\n    return false;\n  }\n  const zeroAddr = zeroAddress();\n  return zeroAddr === hexAddress;\n};\nexport function accountBodyFromSlim(body) {\n  const [nonce, balance, storageRoot, codeHash] = body;\n  return [nonce, balance, storageRoot.length === 0 ? KECCAK256_RLP : storageRoot, codeHash.length === 0 ? KECCAK256_NULL : codeHash];\n}\nconst emptyUint8Arr = new Uint8Array(0);\nexport function accountBodyToSlim(body) {\n  const [nonce, balance, storageRoot, codeHash] = body;\n  return [nonce, balance, equalsBytes(storageRoot, KECCAK256_RLP) ? emptyUint8Arr : storageRoot, equalsBytes(codeHash, KECCAK256_NULL) ? emptyUint8Arr : codeHash];\n}\n/**\n * Converts a slim account (per snap protocol spec) to the RLP encoded version of the account\n * @param body Array of 4 Uint8Array-like items to represent the account\n * @returns RLP encoded version of the account\n */\nexport function accountBodyToRLP(body, couldBeSlim = true) {\n  const accountBody = couldBeSlim ? accountBodyFromSlim(body) : body;\n  return RLP.encode(accountBody);\n}\n//# sourceMappingURL=account.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}