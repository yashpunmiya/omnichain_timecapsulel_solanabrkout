{"ast":null,"code":"import ki, { EventEmitter as ee } from \"events\";\nimport { HEARTBEAT_EVENTS as ne, HeartBeat as Ui } from \"@walletconnect/heartbeat\";\nimport Fi from \"@walletconnect/keyvaluestorage\";\nimport { generateChildLogger as N, getLoggerContext as U, pino as Mi, getDefaultLoggerOptions as He, generatePlatformLogger as Ki } from \"@walletconnect/logger\";\nimport { IMessageTracker as Bi, IPublisher as ji, ISubscriber as Vi, IRelayer as qi, IStore as Gi, IJsonRpcHistory as Hi, IExpirer as Yi, IVerify as Ji, IEchoClient as Xi, IEventClient as Wi, ICore as Zi } from \"@walletconnect/types\";\nimport { ONE_DAY as te, SIX_HOURS as Qi, THIRTY_DAYS as Ee, FIVE_SECONDS as we, THIRTY_SECONDS as Ie, toMiliseconds as R, ONE_MINUTE as Ye, ONE_SECOND as Z, Watch as es, FIVE_MINUTES as ye, fromMiliseconds as Je } from \"@walletconnect/time\";\nimport { safeJsonStringify as ts, safeJsonParse as Xe } from \"@walletconnect/safe-json\";\nimport * as be from \"@walletconnect/relay-auth\";\nimport { decodeJWT as We } from \"@walletconnect/relay-auth\";\nimport { mapToObj as Ze, objToMap as Qe, getInternalError as b, generateRandomBytes32 as Te, generateKeyPair as is, deriveSymKey as ss, hashKey as rs, validateEncoding as ns, isTypeTwoEnvelope as et, encodeTypeTwoEnvelope as os, isTypeOneEnvelope as tt, encrypt as as, validateDecoding as cs, decodeTypeTwoEnvelope as hs, decrypt as ls, deserialize as it, decodeTypeByte as us, BASE64 as st, BASE16 as ds, hashMessage as Ce, getRelayProtocolApi as oe, getRelayProtocolName as De, isUndefined as Pe, createExpiringPromise as W, getSdkError as ae, sleep as ps, isAndroid as gs, getAppId as rt, isIos as ys, isOnline as nt, calcExpiry as ce, isNode as ot, formatRelayRpcUrl as bs, subscribeToNetworkChange as Ds, isProposalStruct as ms, isSessionStruct as vs, parseExpirerTarget as fs, TYPE_1 as _s, formatUri as at, parseUri as ct, createDelayedPromise as Es, engineEvent as Se, isExpired as ht, isValidParams as Re, isValidUrl as ws, isValidString as Is, formatTopicTarget as Ts, formatIdTarget as Cs, isTestRun as lt, isBrowser as Ps, verifyP256Jwt as Ss, uuidv4 as ut, formatUA as Rs, getAppMetadata as xs } from \"@walletconnect/utils\";\nimport { toString as Os } from \"uint8arrays\";\nimport { JsonRpcProvider as As } from \"@walletconnect/jsonrpc-provider\";\nimport { getBigIntRpcId as dt, isJsonRpcRequest as pt, isJsonRpcResponse as gt, formatJsonRpcResult as yt, formatJsonRpcRequest as bt, formatJsonRpcError as Ns, isJsonRpcResult as $s, isJsonRpcError as Dt } from \"@walletconnect/jsonrpc-utils\";\nimport zs from \"@walletconnect/jsonrpc-ws-connection\";\nimport Ls from \"lodash.isequal\";\nimport { getDocument as ks } from \"@walletconnect/window-getters\";\nconst xe = \"wc\",\n  Oe = 2,\n  he = \"core\",\n  B = `${xe}@2:${he}:`,\n  mt = {\n    name: he,\n    logger: \"error\"\n  },\n  vt = {\n    database: \":memory:\"\n  },\n  ft = \"crypto\",\n  Ae = \"client_ed25519_seed\",\n  _t = te,\n  Et = \"keychain\",\n  wt = \"0.3\",\n  It = \"messages\",\n  Tt = \"0.3\",\n  Ne = Qi,\n  Ct = \"publisher\",\n  Pt = \"irn\",\n  St = \"error\",\n  $e = \"wss://relay.walletconnect.org\",\n  Rt = \"relayer\",\n  T = {\n    message: \"relayer_message\",\n    message_ack: \"relayer_message_ack\",\n    connect: \"relayer_connect\",\n    disconnect: \"relayer_disconnect\",\n    error: \"relayer_error\",\n    connection_stalled: \"relayer_connection_stalled\",\n    transport_closed: \"relayer_transport_closed\",\n    publish: \"relayer_publish\"\n  },\n  xt = \"_subscription\",\n  L = {\n    payload: \"payload\",\n    connect: \"connect\",\n    disconnect: \"disconnect\",\n    error: \"error\"\n  },\n  Ot = .1,\n  Us = {\n    database: \":memory:\"\n  },\n  me = \"2.19.0\",\n  Fs = 1e4,\n  Q = {\n    link_mode: \"link_mode\",\n    relay: \"relay\"\n  },\n  At = \"0.3\",\n  Nt = \"WALLETCONNECT_CLIENT_ID\",\n  ze = \"WALLETCONNECT_LINK_MODE_APPS\",\n  $ = {\n    created: \"subscription_created\",\n    deleted: \"subscription_deleted\",\n    expired: \"subscription_expired\",\n    disabled: \"subscription_disabled\",\n    sync: \"subscription_sync\",\n    resubscribed: \"subscription_resubscribed\"\n  },\n  Ms = Ee,\n  $t = \"subscription\",\n  zt = \"0.3\",\n  Lt = we * 1e3,\n  kt = \"pairing\",\n  Ut = \"0.3\",\n  Ks = Ee,\n  ie = {\n    wc_pairingDelete: {\n      req: {\n        ttl: te,\n        prompt: !1,\n        tag: 1e3\n      },\n      res: {\n        ttl: te,\n        prompt: !1,\n        tag: 1001\n      }\n    },\n    wc_pairingPing: {\n      req: {\n        ttl: Ie,\n        prompt: !1,\n        tag: 1002\n      },\n      res: {\n        ttl: Ie,\n        prompt: !1,\n        tag: 1003\n      }\n    },\n    unregistered_method: {\n      req: {\n        ttl: te,\n        prompt: !1,\n        tag: 0\n      },\n      res: {\n        ttl: te,\n        prompt: !1,\n        tag: 0\n      }\n    }\n  },\n  se = {\n    create: \"pairing_create\",\n    expire: \"pairing_expire\",\n    delete: \"pairing_delete\",\n    ping: \"pairing_ping\"\n  },\n  F = {\n    created: \"history_created\",\n    updated: \"history_updated\",\n    deleted: \"history_deleted\",\n    sync: \"history_sync\"\n  },\n  Ft = \"history\",\n  Mt = \"0.3\",\n  Kt = \"expirer\",\n  M = {\n    created: \"expirer_created\",\n    deleted: \"expirer_deleted\",\n    expired: \"expirer_expired\",\n    sync: \"expirer_sync\"\n  },\n  Bt = \"0.3\",\n  Bs = te,\n  jt = \"verify-api\",\n  js = \"https://verify.walletconnect.com\",\n  Vt = \"https://verify.walletconnect.org\",\n  le = Vt,\n  qt = `${le}/v3`,\n  Gt = [js, Vt],\n  Ht = \"echo\",\n  Yt = \"https://echo.walletconnect.com\",\n  Vs = \"event-client\",\n  q = {\n    pairing_started: \"pairing_started\",\n    pairing_uri_validation_success: \"pairing_uri_validation_success\",\n    pairing_uri_not_expired: \"pairing_uri_not_expired\",\n    store_new_pairing: \"store_new_pairing\",\n    subscribing_pairing_topic: \"subscribing_pairing_topic\",\n    subscribe_pairing_topic_success: \"subscribe_pairing_topic_success\",\n    existing_pairing: \"existing_pairing\",\n    pairing_not_expired: \"pairing_not_expired\",\n    emit_inactive_pairing: \"emit_inactive_pairing\",\n    emit_session_proposal: \"emit_session_proposal\",\n    subscribing_to_pairing_topic: \"subscribing_to_pairing_topic\"\n  },\n  J = {\n    no_wss_connection: \"no_wss_connection\",\n    no_internet_connection: \"no_internet_connection\",\n    malformed_pairing_uri: \"malformed_pairing_uri\",\n    active_pairing_already_exists: \"active_pairing_already_exists\",\n    subscribe_pairing_topic_failure: \"subscribe_pairing_topic_failure\",\n    pairing_expired: \"pairing_expired\",\n    proposal_expired: \"proposal_expired\",\n    proposal_listener_not_found: \"proposal_listener_not_found\"\n  },\n  qs = {\n    session_approve_started: \"session_approve_started\",\n    proposal_not_expired: \"proposal_not_expired\",\n    session_namespaces_validation_success: \"session_namespaces_validation_success\",\n    create_session_topic: \"create_session_topic\",\n    subscribing_session_topic: \"subscribing_session_topic\",\n    subscribe_session_topic_success: \"subscribe_session_topic_success\",\n    publishing_session_approve: \"publishing_session_approve\",\n    session_approve_publish_success: \"session_approve_publish_success\",\n    store_session: \"store_session\",\n    publishing_session_settle: \"publishing_session_settle\",\n    session_settle_publish_success: \"session_settle_publish_success\"\n  },\n  Gs = {\n    no_internet_connection: \"no_internet_connection\",\n    no_wss_connection: \"no_wss_connection\",\n    proposal_expired: \"proposal_expired\",\n    subscribe_session_topic_failure: \"subscribe_session_topic_failure\",\n    session_approve_publish_failure: \"session_approve_publish_failure\",\n    session_settle_publish_failure: \"session_settle_publish_failure\",\n    session_approve_namespace_validation_failure: \"session_approve_namespace_validation_failure\",\n    proposal_not_found: \"proposal_not_found\"\n  },\n  Hs = {\n    authenticated_session_approve_started: \"authenticated_session_approve_started\",\n    authenticated_session_not_expired: \"authenticated_session_not_expired\",\n    chains_caip2_compliant: \"chains_caip2_compliant\",\n    chains_evm_compliant: \"chains_evm_compliant\",\n    create_authenticated_session_topic: \"create_authenticated_session_topic\",\n    cacaos_verified: \"cacaos_verified\",\n    store_authenticated_session: \"store_authenticated_session\",\n    subscribing_authenticated_session_topic: \"subscribing_authenticated_session_topic\",\n    subscribe_authenticated_session_topic_success: \"subscribe_authenticated_session_topic_success\",\n    publishing_authenticated_session_approve: \"publishing_authenticated_session_approve\",\n    authenticated_session_approve_publish_success: \"authenticated_session_approve_publish_success\"\n  },\n  Ys = {\n    no_internet_connection: \"no_internet_connection\",\n    no_wss_connection: \"no_wss_connection\",\n    missing_session_authenticate_request: \"missing_session_authenticate_request\",\n    session_authenticate_request_expired: \"session_authenticate_request_expired\",\n    chains_caip2_compliant_failure: \"chains_caip2_compliant_failure\",\n    chains_evm_compliant_failure: \"chains_evm_compliant_failure\",\n    invalid_cacao: \"invalid_cacao\",\n    subscribe_authenticated_session_topic_failure: \"subscribe_authenticated_session_topic_failure\",\n    authenticated_session_approve_publish_failure: \"authenticated_session_approve_publish_failure\",\n    authenticated_session_pending_request_not_found: \"authenticated_session_pending_request_not_found\"\n  },\n  Jt = .1,\n  Xt = \"event-client\",\n  Wt = 86400,\n  Zt = \"https://pulse.walletconnect.org/batch\";\nfunction Js(n, e) {\n  if (n.length >= 255) throw new TypeError(\"Alphabet too long\");\n  for (var t = new Uint8Array(256), s = 0; s < t.length; s++) t[s] = 255;\n  for (var i = 0; i < n.length; i++) {\n    var r = n.charAt(i),\n      o = r.charCodeAt(0);\n    if (t[o] !== 255) throw new TypeError(r + \" is ambiguous\");\n    t[o] = i;\n  }\n  var a = n.length,\n    c = n.charAt(0),\n    h = Math.log(a) / Math.log(256),\n    u = Math.log(256) / Math.log(a);\n  function g(l) {\n    if (l instanceof Uint8Array || (ArrayBuffer.isView(l) ? l = new Uint8Array(l.buffer, l.byteOffset, l.byteLength) : Array.isArray(l) && (l = Uint8Array.from(l))), !(l instanceof Uint8Array)) throw new TypeError(\"Expected Uint8Array\");\n    if (l.length === 0) return \"\";\n    for (var y = 0, O = 0, w = 0, v = l.length; w !== v && l[w] === 0;) w++, y++;\n    for (var k = (v - w) * u + 1 >>> 0, I = new Uint8Array(k); w !== v;) {\n      for (var V = l[w], X = 0, K = k - 1; (V !== 0 || X < O) && K !== -1; K--, X++) V += 256 * I[K] >>> 0, I[K] = V % a >>> 0, V = V / a >>> 0;\n      if (V !== 0) throw new Error(\"Non-zero carry\");\n      O = X, w++;\n    }\n    for (var Y = k - O; Y !== k && I[Y] === 0;) Y++;\n    for (var ge = c.repeat(y); Y < k; ++Y) ge += n.charAt(I[Y]);\n    return ge;\n  }\n  function m(l) {\n    if (typeof l != \"string\") throw new TypeError(\"Expected String\");\n    if (l.length === 0) return new Uint8Array();\n    var y = 0;\n    if (l[y] !== \" \") {\n      for (var O = 0, w = 0; l[y] === c;) O++, y++;\n      for (var v = (l.length - y) * h + 1 >>> 0, k = new Uint8Array(v); l[y];) {\n        var I = t[l.charCodeAt(y)];\n        if (I === 255) return;\n        for (var V = 0, X = v - 1; (I !== 0 || V < w) && X !== -1; X--, V++) I += a * k[X] >>> 0, k[X] = I % 256 >>> 0, I = I / 256 >>> 0;\n        if (I !== 0) throw new Error(\"Non-zero carry\");\n        w = V, y++;\n      }\n      if (l[y] !== \" \") {\n        for (var K = v - w; K !== v && k[K] === 0;) K++;\n        for (var Y = new Uint8Array(O + (v - K)), ge = O; K !== v;) Y[ge++] = k[K++];\n        return Y;\n      }\n    }\n  }\n  function A(l) {\n    var y = m(l);\n    if (y) return y;\n    throw new Error(`Non-${e} character`);\n  }\n  return {\n    encode: g,\n    decodeUnsafe: m,\n    decode: A\n  };\n}\nvar Xs = Js,\n  Ws = Xs;\nconst Qt = n => {\n    if (n instanceof Uint8Array && n.constructor.name === \"Uint8Array\") return n;\n    if (n instanceof ArrayBuffer) return new Uint8Array(n);\n    if (ArrayBuffer.isView(n)) return new Uint8Array(n.buffer, n.byteOffset, n.byteLength);\n    throw new Error(\"Unknown type, must be binary type\");\n  },\n  Zs = n => new TextEncoder().encode(n),\n  Qs = n => new TextDecoder().decode(n);\nclass er {\n  constructor(e, t, s) {\n    this.name = e, this.prefix = t, this.baseEncode = s;\n  }\n  encode(e) {\n    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;\n    throw Error(\"Unknown type, must be binary type\");\n  }\n}\nclass tr {\n  constructor(e, t, s) {\n    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error(\"Invalid prefix character\");\n    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = s;\n  }\n  decode(e) {\n    if (typeof e == \"string\") {\n      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);\n      return this.baseDecode(e.slice(this.prefix.length));\n    } else throw Error(\"Can only multibase decode strings\");\n  }\n  or(e) {\n    return ei(this, e);\n  }\n}\nclass ir {\n  constructor(e) {\n    this.decoders = e;\n  }\n  or(e) {\n    return ei(this, e);\n  }\n  decode(e) {\n    const t = e[0],\n      s = this.decoders[t];\n    if (s) return s.decode(e);\n    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);\n  }\n}\nconst ei = (n, e) => new ir({\n  ...(n.decoders || {\n    [n.prefix]: n\n  }),\n  ...(e.decoders || {\n    [e.prefix]: e\n  })\n});\nclass sr {\n  constructor(e, t, s, i) {\n    this.name = e, this.prefix = t, this.baseEncode = s, this.baseDecode = i, this.encoder = new er(e, t, s), this.decoder = new tr(e, t, i);\n  }\n  encode(e) {\n    return this.encoder.encode(e);\n  }\n  decode(e) {\n    return this.decoder.decode(e);\n  }\n}\nconst ve = ({\n    name: n,\n    prefix: e,\n    encode: t,\n    decode: s\n  }) => new sr(n, e, t, s),\n  ue = ({\n    prefix: n,\n    name: e,\n    alphabet: t\n  }) => {\n    const {\n      encode: s,\n      decode: i\n    } = Ws(t, e);\n    return ve({\n      prefix: n,\n      name: e,\n      encode: s,\n      decode: r => Qt(i(r))\n    });\n  },\n  rr = (n, e, t, s) => {\n    const i = {};\n    for (let u = 0; u < e.length; ++u) i[e[u]] = u;\n    let r = n.length;\n    for (; n[r - 1] === \"=\";) --r;\n    const o = new Uint8Array(r * t / 8 | 0);\n    let a = 0,\n      c = 0,\n      h = 0;\n    for (let u = 0; u < r; ++u) {\n      const g = i[n[u]];\n      if (g === void 0) throw new SyntaxError(`Non-${s} character`);\n      c = c << t | g, a += t, a >= 8 && (a -= 8, o[h++] = 255 & c >> a);\n    }\n    if (a >= t || 255 & c << 8 - a) throw new SyntaxError(\"Unexpected end of data\");\n    return o;\n  },\n  nr = (n, e, t) => {\n    const s = e[e.length - 1] === \"=\",\n      i = (1 << t) - 1;\n    let r = \"\",\n      o = 0,\n      a = 0;\n    for (let c = 0; c < n.length; ++c) for (a = a << 8 | n[c], o += 8; o > t;) o -= t, r += e[i & a >> o];\n    if (o && (r += e[i & a << t - o]), s) for (; r.length * t & 7;) r += \"=\";\n    return r;\n  },\n  C = ({\n    name: n,\n    prefix: e,\n    bitsPerChar: t,\n    alphabet: s\n  }) => ve({\n    prefix: e,\n    name: n,\n    encode(i) {\n      return nr(i, s, t);\n    },\n    decode(i) {\n      return rr(i, s, t, n);\n    }\n  }),\n  or = ve({\n    prefix: \"\\0\",\n    name: \"identity\",\n    encode: n => Qs(n),\n    decode: n => Zs(n)\n  });\nvar ar = Object.freeze({\n  __proto__: null,\n  identity: or\n});\nconst cr = C({\n  prefix: \"0\",\n  name: \"base2\",\n  alphabet: \"01\",\n  bitsPerChar: 1\n});\nvar hr = Object.freeze({\n  __proto__: null,\n  base2: cr\n});\nconst lr = C({\n  prefix: \"7\",\n  name: \"base8\",\n  alphabet: \"01234567\",\n  bitsPerChar: 3\n});\nvar ur = Object.freeze({\n  __proto__: null,\n  base8: lr\n});\nconst dr = ue({\n  prefix: \"9\",\n  name: \"base10\",\n  alphabet: \"0123456789\"\n});\nvar pr = Object.freeze({\n  __proto__: null,\n  base10: dr\n});\nconst gr = C({\n    prefix: \"f\",\n    name: \"base16\",\n    alphabet: \"0123456789abcdef\",\n    bitsPerChar: 4\n  }),\n  yr = C({\n    prefix: \"F\",\n    name: \"base16upper\",\n    alphabet: \"0123456789ABCDEF\",\n    bitsPerChar: 4\n  });\nvar br = Object.freeze({\n  __proto__: null,\n  base16: gr,\n  base16upper: yr\n});\nconst Dr = C({\n    prefix: \"b\",\n    name: \"base32\",\n    alphabet: \"abcdefghijklmnopqrstuvwxyz234567\",\n    bitsPerChar: 5\n  }),\n  mr = C({\n    prefix: \"B\",\n    name: \"base32upper\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\",\n    bitsPerChar: 5\n  }),\n  vr = C({\n    prefix: \"c\",\n    name: \"base32pad\",\n    alphabet: \"abcdefghijklmnopqrstuvwxyz234567=\",\n    bitsPerChar: 5\n  }),\n  fr = C({\n    prefix: \"C\",\n    name: \"base32padupper\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=\",\n    bitsPerChar: 5\n  }),\n  _r = C({\n    prefix: \"v\",\n    name: \"base32hex\",\n    alphabet: \"0123456789abcdefghijklmnopqrstuv\",\n    bitsPerChar: 5\n  }),\n  Er = C({\n    prefix: \"V\",\n    name: \"base32hexupper\",\n    alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV\",\n    bitsPerChar: 5\n  }),\n  wr = C({\n    prefix: \"t\",\n    name: \"base32hexpad\",\n    alphabet: \"0123456789abcdefghijklmnopqrstuv=\",\n    bitsPerChar: 5\n  }),\n  Ir = C({\n    prefix: \"T\",\n    name: \"base32hexpadupper\",\n    alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV=\",\n    bitsPerChar: 5\n  }),\n  Tr = C({\n    prefix: \"h\",\n    name: \"base32z\",\n    alphabet: \"ybndrfg8ejkmcpqxot1uwisza345h769\",\n    bitsPerChar: 5\n  });\nvar Cr = Object.freeze({\n  __proto__: null,\n  base32: Dr,\n  base32upper: mr,\n  base32pad: vr,\n  base32padupper: fr,\n  base32hex: _r,\n  base32hexupper: Er,\n  base32hexpad: wr,\n  base32hexpadupper: Ir,\n  base32z: Tr\n});\nconst Pr = ue({\n    prefix: \"k\",\n    name: \"base36\",\n    alphabet: \"0123456789abcdefghijklmnopqrstuvwxyz\"\n  }),\n  Sr = ue({\n    prefix: \"K\",\n    name: \"base36upper\",\n    alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  });\nvar Rr = Object.freeze({\n  __proto__: null,\n  base36: Pr,\n  base36upper: Sr\n});\nconst xr = ue({\n    name: \"base58btc\",\n    prefix: \"z\",\n    alphabet: \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n  }),\n  Or = ue({\n    name: \"base58flickr\",\n    prefix: \"Z\",\n    alphabet: \"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\"\n  });\nvar Ar = Object.freeze({\n  __proto__: null,\n  base58btc: xr,\n  base58flickr: Or\n});\nconst Nr = C({\n    prefix: \"m\",\n    name: \"base64\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",\n    bitsPerChar: 6\n  }),\n  $r = C({\n    prefix: \"M\",\n    name: \"base64pad\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n    bitsPerChar: 6\n  }),\n  zr = C({\n    prefix: \"u\",\n    name: \"base64url\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\",\n    bitsPerChar: 6\n  }),\n  Lr = C({\n    prefix: \"U\",\n    name: \"base64urlpad\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=\",\n    bitsPerChar: 6\n  });\nvar kr = Object.freeze({\n  __proto__: null,\n  base64: Nr,\n  base64pad: $r,\n  base64url: zr,\n  base64urlpad: Lr\n});\nconst ti = Array.from(\"\\u{1F680}\\u{1FA90}\\u2604\\u{1F6F0}\\u{1F30C}\\u{1F311}\\u{1F312}\\u{1F313}\\u{1F314}\\u{1F315}\\u{1F316}\\u{1F317}\\u{1F318}\\u{1F30D}\\u{1F30F}\\u{1F30E}\\u{1F409}\\u2600\\u{1F4BB}\\u{1F5A5}\\u{1F4BE}\\u{1F4BF}\\u{1F602}\\u2764\\u{1F60D}\\u{1F923}\\u{1F60A}\\u{1F64F}\\u{1F495}\\u{1F62D}\\u{1F618}\\u{1F44D}\\u{1F605}\\u{1F44F}\\u{1F601}\\u{1F525}\\u{1F970}\\u{1F494}\\u{1F496}\\u{1F499}\\u{1F622}\\u{1F914}\\u{1F606}\\u{1F644}\\u{1F4AA}\\u{1F609}\\u263A\\u{1F44C}\\u{1F917}\\u{1F49C}\\u{1F614}\\u{1F60E}\\u{1F607}\\u{1F339}\\u{1F926}\\u{1F389}\\u{1F49E}\\u270C\\u2728\\u{1F937}\\u{1F631}\\u{1F60C}\\u{1F338}\\u{1F64C}\\u{1F60B}\\u{1F497}\\u{1F49A}\\u{1F60F}\\u{1F49B}\\u{1F642}\\u{1F493}\\u{1F929}\\u{1F604}\\u{1F600}\\u{1F5A4}\\u{1F603}\\u{1F4AF}\\u{1F648}\\u{1F447}\\u{1F3B6}\\u{1F612}\\u{1F92D}\\u2763\\u{1F61C}\\u{1F48B}\\u{1F440}\\u{1F62A}\\u{1F611}\\u{1F4A5}\\u{1F64B}\\u{1F61E}\\u{1F629}\\u{1F621}\\u{1F92A}\\u{1F44A}\\u{1F973}\\u{1F625}\\u{1F924}\\u{1F449}\\u{1F483}\\u{1F633}\\u270B\\u{1F61A}\\u{1F61D}\\u{1F634}\\u{1F31F}\\u{1F62C}\\u{1F643}\\u{1F340}\\u{1F337}\\u{1F63B}\\u{1F613}\\u2B50\\u2705\\u{1F97A}\\u{1F308}\\u{1F608}\\u{1F918}\\u{1F4A6}\\u2714\\u{1F623}\\u{1F3C3}\\u{1F490}\\u2639\\u{1F38A}\\u{1F498}\\u{1F620}\\u261D\\u{1F615}\\u{1F33A}\\u{1F382}\\u{1F33B}\\u{1F610}\\u{1F595}\\u{1F49D}\\u{1F64A}\\u{1F639}\\u{1F5E3}\\u{1F4AB}\\u{1F480}\\u{1F451}\\u{1F3B5}\\u{1F91E}\\u{1F61B}\\u{1F534}\\u{1F624}\\u{1F33C}\\u{1F62B}\\u26BD\\u{1F919}\\u2615\\u{1F3C6}\\u{1F92B}\\u{1F448}\\u{1F62E}\\u{1F646}\\u{1F37B}\\u{1F343}\\u{1F436}\\u{1F481}\\u{1F632}\\u{1F33F}\\u{1F9E1}\\u{1F381}\\u26A1\\u{1F31E}\\u{1F388}\\u274C\\u270A\\u{1F44B}\\u{1F630}\\u{1F928}\\u{1F636}\\u{1F91D}\\u{1F6B6}\\u{1F4B0}\\u{1F353}\\u{1F4A2}\\u{1F91F}\\u{1F641}\\u{1F6A8}\\u{1F4A8}\\u{1F92C}\\u2708\\u{1F380}\\u{1F37A}\\u{1F913}\\u{1F619}\\u{1F49F}\\u{1F331}\\u{1F616}\\u{1F476}\\u{1F974}\\u25B6\\u27A1\\u2753\\u{1F48E}\\u{1F4B8}\\u2B07\\u{1F628}\\u{1F31A}\\u{1F98B}\\u{1F637}\\u{1F57A}\\u26A0\\u{1F645}\\u{1F61F}\\u{1F635}\\u{1F44E}\\u{1F932}\\u{1F920}\\u{1F927}\\u{1F4CC}\\u{1F535}\\u{1F485}\\u{1F9D0}\\u{1F43E}\\u{1F352}\\u{1F617}\\u{1F911}\\u{1F30A}\\u{1F92F}\\u{1F437}\\u260E\\u{1F4A7}\\u{1F62F}\\u{1F486}\\u{1F446}\\u{1F3A4}\\u{1F647}\\u{1F351}\\u2744\\u{1F334}\\u{1F4A3}\\u{1F438}\\u{1F48C}\\u{1F4CD}\\u{1F940}\\u{1F922}\\u{1F445}\\u{1F4A1}\\u{1F4A9}\\u{1F450}\\u{1F4F8}\\u{1F47B}\\u{1F910}\\u{1F92E}\\u{1F3BC}\\u{1F975}\\u{1F6A9}\\u{1F34E}\\u{1F34A}\\u{1F47C}\\u{1F48D}\\u{1F4E3}\\u{1F942}\"),\n  Ur = ti.reduce((n, e, t) => (n[t] = e, n), []),\n  Fr = ti.reduce((n, e, t) => (n[e.codePointAt(0)] = t, n), []);\nfunction Mr(n) {\n  return n.reduce((e, t) => (e += Ur[t], e), \"\");\n}\nfunction Kr(n) {\n  const e = [];\n  for (const t of n) {\n    const s = Fr[t.codePointAt(0)];\n    if (s === void 0) throw new Error(`Non-base256emoji character: ${t}`);\n    e.push(s);\n  }\n  return new Uint8Array(e);\n}\nconst Br = ve({\n  prefix: \"\\u{1F680}\",\n  name: \"base256emoji\",\n  encode: Mr,\n  decode: Kr\n});\nvar jr = Object.freeze({\n    __proto__: null,\n    base256emoji: Br\n  }),\n  Vr = si,\n  ii = 128,\n  qr = 127,\n  Gr = ~qr,\n  Hr = Math.pow(2, 31);\nfunction si(n, e, t) {\n  e = e || [], t = t || 0;\n  for (var s = t; n >= Hr;) e[t++] = n & 255 | ii, n /= 128;\n  for (; n & Gr;) e[t++] = n & 255 | ii, n >>>= 7;\n  return e[t] = n | 0, si.bytes = t - s + 1, e;\n}\nvar Yr = Le,\n  Jr = 128,\n  ri = 127;\nfunction Le(n, s) {\n  var t = 0,\n    s = s || 0,\n    i = 0,\n    r = s,\n    o,\n    a = n.length;\n  do {\n    if (r >= a) throw Le.bytes = 0, new RangeError(\"Could not decode varint\");\n    o = n[r++], t += i < 28 ? (o & ri) << i : (o & ri) * Math.pow(2, i), i += 7;\n  } while (o >= Jr);\n  return Le.bytes = r - s, t;\n}\nvar Xr = Math.pow(2, 7),\n  Wr = Math.pow(2, 14),\n  Zr = Math.pow(2, 21),\n  Qr = Math.pow(2, 28),\n  en = Math.pow(2, 35),\n  tn = Math.pow(2, 42),\n  sn = Math.pow(2, 49),\n  rn = Math.pow(2, 56),\n  nn = Math.pow(2, 63),\n  on = function (n) {\n    return n < Xr ? 1 : n < Wr ? 2 : n < Zr ? 3 : n < Qr ? 4 : n < en ? 5 : n < tn ? 6 : n < sn ? 7 : n < rn ? 8 : n < nn ? 9 : 10;\n  },\n  an = {\n    encode: Vr,\n    decode: Yr,\n    encodingLength: on\n  },\n  ni = an;\nconst oi = (n, e, t = 0) => (ni.encode(n, e, t), e),\n  ai = n => ni.encodingLength(n),\n  ke = (n, e) => {\n    const t = e.byteLength,\n      s = ai(n),\n      i = s + ai(t),\n      r = new Uint8Array(i + t);\n    return oi(n, r, 0), oi(t, r, s), r.set(e, i), new cn(n, t, e, r);\n  };\nclass cn {\n  constructor(e, t, s, i) {\n    this.code = e, this.size = t, this.digest = s, this.bytes = i;\n  }\n}\nconst ci = ({\n  name: n,\n  code: e,\n  encode: t\n}) => new hn(n, e, t);\nclass hn {\n  constructor(e, t, s) {\n    this.name = e, this.code = t, this.encode = s;\n  }\n  digest(e) {\n    if (e instanceof Uint8Array) {\n      const t = this.encode(e);\n      return t instanceof Uint8Array ? ke(this.code, t) : t.then(s => ke(this.code, s));\n    } else throw Error(\"Unknown type, must be binary type\");\n  }\n}\nconst hi = n => async e => new Uint8Array(await crypto.subtle.digest(n, e)),\n  ln = ci({\n    name: \"sha2-256\",\n    code: 18,\n    encode: hi(\"SHA-256\")\n  }),\n  un = ci({\n    name: \"sha2-512\",\n    code: 19,\n    encode: hi(\"SHA-512\")\n  });\nvar dn = Object.freeze({\n  __proto__: null,\n  sha256: ln,\n  sha512: un\n});\nconst li = 0,\n  pn = \"identity\",\n  ui = Qt,\n  gn = n => ke(li, ui(n)),\n  yn = {\n    code: li,\n    name: pn,\n    encode: ui,\n    digest: gn\n  };\nvar bn = Object.freeze({\n  __proto__: null,\n  identity: yn\n});\nnew TextEncoder(), new TextDecoder();\nconst di = {\n  ...ar,\n  ...hr,\n  ...ur,\n  ...pr,\n  ...br,\n  ...Cr,\n  ...Rr,\n  ...Ar,\n  ...kr,\n  ...jr\n};\n({\n  ...dn,\n  ...bn\n});\nfunction Dn(n = 0) {\n  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(n) : new Uint8Array(n);\n}\nfunction pi(n, e, t, s) {\n  return {\n    name: n,\n    prefix: e,\n    encoder: {\n      name: n,\n      prefix: e,\n      encode: t\n    },\n    decoder: {\n      decode: s\n    }\n  };\n}\nconst gi = pi(\"utf8\", \"u\", n => \"u\" + new TextDecoder(\"utf8\").decode(n), n => new TextEncoder().encode(n.substring(1))),\n  Ue = pi(\"ascii\", \"a\", n => {\n    let e = \"a\";\n    for (let t = 0; t < n.length; t++) e += String.fromCharCode(n[t]);\n    return e;\n  }, n => {\n    n = n.substring(1);\n    const e = Dn(n.length);\n    for (let t = 0; t < n.length; t++) e[t] = n.charCodeAt(t);\n    return e;\n  }),\n  mn = {\n    utf8: gi,\n    \"utf-8\": gi,\n    hex: di.base16,\n    latin1: Ue,\n    ascii: Ue,\n    binary: Ue,\n    ...di\n  };\nfunction vn(n, e = \"utf8\") {\n  const t = mn[e];\n  if (!t) throw new Error(`Unsupported encoding \"${e}\"`);\n  return (e === \"utf8\" || e === \"utf-8\") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(n, \"utf8\") : t.decoder.decode(`${t.prefix}${n}`);\n}\nvar fn = Object.defineProperty,\n  _n = (n, e, t) => e in n ? fn(n, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : n[e] = t,\n  G = (n, e, t) => _n(n, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass yi {\n  constructor(e, t) {\n    this.core = e, this.logger = t, G(this, \"keychain\", new Map()), G(this, \"name\", Et), G(this, \"version\", wt), G(this, \"initialized\", !1), G(this, \"storagePrefix\", B), G(this, \"init\", async () => {\n      if (!this.initialized) {\n        const s = await this.getKeyChain();\n        typeof s < \"u\" && (this.keychain = s), this.initialized = !0;\n      }\n    }), G(this, \"has\", s => (this.isInitialized(), this.keychain.has(s))), G(this, \"set\", async (s, i) => {\n      this.isInitialized(), this.keychain.set(s, i), await this.persist();\n    }), G(this, \"get\", s => {\n      this.isInitialized();\n      const i = this.keychain.get(s);\n      if (typeof i > \"u\") {\n        const {\n          message: r\n        } = b(\"NO_MATCHING_KEY\", `${this.name}: ${s}`);\n        throw new Error(r);\n      }\n      return i;\n    }), G(this, \"del\", async s => {\n      this.isInitialized(), this.keychain.delete(s), await this.persist();\n    }), this.core = e, this.logger = N(t, this.name);\n  }\n  get context() {\n    return U(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + this.name;\n  }\n  async setKeyChain(e) {\n    await this.core.storage.setItem(this.storageKey, Ze(e));\n  }\n  async getKeyChain() {\n    const e = await this.core.storage.getItem(this.storageKey);\n    return typeof e < \"u\" ? Qe(e) : void 0;\n  }\n  async persist() {\n    await this.setKeyChain(this.keychain);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = b(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nvar En = Object.defineProperty,\n  wn = (n, e, t) => e in n ? En(n, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : n[e] = t,\n  P = (n, e, t) => wn(n, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass bi {\n  constructor(e, t, s) {\n    this.core = e, this.logger = t, P(this, \"name\", ft), P(this, \"keychain\"), P(this, \"randomSessionIdentifier\", Te()), P(this, \"initialized\", !1), P(this, \"init\", async () => {\n      this.initialized || (await this.keychain.init(), this.initialized = !0);\n    }), P(this, \"hasKeys\", i => (this.isInitialized(), this.keychain.has(i))), P(this, \"getClientId\", async () => {\n      this.isInitialized();\n      const i = await this.getClientSeed(),\n        r = be.generateKeyPair(i);\n      return be.encodeIss(r.publicKey);\n    }), P(this, \"generateKeyPair\", () => {\n      this.isInitialized();\n      const i = is();\n      return this.setPrivateKey(i.publicKey, i.privateKey);\n    }), P(this, \"signJWT\", async i => {\n      this.isInitialized();\n      const r = await this.getClientSeed(),\n        o = be.generateKeyPair(r),\n        a = this.randomSessionIdentifier,\n        c = _t;\n      return await be.signJWT(a, i, c, o);\n    }), P(this, \"generateSharedKey\", (i, r, o) => {\n      this.isInitialized();\n      const a = this.getPrivateKey(i),\n        c = ss(a, r);\n      return this.setSymKey(c, o);\n    }), P(this, \"setSymKey\", async (i, r) => {\n      this.isInitialized();\n      const o = r || rs(i);\n      return await this.keychain.set(o, i), o;\n    }), P(this, \"deleteKeyPair\", async i => {\n      this.isInitialized(), await this.keychain.del(i);\n    }), P(this, \"deleteSymKey\", async i => {\n      this.isInitialized(), await this.keychain.del(i);\n    }), P(this, \"encode\", async (i, r, o) => {\n      this.isInitialized();\n      const a = ns(o),\n        c = ts(r);\n      if (et(a)) return os(c, o?.encoding);\n      if (tt(a)) {\n        const m = a.senderPublicKey,\n          A = a.receiverPublicKey;\n        i = await this.generateSharedKey(m, A);\n      }\n      const h = this.getSymKey(i),\n        {\n          type: u,\n          senderPublicKey: g\n        } = a;\n      return as({\n        type: u,\n        symKey: h,\n        message: c,\n        senderPublicKey: g,\n        encoding: o?.encoding\n      });\n    }), P(this, \"decode\", async (i, r, o) => {\n      this.isInitialized();\n      const a = cs(r, o);\n      if (et(a)) {\n        const c = hs(r, o?.encoding);\n        return Xe(c);\n      }\n      if (tt(a)) {\n        const c = a.receiverPublicKey,\n          h = a.senderPublicKey;\n        i = await this.generateSharedKey(c, h);\n      }\n      try {\n        const c = this.getSymKey(i),\n          h = ls({\n            symKey: c,\n            encoded: r,\n            encoding: o?.encoding\n          });\n        return Xe(h);\n      } catch (c) {\n        this.logger.error(`Failed to decode message from topic: '${i}', clientId: '${await this.getClientId()}'`), this.logger.error(c);\n      }\n    }), P(this, \"getPayloadType\", (i, r = st) => {\n      const o = it({\n        encoded: i,\n        encoding: r\n      });\n      return us(o.type);\n    }), P(this, \"getPayloadSenderPublicKey\", (i, r = st) => {\n      const o = it({\n        encoded: i,\n        encoding: r\n      });\n      return o.senderPublicKey ? Os(o.senderPublicKey, ds) : void 0;\n    }), this.core = e, this.logger = N(t, this.name), this.keychain = s || new yi(this.core, this.logger);\n  }\n  get context() {\n    return U(this.logger);\n  }\n  async setPrivateKey(e, t) {\n    return await this.keychain.set(e, t), e;\n  }\n  getPrivateKey(e) {\n    return this.keychain.get(e);\n  }\n  async getClientSeed() {\n    let e = \"\";\n    try {\n      e = this.keychain.get(Ae);\n    } catch {\n      e = Te(), await this.keychain.set(Ae, e);\n    }\n    return vn(e, \"base16\");\n  }\n  getSymKey(e) {\n    return this.keychain.get(e);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = b(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nvar In = Object.defineProperty,\n  Tn = (n, e, t) => e in n ? In(n, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : n[e] = t,\n  H = (n, e, t) => Tn(n, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass Di extends Bi {\n  constructor(e, t) {\n    super(e, t), this.logger = e, this.core = t, H(this, \"messages\", new Map()), H(this, \"name\", It), H(this, \"version\", Tt), H(this, \"initialized\", !1), H(this, \"storagePrefix\", B), H(this, \"init\", async () => {\n      if (!this.initialized) {\n        this.logger.trace(\"Initialized\");\n        try {\n          const s = await this.getRelayerMessages();\n          typeof s < \"u\" && (this.messages = s), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({\n            type: \"method\",\n            method: \"restore\",\n            size: this.messages.size\n          });\n        } catch (s) {\n          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(s);\n        } finally {\n          this.initialized = !0;\n        }\n      }\n    }), H(this, \"set\", async (s, i) => {\n      this.isInitialized();\n      const r = Ce(i);\n      let o = this.messages.get(s);\n      return typeof o > \"u\" && (o = {}), typeof o[r] < \"u\" || (o[r] = i, this.messages.set(s, o), await this.persist()), r;\n    }), H(this, \"get\", s => {\n      this.isInitialized();\n      let i = this.messages.get(s);\n      return typeof i > \"u\" && (i = {}), i;\n    }), H(this, \"has\", (s, i) => {\n      this.isInitialized();\n      const r = this.get(s),\n        o = Ce(i);\n      return typeof r[o] < \"u\";\n    }), H(this, \"del\", async s => {\n      this.isInitialized(), this.messages.delete(s), await this.persist();\n    }), this.logger = N(e, this.name), this.core = t;\n  }\n  get context() {\n    return U(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + this.name;\n  }\n  async setRelayerMessages(e) {\n    await this.core.storage.setItem(this.storageKey, Ze(e));\n  }\n  async getRelayerMessages() {\n    const e = await this.core.storage.getItem(this.storageKey);\n    return typeof e < \"u\" ? Qe(e) : void 0;\n  }\n  async persist() {\n    await this.setRelayerMessages(this.messages);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = b(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nvar Cn = Object.defineProperty,\n  Pn = Object.defineProperties,\n  Sn = Object.getOwnPropertyDescriptors,\n  mi = Object.getOwnPropertySymbols,\n  Rn = Object.prototype.hasOwnProperty,\n  xn = Object.prototype.propertyIsEnumerable,\n  Fe = (n, e, t) => e in n ? Cn(n, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : n[e] = t,\n  fe = (n, e) => {\n    for (var t in e || (e = {})) Rn.call(e, t) && Fe(n, t, e[t]);\n    if (mi) for (var t of mi(e)) xn.call(e, t) && Fe(n, t, e[t]);\n    return n;\n  },\n  Me = (n, e) => Pn(n, Sn(e)),\n  j = (n, e, t) => Fe(n, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass On extends ji {\n  constructor(e, t) {\n    super(e, t), this.relayer = e, this.logger = t, j(this, \"events\", new ee()), j(this, \"name\", Ct), j(this, \"queue\", new Map()), j(this, \"publishTimeout\", R(Ye)), j(this, \"initialPublishTimeout\", R(Z * 15)), j(this, \"needsTransportRestart\", !1), j(this, \"publish\", async (s, i, r) => {\n      var o;\n      this.logger.debug(\"Publishing Payload\"), this.logger.trace({\n        type: \"method\",\n        method: \"publish\",\n        params: {\n          topic: s,\n          message: i,\n          opts: r\n        }\n      });\n      const a = r?.ttl || Ne,\n        c = De(r),\n        h = r?.prompt || !1,\n        u = r?.tag || 0,\n        g = r?.id || dt().toString(),\n        m = {\n          topic: s,\n          message: i,\n          opts: {\n            ttl: a,\n            relay: c,\n            prompt: h,\n            tag: u,\n            id: g,\n            attestation: r?.attestation,\n            tvf: r?.tvf\n          }\n        },\n        A = `Failed to publish payload, please try again. id:${g} tag:${u}`;\n      try {\n        const l = new Promise(async y => {\n          const O = ({\n            id: v\n          }) => {\n            m.opts.id === v && (this.removeRequestFromQueue(v), this.relayer.events.removeListener(T.publish, O), y(m));\n          };\n          this.relayer.events.on(T.publish, O);\n          const w = W(new Promise((v, k) => {\n            this.rpcPublish({\n              topic: s,\n              message: i,\n              ttl: a,\n              prompt: h,\n              tag: u,\n              id: g,\n              attestation: r?.attestation,\n              tvf: r?.tvf\n            }).then(v).catch(I => {\n              this.logger.warn(I, I?.message), k(I);\n            });\n          }), this.initialPublishTimeout, `Failed initial publish, retrying.... id:${g} tag:${u}`);\n          try {\n            await w, this.events.removeListener(T.publish, O);\n          } catch (v) {\n            this.queue.set(g, Me(fe({}, m), {\n              attempt: 1\n            })), this.logger.warn(v, v?.message);\n          }\n        });\n        this.logger.trace({\n          type: \"method\",\n          method: \"publish\",\n          params: {\n            id: g,\n            topic: s,\n            message: i,\n            opts: r\n          }\n        }), await W(l, this.publishTimeout, A);\n      } catch (l) {\n        if (this.logger.debug(\"Failed to Publish Payload\"), this.logger.error(l), (o = r?.internal) != null && o.throwOnFailedPublish) throw l;\n      } finally {\n        this.queue.delete(g);\n      }\n    }), j(this, \"on\", (s, i) => {\n      this.events.on(s, i);\n    }), j(this, \"once\", (s, i) => {\n      this.events.once(s, i);\n    }), j(this, \"off\", (s, i) => {\n      this.events.off(s, i);\n    }), j(this, \"removeListener\", (s, i) => {\n      this.events.removeListener(s, i);\n    }), this.relayer = e, this.logger = N(t, this.name), this.registerEventListeners();\n  }\n  get context() {\n    return U(this.logger);\n  }\n  async rpcPublish(e) {\n    var t, s, i, r;\n    const {\n        topic: o,\n        message: a,\n        ttl: c = Ne,\n        prompt: h,\n        tag: u,\n        id: g,\n        attestation: m,\n        tvf: A\n      } = e,\n      l = {\n        method: oe(De().protocol).publish,\n        params: fe({\n          topic: o,\n          message: a,\n          ttl: c,\n          prompt: h,\n          tag: u,\n          attestation: m\n        }, A),\n        id: g\n      };\n    Pe((t = l.params) == null ? void 0 : t.prompt) && ((s = l.params) == null || delete s.prompt), Pe((i = l.params) == null ? void 0 : i.tag) && ((r = l.params) == null || delete r.tag), this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({\n      type: \"message\",\n      direction: \"outgoing\",\n      request: l\n    });\n    const y = await this.relayer.request(l);\n    return this.relayer.events.emit(T.publish, e), this.logger.debug(\"Successfully Published Payload\"), y;\n  }\n  removeRequestFromQueue(e) {\n    this.queue.delete(e);\n  }\n  checkQueue() {\n    this.queue.forEach(async (e, t) => {\n      const s = e.attempt + 1;\n      this.queue.set(t, Me(fe({}, e), {\n        attempt: s\n      }));\n      const {\n        topic: i,\n        message: r,\n        opts: o,\n        attestation: a\n      } = e;\n      this.logger.warn({}, `Publisher: queue->publishing: ${e.opts.id}, tag: ${e.opts.tag}, attempt: ${s}`), await this.rpcPublish(Me(fe({}, e), {\n        topic: i,\n        message: r,\n        ttl: o.ttl,\n        prompt: o.prompt,\n        tag: o.tag,\n        id: o.id,\n        attestation: a,\n        tvf: o.tvf\n      })), this.logger.warn({}, `Publisher: queue->published: ${e.opts.id}`);\n    });\n  }\n  registerEventListeners() {\n    this.relayer.core.heartbeat.on(ne.pulse, () => {\n      if (this.needsTransportRestart) {\n        this.needsTransportRestart = !1, this.relayer.events.emit(T.connection_stalled);\n        return;\n      }\n      this.checkQueue();\n    }), this.relayer.on(T.message_ack, e => {\n      this.removeRequestFromQueue(e.id.toString());\n    });\n  }\n}\nvar An = Object.defineProperty,\n  Nn = (n, e, t) => e in n ? An(n, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : n[e] = t,\n  re = (n, e, t) => Nn(n, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass $n {\n  constructor() {\n    re(this, \"map\", new Map()), re(this, \"set\", (e, t) => {\n      const s = this.get(e);\n      this.exists(e, t) || this.map.set(e, [...s, t]);\n    }), re(this, \"get\", e => this.map.get(e) || []), re(this, \"exists\", (e, t) => this.get(e).includes(t)), re(this, \"delete\", (e, t) => {\n      if (typeof t > \"u\") {\n        this.map.delete(e);\n        return;\n      }\n      if (!this.map.has(e)) return;\n      const s = this.get(e);\n      if (!this.exists(e, t)) return;\n      const i = s.filter(r => r !== t);\n      if (!i.length) {\n        this.map.delete(e);\n        return;\n      }\n      this.map.set(e, i);\n    }), re(this, \"clear\", () => {\n      this.map.clear();\n    });\n  }\n  get topics() {\n    return Array.from(this.map.keys());\n  }\n}\nvar zn = Object.defineProperty,\n  Ln = Object.defineProperties,\n  kn = Object.getOwnPropertyDescriptors,\n  vi = Object.getOwnPropertySymbols,\n  Un = Object.prototype.hasOwnProperty,\n  Fn = Object.prototype.propertyIsEnumerable,\n  Ke = (n, e, t) => e in n ? zn(n, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : n[e] = t,\n  de = (n, e) => {\n    for (var t in e || (e = {})) Un.call(e, t) && Ke(n, t, e[t]);\n    if (vi) for (var t of vi(e)) Fn.call(e, t) && Ke(n, t, e[t]);\n    return n;\n  },\n  Be = (n, e) => Ln(n, kn(e)),\n  D = (n, e, t) => Ke(n, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass fi extends Vi {\n  constructor(e, t) {\n    super(e, t), this.relayer = e, this.logger = t, D(this, \"subscriptions\", new Map()), D(this, \"topicMap\", new $n()), D(this, \"events\", new ee()), D(this, \"name\", $t), D(this, \"version\", zt), D(this, \"pending\", new Map()), D(this, \"cached\", []), D(this, \"initialized\", !1), D(this, \"pendingSubscriptionWatchLabel\", \"pending_sub_watch_label\"), D(this, \"pollingInterval\", 20), D(this, \"storagePrefix\", B), D(this, \"subscribeTimeout\", R(Ye)), D(this, \"initialSubscribeTimeout\", R(Z * 15)), D(this, \"clientId\"), D(this, \"batchSubscribeTopicsLimit\", 500), D(this, \"init\", async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), this.registerEventListeners(), await this.restore()), this.initialized = !0;\n    }), D(this, \"subscribe\", async (s, i) => {\n      this.isInitialized(), this.logger.debug(\"Subscribing Topic\"), this.logger.trace({\n        type: \"method\",\n        method: \"subscribe\",\n        params: {\n          topic: s,\n          opts: i\n        }\n      });\n      try {\n        const r = De(i),\n          o = {\n            topic: s,\n            relay: r,\n            transportType: i?.transportType\n          };\n        this.pending.set(s, o);\n        const a = await this.rpcSubscribe(s, r, i);\n        return typeof a == \"string\" && (this.onSubscribe(a, o), this.logger.debug(\"Successfully Subscribed Topic\"), this.logger.trace({\n          type: \"method\",\n          method: \"subscribe\",\n          params: {\n            topic: s,\n            opts: i\n          }\n        })), a;\n      } catch (r) {\n        throw this.logger.debug(\"Failed to Subscribe Topic\"), this.logger.error(r), r;\n      }\n    }), D(this, \"unsubscribe\", async (s, i) => {\n      this.isInitialized(), typeof i?.id < \"u\" ? await this.unsubscribeById(s, i.id, i) : await this.unsubscribeByTopic(s, i);\n    }), D(this, \"isSubscribed\", async s => {\n      if (this.topics.includes(s)) return !0;\n      const i = `${this.pendingSubscriptionWatchLabel}_${s}`;\n      return await new Promise((r, o) => {\n        const a = new es();\n        a.start(i);\n        const c = setInterval(() => {\n          (!this.pending.has(s) && this.topics.includes(s) || this.cached.some(h => h.topic === s)) && (clearInterval(c), a.stop(i), r(!0)), a.elapsed(i) >= Lt && (clearInterval(c), a.stop(i), o(new Error(\"Subscription resolution timeout\")));\n        }, this.pollingInterval);\n      }).catch(() => !1);\n    }), D(this, \"on\", (s, i) => {\n      this.events.on(s, i);\n    }), D(this, \"once\", (s, i) => {\n      this.events.once(s, i);\n    }), D(this, \"off\", (s, i) => {\n      this.events.off(s, i);\n    }), D(this, \"removeListener\", (s, i) => {\n      this.events.removeListener(s, i);\n    }), D(this, \"start\", async () => {\n      await this.onConnect();\n    }), D(this, \"stop\", async () => {\n      await this.onDisconnect();\n    }), D(this, \"restart\", async () => {\n      await this.restore(), await this.onRestart();\n    }), D(this, \"checkPending\", async () => {\n      if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected)) return;\n      const s = [];\n      this.pending.forEach(i => {\n        s.push(i);\n      }), await this.batchSubscribe(s);\n    }), D(this, \"registerEventListeners\", () => {\n      this.relayer.core.heartbeat.on(ne.pulse, async () => {\n        await this.checkPending();\n      }), this.events.on($.created, async s => {\n        const i = $.created;\n        this.logger.info(`Emitting ${i}`), this.logger.debug({\n          type: \"event\",\n          event: i,\n          data: s\n        }), await this.persist();\n      }), this.events.on($.deleted, async s => {\n        const i = $.deleted;\n        this.logger.info(`Emitting ${i}`), this.logger.debug({\n          type: \"event\",\n          event: i,\n          data: s\n        }), await this.persist();\n      });\n    }), this.relayer = e, this.logger = N(t, this.name), this.clientId = \"\";\n  }\n  get context() {\n    return U(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + \"//\" + this.name;\n  }\n  get length() {\n    return this.subscriptions.size;\n  }\n  get ids() {\n    return Array.from(this.subscriptions.keys());\n  }\n  get values() {\n    return Array.from(this.subscriptions.values());\n  }\n  get topics() {\n    return this.topicMap.topics;\n  }\n  get hasAnyTopics() {\n    return this.topicMap.topics.length > 0 || this.pending.size > 0 || this.cached.length > 0 || this.subscriptions.size > 0;\n  }\n  hasSubscription(e, t) {\n    let s = !1;\n    try {\n      s = this.getSubscription(e).topic === t;\n    } catch {}\n    return s;\n  }\n  reset() {\n    this.cached = [], this.initialized = !0;\n  }\n  onDisable() {\n    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();\n  }\n  async unsubscribeByTopic(e, t) {\n    const s = this.topicMap.get(e);\n    await Promise.all(s.map(async i => await this.unsubscribeById(e, i, t)));\n  }\n  async unsubscribeById(e, t, s) {\n    this.logger.debug(\"Unsubscribing Topic\"), this.logger.trace({\n      type: \"method\",\n      method: \"unsubscribe\",\n      params: {\n        topic: e,\n        id: t,\n        opts: s\n      }\n    });\n    try {\n      const i = De(s);\n      await this.restartToComplete({\n        topic: e,\n        id: t,\n        relay: i\n      }), await this.rpcUnsubscribe(e, t, i);\n      const r = ae(\"USER_DISCONNECTED\", `${this.name}, ${e}`);\n      await this.onUnsubscribe(e, t, r), this.logger.debug(\"Successfully Unsubscribed Topic\"), this.logger.trace({\n        type: \"method\",\n        method: \"unsubscribe\",\n        params: {\n          topic: e,\n          id: t,\n          opts: s\n        }\n      });\n    } catch (i) {\n      throw this.logger.debug(\"Failed to Unsubscribe Topic\"), this.logger.error(i), i;\n    }\n  }\n  async rpcSubscribe(e, t, s) {\n    var i;\n    (!s || s?.transportType === Q.relay) && (await this.restartToComplete({\n      topic: e,\n      id: e,\n      relay: t\n    }));\n    const r = {\n      method: oe(t.protocol).subscribe,\n      params: {\n        topic: e\n      }\n    };\n    this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({\n      type: \"payload\",\n      direction: \"outgoing\",\n      request: r\n    });\n    const o = (i = s?.internal) == null ? void 0 : i.throwOnFailedPublish;\n    try {\n      const a = await this.getSubscriptionId(e);\n      if (s?.transportType === Q.link_mode) return setTimeout(() => {\n        (this.relayer.connected || this.relayer.connecting) && this.relayer.request(r).catch(u => this.logger.warn(u));\n      }, R(Z)), a;\n      const c = new Promise(async u => {\n          const g = m => {\n            m.topic === e && (this.events.removeListener($.created, g), u(m.id));\n          };\n          this.events.on($.created, g);\n          try {\n            const m = await W(new Promise((A, l) => {\n              this.relayer.request(r).catch(y => {\n                this.logger.warn(y, y?.message), l(y);\n              }).then(A);\n            }), this.initialSubscribeTimeout, `Subscribing to ${e} failed, please try again`);\n            this.events.removeListener($.created, g), u(m);\n          } catch {}\n        }),\n        h = await W(c, this.subscribeTimeout, `Subscribing to ${e} failed, please try again`);\n      if (!h && o) throw new Error(`Subscribing to ${e} failed, please try again`);\n      return h ? a : null;\n    } catch (a) {\n      if (this.logger.debug(\"Outgoing Relay Subscribe Payload stalled\"), this.relayer.events.emit(T.connection_stalled), o) throw a;\n    }\n    return null;\n  }\n  async rpcBatchSubscribe(e) {\n    if (!e.length) return;\n    const t = e[0].relay,\n      s = {\n        method: oe(t.protocol).batchSubscribe,\n        params: {\n          topics: e.map(i => i.topic)\n        }\n      };\n    this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({\n      type: \"payload\",\n      direction: \"outgoing\",\n      request: s\n    });\n    try {\n      await await W(new Promise(i => {\n        this.relayer.request(s).catch(r => this.logger.warn(r)).then(i);\n      }), this.subscribeTimeout, \"rpcBatchSubscribe failed, please try again\");\n    } catch {\n      this.relayer.events.emit(T.connection_stalled);\n    }\n  }\n  async rpcBatchFetchMessages(e) {\n    if (!e.length) return;\n    const t = e[0].relay,\n      s = {\n        method: oe(t.protocol).batchFetchMessages,\n        params: {\n          topics: e.map(r => r.topic)\n        }\n      };\n    this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({\n      type: \"payload\",\n      direction: \"outgoing\",\n      request: s\n    });\n    let i;\n    try {\n      i = await await W(new Promise((r, o) => {\n        this.relayer.request(s).catch(a => {\n          this.logger.warn(a), o(a);\n        }).then(r);\n      }), this.subscribeTimeout, \"rpcBatchFetchMessages failed, please try again\");\n    } catch {\n      this.relayer.events.emit(T.connection_stalled);\n    }\n    return i;\n  }\n  rpcUnsubscribe(e, t, s) {\n    const i = {\n      method: oe(s.protocol).unsubscribe,\n      params: {\n        topic: e,\n        id: t\n      }\n    };\n    return this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({\n      type: \"payload\",\n      direction: \"outgoing\",\n      request: i\n    }), this.relayer.request(i);\n  }\n  onSubscribe(e, t) {\n    this.setSubscription(e, Be(de({}, t), {\n      id: e\n    })), this.pending.delete(t.topic);\n  }\n  onBatchSubscribe(e) {\n    e.length && e.forEach(t => {\n      this.setSubscription(t.id, de({}, t)), this.pending.delete(t.topic);\n    });\n  }\n  async onUnsubscribe(e, t, s) {\n    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, s), await this.relayer.messages.del(e);\n  }\n  async setRelayerSubscriptions(e) {\n    await this.relayer.core.storage.setItem(this.storageKey, e);\n  }\n  async getRelayerSubscriptions() {\n    return await this.relayer.core.storage.getItem(this.storageKey);\n  }\n  setSubscription(e, t) {\n    this.logger.debug(\"Setting subscription\"), this.logger.trace({\n      type: \"method\",\n      method: \"setSubscription\",\n      id: e,\n      subscription: t\n    }), this.addSubscription(e, t);\n  }\n  addSubscription(e, t) {\n    this.subscriptions.set(e, de({}, t)), this.topicMap.set(t.topic, e), this.events.emit($.created, t);\n  }\n  getSubscription(e) {\n    this.logger.debug(\"Getting subscription\"), this.logger.trace({\n      type: \"method\",\n      method: \"getSubscription\",\n      id: e\n    });\n    const t = this.subscriptions.get(e);\n    if (!t) {\n      const {\n        message: s\n      } = b(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw new Error(s);\n    }\n    return t;\n  }\n  deleteSubscription(e, t) {\n    this.logger.debug(\"Deleting subscription\"), this.logger.trace({\n      type: \"method\",\n      method: \"deleteSubscription\",\n      id: e,\n      reason: t\n    });\n    const s = this.getSubscription(e);\n    this.subscriptions.delete(e), this.topicMap.delete(s.topic, e), this.events.emit($.deleted, Be(de({}, s), {\n      reason: t\n    }));\n  }\n  async persist() {\n    await this.setRelayerSubscriptions(this.values), this.events.emit($.sync);\n  }\n  async onRestart() {\n    if (this.cached.length) {\n      const e = [...this.cached],\n        t = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);\n      for (let s = 0; s < t; s++) {\n        const i = e.splice(0, this.batchSubscribeTopicsLimit);\n        await this.batchSubscribe(i);\n      }\n    }\n    this.events.emit($.resubscribed);\n  }\n  async restore() {\n    try {\n      const e = await this.getRelayerSubscriptions();\n      if (typeof e > \"u\" || !e.length) return;\n      if (this.subscriptions.size) {\n        const {\n          message: t\n        } = b(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({\n        type: \"method\",\n        method: \"restore\",\n        subscriptions: this.values\n      });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);\n    }\n  }\n  async batchSubscribe(e) {\n    e.length && (await this.rpcBatchSubscribe(e), this.onBatchSubscribe(await Promise.all(e.map(async t => Be(de({}, t), {\n      id: await this.getSubscriptionId(t.topic)\n    })))));\n  }\n  async batchFetchMessages(e) {\n    if (!e.length) return;\n    this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);\n    const t = await this.rpcBatchFetchMessages(e);\n    t && t.messages && (await ps(R(Z)), await this.relayer.handleBatchMessageEvents(t.messages));\n  }\n  async onConnect() {\n    await this.restart(), this.reset();\n  }\n  onDisconnect() {\n    this.onDisable();\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = b(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n  async restartToComplete(e) {\n    !this.relayer.connected && !this.relayer.connecting && (this.cached.push(e), await this.relayer.transportOpen());\n  }\n  async getClientId() {\n    return this.clientId || (this.clientId = await this.relayer.core.crypto.getClientId()), this.clientId;\n  }\n  async getSubscriptionId(e) {\n    return Ce(e + (await this.getClientId()));\n  }\n}\nvar Mn = Object.defineProperty,\n  _i = Object.getOwnPropertySymbols,\n  Kn = Object.prototype.hasOwnProperty,\n  Bn = Object.prototype.propertyIsEnumerable,\n  je = (n, e, t) => e in n ? Mn(n, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : n[e] = t,\n  Ei = (n, e) => {\n    for (var t in e || (e = {})) Kn.call(e, t) && je(n, t, e[t]);\n    if (_i) for (var t of _i(e)) Bn.call(e, t) && je(n, t, e[t]);\n    return n;\n  },\n  p = (n, e, t) => je(n, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass wi extends qi {\n  constructor(e) {\n    super(e), p(this, \"protocol\", \"wc\"), p(this, \"version\", 2), p(this, \"core\"), p(this, \"logger\"), p(this, \"events\", new ee()), p(this, \"provider\"), p(this, \"messages\"), p(this, \"subscriber\"), p(this, \"publisher\"), p(this, \"name\", Rt), p(this, \"transportExplicitlyClosed\", !1), p(this, \"initialized\", !1), p(this, \"connectionAttemptInProgress\", !1), p(this, \"relayUrl\"), p(this, \"projectId\"), p(this, \"packageName\"), p(this, \"bundleId\"), p(this, \"hasExperiencedNetworkDisruption\", !1), p(this, \"pingTimeout\"), p(this, \"heartBeatTimeout\", R(Ie + we)), p(this, \"reconnectTimeout\"), p(this, \"connectPromise\"), p(this, \"reconnectInProgress\", !1), p(this, \"requestsInFlight\", []), p(this, \"connectTimeout\", R(Z * 15)), p(this, \"request\", async t => {\n      var s, i;\n      this.logger.debug(\"Publishing Request Payload\");\n      const r = t.id || dt().toString();\n      await this.toEstablishConnection();\n      try {\n        this.logger.trace({\n          id: r,\n          method: t.method,\n          topic: (s = t.params) == null ? void 0 : s.topic\n        }, \"relayer.request - publishing...\");\n        const o = `${r}:${((i = t.params) == null ? void 0 : i.tag) || \"\"}`;\n        this.requestsInFlight.push(o);\n        const a = await this.provider.request(t);\n        return this.requestsInFlight = this.requestsInFlight.filter(c => c !== o), a;\n      } catch (o) {\n        throw this.logger.debug(`Failed to Publish Request: ${r}`), o;\n      }\n    }), p(this, \"resetPingTimeout\", () => {\n      if (ot()) try {\n        clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {\n          var t, s, i;\n          this.logger.debug({}, \"pingTimeout: Connection stalled, terminating...\"), (i = (s = (t = this.provider) == null ? void 0 : t.connection) == null ? void 0 : s.socket) == null || i.terminate();\n        }, this.heartBeatTimeout);\n      } catch (t) {\n        this.logger.warn(t, t?.message);\n      }\n    }), p(this, \"onPayloadHandler\", t => {\n      this.onProviderPayload(t), this.resetPingTimeout();\n    }), p(this, \"onConnectHandler\", () => {\n      this.logger.warn({}, \"Relayer connected \\u{1F6DC}\"), this.startPingTimeout(), this.events.emit(T.connect);\n    }), p(this, \"onDisconnectHandler\", () => {\n      this.logger.warn({}, \"Relayer disconnected \\u{1F6D1}\"), this.requestsInFlight = [], this.onProviderDisconnect();\n    }), p(this, \"onProviderErrorHandler\", t => {\n      this.logger.fatal(`Fatal socket error: ${t.message}`), this.events.emit(T.error, t), this.logger.fatal(\"Fatal socket error received, closing transport\"), this.transportClose();\n    }), p(this, \"registerProviderListeners\", () => {\n      this.provider.on(L.payload, this.onPayloadHandler), this.provider.on(L.connect, this.onConnectHandler), this.provider.on(L.disconnect, this.onDisconnectHandler), this.provider.on(L.error, this.onProviderErrorHandler);\n    }), this.core = e.core, this.logger = typeof e.logger < \"u\" && typeof e.logger != \"string\" ? N(e.logger, this.name) : Mi(He({\n      level: e.logger || St\n    })), this.messages = new Di(this.logger, e.core), this.subscriber = new fi(this, this.logger), this.publisher = new On(this, this.logger), this.relayUrl = e?.relayUrl || $e, this.projectId = e.projectId, gs() ? this.packageName = rt() : ys() && (this.bundleId = rt()), this.provider = {};\n  }\n  async init() {\n    if (this.logger.trace(\"Initialized\"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = !0, this.subscriber.hasAnyTopics) try {\n      await this.transportOpen();\n    } catch (e) {\n      this.logger.warn(e, e?.message);\n    }\n  }\n  get context() {\n    return U(this.logger);\n  }\n  get connected() {\n    var e, t, s;\n    return ((s = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : s.readyState) === 1 || !1;\n  }\n  get connecting() {\n    var e, t, s;\n    return ((s = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : s.readyState) === 0 || this.connectPromise !== void 0 || !1;\n  }\n  async publish(e, t, s) {\n    this.isInitialized(), await this.publisher.publish(e, t, s), await this.recordMessageEvent({\n      topic: e,\n      message: t,\n      publishedAt: Date.now(),\n      transportType: Q.relay\n    });\n  }\n  async subscribe(e, t) {\n    var s, i, r;\n    this.isInitialized(), (!(t != null && t.transportType) || t?.transportType === \"relay\") && (await this.toEstablishConnection());\n    const o = typeof ((s = t?.internal) == null ? void 0 : s.throwOnFailedPublish) > \"u\" ? !0 : (i = t?.internal) == null ? void 0 : i.throwOnFailedPublish;\n    let a = ((r = this.subscriber.topicMap.get(e)) == null ? void 0 : r[0]) || \"\",\n      c;\n    const h = u => {\n      u.topic === e && (this.subscriber.off($.created, h), c());\n    };\n    return await Promise.all([new Promise(u => {\n      c = u, this.subscriber.on($.created, h);\n    }), new Promise(async (u, g) => {\n      a = (await this.subscriber.subscribe(e, Ei({\n        internal: {\n          throwOnFailedPublish: o\n        }\n      }, t)).catch(m => {\n        o && g(m);\n      })) || a, u();\n    })]), a;\n  }\n  async unsubscribe(e, t) {\n    this.isInitialized(), await this.subscriber.unsubscribe(e, t);\n  }\n  on(e, t) {\n    this.events.on(e, t);\n  }\n  once(e, t) {\n    this.events.once(e, t);\n  }\n  off(e, t) {\n    this.events.off(e, t);\n  }\n  removeListener(e, t) {\n    this.events.removeListener(e, t);\n  }\n  async transportDisconnect() {\n    this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected) ? await W(this.provider.disconnect(), 2e3, \"provider.disconnect()\").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();\n  }\n  async transportClose() {\n    this.transportExplicitlyClosed = !0, await this.transportDisconnect();\n  }\n  async transportOpen(e) {\n    if (!this.subscriber.hasAnyTopics) {\n      this.logger.warn(\"Starting WS connection skipped because the client has no topics to work with.\");\n      return;\n    }\n    if (this.connectPromise ? (this.logger.debug({}, \"Waiting for existing connection attempt to resolve...\"), await this.connectPromise, this.logger.debug({}, \"Existing connection attempt resolved\")) : (this.connectPromise = new Promise(async (t, s) => {\n      await this.connect(e).then(t).catch(s).finally(() => {\n        this.connectPromise = void 0;\n      });\n    }), await this.connectPromise), !this.connected) throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`);\n  }\n  async restartTransport(e) {\n    this.logger.debug({}, \"Restarting transport...\"), !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());\n  }\n  async confirmOnlineStateOrThrow() {\n    if (!(await nt())) throw new Error(\"No internet connection detected. Please restart your network and try again.\");\n  }\n  async handleBatchMessageEvents(e) {\n    if (e?.length === 0) {\n      this.logger.trace(\"Batch message events is empty. Ignoring...\");\n      return;\n    }\n    const t = e.sort((s, i) => s.publishedAt - i.publishedAt);\n    this.logger.debug(`Batch of ${t.length} message events sorted`);\n    for (const s of t) try {\n      await this.onMessageEvent(s);\n    } catch (i) {\n      this.logger.warn(i, \"Error while processing batch message event: \" + i?.message);\n    }\n    this.logger.trace(`Batch of ${t.length} message events processed`);\n  }\n  async onLinkMessageEvent(e, t) {\n    const {\n      topic: s\n    } = e;\n    if (!t.sessionExists) {\n      const i = ce(ye),\n        r = {\n          topic: s,\n          expiry: i,\n          relay: {\n            protocol: \"irn\"\n          },\n          active: !1\n        };\n      await this.core.pairing.pairings.set(s, r);\n    }\n    this.events.emit(T.message, e), await this.recordMessageEvent(e);\n  }\n  async connect(e) {\n    await this.confirmOnlineStateOrThrow(), e && e !== this.relayUrl && (this.relayUrl = e, await this.transportDisconnect()), this.connectionAttemptInProgress = !0, this.transportExplicitlyClosed = !1;\n    let t = 1;\n    for (; t < 6;) {\n      try {\n        if (this.transportExplicitlyClosed) break;\n        this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${t}...`), await this.createProvider(), await new Promise(async (s, i) => {\n          const r = () => {\n            i(new Error(\"Connection interrupted while trying to subscribe\"));\n          };\n          this.provider.once(L.disconnect, r), await W(new Promise((o, a) => {\n            this.provider.connect().then(o).catch(a);\n          }), this.connectTimeout, `Socket stalled when trying to connect to ${this.relayUrl}`).catch(o => {\n            i(o);\n          }).finally(() => {\n            this.provider.off(L.disconnect, r), clearTimeout(this.reconnectTimeout);\n          }), await new Promise(async (o, a) => {\n            const c = () => {\n              a(new Error(\"Connection interrupted while trying to subscribe\"));\n            };\n            this.provider.once(L.disconnect, c), await this.subscriber.start().then(o).catch(a).finally(() => {\n              this.provider.off(L.disconnect, c);\n            });\n          }), this.hasExperiencedNetworkDisruption = !1, s();\n        });\n      } catch (s) {\n        await this.subscriber.stop();\n        const i = s;\n        this.logger.warn({}, i.message), this.hasExperiencedNetworkDisruption = !0;\n      } finally {\n        this.connectionAttemptInProgress = !1;\n      }\n      if (this.connected) {\n        this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${t}`);\n        break;\n      }\n      await new Promise(s => setTimeout(s, R(t * 1))), t++;\n    }\n  }\n  startPingTimeout() {\n    var e, t, s, i, r;\n    if (ot()) try {\n      (t = (e = this.provider) == null ? void 0 : e.connection) != null && t.socket && ((r = (i = (s = this.provider) == null ? void 0 : s.connection) == null ? void 0 : i.socket) == null || r.on(\"ping\", () => {\n        this.resetPingTimeout();\n      })), this.resetPingTimeout();\n    } catch (o) {\n      this.logger.warn(o, o?.message);\n    }\n  }\n  async createProvider() {\n    this.provider.connection && this.unregisterProviderListeners();\n    const e = await this.core.crypto.signJWT(this.relayUrl);\n    this.provider = new As(new zs(bs({\n      sdkVersion: me,\n      protocol: this.protocol,\n      version: this.version,\n      relayUrl: this.relayUrl,\n      projectId: this.projectId,\n      auth: e,\n      useOnCloseEvent: !0,\n      bundleId: this.bundleId,\n      packageName: this.packageName\n    }))), this.registerProviderListeners();\n  }\n  async recordMessageEvent(e) {\n    const {\n      topic: t,\n      message: s\n    } = e;\n    await this.messages.set(t, s);\n  }\n  async shouldIgnoreMessageEvent(e) {\n    const {\n      topic: t,\n      message: s\n    } = e;\n    if (!s || s.length === 0) return this.logger.warn(`Ignoring invalid/empty message: ${s}`), !0;\n    if (!(await this.subscriber.isSubscribed(t))) return this.logger.warn(`Ignoring message for non-subscribed topic ${t}`), !0;\n    const i = this.messages.has(t, s);\n    return i && this.logger.warn(`Ignoring duplicate message: ${s}`), i;\n  }\n  async onProviderPayload(e) {\n    if (this.logger.debug(\"Incoming Relay Payload\"), this.logger.trace({\n      type: \"payload\",\n      direction: \"incoming\",\n      payload: e\n    }), pt(e)) {\n      if (!e.method.endsWith(xt)) return;\n      const t = e.params,\n        {\n          topic: s,\n          message: i,\n          publishedAt: r,\n          attestation: o\n        } = t.data,\n        a = {\n          topic: s,\n          message: i,\n          publishedAt: r,\n          transportType: Q.relay,\n          attestation: o\n        };\n      this.logger.debug(\"Emitting Relayer Payload\"), this.logger.trace(Ei({\n        type: \"event\",\n        event: t.id\n      }, a)), this.events.emit(t.id, a), await this.acknowledgePayload(e), await this.onMessageEvent(a);\n    } else gt(e) && this.events.emit(T.message_ack, e);\n  }\n  async onMessageEvent(e) {\n    (await this.shouldIgnoreMessageEvent(e)) || (this.events.emit(T.message, e), await this.recordMessageEvent(e));\n  }\n  async acknowledgePayload(e) {\n    const t = yt(e.id, !0);\n    await this.provider.connection.send(t);\n  }\n  unregisterProviderListeners() {\n    this.provider.off(L.payload, this.onPayloadHandler), this.provider.off(L.connect, this.onConnectHandler), this.provider.off(L.disconnect, this.onDisconnectHandler), this.provider.off(L.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);\n  }\n  async registerEventListeners() {\n    let e = await nt();\n    Ds(async t => {\n      e !== t && (e = t, t ? await this.transportOpen().catch(s => this.logger.error(s, s?.message)) : (this.hasExperiencedNetworkDisruption = !0, await this.transportDisconnect(), this.transportExplicitlyClosed = !1));\n    });\n  }\n  async onProviderDisconnect() {\n    clearTimeout(this.pingTimeout), this.events.emit(T.disconnect), this.connectionAttemptInProgress = !1, !this.reconnectInProgress && (this.reconnectInProgress = !0, await this.subscriber.stop(), this.subscriber.hasAnyTopics && (this.transportExplicitlyClosed || (this.reconnectTimeout = setTimeout(async () => {\n      await this.transportOpen().catch(e => this.logger.error(e, e?.message)), this.reconnectTimeout = void 0, this.reconnectInProgress = !1;\n    }, R(Ot)))));\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = b(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n  async toEstablishConnection() {\n    await this.confirmOnlineStateOrThrow(), !this.connected && (await this.connect());\n  }\n}\nvar jn = Object.defineProperty,\n  Ii = Object.getOwnPropertySymbols,\n  Vn = Object.prototype.hasOwnProperty,\n  qn = Object.prototype.propertyIsEnumerable,\n  Ve = (n, e, t) => e in n ? jn(n, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : n[e] = t,\n  Ti = (n, e) => {\n    for (var t in e || (e = {})) Vn.call(e, t) && Ve(n, t, e[t]);\n    if (Ii) for (var t of Ii(e)) qn.call(e, t) && Ve(n, t, e[t]);\n    return n;\n  },\n  z = (n, e, t) => Ve(n, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass Ci extends Gi {\n  constructor(e, t, s, i = B, r = void 0) {\n    super(e, t, s, i), this.core = e, this.logger = t, this.name = s, z(this, \"map\", new Map()), z(this, \"version\", At), z(this, \"cached\", []), z(this, \"initialized\", !1), z(this, \"getKey\"), z(this, \"storagePrefix\", B), z(this, \"recentlyDeleted\", []), z(this, \"recentlyDeletedLimit\", 200), z(this, \"init\", async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restore(), this.cached.forEach(o => {\n        this.getKey && o !== null && !Pe(o) ? this.map.set(this.getKey(o), o) : ms(o) ? this.map.set(o.id, o) : vs(o) && this.map.set(o.topic, o);\n      }), this.cached = [], this.initialized = !0);\n    }), z(this, \"set\", async (o, a) => {\n      this.isInitialized(), this.map.has(o) ? await this.update(o, a) : (this.logger.debug(\"Setting value\"), this.logger.trace({\n        type: \"method\",\n        method: \"set\",\n        key: o,\n        value: a\n      }), this.map.set(o, a), await this.persist());\n    }), z(this, \"get\", o => (this.isInitialized(), this.logger.debug(\"Getting value\"), this.logger.trace({\n      type: \"method\",\n      method: \"get\",\n      key: o\n    }), this.getData(o))), z(this, \"getAll\", o => (this.isInitialized(), o ? this.values.filter(a => Object.keys(o).every(c => Ls(a[c], o[c]))) : this.values)), z(this, \"update\", async (o, a) => {\n      this.isInitialized(), this.logger.debug(\"Updating value\"), this.logger.trace({\n        type: \"method\",\n        method: \"update\",\n        key: o,\n        update: a\n      });\n      const c = Ti(Ti({}, this.getData(o)), a);\n      this.map.set(o, c), await this.persist();\n    }), z(this, \"delete\", async (o, a) => {\n      this.isInitialized(), this.map.has(o) && (this.logger.debug(\"Deleting value\"), this.logger.trace({\n        type: \"method\",\n        method: \"delete\",\n        key: o,\n        reason: a\n      }), this.map.delete(o), this.addToRecentlyDeleted(o), await this.persist());\n    }), this.logger = N(t, this.name), this.storagePrefix = i, this.getKey = r;\n  }\n  get context() {\n    return U(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + this.name;\n  }\n  get length() {\n    return this.map.size;\n  }\n  get keys() {\n    return Array.from(this.map.keys());\n  }\n  get values() {\n    return Array.from(this.map.values());\n  }\n  addToRecentlyDeleted(e) {\n    this.recentlyDeleted.push(e), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);\n  }\n  async setDataStore(e) {\n    await this.core.storage.setItem(this.storageKey, e);\n  }\n  async getDataStore() {\n    return await this.core.storage.getItem(this.storageKey);\n  }\n  getData(e) {\n    const t = this.map.get(e);\n    if (!t) {\n      if (this.recentlyDeleted.includes(e)) {\n        const {\n          message: i\n        } = b(\"MISSING_OR_INVALID\", `Record was recently deleted - ${this.name}: ${e}`);\n        throw this.logger.error(i), new Error(i);\n      }\n      const {\n        message: s\n      } = b(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw this.logger.error(s), new Error(s);\n    }\n    return t;\n  }\n  async persist() {\n    await this.setDataStore(this.values);\n  }\n  async restore() {\n    try {\n      const e = await this.getDataStore();\n      if (typeof e > \"u\" || !e.length) return;\n      if (this.map.size) {\n        const {\n          message: t\n        } = b(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({\n        type: \"method\",\n        method: \"restore\",\n        value: this.values\n      });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);\n    }\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = b(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nvar Gn = Object.defineProperty,\n  Hn = (n, e, t) => e in n ? Gn(n, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : n[e] = t,\n  d = (n, e, t) => Hn(n, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass Pi {\n  constructor(e, t) {\n    this.core = e, this.logger = t, d(this, \"name\", kt), d(this, \"version\", Ut), d(this, \"events\", new ki()), d(this, \"pairings\"), d(this, \"initialized\", !1), d(this, \"storagePrefix\", B), d(this, \"ignoredPayloadTypes\", [_s]), d(this, \"registeredMethods\", []), d(this, \"init\", async () => {\n      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace(\"Initialized\"));\n    }), d(this, \"register\", ({\n      methods: s\n    }) => {\n      this.isInitialized(), this.registeredMethods = [...new Set([...this.registeredMethods, ...s])];\n    }), d(this, \"create\", async s => {\n      this.isInitialized();\n      const i = Te(),\n        r = await this.core.crypto.setSymKey(i),\n        o = ce(ye),\n        a = {\n          protocol: Pt\n        },\n        c = {\n          topic: r,\n          expiry: o,\n          relay: a,\n          active: !1,\n          methods: s?.methods\n        },\n        h = at({\n          protocol: this.core.protocol,\n          version: this.core.version,\n          topic: r,\n          symKey: i,\n          relay: a,\n          expiryTimestamp: o,\n          methods: s?.methods\n        });\n      return this.events.emit(se.create, c), this.core.expirer.set(r, o), await this.pairings.set(r, c), await this.core.relayer.subscribe(r, {\n        transportType: s?.transportType\n      }), {\n        topic: r,\n        uri: h\n      };\n    }), d(this, \"pair\", async s => {\n      this.isInitialized();\n      const i = this.core.eventClient.createEvent({\n        properties: {\n          topic: s?.uri,\n          trace: [q.pairing_started]\n        }\n      });\n      this.isValidPair(s, i);\n      const {\n        topic: r,\n        symKey: o,\n        relay: a,\n        expiryTimestamp: c,\n        methods: h\n      } = ct(s.uri);\n      i.props.properties.topic = r, i.addTrace(q.pairing_uri_validation_success), i.addTrace(q.pairing_uri_not_expired);\n      let u;\n      if (this.pairings.keys.includes(r)) {\n        if (u = this.pairings.get(r), i.addTrace(q.existing_pairing), u.active) throw i.setError(J.active_pairing_already_exists), new Error(`Pairing already exists: ${r}. Please try again with a new connection URI.`);\n        i.addTrace(q.pairing_not_expired);\n      }\n      const g = c || ce(ye),\n        m = {\n          topic: r,\n          relay: a,\n          expiry: g,\n          active: !1,\n          methods: h\n        };\n      this.core.expirer.set(r, g), await this.pairings.set(r, m), i.addTrace(q.store_new_pairing), s.activatePairing && (await this.activate({\n        topic: r\n      })), this.events.emit(se.create, m), i.addTrace(q.emit_inactive_pairing), this.core.crypto.keychain.has(r) || (await this.core.crypto.setSymKey(o, r)), i.addTrace(q.subscribing_pairing_topic);\n      try {\n        await this.core.relayer.confirmOnlineStateOrThrow();\n      } catch {\n        i.setError(J.no_internet_connection);\n      }\n      try {\n        await this.core.relayer.subscribe(r, {\n          relay: a\n        });\n      } catch (A) {\n        throw i.setError(J.subscribe_pairing_topic_failure), A;\n      }\n      return i.addTrace(q.subscribe_pairing_topic_success), m;\n    }), d(this, \"activate\", async ({\n      topic: s\n    }) => {\n      this.isInitialized();\n      const i = ce(ye);\n      this.core.expirer.set(s, i), await this.pairings.update(s, {\n        active: !0,\n        expiry: i\n      });\n    }), d(this, \"ping\", async s => {\n      this.isInitialized(), await this.isValidPing(s), this.logger.warn(\"ping() is deprecated and will be removed in the next major release.\");\n      const {\n        topic: i\n      } = s;\n      if (this.pairings.keys.includes(i)) {\n        const r = await this.sendRequest(i, \"wc_pairingPing\", {}),\n          {\n            done: o,\n            resolve: a,\n            reject: c\n          } = Es();\n        this.events.once(Se(\"pairing_ping\", r), ({\n          error: h\n        }) => {\n          h ? c(h) : a();\n        }), await o();\n      }\n    }), d(this, \"updateExpiry\", async ({\n      topic: s,\n      expiry: i\n    }) => {\n      this.isInitialized(), await this.pairings.update(s, {\n        expiry: i\n      });\n    }), d(this, \"updateMetadata\", async ({\n      topic: s,\n      metadata: i\n    }) => {\n      this.isInitialized(), await this.pairings.update(s, {\n        peerMetadata: i\n      });\n    }), d(this, \"getPairings\", () => (this.isInitialized(), this.pairings.values)), d(this, \"disconnect\", async s => {\n      this.isInitialized(), await this.isValidDisconnect(s);\n      const {\n        topic: i\n      } = s;\n      this.pairings.keys.includes(i) && (await this.sendRequest(i, \"wc_pairingDelete\", ae(\"USER_DISCONNECTED\")), await this.deletePairing(i));\n    }), d(this, \"formatUriFromPairing\", s => {\n      this.isInitialized();\n      const {\n          topic: i,\n          relay: r,\n          expiry: o,\n          methods: a\n        } = s,\n        c = this.core.crypto.keychain.get(i);\n      return at({\n        protocol: this.core.protocol,\n        version: this.core.version,\n        topic: i,\n        symKey: c,\n        relay: r,\n        expiryTimestamp: o,\n        methods: a\n      });\n    }), d(this, \"sendRequest\", async (s, i, r) => {\n      const o = bt(i, r),\n        a = await this.core.crypto.encode(s, o),\n        c = ie[i].req;\n      return this.core.history.set(s, o), this.core.relayer.publish(s, a, c), o.id;\n    }), d(this, \"sendResult\", async (s, i, r) => {\n      const o = yt(s, r),\n        a = await this.core.crypto.encode(i, o),\n        c = (await this.core.history.get(i, s)).request.method,\n        h = ie[c].res;\n      await this.core.relayer.publish(i, a, h), await this.core.history.resolve(o);\n    }), d(this, \"sendError\", async (s, i, r) => {\n      const o = Ns(s, r),\n        a = await this.core.crypto.encode(i, o),\n        c = (await this.core.history.get(i, s)).request.method,\n        h = ie[c] ? ie[c].res : ie.unregistered_method.res;\n      await this.core.relayer.publish(i, a, h), await this.core.history.resolve(o);\n    }), d(this, \"deletePairing\", async (s, i) => {\n      await this.core.relayer.unsubscribe(s), await Promise.all([this.pairings.delete(s, ae(\"USER_DISCONNECTED\")), this.core.crypto.deleteSymKey(s), i ? Promise.resolve() : this.core.expirer.del(s)]);\n    }), d(this, \"cleanup\", async () => {\n      const s = this.pairings.getAll().filter(i => ht(i.expiry));\n      await Promise.all(s.map(i => this.deletePairing(i.topic)));\n    }), d(this, \"onRelayEventRequest\", s => {\n      const {\n        topic: i,\n        payload: r\n      } = s;\n      switch (r.method) {\n        case \"wc_pairingPing\":\n          return this.onPairingPingRequest(i, r);\n        case \"wc_pairingDelete\":\n          return this.onPairingDeleteRequest(i, r);\n        default:\n          return this.onUnknownRpcMethodRequest(i, r);\n      }\n    }), d(this, \"onRelayEventResponse\", async s => {\n      const {\n          topic: i,\n          payload: r\n        } = s,\n        o = (await this.core.history.get(i, r.id)).request.method;\n      switch (o) {\n        case \"wc_pairingPing\":\n          return this.onPairingPingResponse(i, r);\n        default:\n          return this.onUnknownRpcMethodResponse(o);\n      }\n    }), d(this, \"onPairingPingRequest\", async (s, i) => {\n      const {\n        id: r\n      } = i;\n      try {\n        this.isValidPing({\n          topic: s\n        }), await this.sendResult(r, s, !0), this.events.emit(se.ping, {\n          id: r,\n          topic: s\n        });\n      } catch (o) {\n        await this.sendError(r, s, o), this.logger.error(o);\n      }\n    }), d(this, \"onPairingPingResponse\", (s, i) => {\n      const {\n        id: r\n      } = i;\n      setTimeout(() => {\n        $s(i) ? this.events.emit(Se(\"pairing_ping\", r), {}) : Dt(i) && this.events.emit(Se(\"pairing_ping\", r), {\n          error: i.error\n        });\n      }, 500);\n    }), d(this, \"onPairingDeleteRequest\", async (s, i) => {\n      const {\n        id: r\n      } = i;\n      try {\n        this.isValidDisconnect({\n          topic: s\n        }), await this.deletePairing(s), this.events.emit(se.delete, {\n          id: r,\n          topic: s\n        });\n      } catch (o) {\n        await this.sendError(r, s, o), this.logger.error(o);\n      }\n    }), d(this, \"onUnknownRpcMethodRequest\", async (s, i) => {\n      const {\n        id: r,\n        method: o\n      } = i;\n      try {\n        if (this.registeredMethods.includes(o)) return;\n        const a = ae(\"WC_METHOD_UNSUPPORTED\", o);\n        await this.sendError(r, s, a), this.logger.error(a);\n      } catch (a) {\n        await this.sendError(r, s, a), this.logger.error(a);\n      }\n    }), d(this, \"onUnknownRpcMethodResponse\", s => {\n      this.registeredMethods.includes(s) || this.logger.error(ae(\"WC_METHOD_UNSUPPORTED\", s));\n    }), d(this, \"isValidPair\", (s, i) => {\n      var r;\n      if (!Re(s)) {\n        const {\n          message: a\n        } = b(\"MISSING_OR_INVALID\", `pair() params: ${s}`);\n        throw i.setError(J.malformed_pairing_uri), new Error(a);\n      }\n      if (!ws(s.uri)) {\n        const {\n          message: a\n        } = b(\"MISSING_OR_INVALID\", `pair() uri: ${s.uri}`);\n        throw i.setError(J.malformed_pairing_uri), new Error(a);\n      }\n      const o = ct(s?.uri);\n      if (!((r = o?.relay) != null && r.protocol)) {\n        const {\n          message: a\n        } = b(\"MISSING_OR_INVALID\", \"pair() uri#relay-protocol\");\n        throw i.setError(J.malformed_pairing_uri), new Error(a);\n      }\n      if (!(o != null && o.symKey)) {\n        const {\n          message: a\n        } = b(\"MISSING_OR_INVALID\", \"pair() uri#symKey\");\n        throw i.setError(J.malformed_pairing_uri), new Error(a);\n      }\n      if (o != null && o.expiryTimestamp && R(o?.expiryTimestamp) < Date.now()) {\n        i.setError(J.pairing_expired);\n        const {\n          message: a\n        } = b(\"EXPIRED\", \"pair() URI has expired. Please try again with a new connection URI.\");\n        throw new Error(a);\n      }\n    }), d(this, \"isValidPing\", async s => {\n      if (!Re(s)) {\n        const {\n          message: r\n        } = b(\"MISSING_OR_INVALID\", `ping() params: ${s}`);\n        throw new Error(r);\n      }\n      const {\n        topic: i\n      } = s;\n      await this.isValidPairingTopic(i);\n    }), d(this, \"isValidDisconnect\", async s => {\n      if (!Re(s)) {\n        const {\n          message: r\n        } = b(\"MISSING_OR_INVALID\", `disconnect() params: ${s}`);\n        throw new Error(r);\n      }\n      const {\n        topic: i\n      } = s;\n      await this.isValidPairingTopic(i);\n    }), d(this, \"isValidPairingTopic\", async s => {\n      if (!Is(s, !1)) {\n        const {\n          message: i\n        } = b(\"MISSING_OR_INVALID\", `pairing topic should be a string: ${s}`);\n        throw new Error(i);\n      }\n      if (!this.pairings.keys.includes(s)) {\n        const {\n          message: i\n        } = b(\"NO_MATCHING_KEY\", `pairing topic doesn't exist: ${s}`);\n        throw new Error(i);\n      }\n      if (ht(this.pairings.get(s).expiry)) {\n        await this.deletePairing(s);\n        const {\n          message: i\n        } = b(\"EXPIRED\", `pairing topic: ${s}`);\n        throw new Error(i);\n      }\n    }), this.core = e, this.logger = N(t, this.name), this.pairings = new Ci(this.core, this.logger, this.name, this.storagePrefix);\n  }\n  get context() {\n    return U(this.logger);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = b(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n  registerRelayerEvents() {\n    this.core.relayer.on(T.message, async e => {\n      const {\n        topic: t,\n        message: s,\n        transportType: i\n      } = e;\n      if (!this.pairings.keys.includes(t) || i === Q.link_mode || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(s))) return;\n      const r = await this.core.crypto.decode(t, s);\n      try {\n        pt(r) ? (this.core.history.set(t, r), this.onRelayEventRequest({\n          topic: t,\n          payload: r\n        })) : gt(r) && (await this.core.history.resolve(r), await this.onRelayEventResponse({\n          topic: t,\n          payload: r\n        }), this.core.history.delete(t, r.id));\n      } catch (o) {\n        this.logger.error(o);\n      }\n    });\n  }\n  registerExpirerEvents() {\n    this.core.expirer.on(M.expired, async e => {\n      const {\n        topic: t\n      } = fs(e.target);\n      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, !0), this.events.emit(se.expire, {\n        topic: t\n      }));\n    });\n  }\n}\nvar Yn = Object.defineProperty,\n  Jn = (n, e, t) => e in n ? Yn(n, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : n[e] = t,\n  S = (n, e, t) => Jn(n, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass Si extends Hi {\n  constructor(e, t) {\n    super(e, t), this.core = e, this.logger = t, S(this, \"records\", new Map()), S(this, \"events\", new ee()), S(this, \"name\", Ft), S(this, \"version\", Mt), S(this, \"cached\", []), S(this, \"initialized\", !1), S(this, \"storagePrefix\", B), S(this, \"init\", async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restore(), this.cached.forEach(s => this.records.set(s.id, s)), this.cached = [], this.registerEventListeners(), this.initialized = !0);\n    }), S(this, \"set\", (s, i, r) => {\n      if (this.isInitialized(), this.logger.debug(\"Setting JSON-RPC request history record\"), this.logger.trace({\n        type: \"method\",\n        method: \"set\",\n        topic: s,\n        request: i,\n        chainId: r\n      }), this.records.has(i.id)) return;\n      const o = {\n        id: i.id,\n        topic: s,\n        request: {\n          method: i.method,\n          params: i.params || null\n        },\n        chainId: r,\n        expiry: ce(Ee)\n      };\n      this.records.set(o.id, o), this.persist(), this.events.emit(F.created, o);\n    }), S(this, \"resolve\", async s => {\n      if (this.isInitialized(), this.logger.debug(\"Updating JSON-RPC response history record\"), this.logger.trace({\n        type: \"method\",\n        method: \"update\",\n        response: s\n      }), !this.records.has(s.id)) return;\n      const i = await this.getRecord(s.id);\n      typeof i.response > \"u\" && (i.response = Dt(s) ? {\n        error: s.error\n      } : {\n        result: s.result\n      }, this.records.set(i.id, i), this.persist(), this.events.emit(F.updated, i));\n    }), S(this, \"get\", async (s, i) => (this.isInitialized(), this.logger.debug(\"Getting record\"), this.logger.trace({\n      type: \"method\",\n      method: \"get\",\n      topic: s,\n      id: i\n    }), await this.getRecord(i))), S(this, \"delete\", (s, i) => {\n      this.isInitialized(), this.logger.debug(\"Deleting record\"), this.logger.trace({\n        type: \"method\",\n        method: \"delete\",\n        id: i\n      }), this.values.forEach(r => {\n        if (r.topic === s) {\n          if (typeof i < \"u\" && r.id !== i) return;\n          this.records.delete(r.id), this.events.emit(F.deleted, r);\n        }\n      }), this.persist();\n    }), S(this, \"exists\", async (s, i) => (this.isInitialized(), this.records.has(i) ? (await this.getRecord(i)).topic === s : !1)), S(this, \"on\", (s, i) => {\n      this.events.on(s, i);\n    }), S(this, \"once\", (s, i) => {\n      this.events.once(s, i);\n    }), S(this, \"off\", (s, i) => {\n      this.events.off(s, i);\n    }), S(this, \"removeListener\", (s, i) => {\n      this.events.removeListener(s, i);\n    }), this.logger = N(t, this.name);\n  }\n  get context() {\n    return U(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + this.name;\n  }\n  get size() {\n    return this.records.size;\n  }\n  get keys() {\n    return Array.from(this.records.keys());\n  }\n  get values() {\n    return Array.from(this.records.values());\n  }\n  get pending() {\n    const e = [];\n    return this.values.forEach(t => {\n      if (typeof t.response < \"u\") return;\n      const s = {\n        topic: t.topic,\n        request: bt(t.request.method, t.request.params, t.id),\n        chainId: t.chainId\n      };\n      return e.push(s);\n    }), e;\n  }\n  async setJsonRpcRecords(e) {\n    await this.core.storage.setItem(this.storageKey, e);\n  }\n  async getJsonRpcRecords() {\n    return await this.core.storage.getItem(this.storageKey);\n  }\n  getRecord(e) {\n    this.isInitialized();\n    const t = this.records.get(e);\n    if (!t) {\n      const {\n        message: s\n      } = b(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw new Error(s);\n    }\n    return t;\n  }\n  async persist() {\n    await this.setJsonRpcRecords(this.values), this.events.emit(F.sync);\n  }\n  async restore() {\n    try {\n      const e = await this.getJsonRpcRecords();\n      if (typeof e > \"u\" || !e.length) return;\n      if (this.records.size) {\n        const {\n          message: t\n        } = b(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({\n        type: \"method\",\n        method: \"restore\",\n        records: this.values\n      });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);\n    }\n  }\n  registerEventListeners() {\n    this.events.on(F.created, e => {\n      const t = F.created;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        record: e\n      });\n    }), this.events.on(F.updated, e => {\n      const t = F.updated;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        record: e\n      });\n    }), this.events.on(F.deleted, e => {\n      const t = F.deleted;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        record: e\n      });\n    }), this.core.heartbeat.on(ne.pulse, () => {\n      this.cleanup();\n    });\n  }\n  cleanup() {\n    try {\n      this.isInitialized();\n      let e = !1;\n      this.records.forEach(t => {\n        R(t.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t.id}`), this.records.delete(t.id), this.events.emit(F.deleted, t, !1), e = !0);\n      }), e && this.persist();\n    } catch (e) {\n      this.logger.warn(e);\n    }\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = b(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nvar Xn = Object.defineProperty,\n  Wn = (n, e, t) => e in n ? Xn(n, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : n[e] = t,\n  x = (n, e, t) => Wn(n, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass Ri extends Yi {\n  constructor(e, t) {\n    super(e, t), this.core = e, this.logger = t, x(this, \"expirations\", new Map()), x(this, \"events\", new ee()), x(this, \"name\", Kt), x(this, \"version\", Bt), x(this, \"cached\", []), x(this, \"initialized\", !1), x(this, \"storagePrefix\", B), x(this, \"init\", async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restore(), this.cached.forEach(s => this.expirations.set(s.target, s)), this.cached = [], this.registerEventListeners(), this.initialized = !0);\n    }), x(this, \"has\", s => {\n      try {\n        const i = this.formatTarget(s);\n        return typeof this.getExpiration(i) < \"u\";\n      } catch {\n        return !1;\n      }\n    }), x(this, \"set\", (s, i) => {\n      this.isInitialized();\n      const r = this.formatTarget(s),\n        o = {\n          target: r,\n          expiry: i\n        };\n      this.expirations.set(r, o), this.checkExpiry(r, o), this.events.emit(M.created, {\n        target: r,\n        expiration: o\n      });\n    }), x(this, \"get\", s => {\n      this.isInitialized();\n      const i = this.formatTarget(s);\n      return this.getExpiration(i);\n    }), x(this, \"del\", s => {\n      if (this.isInitialized(), this.has(s)) {\n        const i = this.formatTarget(s),\n          r = this.getExpiration(i);\n        this.expirations.delete(i), this.events.emit(M.deleted, {\n          target: i,\n          expiration: r\n        });\n      }\n    }), x(this, \"on\", (s, i) => {\n      this.events.on(s, i);\n    }), x(this, \"once\", (s, i) => {\n      this.events.once(s, i);\n    }), x(this, \"off\", (s, i) => {\n      this.events.off(s, i);\n    }), x(this, \"removeListener\", (s, i) => {\n      this.events.removeListener(s, i);\n    }), this.logger = N(t, this.name);\n  }\n  get context() {\n    return U(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + this.name;\n  }\n  get length() {\n    return this.expirations.size;\n  }\n  get keys() {\n    return Array.from(this.expirations.keys());\n  }\n  get values() {\n    return Array.from(this.expirations.values());\n  }\n  formatTarget(e) {\n    if (typeof e == \"string\") return Ts(e);\n    if (typeof e == \"number\") return Cs(e);\n    const {\n      message: t\n    } = b(\"UNKNOWN_TYPE\", `Target type: ${typeof e}`);\n    throw new Error(t);\n  }\n  async setExpirations(e) {\n    await this.core.storage.setItem(this.storageKey, e);\n  }\n  async getExpirations() {\n    return await this.core.storage.getItem(this.storageKey);\n  }\n  async persist() {\n    await this.setExpirations(this.values), this.events.emit(M.sync);\n  }\n  async restore() {\n    try {\n      const e = await this.getExpirations();\n      if (typeof e > \"u\" || !e.length) return;\n      if (this.expirations.size) {\n        const {\n          message: t\n        } = b(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({\n        type: \"method\",\n        method: \"restore\",\n        expirations: this.values\n      });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);\n    }\n  }\n  getExpiration(e) {\n    const t = this.expirations.get(e);\n    if (!t) {\n      const {\n        message: s\n      } = b(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw this.logger.warn(s), new Error(s);\n    }\n    return t;\n  }\n  checkExpiry(e, t) {\n    const {\n      expiry: s\n    } = t;\n    R(s) - Date.now() <= 0 && this.expire(e, t);\n  }\n  expire(e, t) {\n    this.expirations.delete(e), this.events.emit(M.expired, {\n      target: e,\n      expiration: t\n    });\n  }\n  checkExpirations() {\n    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));\n  }\n  registerEventListeners() {\n    this.core.heartbeat.on(ne.pulse, () => this.checkExpirations()), this.events.on(M.created, e => {\n      const t = M.created;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        data: e\n      }), this.persist();\n    }), this.events.on(M.expired, e => {\n      const t = M.expired;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        data: e\n      }), this.persist();\n    }), this.events.on(M.deleted, e => {\n      const t = M.deleted;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        data: e\n      }), this.persist();\n    });\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = b(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nvar Zn = Object.defineProperty,\n  Qn = (n, e, t) => e in n ? Zn(n, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : n[e] = t,\n  _ = (n, e, t) => Qn(n, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass xi extends Ji {\n  constructor(e, t, s) {\n    super(e, t, s), this.core = e, this.logger = t, this.store = s, _(this, \"name\", jt), _(this, \"abortController\"), _(this, \"isDevEnv\"), _(this, \"verifyUrlV3\", qt), _(this, \"storagePrefix\", B), _(this, \"version\", Oe), _(this, \"publicKey\"), _(this, \"fetchPromise\"), _(this, \"init\", async () => {\n      var i;\n      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && R((i = this.publicKey) == null ? void 0 : i.expiresAt) < Date.now() && (this.logger.debug(\"verify v2 public key expired\"), await this.removePublicKey()));\n    }), _(this, \"register\", async i => {\n      if (!Ps() || this.isDevEnv) return;\n      const r = window.location.origin,\n        {\n          id: o,\n          decryptedId: a\n        } = i,\n        c = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${r}&id=${o}&decryptedId=${a}`;\n      try {\n        const h = ks(),\n          u = this.startAbortTimer(Z * 5),\n          g = await new Promise((m, A) => {\n            const l = () => {\n              window.removeEventListener(\"message\", O), h.body.removeChild(y), A(\"attestation aborted\");\n            };\n            this.abortController.signal.addEventListener(\"abort\", l);\n            const y = h.createElement(\"iframe\");\n            y.src = c, y.style.display = \"none\", y.addEventListener(\"error\", l, {\n              signal: this.abortController.signal\n            });\n            const O = w => {\n              if (w.data && typeof w.data == \"string\") try {\n                const v = JSON.parse(w.data);\n                if (v.type === \"verify_attestation\") {\n                  if (We(v.attestation).payload.id !== o) return;\n                  clearInterval(u), h.body.removeChild(y), this.abortController.signal.removeEventListener(\"abort\", l), window.removeEventListener(\"message\", O), m(v.attestation === null ? \"\" : v.attestation);\n                }\n              } catch (v) {\n                this.logger.warn(v);\n              }\n            };\n            h.body.appendChild(y), window.addEventListener(\"message\", O, {\n              signal: this.abortController.signal\n            });\n          });\n        return this.logger.debug(\"jwt attestation\", g), g;\n      } catch (h) {\n        this.logger.warn(h);\n      }\n      return \"\";\n    }), _(this, \"resolve\", async i => {\n      if (this.isDevEnv) return \"\";\n      const {\n        attestationId: r,\n        hash: o,\n        encryptedId: a\n      } = i;\n      if (r === \"\") {\n        this.logger.debug(\"resolve: attestationId is empty, skipping\");\n        return;\n      }\n      if (r) {\n        if (We(r).payload.id !== a) return;\n        const h = await this.isValidJwtAttestation(r);\n        if (h) {\n          if (!h.isVerified) {\n            this.logger.warn(\"resolve: jwt attestation: origin url not verified\");\n            return;\n          }\n          return h;\n        }\n      }\n      if (!o) return;\n      const c = this.getVerifyUrl(i?.verifyUrl);\n      return this.fetchAttestation(o, c);\n    }), _(this, \"fetchAttestation\", async (i, r) => {\n      this.logger.debug(`resolving attestation: ${i} from url: ${r}`);\n      const o = this.startAbortTimer(Z * 5),\n        a = await fetch(`${r}/attestation/${i}?v2Supported=true`, {\n          signal: this.abortController.signal\n        });\n      return clearTimeout(o), a.status === 200 ? await a.json() : void 0;\n    }), _(this, \"getVerifyUrl\", i => {\n      let r = i || le;\n      return Gt.includes(r) || (this.logger.info(`verify url: ${r}, not included in trusted list, assigning default: ${le}`), r = le), r;\n    }), _(this, \"fetchPublicKey\", async () => {\n      try {\n        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);\n        const i = this.startAbortTimer(we),\n          r = await fetch(`${this.verifyUrlV3}/public-key`, {\n            signal: this.abortController.signal\n          });\n        return clearTimeout(i), await r.json();\n      } catch (i) {\n        this.logger.warn(i);\n      }\n    }), _(this, \"persistPublicKey\", async i => {\n      this.logger.debug(\"persisting public key to local storage\", i), await this.store.setItem(this.storeKey, i), this.publicKey = i;\n    }), _(this, \"removePublicKey\", async () => {\n      this.logger.debug(\"removing verify v2 public key from storage\"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;\n    }), _(this, \"isValidJwtAttestation\", async i => {\n      const r = await this.getPublicKey();\n      try {\n        if (r) return this.validateAttestation(i, r);\n      } catch (a) {\n        this.logger.error(a), this.logger.warn(\"error validating attestation\");\n      }\n      const o = await this.fetchAndPersistPublicKey();\n      try {\n        if (o) return this.validateAttestation(i, o);\n      } catch (a) {\n        this.logger.error(a), this.logger.warn(\"error validating attestation\");\n      }\n    }), _(this, \"getPublicKey\", async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey()), _(this, \"fetchAndPersistPublicKey\", async () => {\n      if (this.fetchPromise) return await this.fetchPromise, this.publicKey;\n      this.fetchPromise = new Promise(async r => {\n        const o = await this.fetchPublicKey();\n        o && (await this.persistPublicKey(o), r(o));\n      });\n      const i = await this.fetchPromise;\n      return this.fetchPromise = void 0, i;\n    }), _(this, \"validateAttestation\", (i, r) => {\n      const o = Ss(i, r.publicKey),\n        a = {\n          hasExpired: R(o.exp) < Date.now(),\n          payload: o\n        };\n      if (a.hasExpired) throw this.logger.warn(\"resolve: jwt attestation expired\"), new Error(\"JWT attestation expired\");\n      return {\n        origin: a.payload.origin,\n        isScam: a.payload.isScam,\n        isVerified: a.payload.isVerified\n      };\n    }), this.logger = N(t, this.name), this.abortController = new AbortController(), this.isDevEnv = lt(), this.init();\n  }\n  get storeKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//verify:public:key\";\n  }\n  get context() {\n    return U(this.logger);\n  }\n  startAbortTimer(e) {\n    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), R(e));\n  }\n}\nvar eo = Object.defineProperty,\n  to = (n, e, t) => e in n ? eo(n, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : n[e] = t,\n  Oi = (n, e, t) => to(n, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass Ai extends Xi {\n  constructor(e, t) {\n    super(e, t), this.projectId = e, this.logger = t, Oi(this, \"context\", Ht), Oi(this, \"registerDeviceToken\", async s => {\n      const {\n          clientId: i,\n          token: r,\n          notificationType: o,\n          enableEncrypted: a = !1\n        } = s,\n        c = `${Yt}/${this.projectId}/clients`;\n      await fetch(c, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          client_id: i,\n          type: o,\n          token: r,\n          always_raw: a\n        })\n      });\n    }), this.logger = N(t, this.context);\n  }\n}\nvar io = Object.defineProperty,\n  Ni = Object.getOwnPropertySymbols,\n  so = Object.prototype.hasOwnProperty,\n  ro = Object.prototype.propertyIsEnumerable,\n  qe = (n, e, t) => e in n ? io(n, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : n[e] = t,\n  pe = (n, e) => {\n    for (var t in e || (e = {})) so.call(e, t) && qe(n, t, e[t]);\n    if (Ni) for (var t of Ni(e)) ro.call(e, t) && qe(n, t, e[t]);\n    return n;\n  },\n  E = (n, e, t) => qe(n, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass $i extends Wi {\n  constructor(e, t, s = !0) {\n    super(e, t, s), this.core = e, this.logger = t, E(this, \"context\", Xt), E(this, \"storagePrefix\", B), E(this, \"storageVersion\", Jt), E(this, \"events\", new Map()), E(this, \"shouldPersist\", !1), E(this, \"init\", async () => {\n      if (!lt()) try {\n        const i = {\n          eventId: ut(),\n          timestamp: Date.now(),\n          domain: this.getAppDomain(),\n          props: {\n            event: \"INIT\",\n            type: \"\",\n            properties: {\n              client_id: await this.core.crypto.getClientId(),\n              user_agent: Rs(this.core.relayer.protocol, this.core.relayer.version, me)\n            }\n          }\n        };\n        await this.sendEvent([i]);\n      } catch (i) {\n        this.logger.warn(i);\n      }\n    }), E(this, \"createEvent\", i => {\n      const {\n          event: r = \"ERROR\",\n          type: o = \"\",\n          properties: {\n            topic: a,\n            trace: c\n          }\n        } = i,\n        h = ut(),\n        u = this.core.projectId || \"\",\n        g = Date.now(),\n        m = pe({\n          eventId: h,\n          timestamp: g,\n          props: {\n            event: r,\n            type: o,\n            properties: {\n              topic: a,\n              trace: c\n            }\n          },\n          bundleId: u,\n          domain: this.getAppDomain()\n        }, this.setMethods(h));\n      return this.telemetryEnabled && (this.events.set(h, m), this.shouldPersist = !0), m;\n    }), E(this, \"getEvent\", i => {\n      const {\n        eventId: r,\n        topic: o\n      } = i;\n      if (r) return this.events.get(r);\n      const a = Array.from(this.events.values()).find(c => c.props.properties.topic === o);\n      if (a) return pe(pe({}, a), this.setMethods(a.eventId));\n    }), E(this, \"deleteEvent\", i => {\n      const {\n        eventId: r\n      } = i;\n      this.events.delete(r), this.shouldPersist = !0;\n    }), E(this, \"setEventListeners\", () => {\n      this.core.heartbeat.on(ne.pulse, async () => {\n        this.shouldPersist && (await this.persist()), this.events.forEach(i => {\n          Je(Date.now()) - Je(i.timestamp) > Wt && (this.events.delete(i.eventId), this.shouldPersist = !0);\n        });\n      });\n    }), E(this, \"setMethods\", i => ({\n      addTrace: r => this.addTrace(i, r),\n      setError: r => this.setError(i, r)\n    })), E(this, \"addTrace\", (i, r) => {\n      const o = this.events.get(i);\n      o && (o.props.properties.trace.push(r), this.events.set(i, o), this.shouldPersist = !0);\n    }), E(this, \"setError\", (i, r) => {\n      const o = this.events.get(i);\n      o && (o.props.type = r, o.timestamp = Date.now(), this.events.set(i, o), this.shouldPersist = !0);\n    }), E(this, \"persist\", async () => {\n      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = !1;\n    }), E(this, \"restore\", async () => {\n      try {\n        const i = (await this.core.storage.getItem(this.storageKey)) || [];\n        if (!i.length) return;\n        i.forEach(r => {\n          this.events.set(r.eventId, pe(pe({}, r), this.setMethods(r.eventId)));\n        });\n      } catch (i) {\n        this.logger.warn(i);\n      }\n    }), E(this, \"submit\", async () => {\n      if (!this.telemetryEnabled || this.events.size === 0) return;\n      const i = [];\n      for (const [r, o] of this.events) o.props.type && i.push(o);\n      if (i.length !== 0) try {\n        if ((await this.sendEvent(i)).ok) for (const r of i) this.events.delete(r.eventId), this.shouldPersist = !0;\n      } catch (r) {\n        this.logger.warn(r);\n      }\n    }), E(this, \"sendEvent\", async i => {\n      const r = this.getAppDomain() ? \"\" : \"&sp=desktop\";\n      return await fetch(`${Zt}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${me}${r}`, {\n        method: \"POST\",\n        body: JSON.stringify(i)\n      });\n    }), E(this, \"getAppDomain\", () => xs().url), this.logger = N(t, this.context), this.telemetryEnabled = s, s ? this.restore().then(async () => {\n      await this.submit(), this.setEventListeners();\n    }) : this.persist();\n  }\n  get storageKey() {\n    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + \"//\" + this.context;\n  }\n}\nvar no = Object.defineProperty,\n  zi = Object.getOwnPropertySymbols,\n  oo = Object.prototype.hasOwnProperty,\n  ao = Object.prototype.propertyIsEnumerable,\n  Ge = (n, e, t) => e in n ? no(n, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : n[e] = t,\n  Li = (n, e) => {\n    for (var t in e || (e = {})) oo.call(e, t) && Ge(n, t, e[t]);\n    if (zi) for (var t of zi(e)) ao.call(e, t) && Ge(n, t, e[t]);\n    return n;\n  },\n  f = (n, e, t) => Ge(n, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass _e extends Zi {\n  constructor(e) {\n    var t;\n    super(e), f(this, \"protocol\", xe), f(this, \"version\", Oe), f(this, \"name\", he), f(this, \"relayUrl\"), f(this, \"projectId\"), f(this, \"customStoragePrefix\"), f(this, \"events\", new ee()), f(this, \"logger\"), f(this, \"heartbeat\"), f(this, \"relayer\"), f(this, \"crypto\"), f(this, \"storage\"), f(this, \"history\"), f(this, \"expirer\"), f(this, \"pairing\"), f(this, \"verify\"), f(this, \"echoClient\"), f(this, \"linkModeSupportedApps\"), f(this, \"eventClient\"), f(this, \"initialized\", !1), f(this, \"logChunkController\"), f(this, \"on\", (o, a) => this.events.on(o, a)), f(this, \"once\", (o, a) => this.events.once(o, a)), f(this, \"off\", (o, a) => this.events.off(o, a)), f(this, \"removeListener\", (o, a) => this.events.removeListener(o, a)), f(this, \"dispatchEnvelope\", ({\n      topic: o,\n      message: a,\n      sessionExists: c\n    }) => {\n      if (!o || !a) return;\n      const h = {\n        topic: o,\n        message: a,\n        publishedAt: Date.now(),\n        transportType: Q.link_mode\n      };\n      this.relayer.onLinkMessageEvent(h, {\n        sessionExists: c\n      });\n    }), this.projectId = e?.projectId, this.relayUrl = e?.relayUrl || $e, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : \"\";\n    const s = He({\n        level: typeof e?.logger == \"string\" && e.logger ? e.logger : mt.logger,\n        name: he\n      }),\n      {\n        logger: i,\n        chunkLoggerController: r\n      } = Ki({\n        opts: s,\n        maxSizeInBytes: e?.maxLogBlobSizeInBytes,\n        loggerOverride: e?.logger\n      });\n    this.logChunkController = r, (t = this.logChunkController) != null && t.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {\n      var o, a;\n      (o = this.logChunkController) != null && o.downloadLogsBlobInBrowser && ((a = this.logChunkController) == null || a.downloadLogsBlobInBrowser({\n        clientId: await this.crypto.getClientId()\n      }));\n    }), this.logger = N(i, this.name), this.heartbeat = new Ui(), this.crypto = new bi(this, this.logger, e?.keychain), this.history = new Si(this, this.logger), this.expirer = new Ri(this, this.logger), this.storage = e != null && e.storage ? e.storage : new Fi(Li(Li({}, vt), e?.storageOptions)), this.relayer = new wi({\n      core: this,\n      logger: this.logger,\n      relayUrl: this.relayUrl,\n      projectId: this.projectId\n    }), this.pairing = new Pi(this, this.logger), this.verify = new xi(this, this.logger, this.storage), this.echoClient = new Ai(this.projectId || \"\", this.logger), this.linkModeSupportedApps = [], this.eventClient = new $i(this, this.logger, e?.telemetryEnabled);\n  }\n  static async init(e) {\n    const t = new _e(e);\n    await t.initialize();\n    const s = await t.crypto.getClientId();\n    return await t.storage.setItem(Nt, s), t;\n  }\n  get context() {\n    return U(this.logger);\n  }\n  async start() {\n    this.initialized || (await this.initialize());\n  }\n  async getLogsBlob() {\n    var e;\n    return (e = this.logChunkController) == null ? void 0 : e.logsToBlob({\n      clientId: await this.crypto.getClientId()\n    });\n  }\n  async addLinkModeSupportedApp(e) {\n    this.linkModeSupportedApps.includes(e) || (this.linkModeSupportedApps.push(e), await this.storage.setItem(ze, this.linkModeSupportedApps));\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\");\n    try {\n      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.linkModeSupportedApps = (await this.storage.getItem(ze)) || [], this.initialized = !0, this.logger.info(\"Core Initialization Success\");\n    } catch (e) {\n      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;\n    }\n  }\n}\nconst co = _e;\nexport { he as CORE_CONTEXT, mt as CORE_DEFAULT, xe as CORE_PROTOCOL, vt as CORE_STORAGE_OPTIONS, B as CORE_STORAGE_PREFIX, Oe as CORE_VERSION, Ae as CRYPTO_CLIENT_SEED, ft as CRYPTO_CONTEXT, _t as CRYPTO_JWT_TTL, co as Core, bi as Crypto, Ht as ECHO_CONTEXT, Yt as ECHO_URL, Zt as EVENTS_CLIENT_API_URL, Wt as EVENTS_STORAGE_CLEANUP_INTERVAL, Xt as EVENTS_STORAGE_CONTEXT, Jt as EVENTS_STORAGE_VERSION, Ys as EVENT_CLIENT_AUTHENTICATE_ERRORS, Hs as EVENT_CLIENT_AUTHENTICATE_TRACES, Vs as EVENT_CLIENT_CONTEXT, J as EVENT_CLIENT_PAIRING_ERRORS, q as EVENT_CLIENT_PAIRING_TRACES, Gs as EVENT_CLIENT_SESSION_ERRORS, qs as EVENT_CLIENT_SESSION_TRACES, Kt as EXPIRER_CONTEXT, Bs as EXPIRER_DEFAULT_TTL, M as EXPIRER_EVENTS, Bt as EXPIRER_STORAGE_VERSION, Ai as EchoClient, $i as EventClient, Ri as Expirer, Ft as HISTORY_CONTEXT, F as HISTORY_EVENTS, Mt as HISTORY_STORAGE_VERSION, Si as JsonRpcHistory, Et as KEYCHAIN_CONTEXT, wt as KEYCHAIN_STORAGE_VERSION, yi as KeyChain, It as MESSAGES_CONTEXT, Tt as MESSAGES_STORAGE_VERSION, Di as MessageTracker, kt as PAIRING_CONTEXT, Ks as PAIRING_DEFAULT_TTL, se as PAIRING_EVENTS, ie as PAIRING_RPC_OPTS, Ut as PAIRING_STORAGE_VERSION, Lt as PENDING_SUB_RESOLUTION_TIMEOUT, Ct as PUBLISHER_CONTEXT, Ne as PUBLISHER_DEFAULT_TTL, Pi as Pairing, Rt as RELAYER_CONTEXT, St as RELAYER_DEFAULT_LOGGER, Pt as RELAYER_DEFAULT_PROTOCOL, $e as RELAYER_DEFAULT_RELAY_URL, T as RELAYER_EVENTS, L as RELAYER_PROVIDER_EVENTS, Ot as RELAYER_RECONNECT_TIMEOUT, me as RELAYER_SDK_VERSION, Us as RELAYER_STORAGE_OPTIONS, xt as RELAYER_SUBSCRIBER_SUFFIX, Fs as RELAYER_TRANSPORT_CUTOFF, wi as Relayer, At as STORE_STORAGE_VERSION, $t as SUBSCRIBER_CONTEXT, Ms as SUBSCRIBER_DEFAULT_TTL, $ as SUBSCRIBER_EVENTS, zt as SUBSCRIBER_STORAGE_VERSION, Ci as Store, fi as Subscriber, Q as TRANSPORT_TYPES, Gt as TRUSTED_VERIFY_URLS, jt as VERIFY_CONTEXT, le as VERIFY_SERVER, qt as VERIFY_SERVER_V3, xi as Verify, Nt as WALLETCONNECT_CLIENT_ID, ze as WALLETCONNECT_LINK_MODE_APPS, _e as default };","map":{"version":3,"names":[],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\core\\src\\constants\\core.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\core\\src\\constants\\crypto.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\core\\src\\constants\\keychain.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\core\\src\\constants\\messages.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\core\\src\\constants\\publisher.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\core\\src\\constants\\relayer.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\core\\src\\constants\\store.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\core\\src\\constants\\subscriber.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\core\\src\\constants\\pairing.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\core\\src\\constants\\history.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\core\\src\\constants\\expirer.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\core\\src\\constants\\verify.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\core\\src\\constants\\echo.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\core\\src\\constants\\events.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\multiformats\\esm\\vendor\\base-x.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\multiformats\\esm\\src\\bytes.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\multiformats\\esm\\src\\bases\\base.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\multiformats\\esm\\src\\bases\\identity.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\multiformats\\esm\\src\\bases\\base2.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\multiformats\\esm\\src\\bases\\base8.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\multiformats\\esm\\src\\bases\\base10.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\multiformats\\esm\\src\\bases\\base16.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\multiformats\\esm\\src\\bases\\base32.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\multiformats\\esm\\src\\bases\\base36.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\multiformats\\esm\\src\\bases\\base58.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\multiformats\\esm\\src\\bases\\base64.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\multiformats\\esm\\src\\bases\\base256emoji.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\multiformats\\esm\\vendor\\varint.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\multiformats\\esm\\src\\varint.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\multiformats\\esm\\src\\hashes\\digest.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\multiformats\\esm\\src\\hashes\\hasher.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\multiformats\\esm\\src\\hashes\\sha2-browser.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\multiformats\\esm\\src\\hashes\\identity.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\multiformats\\esm\\src\\codecs\\json.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\multiformats\\esm\\src\\basics.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\uint8arrays\\esm\\src\\alloc.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\uint8arrays\\esm\\src\\util\\bases.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\node_modules\\uint8arrays\\esm\\src\\from-string.js","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\core\\src\\controllers\\keychain.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\core\\src\\controllers\\crypto.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\core\\src\\controllers\\messages.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\core\\src\\controllers\\publisher.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\core\\src\\controllers\\topicmap.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\core\\src\\controllers\\subscriber.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\core\\src\\controllers\\relayer.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\core\\src\\controllers\\store.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\core\\src\\controllers\\pairing.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\core\\src\\controllers\\history.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\core\\src\\controllers\\expirer.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\core\\src\\controllers\\verify.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\core\\src\\controllers\\echo.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\core\\src\\controllers\\events.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\core\\src\\core.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\core\\src\\index.ts"],"sourcesContent":["export const CORE_PROTOCOL = \"wc\";\nexport const CORE_VERSION = 2;\nexport const CORE_CONTEXT = \"core\";\n\nexport const CORE_STORAGE_PREFIX = `${CORE_PROTOCOL}@${CORE_VERSION}:${CORE_CONTEXT}:`;\n\nexport const CORE_DEFAULT = {\n  name: CORE_CONTEXT,\n  logger: \"error\",\n};\n\nexport const CORE_STORAGE_OPTIONS = {\n  database: \":memory:\",\n};\n","import { ONE_DAY } from \"@walletconnect/time\";\n\nexport const CRYPTO_CONTEXT = \"crypto\";\n\nexport const CRYPTO_CLIENT_SEED = \"client_ed25519_seed\";\n\nexport const CRYPTO_JWT_TTL = ONE_DAY;\n","export const KEYCHAIN_CONTEXT = \"keychain\";\n\nexport const KEYCHAIN_STORAGE_VERSION = \"0.3\";\n","export const MESSAGES_CONTEXT = \"messages\";\n\nexport const MESSAGES_STORAGE_VERSION = \"0.3\";\n","import { SIX_HOURS } from \"@walletconnect/time\";\n\nexport const PUBLISHER_DEFAULT_TTL = SIX_HOURS;\n\nexport const PUBLISHER_CONTEXT = \"publisher\";\n","export const RELAYER_DEFAULT_PROTOCOL = \"irn\";\n\nexport const RELAYER_DEFAULT_LOGGER = \"error\";\n\nexport const RELAYER_DEFAULT_RELAY_URL = \"wss://relay.walletconnect.org\";\n\nexport const RELAYER_CONTEXT = \"relayer\";\n\nexport const RELAYER_EVENTS = {\n  message: \"relayer_message\",\n  message_ack: \"relayer_message_ack\",\n  connect: \"relayer_connect\",\n  disconnect: \"relayer_disconnect\",\n  error: \"relayer_error\",\n  connection_stalled: \"relayer_connection_stalled\",\n  transport_closed: \"relayer_transport_closed\",\n  publish: \"relayer_publish\",\n};\n\nexport const RELAYER_SUBSCRIBER_SUFFIX = \"_subscription\";\n\nexport const RELAYER_PROVIDER_EVENTS = {\n  payload: \"payload\",\n  connect: \"connect\",\n  disconnect: \"disconnect\",\n  error: \"error\",\n};\n\nexport const RELAYER_RECONNECT_TIMEOUT = 0.1;\n\nexport const RELAYER_STORAGE_OPTIONS = {\n  database: \":memory:\",\n};\n\n// Updated automatically via `new-version` npm script.\n\nexport const RELAYER_SDK_VERSION = \"2.19.0\";\n\n// delay to wait before closing the transport connection after init if not active\nexport const RELAYER_TRANSPORT_CUTOFF = 10_000;\n\nexport const TRANSPORT_TYPES = {\n  link_mode: \"link_mode\",\n  relay: \"relay\",\n} as const;\n","export const STORE_STORAGE_VERSION = \"0.3\";\n\nexport const WALLETCONNECT_CLIENT_ID = \"WALLETCONNECT_CLIENT_ID\";\nexport const WALLETCONNECT_LINK_MODE_APPS = \"WALLETCONNECT_LINK_MODE_APPS\";\n","import { THIRTY_DAYS, FIVE_SECONDS } from \"@walletconnect/time\";\n\nexport const SUBSCRIBER_EVENTS = {\n  created: \"subscription_created\",\n  deleted: \"subscription_deleted\",\n  expired: \"subscription_expired\",\n  disabled: \"subscription_disabled\",\n  sync: \"subscription_sync\",\n  resubscribed: \"subscription_resubscribed\",\n};\n\nexport const SUBSCRIBER_DEFAULT_TTL = THIRTY_DAYS;\n\nexport const SUBSCRIBER_CONTEXT = \"subscription\";\n\nexport const SUBSCRIBER_STORAGE_VERSION = \"0.3\";\n\nexport const PENDING_SUB_RESOLUTION_TIMEOUT = FIVE_SECONDS * 1000;\n","import { THIRTY_DAYS, ONE_DAY, THIRTY_SECONDS } from \"@walletconnect/time\";\nimport { RelayerTypes, PairingJsonRpcTypes } from \"@walletconnect/types\";\n\nexport const PAIRING_CONTEXT = \"pairing\";\n\nexport const PAIRING_STORAGE_VERSION = \"0.3\";\n\nexport const PAIRING_DEFAULT_TTL = THIRTY_DAYS;\n\nexport const PAIRING_RPC_OPTS: Record<\n  PairingJsonRpcTypes.WcMethod | \"unregistered_method\",\n  {\n    req: RelayerTypes.PublishOptions;\n    res: RelayerTypes.PublishOptions;\n  }\n> = {\n  wc_pairingDelete: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1000,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1001,\n    },\n  },\n  wc_pairingPing: {\n    req: {\n      ttl: THIRTY_SECONDS,\n      prompt: false,\n      tag: 1002,\n    },\n    res: {\n      ttl: THIRTY_SECONDS,\n      prompt: false,\n      tag: 1003,\n    },\n  },\n  unregistered_method: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 0,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 0,\n    },\n  },\n};\n\nexport const PAIRING_EVENTS = {\n  create: \"pairing_create\",\n  expire: \"pairing_expire\",\n  delete: \"pairing_delete\",\n  ping: \"pairing_ping\",\n};\n","export const HISTORY_EVENTS = {\n  created: \"history_created\",\n  updated: \"history_updated\",\n  deleted: \"history_deleted\",\n  sync: \"history_sync\",\n};\n\nexport const HISTORY_CONTEXT = \"history\";\n\nexport const HISTORY_STORAGE_VERSION = \"0.3\";\n","import { ONE_DAY } from \"@walletconnect/time\";\n\nexport const EXPIRER_CONTEXT = \"expirer\";\n\nexport const EXPIRER_EVENTS = {\n  created: \"expirer_created\",\n  deleted: \"expirer_deleted\",\n  expired: \"expirer_expired\",\n  sync: \"expirer_sync\",\n};\n\nexport const EXPIRER_STORAGE_VERSION = \"0.3\";\n\nexport const EXPIRER_DEFAULT_TTL = ONE_DAY;\n","export const VERIFY_CONTEXT = \"verify-api\";\n\nconst VERIFY_SERVER_COM = \"https://verify.walletconnect.com\";\nconst VERIFY_SERVER_ORG = \"https://verify.walletconnect.org\";\nexport const VERIFY_SERVER = VERIFY_SERVER_ORG;\nexport const VERIFY_SERVER_V3 = `${VERIFY_SERVER}/v3`;\n\nexport const TRUSTED_VERIFY_URLS = [VERIFY_SERVER_COM, VERIFY_SERVER_ORG];\n","export const ECHO_CONTEXT = \"echo\";\n\nexport const ECHO_URL = \"https://echo.walletconnect.com\";\n","export const EVENT_CLIENT_CONTEXT = \"event-client\";\n\nexport const EVENT_CLIENT_PAIRING_TRACES = {\n  pairing_started: \"pairing_started\",\n  pairing_uri_validation_success: \"pairing_uri_validation_success\",\n  pairing_uri_not_expired: \"pairing_uri_not_expired\",\n  store_new_pairing: \"store_new_pairing\",\n  subscribing_pairing_topic: \"subscribing_pairing_topic\",\n  subscribe_pairing_topic_success: \"subscribe_pairing_topic_success\",\n  existing_pairing: \"existing_pairing\",\n  pairing_not_expired: \"pairing_not_expired\",\n  emit_inactive_pairing: \"emit_inactive_pairing\",\n  emit_session_proposal: \"emit_session_proposal\",\n  subscribing_to_pairing_topic: \"subscribing_to_pairing_topic\",\n};\n\nexport const EVENT_CLIENT_PAIRING_ERRORS = {\n  no_wss_connection: \"no_wss_connection\",\n  no_internet_connection: \"no_internet_connection\",\n  malformed_pairing_uri: \"malformed_pairing_uri\",\n  active_pairing_already_exists: \"active_pairing_already_exists\",\n  subscribe_pairing_topic_failure: \"subscribe_pairing_topic_failure\",\n  pairing_expired: \"pairing_expired\",\n  proposal_expired: \"proposal_expired\",\n  proposal_listener_not_found: \"proposal_listener_not_found\",\n};\n\nexport const EVENT_CLIENT_SESSION_TRACES = {\n  session_approve_started: \"session_approve_started\",\n  proposal_not_expired: \"proposal_not_expired\",\n  session_namespaces_validation_success: \"session_namespaces_validation_success\",\n  create_session_topic: \"create_session_topic\",\n  subscribing_session_topic: \"subscribing_session_topic\",\n  subscribe_session_topic_success: \"subscribe_session_topic_success\",\n  publishing_session_approve: \"publishing_session_approve\",\n  session_approve_publish_success: \"session_approve_publish_success\",\n  store_session: \"store_session\",\n  publishing_session_settle: \"publishing_session_settle\",\n  session_settle_publish_success: \"session_settle_publish_success\",\n};\n\nexport const EVENT_CLIENT_SESSION_ERRORS = {\n  no_internet_connection: \"no_internet_connection\",\n  no_wss_connection: \"no_wss_connection\",\n  proposal_expired: \"proposal_expired\",\n  subscribe_session_topic_failure: \"subscribe_session_topic_failure\",\n  session_approve_publish_failure: \"session_approve_publish_failure\",\n  session_settle_publish_failure: \"session_settle_publish_failure\",\n  session_approve_namespace_validation_failure: \"session_approve_namespace_validation_failure\",\n  proposal_not_found: \"proposal_not_found\",\n};\n\nexport const EVENT_CLIENT_AUTHENTICATE_TRACES = {\n  authenticated_session_approve_started: \"authenticated_session_approve_started\",\n  authenticated_session_not_expired: \"authenticated_session_not_expired\",\n  chains_caip2_compliant: \"chains_caip2_compliant\",\n  chains_evm_compliant: \"chains_evm_compliant\",\n  create_authenticated_session_topic: \"create_authenticated_session_topic\",\n  cacaos_verified: \"cacaos_verified\",\n  store_authenticated_session: \"store_authenticated_session\",\n  subscribing_authenticated_session_topic: \"subscribing_authenticated_session_topic\",\n  subscribe_authenticated_session_topic_success: \"subscribe_authenticated_session_topic_success\",\n  publishing_authenticated_session_approve: \"publishing_authenticated_session_approve\",\n  authenticated_session_approve_publish_success: \"authenticated_session_approve_publish_success\",\n};\n\nexport const EVENT_CLIENT_AUTHENTICATE_ERRORS = {\n  no_internet_connection: \"no_internet_connection\",\n  no_wss_connection: \"no_wss_connection\",\n  missing_session_authenticate_request: \"missing_session_authenticate_request\",\n  session_authenticate_request_expired: \"session_authenticate_request_expired\",\n  chains_caip2_compliant_failure: \"chains_caip2_compliant_failure\",\n  chains_evm_compliant_failure: \"chains_evm_compliant_failure\",\n  invalid_cacao: \"invalid_cacao\",\n  subscribe_authenticated_session_topic_failure: \"subscribe_authenticated_session_topic_failure\",\n  authenticated_session_approve_publish_failure: \"authenticated_session_approve_publish_failure\",\n  authenticated_session_pending_request_not_found:\n    \"authenticated_session_pending_request_not_found\",\n};\n\nexport const EVENTS_STORAGE_VERSION = 0.1;\n\nexport const EVENTS_STORAGE_CONTEXT = \"event-client\";\n\nexport const EVENTS_STORAGE_CLEANUP_INTERVAL = 86400;\n\nexport const EVENTS_CLIENT_API_URL = \"https://pulse.walletconnect.org/batch\";\n","function base(ALPHABET, name) {\n  if (ALPHABET.length >= 255) {\n    throw new TypeError('Alphabet too long');\n  }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) {\n      throw new TypeError(x + ' is ambiguous');\n    }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256);\n  var iFACTOR = Math.log(256) / Math.log(BASE);\n  function encode(source) {\n    if (source instanceof Uint8Array);\n    else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) {\n      throw new TypeError('Expected Uint8Array');\n    }\n    if (source.length === 0) {\n      return '';\n    }\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;\n    var b58 = new Uint8Array(size);\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {\n        carry += 256 * b58[it1] >>> 0;\n        b58[it1] = carry % BASE >>> 0;\n        carry = carry / BASE >>> 0;\n      }\n      if (carry !== 0) {\n        throw new Error('Non-zero carry');\n      }\n      length = i;\n      pbegin++;\n    }\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) {\n      str += ALPHABET.charAt(b58[it2]);\n    }\n    return str;\n  }\n  function decodeUnsafe(source) {\n    if (typeof source !== 'string') {\n      throw new TypeError('Expected String');\n    }\n    if (source.length === 0) {\n      return new Uint8Array();\n    }\n    var psz = 0;\n    if (source[psz] === ' ') {\n      return;\n    }\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n    var size = (source.length - psz) * FACTOR + 1 >>> 0;\n    var b256 = new Uint8Array(size);\n    while (source[psz]) {\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n      if (carry === 255) {\n        return;\n      }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {\n        carry += BASE * b256[it3] >>> 0;\n        b256[it3] = carry % 256 >>> 0;\n        carry = carry / 256 >>> 0;\n      }\n      if (carry !== 0) {\n        throw new Error('Non-zero carry');\n      }\n      length = i;\n      psz++;\n    }\n    if (source[psz] === ' ') {\n      return;\n    }\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch;\n  }\n  function decode(string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) {\n      return buffer;\n    }\n    throw new Error(`Non-${ name } character`);\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  };\n}\nvar src = base;\nvar _brrp__multiformats_scope_baseX = src;\nexport default _brrp__multiformats_scope_baseX;","const empty = new Uint8Array(0);\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '');\nconst fromHex = hex => {\n  const hexes = hex.match(/../g);\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty;\n};\nconst equals = (aa, bb) => {\n  if (aa === bb)\n    return true;\n  if (aa.byteLength !== bb.byteLength) {\n    return false;\n  }\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false;\n    }\n  }\n  return true;\n};\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array')\n    return o;\n  if (o instanceof ArrayBuffer)\n    return new Uint8Array(o);\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);\n  }\n  throw new Error('Unknown type, must be binary type');\n};\nconst isBinary = o => o instanceof ArrayBuffer || ArrayBuffer.isView(o);\nconst fromString = str => new TextEncoder().encode(str);\nconst toString = b => new TextDecoder().decode(b);\nexport {\n  equals,\n  coerce,\n  isBinary,\n  fromHex,\n  toHex,\n  fromString,\n  toString,\n  empty\n};","import basex from '../../vendor/base-x.js';\nimport { coerce } from '../bytes.js';\nclass Encoder {\n  constructor(name, prefix, baseEncode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n  }\n  encode(bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${ this.prefix }${ this.baseEncode(bytes) }`;\n    } else {\n      throw Error('Unknown type, must be binary type');\n    }\n  }\n}\nclass Decoder {\n  constructor(name, prefix, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    if (prefix.codePointAt(0) === undefined) {\n      throw new Error('Invalid prefix character');\n    }\n    this.prefixCodePoint = prefix.codePointAt(0);\n    this.baseDecode = baseDecode;\n  }\n  decode(text) {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${ JSON.stringify(text) }, ${ this.name } decoder only supports inputs prefixed with ${ this.prefix }`);\n      }\n      return this.baseDecode(text.slice(this.prefix.length));\n    } else {\n      throw Error('Can only multibase decode strings');\n    }\n  }\n  or(decoder) {\n    return or(this, decoder);\n  }\n}\nclass ComposedDecoder {\n  constructor(decoders) {\n    this.decoders = decoders;\n  }\n  or(decoder) {\n    return or(this, decoder);\n  }\n  decode(input) {\n    const prefix = input[0];\n    const decoder = this.decoders[prefix];\n    if (decoder) {\n      return decoder.decode(input);\n    } else {\n      throw RangeError(`Unable to decode multibase string ${ JSON.stringify(input) }, only inputs prefixed with ${ Object.keys(this.decoders) } are supported`);\n    }\n  }\n}\nexport const or = (left, right) => new ComposedDecoder({\n  ...left.decoders || { [left.prefix]: left },\n  ...right.decoders || { [right.prefix]: right }\n});\nexport class Codec {\n  constructor(name, prefix, baseEncode, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n    this.baseDecode = baseDecode;\n    this.encoder = new Encoder(name, prefix, baseEncode);\n    this.decoder = new Decoder(name, prefix, baseDecode);\n  }\n  encode(input) {\n    return this.encoder.encode(input);\n  }\n  decode(input) {\n    return this.decoder.decode(input);\n  }\n}\nexport const from = ({name, prefix, encode, decode}) => new Codec(name, prefix, encode, decode);\nexport const baseX = ({prefix, name, alphabet}) => {\n  const {encode, decode} = basex(alphabet, name);\n  return from({\n    prefix,\n    name,\n    encode,\n    decode: text => coerce(decode(text))\n  });\n};\nconst decode = (string, alphabet, bitsPerChar, name) => {\n  const codes = {};\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i;\n  }\n  let end = string.length;\n  while (string[end - 1] === '=') {\n    --end;\n  }\n  const out = new Uint8Array(end * bitsPerChar / 8 | 0);\n  let bits = 0;\n  let buffer = 0;\n  let written = 0;\n  for (let i = 0; i < end; ++i) {\n    const value = codes[string[i]];\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${ name } character`);\n    }\n    buffer = buffer << bitsPerChar | value;\n    bits += bitsPerChar;\n    if (bits >= 8) {\n      bits -= 8;\n      out[written++] = 255 & buffer >> bits;\n    }\n  }\n  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {\n    throw new SyntaxError('Unexpected end of data');\n  }\n  return out;\n};\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '=';\n  const mask = (1 << bitsPerChar) - 1;\n  let out = '';\n  let bits = 0;\n  let buffer = 0;\n  for (let i = 0; i < data.length; ++i) {\n    buffer = buffer << 8 | data[i];\n    bits += 8;\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar;\n      out += alphabet[mask & buffer >> bits];\n    }\n  }\n  if (bits) {\n    out += alphabet[mask & buffer << bitsPerChar - bits];\n  }\n  if (pad) {\n    while (out.length * bitsPerChar & 7) {\n      out += '=';\n    }\n  }\n  return out;\n};\nexport const rfc4648 = ({name, prefix, bitsPerChar, alphabet}) => {\n  return from({\n    prefix,\n    name,\n    encode(input) {\n      return encode(input, alphabet, bitsPerChar);\n    },\n    decode(input) {\n      return decode(input, alphabet, bitsPerChar, name);\n    }\n  });\n};","import { from } from './base.js';\nimport {\n  fromString,\n  toString\n} from '../bytes.js';\nexport const identity = from({\n  prefix: '\\0',\n  name: 'identity',\n  encode: buf => toString(buf),\n  decode: str => fromString(str)\n});","import { rfc4648 } from './base.js';\nexport const base2 = rfc4648({\n  prefix: '0',\n  name: 'base2',\n  alphabet: '01',\n  bitsPerChar: 1\n});","import { rfc4648 } from './base.js';\nexport const base8 = rfc4648({\n  prefix: '7',\n  name: 'base8',\n  alphabet: '01234567',\n  bitsPerChar: 3\n});","import { baseX } from './base.js';\nexport const base10 = baseX({\n  prefix: '9',\n  name: 'base10',\n  alphabet: '0123456789'\n});","import { rfc4648 } from './base.js';\nexport const base16 = rfc4648({\n  prefix: 'f',\n  name: 'base16',\n  alphabet: '0123456789abcdef',\n  bitsPerChar: 4\n});\nexport const base16upper = rfc4648({\n  prefix: 'F',\n  name: 'base16upper',\n  alphabet: '0123456789ABCDEF',\n  bitsPerChar: 4\n});","import { rfc4648 } from './base.js';\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n});\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n});\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n});\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n});\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n});\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n});\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n});\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n});\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n});","import { baseX } from './base.js';\nexport const base36 = baseX({\n  prefix: 'k',\n  name: 'base36',\n  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n});\nexport const base36upper = baseX({\n  prefix: 'K',\n  name: 'base36upper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n});","import { baseX } from './base.js';\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n});\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n});","import { rfc4648 } from './base.js';\nexport const base64 = rfc4648({\n  prefix: 'm',\n  name: 'base64',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bitsPerChar: 6\n});\nexport const base64pad = rfc4648({\n  prefix: 'M',\n  name: 'base64pad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  bitsPerChar: 6\n});\nexport const base64url = rfc4648({\n  prefix: 'u',\n  name: 'base64url',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bitsPerChar: 6\n});\nexport const base64urlpad = rfc4648({\n  prefix: 'U',\n  name: 'base64urlpad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n  bitsPerChar: 6\n});","import { from } from './base.js';\nconst alphabet = Array.from('\\uD83D\\uDE80\\uD83E\\uDE90\\u2604\\uD83D\\uDEF0\\uD83C\\uDF0C\\uD83C\\uDF11\\uD83C\\uDF12\\uD83C\\uDF13\\uD83C\\uDF14\\uD83C\\uDF15\\uD83C\\uDF16\\uD83C\\uDF17\\uD83C\\uDF18\\uD83C\\uDF0D\\uD83C\\uDF0F\\uD83C\\uDF0E\\uD83D\\uDC09\\u2600\\uD83D\\uDCBB\\uD83D\\uDDA5\\uD83D\\uDCBE\\uD83D\\uDCBF\\uD83D\\uDE02\\u2764\\uD83D\\uDE0D\\uD83E\\uDD23\\uD83D\\uDE0A\\uD83D\\uDE4F\\uD83D\\uDC95\\uD83D\\uDE2D\\uD83D\\uDE18\\uD83D\\uDC4D\\uD83D\\uDE05\\uD83D\\uDC4F\\uD83D\\uDE01\\uD83D\\uDD25\\uD83E\\uDD70\\uD83D\\uDC94\\uD83D\\uDC96\\uD83D\\uDC99\\uD83D\\uDE22\\uD83E\\uDD14\\uD83D\\uDE06\\uD83D\\uDE44\\uD83D\\uDCAA\\uD83D\\uDE09\\u263A\\uD83D\\uDC4C\\uD83E\\uDD17\\uD83D\\uDC9C\\uD83D\\uDE14\\uD83D\\uDE0E\\uD83D\\uDE07\\uD83C\\uDF39\\uD83E\\uDD26\\uD83C\\uDF89\\uD83D\\uDC9E\\u270C\\u2728\\uD83E\\uDD37\\uD83D\\uDE31\\uD83D\\uDE0C\\uD83C\\uDF38\\uD83D\\uDE4C\\uD83D\\uDE0B\\uD83D\\uDC97\\uD83D\\uDC9A\\uD83D\\uDE0F\\uD83D\\uDC9B\\uD83D\\uDE42\\uD83D\\uDC93\\uD83E\\uDD29\\uD83D\\uDE04\\uD83D\\uDE00\\uD83D\\uDDA4\\uD83D\\uDE03\\uD83D\\uDCAF\\uD83D\\uDE48\\uD83D\\uDC47\\uD83C\\uDFB6\\uD83D\\uDE12\\uD83E\\uDD2D\\u2763\\uD83D\\uDE1C\\uD83D\\uDC8B\\uD83D\\uDC40\\uD83D\\uDE2A\\uD83D\\uDE11\\uD83D\\uDCA5\\uD83D\\uDE4B\\uD83D\\uDE1E\\uD83D\\uDE29\\uD83D\\uDE21\\uD83E\\uDD2A\\uD83D\\uDC4A\\uD83E\\uDD73\\uD83D\\uDE25\\uD83E\\uDD24\\uD83D\\uDC49\\uD83D\\uDC83\\uD83D\\uDE33\\u270B\\uD83D\\uDE1A\\uD83D\\uDE1D\\uD83D\\uDE34\\uD83C\\uDF1F\\uD83D\\uDE2C\\uD83D\\uDE43\\uD83C\\uDF40\\uD83C\\uDF37\\uD83D\\uDE3B\\uD83D\\uDE13\\u2B50\\u2705\\uD83E\\uDD7A\\uD83C\\uDF08\\uD83D\\uDE08\\uD83E\\uDD18\\uD83D\\uDCA6\\u2714\\uD83D\\uDE23\\uD83C\\uDFC3\\uD83D\\uDC90\\u2639\\uD83C\\uDF8A\\uD83D\\uDC98\\uD83D\\uDE20\\u261D\\uD83D\\uDE15\\uD83C\\uDF3A\\uD83C\\uDF82\\uD83C\\uDF3B\\uD83D\\uDE10\\uD83D\\uDD95\\uD83D\\uDC9D\\uD83D\\uDE4A\\uD83D\\uDE39\\uD83D\\uDDE3\\uD83D\\uDCAB\\uD83D\\uDC80\\uD83D\\uDC51\\uD83C\\uDFB5\\uD83E\\uDD1E\\uD83D\\uDE1B\\uD83D\\uDD34\\uD83D\\uDE24\\uD83C\\uDF3C\\uD83D\\uDE2B\\u26BD\\uD83E\\uDD19\\u2615\\uD83C\\uDFC6\\uD83E\\uDD2B\\uD83D\\uDC48\\uD83D\\uDE2E\\uD83D\\uDE46\\uD83C\\uDF7B\\uD83C\\uDF43\\uD83D\\uDC36\\uD83D\\uDC81\\uD83D\\uDE32\\uD83C\\uDF3F\\uD83E\\uDDE1\\uD83C\\uDF81\\u26A1\\uD83C\\uDF1E\\uD83C\\uDF88\\u274C\\u270A\\uD83D\\uDC4B\\uD83D\\uDE30\\uD83E\\uDD28\\uD83D\\uDE36\\uD83E\\uDD1D\\uD83D\\uDEB6\\uD83D\\uDCB0\\uD83C\\uDF53\\uD83D\\uDCA2\\uD83E\\uDD1F\\uD83D\\uDE41\\uD83D\\uDEA8\\uD83D\\uDCA8\\uD83E\\uDD2C\\u2708\\uD83C\\uDF80\\uD83C\\uDF7A\\uD83E\\uDD13\\uD83D\\uDE19\\uD83D\\uDC9F\\uD83C\\uDF31\\uD83D\\uDE16\\uD83D\\uDC76\\uD83E\\uDD74\\u25B6\\u27A1\\u2753\\uD83D\\uDC8E\\uD83D\\uDCB8\\u2B07\\uD83D\\uDE28\\uD83C\\uDF1A\\uD83E\\uDD8B\\uD83D\\uDE37\\uD83D\\uDD7A\\u26A0\\uD83D\\uDE45\\uD83D\\uDE1F\\uD83D\\uDE35\\uD83D\\uDC4E\\uD83E\\uDD32\\uD83E\\uDD20\\uD83E\\uDD27\\uD83D\\uDCCC\\uD83D\\uDD35\\uD83D\\uDC85\\uD83E\\uDDD0\\uD83D\\uDC3E\\uD83C\\uDF52\\uD83D\\uDE17\\uD83E\\uDD11\\uD83C\\uDF0A\\uD83E\\uDD2F\\uD83D\\uDC37\\u260E\\uD83D\\uDCA7\\uD83D\\uDE2F\\uD83D\\uDC86\\uD83D\\uDC46\\uD83C\\uDFA4\\uD83D\\uDE47\\uD83C\\uDF51\\u2744\\uD83C\\uDF34\\uD83D\\uDCA3\\uD83D\\uDC38\\uD83D\\uDC8C\\uD83D\\uDCCD\\uD83E\\uDD40\\uD83E\\uDD22\\uD83D\\uDC45\\uD83D\\uDCA1\\uD83D\\uDCA9\\uD83D\\uDC50\\uD83D\\uDCF8\\uD83D\\uDC7B\\uD83E\\uDD10\\uD83E\\uDD2E\\uD83C\\uDFBC\\uD83E\\uDD75\\uD83D\\uDEA9\\uD83C\\uDF4E\\uD83C\\uDF4A\\uD83D\\uDC7C\\uD83D\\uDC8D\\uD83D\\uDCE3\\uD83E\\uDD42');\nconst alphabetBytesToChars = alphabet.reduce((p, c, i) => {\n  p[i] = c;\n  return p;\n}, []);\nconst alphabetCharsToBytes = alphabet.reduce((p, c, i) => {\n  p[c.codePointAt(0)] = i;\n  return p;\n}, []);\nfunction encode(data) {\n  return data.reduce((p, c) => {\n    p += alphabetBytesToChars[c];\n    return p;\n  }, '');\n}\nfunction decode(str) {\n  const byts = [];\n  for (const char of str) {\n    const byt = alphabetCharsToBytes[char.codePointAt(0)];\n    if (byt === undefined) {\n      throw new Error(`Non-base256emoji character: ${ char }`);\n    }\n    byts.push(byt);\n  }\n  return new Uint8Array(byts);\n}\nexport const base256emoji = from({\n  prefix: '\\uD83D\\uDE80',\n  name: 'base256emoji',\n  encode,\n  decode\n});","var encode_1 = encode;\nvar MSB = 128, REST = 127, MSBALL = ~REST, INT = Math.pow(2, 31);\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n  while (num >= INT) {\n    out[offset++] = num & 255 | MSB;\n    num /= 128;\n  }\n  while (num & MSBALL) {\n    out[offset++] = num & 255 | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  encode.bytes = offset - oldOffset + 1;\n  return out;\n}\nvar decode = read;\nvar MSB$1 = 128, REST$1 = 127;\nfunction read(buf, offset) {\n  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint');\n    }\n    b = buf[counter++];\n    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1);\n  read.bytes = counter - offset;\n  return res;\n}\nvar N1 = Math.pow(2, 7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\nvar length = function (value) {\n  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;\n};\nvar varint = {\n  encode: encode_1,\n  decode: decode,\n  encodingLength: length\n};\nvar _brrp_varint = varint;\nexport default _brrp_varint;","import varint from '../vendor/varint.js';\nexport const decode = (data, offset = 0) => {\n  const code = varint.decode(data, offset);\n  return [\n    code,\n    varint.decode.bytes\n  ];\n};\nexport const encodeTo = (int, target, offset = 0) => {\n  varint.encode(int, target, offset);\n  return target;\n};\nexport const encodingLength = int => {\n  return varint.encodingLength(int);\n};","import {\n  coerce,\n  equals as equalBytes\n} from '../bytes.js';\nimport * as varint from '../varint.js';\nexport const create = (code, digest) => {\n  const size = digest.byteLength;\n  const sizeOffset = varint.encodingLength(code);\n  const digestOffset = sizeOffset + varint.encodingLength(size);\n  const bytes = new Uint8Array(digestOffset + size);\n  varint.encodeTo(code, bytes, 0);\n  varint.encodeTo(size, bytes, sizeOffset);\n  bytes.set(digest, digestOffset);\n  return new Digest(code, size, digest, bytes);\n};\nexport const decode = multihash => {\n  const bytes = coerce(multihash);\n  const [code, sizeOffset] = varint.decode(bytes);\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset));\n  const digest = bytes.subarray(sizeOffset + digestOffset);\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length');\n  }\n  return new Digest(code, size, digest, bytes);\n};\nexport const equals = (a, b) => {\n  if (a === b) {\n    return true;\n  } else {\n    return a.code === b.code && a.size === b.size && equalBytes(a.bytes, b.bytes);\n  }\n};\nexport class Digest {\n  constructor(code, size, digest, bytes) {\n    this.code = code;\n    this.size = size;\n    this.digest = digest;\n    this.bytes = bytes;\n  }\n}","import * as Digest from './digest.js';\nexport const from = ({name, code, encode}) => new Hasher(name, code, encode);\nexport class Hasher {\n  constructor(name, code, encode) {\n    this.name = name;\n    this.code = code;\n    this.encode = encode;\n  }\n  digest(input) {\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input);\n      return result instanceof Uint8Array ? Digest.create(this.code, result) : result.then(digest => Digest.create(this.code, digest));\n    } else {\n      throw Error('Unknown type, must be binary type');\n    }\n  }\n}","import { from } from './hasher.js';\nconst sha = name => async data => new Uint8Array(await crypto.subtle.digest(name, data));\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 18,\n  encode: sha('SHA-256')\n});\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 19,\n  encode: sha('SHA-512')\n});","import { coerce } from '../bytes.js';\nimport * as Digest from './digest.js';\nconst code = 0;\nconst name = 'identity';\nconst encode = coerce;\nconst digest = input => Digest.create(code, encode(input));\nexport const identity = {\n  code,\n  name,\n  encode,\n  digest\n};","const textEncoder = new TextEncoder();\nconst textDecoder = new TextDecoder();\nexport const name = 'json';\nexport const code = 512;\nexport const encode = node => textEncoder.encode(JSON.stringify(node));\nexport const decode = data => JSON.parse(textDecoder.decode(data));","import * as identityBase from './bases/identity.js';\nimport * as base2 from './bases/base2.js';\nimport * as base8 from './bases/base8.js';\nimport * as base10 from './bases/base10.js';\nimport * as base16 from './bases/base16.js';\nimport * as base32 from './bases/base32.js';\nimport * as base36 from './bases/base36.js';\nimport * as base58 from './bases/base58.js';\nimport * as base64 from './bases/base64.js';\nimport * as base256emoji from './bases/base256emoji.js';\nimport * as sha2 from './hashes/sha2.js';\nimport * as identity from './hashes/identity.js';\nimport * as raw from './codecs/raw.js';\nimport * as json from './codecs/json.js';\nimport {\n  CID,\n  hasher,\n  digest,\n  varint,\n  bytes\n} from './index.js';\nconst bases = {\n  ...identityBase,\n  ...base2,\n  ...base8,\n  ...base10,\n  ...base16,\n  ...base32,\n  ...base36,\n  ...base58,\n  ...base64,\n  ...base256emoji\n};\nconst hashes = {\n  ...sha2,\n  ...identity\n};\nconst codecs = {\n  raw,\n  json\n};\nexport {\n  CID,\n  hasher,\n  digest,\n  varint,\n  bytes,\n  hashes,\n  bases,\n  codecs\n};","export function alloc(size = 0) {\n  if (globalThis.Buffer != null && globalThis.Buffer.alloc != null) {\n    return globalThis.Buffer.alloc(size);\n  }\n  return new Uint8Array(size);\n}\nexport function allocUnsafe(size = 0) {\n  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {\n    return globalThis.Buffer.allocUnsafe(size);\n  }\n  return new Uint8Array(size);\n}","import { bases } from 'multiformats/basics';\nimport { allocUnsafe } from '../alloc.js';\nfunction createCodec(name, prefix, encode, decode) {\n  return {\n    name,\n    prefix,\n    encoder: {\n      name,\n      prefix,\n      encode\n    },\n    decoder: { decode }\n  };\n}\nconst string = createCodec('utf8', 'u', buf => {\n  const decoder = new TextDecoder('utf8');\n  return 'u' + decoder.decode(buf);\n}, str => {\n  const encoder = new TextEncoder();\n  return encoder.encode(str.substring(1));\n});\nconst ascii = createCodec('ascii', 'a', buf => {\n  let string = 'a';\n  for (let i = 0; i < buf.length; i++) {\n    string += String.fromCharCode(buf[i]);\n  }\n  return string;\n}, str => {\n  str = str.substring(1);\n  const buf = allocUnsafe(str.length);\n  for (let i = 0; i < str.length; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n});\nconst BASES = {\n  utf8: string,\n  'utf-8': string,\n  hex: bases.base16,\n  latin1: ascii,\n  ascii: ascii,\n  binary: ascii,\n  ...bases\n};\nexport default BASES;","import bases from './util/bases.js';\nexport function fromString(string, encoding = 'utf8') {\n  const base = bases[encoding];\n  if (!base) {\n    throw new Error(`Unsupported encoding \"${ encoding }\"`);\n  }\n  if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {\n    return globalThis.Buffer.from(string, 'utf8');\n  }\n  return base.decoder.decode(`${ base.prefix }${ string }`);\n}","import { generateChildLogger, getLoggerContext, Logger } from \"@walletconnect/logger\";\nimport { ICore, IKeyChain } from \"@walletconnect/types\";\nimport { getInternalError, mapToObj, objToMap } from \"@walletconnect/utils\";\n\nimport { CORE_STORAGE_PREFIX, KEYCHAIN_CONTEXT, KEYCHAIN_STORAGE_VERSION } from \"../constants\";\n\nexport class KeyChain implements IKeyChain {\n  public keychain = new Map<string, string>();\n  public name = KEYCHAIN_CONTEXT;\n  public version = KEYCHAIN_STORAGE_VERSION;\n\n  private initialized = false;\n  private storagePrefix = CORE_STORAGE_PREFIX;\n\n  constructor(public core: ICore, public logger: Logger) {\n    this.core = core;\n    this.logger = generateChildLogger(logger, this.name);\n  }\n\n  public init: IKeyChain[\"init\"] = async () => {\n    if (!this.initialized) {\n      const keychain = await this.getKeyChain();\n      if (typeof keychain !== \"undefined\") {\n        this.keychain = keychain;\n      }\n      this.initialized = true;\n    }\n  };\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  get storageKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + this.name;\n  }\n\n  public has: IKeyChain[\"has\"] = (tag) => {\n    this.isInitialized();\n    return this.keychain.has(tag);\n  };\n\n  public set: IKeyChain[\"set\"] = async (tag, key) => {\n    this.isInitialized();\n    this.keychain.set(tag, key);\n    await this.persist();\n  };\n\n  public get: IKeyChain[\"get\"] = (tag) => {\n    this.isInitialized();\n    const key = this.keychain.get(tag);\n    if (typeof key === \"undefined\") {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `${this.name}: ${tag}`);\n      throw new Error(message);\n    }\n    return key;\n  };\n\n  public del: IKeyChain[\"del\"] = async (tag) => {\n    this.isInitialized();\n    this.keychain.delete(tag);\n    await this.persist();\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async setKeyChain(keychain: Map<string, string>) {\n    await this.core.storage.setItem<Record<string, string>>(this.storageKey, mapToObj(keychain));\n  }\n\n  private async getKeyChain() {\n    const keychain = await this.core.storage.getItem<Record<string, string>>(this.storageKey);\n    return typeof keychain !== \"undefined\" ? objToMap(keychain) : undefined;\n  }\n\n  private async persist() {\n    await this.setKeyChain(this.keychain);\n  }\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n}\n","import { generateChildLogger, getLoggerContext, Logger } from \"@walletconnect/logger\";\nimport { safeJsonParse, safeJsonStringify } from \"@walletconnect/safe-json\";\nimport { ICore, ICrypto, IKeyChain } from \"@walletconnect/types\";\nimport * as relayAuth from \"@walletconnect/relay-auth\";\nimport { fromString } from \"uint8arrays/from-string\";\nimport {\n  decrypt,\n  deriveSymKey,\n  encrypt,\n  generateKeyPair as generateKeyPairUtil,\n  hashKey,\n  getInternalError,\n  generateRandomBytes32,\n  validateEncoding,\n  validateDecoding,\n  isTypeOneEnvelope,\n  isTypeTwoEnvelope,\n  encodeTypeTwoEnvelope,\n  decodeTypeTwoEnvelope,\n  deserialize,\n  decodeTypeByte,\n  BASE16,\n  BASE64,\n} from \"@walletconnect/utils\";\nimport { toString } from \"uint8arrays\";\n\nimport { CRYPTO_CONTEXT, CRYPTO_CLIENT_SEED, CRYPTO_JWT_TTL } from \"../constants\";\nimport { KeyChain } from \"./keychain\";\n\nexport class Crypto implements ICrypto {\n  public name = CRYPTO_CONTEXT;\n  public keychain: ICrypto[\"keychain\"];\n  public readonly randomSessionIdentifier = generateRandomBytes32();\n\n  private initialized = false;\n\n  constructor(public core: ICore, public logger: Logger, keychain?: IKeyChain) {\n    this.core = core;\n    this.logger = generateChildLogger(logger, this.name);\n    this.keychain = keychain || new KeyChain(this.core, this.logger);\n  }\n\n  public init: ICrypto[\"init\"] = async () => {\n    if (!this.initialized) {\n      await this.keychain.init();\n      this.initialized = true;\n    }\n  };\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  public hasKeys: ICrypto[\"hasKeys\"] = (tag) => {\n    this.isInitialized();\n    return this.keychain.has(tag);\n  };\n\n  public getClientId: ICrypto[\"getClientId\"] = async () => {\n    this.isInitialized();\n    const seed = await this.getClientSeed();\n    const keyPair = relayAuth.generateKeyPair(seed);\n    const clientId = relayAuth.encodeIss(keyPair.publicKey);\n    return clientId;\n  };\n\n  public generateKeyPair: ICrypto[\"generateKeyPair\"] = () => {\n    this.isInitialized();\n    const keyPair = generateKeyPairUtil();\n    return this.setPrivateKey(keyPair.publicKey, keyPair.privateKey);\n  };\n\n  public signJWT: ICrypto[\"signJWT\"] = async (aud) => {\n    this.isInitialized();\n    const seed = await this.getClientSeed();\n    const keyPair = relayAuth.generateKeyPair(seed);\n    const sub = this.randomSessionIdentifier;\n    const ttl = CRYPTO_JWT_TTL;\n    const jwt = await relayAuth.signJWT(sub, aud, ttl, keyPair);\n    return jwt;\n  };\n\n  public generateSharedKey: ICrypto[\"generateSharedKey\"] = (\n    selfPublicKey,\n    peerPublicKey,\n    overrideTopic,\n  ) => {\n    this.isInitialized();\n    const selfPrivateKey = this.getPrivateKey(selfPublicKey);\n    const symKey = deriveSymKey(selfPrivateKey, peerPublicKey);\n    return this.setSymKey(symKey, overrideTopic);\n  };\n\n  public setSymKey: ICrypto[\"setSymKey\"] = async (symKey, overrideTopic) => {\n    this.isInitialized();\n    const topic = overrideTopic || hashKey(symKey);\n    await this.keychain.set(topic, symKey);\n    return topic;\n  };\n\n  public deleteKeyPair: ICrypto[\"deleteKeyPair\"] = async (publicKey: string) => {\n    this.isInitialized();\n    await this.keychain.del(publicKey);\n  };\n\n  public deleteSymKey: ICrypto[\"deleteSymKey\"] = async (topic: string) => {\n    this.isInitialized();\n    await this.keychain.del(topic);\n  };\n\n  public encode: ICrypto[\"encode\"] = async (topic, payload, opts) => {\n    this.isInitialized();\n    const params = validateEncoding(opts);\n    const message = safeJsonStringify(payload);\n\n    if (isTypeTwoEnvelope(params)) {\n      return encodeTypeTwoEnvelope(message, opts?.encoding);\n    }\n\n    if (isTypeOneEnvelope(params)) {\n      const selfPublicKey = params.senderPublicKey;\n      const peerPublicKey = params.receiverPublicKey;\n      topic = await this.generateSharedKey(selfPublicKey, peerPublicKey);\n    }\n    const symKey = this.getSymKey(topic);\n    const { type, senderPublicKey } = params;\n    const result = encrypt({ type, symKey, message, senderPublicKey, encoding: opts?.encoding });\n    return result;\n  };\n\n  public decode: ICrypto[\"decode\"] = async (topic, encoded, opts) => {\n    this.isInitialized();\n    const params = validateDecoding(encoded, opts);\n    if (isTypeTwoEnvelope(params)) {\n      const message = decodeTypeTwoEnvelope(encoded, opts?.encoding);\n      return safeJsonParse(message);\n    }\n    if (isTypeOneEnvelope(params)) {\n      const selfPublicKey = params.receiverPublicKey;\n      const peerPublicKey = params.senderPublicKey;\n      topic = await this.generateSharedKey(selfPublicKey, peerPublicKey);\n    }\n    try {\n      const symKey = this.getSymKey(topic);\n      const message = decrypt({ symKey, encoded, encoding: opts?.encoding });\n      const payload = safeJsonParse(message);\n      return payload;\n    } catch (error) {\n      this.logger.error(\n        `Failed to decode message from topic: '${topic}', clientId: '${await this.getClientId()}'`,\n      );\n      this.logger.error(error);\n    }\n  };\n\n  public getPayloadType: ICrypto[\"getPayloadType\"] = (encoded, encoding = BASE64) => {\n    const deserialized = deserialize({ encoded, encoding });\n    return decodeTypeByte(deserialized.type);\n  };\n\n  public getPayloadSenderPublicKey: ICrypto[\"getPayloadSenderPublicKey\"] = (\n    encoded,\n    encoding = BASE64,\n  ) => {\n    const deserialized = deserialize({ encoded, encoding });\n    return deserialized.senderPublicKey\n      ? toString(deserialized.senderPublicKey, BASE16)\n      : undefined;\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async setPrivateKey(publicKey: string, privateKey: string): Promise<string> {\n    await this.keychain.set(publicKey, privateKey);\n    return publicKey;\n  }\n\n  private getPrivateKey(publicKey: string) {\n    const privateKey = this.keychain.get(publicKey);\n    return privateKey;\n  }\n\n  private async getClientSeed(): Promise<Uint8Array> {\n    let seed = \"\";\n    try {\n      seed = this.keychain.get(CRYPTO_CLIENT_SEED);\n    } catch {\n      seed = generateRandomBytes32();\n      await this.keychain.set(CRYPTO_CLIENT_SEED, seed);\n    }\n    return fromString(seed, \"base16\");\n  }\n\n  private getSymKey(topic: string) {\n    const symKey = this.keychain.get(topic);\n    return symKey;\n  }\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n}\n","import { generateChildLogger, getLoggerContext, Logger } from \"@walletconnect/logger\";\nimport { ICore, IMessageTracker, MessageRecord } from \"@walletconnect/types\";\nimport { hashMessage, mapToObj, objToMap, getInternalError } from \"@walletconnect/utils\";\nimport { CORE_STORAGE_PREFIX, MESSAGES_CONTEXT, MESSAGES_STORAGE_VERSION } from \"../constants\";\n\nexport class MessageTracker extends IMessageTracker {\n  public messages = new Map<string, MessageRecord>();\n  public name = MESSAGES_CONTEXT;\n  public version = MESSAGES_STORAGE_VERSION;\n\n  private initialized = false;\n  private storagePrefix = CORE_STORAGE_PREFIX;\n\n  constructor(public logger: Logger, public core: ICore) {\n    super(logger, core);\n    this.logger = generateChildLogger(logger, this.name);\n    this.core = core;\n  }\n\n  public init: IMessageTracker[\"init\"] = async () => {\n    if (!this.initialized) {\n      this.logger.trace(`Initialized`);\n      try {\n        const messages = await this.getRelayerMessages();\n        if (typeof messages !== \"undefined\") {\n          this.messages = messages;\n        }\n\n        this.logger.debug(`Successfully Restored records for ${this.name}`);\n        this.logger.trace({ type: \"method\", method: \"restore\", size: this.messages.size });\n      } catch (e) {\n        this.logger.debug(`Failed to Restore records for ${this.name}`);\n        this.logger.error(e as any);\n      } finally {\n        this.initialized = true;\n      }\n    }\n  };\n\n  get context(): string {\n    return getLoggerContext(this.logger);\n  }\n\n  get storageKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + this.name;\n  }\n\n  public set: IMessageTracker[\"set\"] = async (topic, message) => {\n    this.isInitialized();\n    const hash = hashMessage(message);\n    let messages = this.messages.get(topic);\n    if (typeof messages === \"undefined\") {\n      messages = {};\n    }\n    if (typeof messages[hash] !== \"undefined\") {\n      return hash;\n    }\n    messages[hash] = message;\n    this.messages.set(topic, messages);\n    await this.persist();\n    return hash;\n  };\n\n  public get: IMessageTracker[\"get\"] = (topic) => {\n    this.isInitialized();\n    let messages = this.messages.get(topic);\n    if (typeof messages === \"undefined\") {\n      messages = {};\n    }\n    return messages;\n  };\n\n  public has: IMessageTracker[\"has\"] = (topic, message) => {\n    this.isInitialized();\n    const messages = this.get(topic);\n    const hash = hashMessage(message);\n    return typeof messages[hash] !== \"undefined\";\n  };\n\n  public del: IMessageTracker[\"del\"] = async (topic) => {\n    this.isInitialized();\n    this.messages.delete(topic);\n    await this.persist();\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async setRelayerMessages(messages: Map<string, MessageRecord>): Promise<void> {\n    await this.core.storage.setItem<Record<string, MessageRecord>>(\n      this.storageKey,\n      mapToObj(messages),\n    );\n  }\n\n  private async getRelayerMessages(): Promise<Map<string, MessageRecord> | undefined> {\n    const messages = await this.core.storage.getItem<Record<string, MessageRecord>>(\n      this.storageKey,\n    );\n    return typeof messages !== \"undefined\" ? objToMap(messages) : undefined;\n  }\n\n  private async persist() {\n    await this.setRelayerMessages(this.messages);\n  }\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n}\n","import { HEARTBEAT_EVENTS } from \"@walletconnect/heartbeat\";\nimport { JsonRpcPayload, RequestArguments } from \"@walletconnect/jsonrpc-types\";\nimport { generateChildLogger, getLoggerContext, Logger } from \"@walletconnect/logger\";\nimport { RelayJsonRpc } from \"@walletconnect/relay-api\";\nimport { IPublisher, IRelayer, PublisherTypes, RelayerTypes } from \"@walletconnect/types\";\nimport {\n  getRelayProtocolApi,\n  getRelayProtocolName,\n  isUndefined,\n  createExpiringPromise,\n} from \"@walletconnect/utils\";\nimport { EventEmitter } from \"events\";\n\nimport { PUBLISHER_CONTEXT, PUBLISHER_DEFAULT_TTL, RELAYER_EVENTS } from \"../constants\";\nimport { getBigIntRpcId } from \"@walletconnect/jsonrpc-utils\";\nimport { ONE_MINUTE, ONE_SECOND, toMiliseconds } from \"@walletconnect/time\";\n\ntype IPublishType = PublisherTypes.Params & {\n  attestation?: string;\n  attempt: number;\n};\nexport class Publisher extends IPublisher {\n  public events = new EventEmitter();\n  public name = PUBLISHER_CONTEXT;\n  public queue = new Map<string, IPublishType>();\n\n  private publishTimeout = toMiliseconds(ONE_MINUTE);\n  private initialPublishTimeout = toMiliseconds(ONE_SECOND * 15);\n  private needsTransportRestart = false;\n\n  constructor(public relayer: IRelayer, public logger: Logger) {\n    super(relayer, logger);\n    this.relayer = relayer;\n    this.logger = generateChildLogger(logger, this.name);\n    this.registerEventListeners();\n  }\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  public publish: IPublisher[\"publish\"] = async (topic, message, opts) => {\n    this.logger.debug(`Publishing Payload`);\n    this.logger.trace({ type: \"method\", method: \"publish\", params: { topic, message, opts } });\n\n    const ttl = opts?.ttl || PUBLISHER_DEFAULT_TTL;\n    const relay = getRelayProtocolName(opts);\n    const prompt = opts?.prompt || false;\n    const tag = opts?.tag || 0;\n    const id = opts?.id || (getBigIntRpcId().toString() as any);\n    const params = {\n      topic,\n      message,\n      opts: {\n        ttl,\n        relay,\n        prompt,\n        tag,\n        id,\n        attestation: opts?.attestation,\n        tvf: opts?.tvf,\n      },\n    };\n    const failedPublishMessage = `Failed to publish payload, please try again. id:${id} tag:${tag}`;\n\n    try {\n      /**\n       * attempt to publish the payload for <initialPublishTimeout> seconds,\n       * if the publish fails, add the payload to the queue and it will be retried on every pulse\n       * until it is successfully published or <publishTimeout> seconds have passed\n       */\n      const publishPromise = new Promise(async (resolve) => {\n        const onPublish = ({ id }: { id: string }) => {\n          if (params.opts.id === id) {\n            this.removeRequestFromQueue(id);\n            this.relayer.events.removeListener(RELAYER_EVENTS.publish, onPublish);\n            resolve(params);\n          }\n        };\n        this.relayer.events.on(RELAYER_EVENTS.publish, onPublish);\n        const initialPublish = createExpiringPromise(\n          new Promise((resolve, reject) => {\n            this.rpcPublish({\n              topic,\n              message,\n              ttl,\n              prompt,\n              tag,\n              id,\n              attestation: opts?.attestation,\n              tvf: opts?.tvf,\n            })\n              .then(resolve)\n              .catch((e) => {\n                this.logger.warn(e, e?.message);\n                reject(e);\n              });\n          }),\n          this.initialPublishTimeout,\n          `Failed initial publish, retrying.... id:${id} tag:${tag}`,\n        );\n        try {\n          await initialPublish;\n          this.events.removeListener(RELAYER_EVENTS.publish, onPublish);\n        } catch (e) {\n          this.queue.set(id, { ...params, attempt: 1 });\n          this.logger.warn(e, (e as Error)?.message);\n        }\n      });\n      this.logger.trace({\n        type: \"method\",\n        method: \"publish\",\n        params: { id, topic, message, opts },\n      });\n\n      await createExpiringPromise(publishPromise, this.publishTimeout, failedPublishMessage);\n    } catch (e) {\n      this.logger.debug(`Failed to Publish Payload`);\n      this.logger.error(e as any);\n      if (opts?.internal?.throwOnFailedPublish) {\n        throw e;\n      }\n    } finally {\n      this.queue.delete(id);\n    }\n  };\n\n  public on: IPublisher[\"on\"] = (event, listener) => {\n    this.events.on(event, listener);\n  };\n\n  public once: IPublisher[\"once\"] = (event, listener) => {\n    this.events.once(event, listener);\n  };\n\n  public off: IPublisher[\"off\"] = (event, listener) => {\n    this.events.off(event, listener);\n  };\n\n  public removeListener: IPublisher[\"removeListener\"] = (event, listener) => {\n    this.events.removeListener(event, listener);\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async rpcPublish(params: {\n    topic: string;\n    message: string;\n    ttl?: number;\n    prompt?: boolean;\n    tag?: number;\n    id?: number;\n    attestation?: string;\n    tvf?: RelayerTypes.ITVF;\n  }) {\n    const {\n      topic,\n      message,\n      ttl = PUBLISHER_DEFAULT_TTL,\n      prompt,\n      tag,\n      id,\n      attestation,\n      tvf,\n    } = params;\n    const api = getRelayProtocolApi(getRelayProtocolName().protocol);\n    const request: RequestArguments<RelayJsonRpc.PublishParams> = {\n      method: api.publish,\n      params: {\n        topic,\n        message,\n        ttl,\n        prompt,\n        tag,\n        attestation,\n        ...tvf,\n      },\n      id,\n    };\n    if (isUndefined(request.params?.prompt)) delete request.params?.prompt;\n    if (isUndefined(request.params?.tag)) delete request.params?.tag;\n    this.logger.debug(`Outgoing Relay Payload`);\n    this.logger.trace({ type: \"message\", direction: \"outgoing\", request });\n    const result = await this.relayer.request(request);\n    this.relayer.events.emit(RELAYER_EVENTS.publish, params);\n    this.logger.debug(`Successfully Published Payload`);\n    return result;\n  }\n\n  private removeRequestFromQueue(id: string) {\n    this.queue.delete(id);\n  }\n\n  private checkQueue() {\n    this.queue.forEach(async (params, id) => {\n      const attempt = params.attempt + 1;\n      this.queue.set(id, { ...params, attempt });\n      const { topic, message, opts, attestation } = params;\n      this.logger.warn(\n        {},\n        `Publisher: queue->publishing: ${params.opts.id}, tag: ${params.opts.tag}, attempt: ${attempt}`,\n      );\n      await this.rpcPublish({\n        ...params,\n        topic,\n        message,\n        ttl: opts.ttl,\n        prompt: opts.prompt,\n        tag: opts.tag,\n        id: opts.id,\n        attestation,\n        tvf: opts.tvf,\n      });\n      this.logger.warn({}, `Publisher: queue->published: ${params.opts.id}`);\n    });\n  }\n\n  private registerEventListeners() {\n    this.relayer.core.heartbeat.on(HEARTBEAT_EVENTS.pulse, () => {\n      // restart the transport if needed\n      // queue will be processed on the next pulse\n      if (this.needsTransportRestart) {\n        this.needsTransportRestart = false;\n        this.relayer.events.emit(RELAYER_EVENTS.connection_stalled);\n        return;\n      }\n      this.checkQueue();\n    });\n    this.relayer.on(RELAYER_EVENTS.message_ack, (event: JsonRpcPayload) => {\n      this.removeRequestFromQueue(event.id.toString());\n    });\n  }\n}\n","import { ISubscriberTopicMap } from \"@walletconnect/types\";\n\nexport class SubscriberTopicMap implements ISubscriberTopicMap {\n  public map = new Map<string, string[]>();\n\n  get topics(): string[] {\n    return Array.from(this.map.keys());\n  }\n\n  public set: ISubscriberTopicMap[\"set\"] = (topic, id) => {\n    const ids = this.get(topic);\n    if (this.exists(topic, id)) return;\n    this.map.set(topic, [...ids, id]);\n  };\n\n  public get: ISubscriberTopicMap[\"get\"] = (topic) => {\n    const ids = this.map.get(topic);\n    return ids || [];\n  };\n\n  public exists: ISubscriberTopicMap[\"exists\"] = (topic, id) => {\n    const ids = this.get(topic);\n    return ids.includes(id);\n  };\n\n  public delete: ISubscriberTopicMap[\"delete\"] = (topic, id) => {\n    if (typeof id === \"undefined\") {\n      this.map.delete(topic);\n      return;\n    }\n    if (!this.map.has(topic)) return;\n    const ids = this.get(topic);\n    if (!this.exists(topic, id)) return;\n    const remaining = ids.filter((x) => x !== id);\n    if (!remaining.length) {\n      this.map.delete(topic);\n      return;\n    }\n    this.map.set(topic, remaining);\n  };\n\n  public clear: ISubscriberTopicMap[\"clear\"] = () => {\n    this.map.clear();\n  };\n}\n","import { EventEmitter } from \"events\";\nimport { HEARTBEAT_EVENTS } from \"@walletconnect/heartbeat\";\nimport { ErrorResponse, RequestArguments } from \"@walletconnect/jsonrpc-types\";\nimport { generateChildLogger, getLoggerContext, Logger } from \"@walletconnect/logger\";\nimport { RelayJsonRpc } from \"@walletconnect/relay-api\";\nimport { ONE_SECOND, ONE_MINUTE, Watch, toMiliseconds } from \"@walletconnect/time\";\nimport {\n  IRelayer,\n  ISubscriber,\n  RelayerTypes,\n  SubscriberEvents,\n  SubscriberTypes,\n} from \"@walletconnect/types\";\nimport {\n  getSdkError,\n  getInternalError,\n  getRelayProtocolApi,\n  getRelayProtocolName,\n  createExpiringPromise,\n  hashMessage,\n  sleep,\n} from \"@walletconnect/utils\";\nimport {\n  CORE_STORAGE_PREFIX,\n  SUBSCRIBER_CONTEXT,\n  SUBSCRIBER_EVENTS,\n  SUBSCRIBER_STORAGE_VERSION,\n  PENDING_SUB_RESOLUTION_TIMEOUT,\n  RELAYER_EVENTS,\n  TRANSPORT_TYPES,\n} from \"../constants\";\nimport { SubscriberTopicMap } from \"./topicmap\";\n\nexport class Subscriber extends ISubscriber {\n  public subscriptions = new Map<string, SubscriberTypes.Active>();\n  public topicMap = new SubscriberTopicMap();\n  public events = new EventEmitter();\n  public name = SUBSCRIBER_CONTEXT;\n  public version = SUBSCRIBER_STORAGE_VERSION;\n  public pending = new Map<string, SubscriberTypes.Params>();\n\n  private cached: SubscriberTypes.Active[] = [];\n  private initialized = false;\n  private pendingSubscriptionWatchLabel = \"pending_sub_watch_label\";\n  private pollingInterval = 20;\n  private storagePrefix = CORE_STORAGE_PREFIX;\n  private subscribeTimeout = toMiliseconds(ONE_MINUTE);\n  private initialSubscribeTimeout = toMiliseconds(ONE_SECOND * 15);\n  private clientId: string;\n  private batchSubscribeTopicsLimit = 500;\n\n  constructor(public relayer: IRelayer, public logger: Logger) {\n    super(relayer, logger);\n    this.relayer = relayer;\n    this.logger = generateChildLogger(logger, this.name);\n    this.clientId = \"\"; // assigned when calling this.getClientId()\n  }\n\n  public init: ISubscriber[\"init\"] = async () => {\n    if (!this.initialized) {\n      this.logger.trace(`Initialized`);\n      this.registerEventListeners();\n      await this.restore();\n    }\n    this.initialized = true;\n  };\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  get storageKey() {\n    return (\n      this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + \"//\" + this.name\n    );\n  }\n\n  get length() {\n    return this.subscriptions.size;\n  }\n\n  get ids() {\n    return Array.from(this.subscriptions.keys());\n  }\n\n  get values() {\n    return Array.from(this.subscriptions.values());\n  }\n\n  get topics() {\n    return this.topicMap.topics;\n  }\n\n  get hasAnyTopics() {\n    return (\n      this.topicMap.topics.length > 0 ||\n      this.pending.size > 0 ||\n      this.cached.length > 0 ||\n      this.subscriptions.size > 0\n    );\n  }\n\n  public subscribe: ISubscriber[\"subscribe\"] = async (topic, opts) => {\n    this.isInitialized();\n    this.logger.debug(`Subscribing Topic`);\n    this.logger.trace({ type: \"method\", method: \"subscribe\", params: { topic, opts } });\n    try {\n      const relay = getRelayProtocolName(opts);\n      const params = { topic, relay, transportType: opts?.transportType };\n      this.pending.set(topic, params);\n      const id = await this.rpcSubscribe(topic, relay, opts);\n      if (typeof id === \"string\") {\n        this.onSubscribe(id, params);\n        this.logger.debug(`Successfully Subscribed Topic`);\n        this.logger.trace({ type: \"method\", method: \"subscribe\", params: { topic, opts } });\n      }\n      return id;\n    } catch (e) {\n      this.logger.debug(`Failed to Subscribe Topic`);\n      this.logger.error(e as any);\n      throw e;\n    }\n  };\n\n  public unsubscribe: ISubscriber[\"unsubscribe\"] = async (topic, opts) => {\n    this.isInitialized();\n    if (typeof opts?.id !== \"undefined\") {\n      await this.unsubscribeById(topic, opts.id, opts);\n    } else {\n      await this.unsubscribeByTopic(topic, opts);\n    }\n  };\n\n  public isSubscribed: ISubscriber[\"isSubscribed\"] = async (topic: string) => {\n    // topic subscription is already resolved\n    if (this.topics.includes(topic)) return true;\n    const label = `${this.pendingSubscriptionWatchLabel}_${topic}`;\n    // wait for the subscription to resolve\n    const exists = await new Promise<boolean>((resolve, reject) => {\n      const watch = new Watch();\n      watch.start(label);\n      const interval = setInterval(() => {\n        if (\n          (!this.pending.has(topic) && this.topics.includes(topic)) ||\n          this.cached.some((s) => s.topic === topic)\n        ) {\n          clearInterval(interval);\n          watch.stop(label);\n          resolve(true);\n        }\n        if (watch.elapsed(label) >= PENDING_SUB_RESOLUTION_TIMEOUT) {\n          clearInterval(interval);\n          watch.stop(label);\n          reject(new Error(\"Subscription resolution timeout\"));\n        }\n      }, this.pollingInterval);\n    }).catch(() => false);\n    return exists;\n  };\n\n  public on: ISubscriber[\"on\"] = (event, listener) => {\n    this.events.on(event, listener);\n  };\n\n  public once: ISubscriber[\"once\"] = (event, listener) => {\n    this.events.once(event, listener);\n  };\n\n  public off: ISubscriber[\"off\"] = (event, listener) => {\n    this.events.off(event, listener);\n  };\n\n  public removeListener: ISubscriber[\"removeListener\"] = (event, listener) => {\n    this.events.removeListener(event, listener);\n  };\n\n  public start: ISubscriber[\"start\"] = async () => {\n    await this.onConnect();\n  };\n\n  public stop: ISubscriber[\"stop\"] = async () => {\n    await this.onDisconnect();\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private hasSubscription(id: string, topic: string) {\n    let result = false;\n    try {\n      const subscription = this.getSubscription(id);\n      result = subscription.topic === topic;\n    } catch (e) {\n      // ignore error\n    }\n    return result;\n  }\n\n  private reset() {\n    this.cached = [];\n    this.initialized = true;\n  }\n\n  private onDisable() {\n    this.cached = this.values;\n    this.subscriptions.clear();\n    this.topicMap.clear();\n  }\n\n  private async unsubscribeByTopic(topic: string, opts?: RelayerTypes.UnsubscribeOptions) {\n    const ids = this.topicMap.get(topic);\n    await Promise.all(ids.map(async (id) => await this.unsubscribeById(topic, id, opts)));\n  }\n\n  private async unsubscribeById(topic: string, id: string, opts?: RelayerTypes.UnsubscribeOptions) {\n    this.logger.debug(`Unsubscribing Topic`);\n    this.logger.trace({ type: \"method\", method: \"unsubscribe\", params: { topic, id, opts } });\n\n    try {\n      const relay = getRelayProtocolName(opts);\n      await this.restartToComplete({ topic, id, relay });\n      await this.rpcUnsubscribe(topic, id, relay);\n      const reason = getSdkError(\"USER_DISCONNECTED\", `${this.name}, ${topic}`);\n      await this.onUnsubscribe(topic, id, reason);\n      this.logger.debug(`Successfully Unsubscribed Topic`);\n      this.logger.trace({ type: \"method\", method: \"unsubscribe\", params: { topic, id, opts } });\n    } catch (e) {\n      this.logger.debug(`Failed to Unsubscribe Topic`);\n      this.logger.error(e as any);\n      throw e;\n    }\n  }\n\n  private async rpcSubscribe(\n    topic: string,\n    relay: RelayerTypes.ProtocolOptions,\n    opts?: RelayerTypes.SubscribeOptions,\n  ) {\n    if (!opts || opts?.transportType === TRANSPORT_TYPES.relay) {\n      await this.restartToComplete({ topic, id: topic, relay });\n    }\n    const api = getRelayProtocolApi(relay.protocol);\n    const request: RequestArguments<RelayJsonRpc.SubscribeParams> = {\n      method: api.subscribe,\n      params: {\n        topic,\n      },\n    };\n    this.logger.debug(`Outgoing Relay Payload`);\n    this.logger.trace({ type: \"payload\", direction: \"outgoing\", request });\n    const shouldThrow = opts?.internal?.throwOnFailedPublish;\n    try {\n      const subId = await this.getSubscriptionId(topic);\n      // in link mode, allow the app to update its network state (i.e. active airplane mode) with small delay before attempting to subscribe\n      if (opts?.transportType === TRANSPORT_TYPES.link_mode) {\n        setTimeout(() => {\n          if (this.relayer.connected || this.relayer.connecting) {\n            this.relayer.request(request).catch((e) => this.logger.warn(e));\n          }\n        }, toMiliseconds(ONE_SECOND));\n        return subId;\n      }\n      const subscribePromise = new Promise(async (resolve) => {\n        const onSubscribe = (subscription: SubscriberEvents.Created) => {\n          if (subscription.topic === topic) {\n            this.events.removeListener(SUBSCRIBER_EVENTS.created, onSubscribe);\n            resolve(subscription.id);\n          }\n        };\n        this.events.on(SUBSCRIBER_EVENTS.created, onSubscribe);\n        try {\n          const result = await createExpiringPromise(\n            new Promise((resolve, reject) => {\n              this.relayer\n                .request(request)\n                .catch((e) => {\n                  this.logger.warn(e, e?.message);\n                  reject(e);\n                })\n                .then(resolve);\n            }),\n            this.initialSubscribeTimeout,\n            `Subscribing to ${topic} failed, please try again`,\n          );\n          this.events.removeListener(SUBSCRIBER_EVENTS.created, onSubscribe);\n          resolve(result);\n        } catch (err) {}\n      });\n\n      const subscribe = createExpiringPromise(\n        subscribePromise,\n        this.subscribeTimeout,\n        `Subscribing to ${topic} failed, please try again`,\n      );\n\n      const result = await subscribe;\n      if (!result && shouldThrow) {\n        throw new Error(`Subscribing to ${topic} failed, please try again`);\n      }\n      // return null to indicate that the subscription failed\n      return result ? subId : null;\n    } catch (err) {\n      this.logger.debug(`Outgoing Relay Subscribe Payload stalled`);\n      this.relayer.events.emit(RELAYER_EVENTS.connection_stalled);\n      if (shouldThrow) {\n        throw err;\n      }\n    }\n    return null;\n  }\n\n  private async rpcBatchSubscribe(subscriptions: SubscriberTypes.Params[]) {\n    if (!subscriptions.length) return;\n    const relay = subscriptions[0].relay;\n    const api = getRelayProtocolApi(relay!.protocol);\n    const request: RequestArguments<RelayJsonRpc.BatchSubscribeParams> = {\n      method: api.batchSubscribe,\n      params: {\n        topics: subscriptions.map((s) => s.topic),\n      },\n    };\n    this.logger.debug(`Outgoing Relay Payload`);\n    this.logger.trace({ type: \"payload\", direction: \"outgoing\", request });\n    try {\n      const subscribe = await createExpiringPromise(\n        new Promise((resolve) => {\n          this.relayer\n            .request(request)\n            .catch((e) => this.logger.warn(e))\n            .then(resolve);\n        }),\n        this.subscribeTimeout,\n        \"rpcBatchSubscribe failed, please try again\",\n      );\n      await subscribe;\n    } catch (err) {\n      this.relayer.events.emit(RELAYER_EVENTS.connection_stalled);\n    }\n  }\n\n  private async rpcBatchFetchMessages(subscriptions: SubscriberTypes.Params[]) {\n    if (!subscriptions.length) return;\n    const relay = subscriptions[0].relay;\n    const api = getRelayProtocolApi(relay!.protocol);\n    const request: RequestArguments<RelayJsonRpc.BatchFetchMessagesParams> = {\n      method: api.batchFetchMessages,\n      params: {\n        topics: subscriptions.map((s) => s.topic),\n      },\n    };\n    this.logger.debug(`Outgoing Relay Payload`);\n    this.logger.trace({ type: \"payload\", direction: \"outgoing\", request });\n    let result;\n    try {\n      const fetchMessagesPromise = await createExpiringPromise(\n        new Promise((resolve, reject) => {\n          this.relayer\n            .request(request)\n            .catch((e) => {\n              this.logger.warn(e);\n              reject(e);\n            })\n            .then(resolve);\n        }),\n        this.subscribeTimeout,\n        \"rpcBatchFetchMessages failed, please try again\",\n      );\n      result = (await fetchMessagesPromise) as {\n        messages: RelayerTypes.MessageEvent[];\n      };\n    } catch (err) {\n      this.relayer.events.emit(RELAYER_EVENTS.connection_stalled);\n    }\n    return result;\n  }\n\n  private rpcUnsubscribe(topic: string, id: string, relay: RelayerTypes.ProtocolOptions) {\n    const api = getRelayProtocolApi(relay.protocol);\n    const request: RequestArguments<RelayJsonRpc.UnsubscribeParams> = {\n      method: api.unsubscribe,\n      params: {\n        topic,\n        id,\n      },\n    };\n    this.logger.debug(`Outgoing Relay Payload`);\n    this.logger.trace({ type: \"payload\", direction: \"outgoing\", request });\n    return this.relayer.request(request);\n  }\n\n  private onSubscribe(id: string, params: SubscriberTypes.Params) {\n    this.setSubscription(id, { ...params, id });\n    this.pending.delete(params.topic);\n  }\n\n  private onBatchSubscribe(subscriptions: SubscriberTypes.Active[]) {\n    if (!subscriptions.length) return;\n    subscriptions.forEach((subscription) => {\n      this.setSubscription(subscription.id, { ...subscription });\n      this.pending.delete(subscription.topic);\n    });\n  }\n\n  private async onUnsubscribe(topic: string, id: string, reason: ErrorResponse) {\n    this.events.removeAllListeners(id);\n    if (this.hasSubscription(id, topic)) {\n      this.deleteSubscription(id, reason);\n    }\n    await this.relayer.messages.del(topic);\n  }\n\n  private async setRelayerSubscriptions(subscriptions: SubscriberTypes.Active[]) {\n    await this.relayer.core.storage.setItem<SubscriberTypes.Active[]>(\n      this.storageKey,\n      subscriptions,\n    );\n  }\n\n  private async getRelayerSubscriptions() {\n    const subscriptions = await this.relayer.core.storage.getItem<SubscriberTypes.Active[]>(\n      this.storageKey,\n    );\n    return subscriptions;\n  }\n\n  private setSubscription(id: string, subscription: SubscriberTypes.Active) {\n    this.logger.debug(`Setting subscription`);\n    this.logger.trace({ type: \"method\", method: \"setSubscription\", id, subscription });\n    this.addSubscription(id, subscription);\n  }\n\n  private addSubscription(id: string, subscription: SubscriberTypes.Active) {\n    this.subscriptions.set(id, { ...subscription });\n    this.topicMap.set(subscription.topic, id);\n    this.events.emit(SUBSCRIBER_EVENTS.created, subscription);\n  }\n\n  private getSubscription(id: string) {\n    this.logger.debug(`Getting subscription`);\n    this.logger.trace({ type: \"method\", method: \"getSubscription\", id });\n    const subscription = this.subscriptions.get(id);\n    if (!subscription) {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `${this.name}: ${id}`);\n      throw new Error(message);\n    }\n    return subscription;\n  }\n\n  private deleteSubscription(id: string, reason: ErrorResponse) {\n    this.logger.debug(`Deleting subscription`);\n    this.logger.trace({ type: \"method\", method: \"deleteSubscription\", id, reason });\n    const subscription = this.getSubscription(id);\n    this.subscriptions.delete(id);\n    this.topicMap.delete(subscription.topic, id);\n    this.events.emit(SUBSCRIBER_EVENTS.deleted, {\n      ...subscription,\n      reason,\n    } as SubscriberEvents.Deleted);\n  }\n\n  private restart = async () => {\n    await this.restore();\n    await this.onRestart();\n  };\n\n  private async persist() {\n    await this.setRelayerSubscriptions(this.values);\n    this.events.emit(SUBSCRIBER_EVENTS.sync);\n  }\n\n  private async onRestart() {\n    if (this.cached.length) {\n      const subs = [...this.cached];\n      const numOfBatches = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);\n      for (let i = 0; i < numOfBatches; i++) {\n        const batch = subs.splice(0, this.batchSubscribeTopicsLimit);\n        await this.batchSubscribe(batch);\n      }\n    }\n    this.events.emit(SUBSCRIBER_EVENTS.resubscribed);\n  }\n\n  private async restore() {\n    try {\n      const persisted = await this.getRelayerSubscriptions();\n      if (typeof persisted === \"undefined\") return;\n      if (!persisted.length) return;\n      if (this.subscriptions.size) {\n        const { message } = getInternalError(\"RESTORE_WILL_OVERRIDE\", this.name);\n        this.logger.error(message);\n        this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`);\n        throw new Error(message);\n      }\n      this.cached = persisted;\n      this.logger.debug(`Successfully Restored subscriptions for ${this.name}`);\n      this.logger.trace({ type: \"method\", method: \"restore\", subscriptions: this.values });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`);\n      this.logger.error(e as any);\n    }\n  }\n\n  private async batchSubscribe(subscriptions: SubscriberTypes.Params[]) {\n    if (!subscriptions.length) return;\n\n    await this.rpcBatchSubscribe(subscriptions);\n    this.onBatchSubscribe(\n      await Promise.all(\n        subscriptions.map(async (s) => {\n          return { ...s, id: await this.getSubscriptionId(s.topic) };\n        }),\n      ),\n    );\n  }\n\n  // @ts-ignore\n  private async batchFetchMessages(subscriptions: SubscriberTypes.Params[]) {\n    if (!subscriptions.length) return;\n    this.logger.trace(`Fetching batch messages for ${subscriptions.length} subscriptions`);\n    const response = await this.rpcBatchFetchMessages(subscriptions);\n    if (response && response.messages) {\n      await sleep(toMiliseconds(ONE_SECOND));\n      await this.relayer.handleBatchMessageEvents(response.messages);\n    }\n  }\n\n  private async onConnect() {\n    await this.restart();\n    this.reset();\n  }\n\n  private onDisconnect() {\n    this.onDisable();\n  }\n\n  private checkPending = async () => {\n    if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected)) {\n      return;\n    }\n    const pendingSubscriptions: SubscriberTypes.Params[] = [];\n    this.pending.forEach((params) => {\n      pendingSubscriptions.push(params);\n    });\n\n    await this.batchSubscribe(pendingSubscriptions);\n  };\n\n  private registerEventListeners = () => {\n    this.relayer.core.heartbeat.on(HEARTBEAT_EVENTS.pulse, async () => {\n      await this.checkPending();\n    });\n    this.events.on(SUBSCRIBER_EVENTS.created, async (createdEvent: SubscriberEvents.Created) => {\n      const eventName = SUBSCRIBER_EVENTS.created;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({ type: \"event\", event: eventName, data: createdEvent });\n      await this.persist();\n    });\n    this.events.on(SUBSCRIBER_EVENTS.deleted, async (deletedEvent: SubscriberEvents.Deleted) => {\n      const eventName = SUBSCRIBER_EVENTS.deleted;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({ type: \"event\", event: eventName, data: deletedEvent });\n      await this.persist();\n    });\n  };\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n\n  private async restartToComplete(subscription: SubscriberTypes.Active) {\n    if (!this.relayer.connected && !this.relayer.connecting) {\n      this.cached.push(subscription);\n      await this.relayer.transportOpen();\n    }\n  }\n\n  private async getClientId() {\n    if (!this.clientId) {\n      this.clientId = await this.relayer.core.crypto.getClientId();\n    }\n    return this.clientId;\n  }\n\n  private async getSubscriptionId(topic: string) {\n    return hashMessage(topic + (await this.getClientId()));\n  }\n}\n","import { EventEmitter } from \"events\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport {\n  formatJsonRpcResult,\n  getBigIntRpcId,\n  IJsonRpcProvider,\n  isJsonRpcRequest,\n  isJsonRpcResponse,\n  JsonRpcPayload,\n  JsonRpcRequest,\n  RequestArguments,\n} from \"@walletconnect/jsonrpc-utils\";\nimport WsConnection from \"@walletconnect/jsonrpc-ws-connection\";\nimport {\n  generateChildLogger,\n  getDefaultLoggerOptions,\n  getLoggerContext,\n  pino,\n  Logger,\n} from \"@walletconnect/logger\";\nimport { RelayJsonRpc } from \"@walletconnect/relay-api\";\nimport {\n  FIVE_MINUTES,\n  ONE_SECOND,\n  FIVE_SECONDS,\n  THIRTY_SECONDS,\n  toMiliseconds,\n} from \"@walletconnect/time\";\nimport {\n  ICore,\n  IMessageTracker,\n  IPublisher,\n  IRelayer,\n  ISubscriber,\n  RelayerOptions,\n  RelayerTypes,\n  SubscriberTypes,\n} from \"@walletconnect/types\";\nimport {\n  createExpiringPromise,\n  formatRelayRpcUrl,\n  isOnline,\n  subscribeToNetworkChange,\n  getAppId,\n  isAndroid,\n  isIos,\n  getInternalError,\n  isNode,\n  calcExpiry,\n} from \"@walletconnect/utils\";\n\nimport {\n  RELAYER_SDK_VERSION,\n  RELAYER_CONTEXT,\n  RELAYER_DEFAULT_LOGGER,\n  RELAYER_EVENTS,\n  RELAYER_PROVIDER_EVENTS,\n  RELAYER_SUBSCRIBER_SUFFIX,\n  RELAYER_DEFAULT_RELAY_URL,\n  SUBSCRIBER_EVENTS,\n  RELAYER_RECONNECT_TIMEOUT,\n  TRANSPORT_TYPES,\n} from \"../constants\";\nimport { MessageTracker } from \"./messages\";\nimport { Publisher } from \"./publisher\";\nimport { Subscriber } from \"./subscriber\";\n\nexport class Relayer extends IRelayer {\n  public protocol = \"wc\";\n  public version = 2;\n\n  public core: ICore;\n  public logger: Logger;\n  public events = new EventEmitter();\n  public provider: IJsonRpcProvider;\n  public messages: IMessageTracker;\n  public subscriber: ISubscriber;\n  public publisher: IPublisher;\n  public name = RELAYER_CONTEXT;\n  public transportExplicitlyClosed = false;\n\n  private initialized = false;\n  private connectionAttemptInProgress = false;\n\n  private relayUrl: string;\n  private projectId: string | undefined;\n  private packageName: string | undefined;\n  private bundleId: string | undefined;\n  private hasExperiencedNetworkDisruption = false;\n  private pingTimeout: NodeJS.Timeout | undefined;\n  /**\n   * the relay pings the client 30 seconds after the last message was received\n   * meaning if we don't receive a message in 30 seconds, the connection can be considered dead\n   */\n  private heartBeatTimeout = toMiliseconds(THIRTY_SECONDS + FIVE_SECONDS);\n  private reconnectTimeout: NodeJS.Timeout | undefined;\n  private connectPromise: Promise<void> | undefined;\n  private reconnectInProgress = false;\n  private requestsInFlight: string[] = [];\n  private connectTimeout = toMiliseconds(ONE_SECOND * 15);\n  constructor(opts: RelayerOptions) {\n    super(opts);\n    this.core = opts.core;\n    this.logger =\n      typeof opts.logger !== \"undefined\" && typeof opts.logger !== \"string\"\n        ? generateChildLogger(opts.logger, this.name)\n        : pino(getDefaultLoggerOptions({ level: opts.logger || RELAYER_DEFAULT_LOGGER }));\n    this.messages = new MessageTracker(this.logger, opts.core);\n    this.subscriber = new Subscriber(this, this.logger);\n    this.publisher = new Publisher(this, this.logger);\n\n    this.relayUrl = opts?.relayUrl || RELAYER_DEFAULT_RELAY_URL;\n    this.projectId = opts.projectId;\n\n    if (isAndroid()) {\n      this.packageName = getAppId();\n    } else if (isIos()) {\n      this.bundleId = getAppId();\n    }\n\n    // re-assigned during init()\n    this.provider = {} as IJsonRpcProvider;\n  }\n\n  public async init() {\n    this.logger.trace(`Initialized`);\n    this.registerEventListeners();\n    await Promise.all([this.messages.init(), this.subscriber.init()]);\n    this.initialized = true;\n    if (this.subscriber.hasAnyTopics) {\n      try {\n        await this.transportOpen();\n      } catch (e) {\n        this.logger.warn(e, (e as Error)?.message);\n      }\n    }\n  }\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  get connected() {\n    // @ts-expect-error\n    return this.provider?.connection?.socket?.readyState === 1 || false;\n  }\n\n  get connecting() {\n    return (\n      // @ts-expect-error\n      this.provider?.connection?.socket?.readyState === 0 ||\n      this.connectPromise !== undefined ||\n      false\n    );\n  }\n\n  public async publish(topic: string, message: string, opts?: RelayerTypes.PublishOptions) {\n    this.isInitialized();\n    await this.publisher.publish(topic, message, opts);\n    await this.recordMessageEvent({\n      topic,\n      message,\n      // We don't have `publishedAt` from the relay server on outgoing, so use current time to satisfy type.\n      publishedAt: Date.now(),\n      transportType: TRANSPORT_TYPES.relay,\n    });\n  }\n\n  public async subscribe(topic: string, opts?: RelayerTypes.SubscribeOptions) {\n    this.isInitialized();\n    if (!opts?.transportType || opts?.transportType === \"relay\") {\n      await this.toEstablishConnection();\n    }\n    // throw unless explicitly set to false\n    const shouldThrowOnFailure =\n      typeof opts?.internal?.throwOnFailedPublish === \"undefined\"\n        ? true\n        : opts?.internal?.throwOnFailedPublish;\n\n    let id = this.subscriber.topicMap.get(topic)?.[0] || \"\";\n    let resolvePromise: () => void;\n    const onSubCreated = (subscription: SubscriberTypes.Active) => {\n      if (subscription.topic === topic) {\n        this.subscriber.off(SUBSCRIBER_EVENTS.created, onSubCreated);\n        resolvePromise();\n      }\n    };\n\n    await Promise.all([\n      new Promise<void>((resolve) => {\n        resolvePromise = resolve;\n        this.subscriber.on(SUBSCRIBER_EVENTS.created, onSubCreated);\n      }),\n      new Promise<void>(async (resolve, reject) => {\n        const result = await this.subscriber\n          .subscribe(topic, {\n            internal: {\n              throwOnFailedPublish: shouldThrowOnFailure,\n            },\n            ...opts,\n          })\n          .catch((error) => {\n            if (shouldThrowOnFailure) {\n              reject(error);\n            }\n          });\n        id = result || id;\n        resolve();\n      }),\n    ]);\n    return id;\n  }\n\n  public request = async (request: RequestArguments<RelayJsonRpc.SubscribeParams>) => {\n    this.logger.debug(`Publishing Request Payload`);\n    const id = request.id || (getBigIntRpcId().toString() as any);\n    await this.toEstablishConnection();\n    try {\n      this.logger.trace(\n        {\n          id,\n          method: request.method,\n          topic: request.params?.topic,\n        },\n        \"relayer.request - publishing...\",\n      );\n      const tag = `${id}:${(request.params as any)?.tag || \"\"}`;\n      this.requestsInFlight.push(tag);\n      const result = await this.provider.request(request);\n      this.requestsInFlight = this.requestsInFlight.filter((i) => i !== tag);\n      return result;\n    } catch (e) {\n      this.logger.debug(`Failed to Publish Request: ${id}`);\n      throw e;\n    }\n  };\n\n  public async unsubscribe(topic: string, opts?: RelayerTypes.UnsubscribeOptions) {\n    this.isInitialized();\n    await this.subscriber.unsubscribe(topic, opts);\n  }\n\n  public on(event: string, listener: any) {\n    this.events.on(event, listener);\n  }\n\n  public once(event: string, listener: any) {\n    this.events.once(event, listener);\n  }\n\n  public off(event: string, listener: any) {\n    this.events.off(event, listener);\n  }\n\n  public removeListener(event: string, listener: any) {\n    this.events.removeListener(event, listener);\n  }\n\n  public async transportDisconnect() {\n    if (this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected)) {\n      await createExpiringPromise(this.provider.disconnect(), 2000, \"provider.disconnect()\").catch(\n        () => this.onProviderDisconnect(),\n      );\n    } else {\n      this.onProviderDisconnect();\n    }\n  }\n\n  public async transportClose() {\n    this.transportExplicitlyClosed = true;\n    await this.transportDisconnect();\n  }\n\n  async transportOpen(relayUrl?: string) {\n    if (!this.subscriber.hasAnyTopics) {\n      this.logger.warn(\n        \"Starting WS connection skipped because the client has no topics to work with.\",\n      );\n      return;\n    }\n\n    if (this.connectPromise) {\n      this.logger.debug({}, `Waiting for existing connection attempt to resolve...`);\n      await this.connectPromise;\n      this.logger.debug({}, `Existing connection attempt resolved`);\n    } else {\n      this.connectPromise = new Promise(async (resolve, reject) => {\n        await this.connect(relayUrl)\n          .then(resolve)\n          .catch(reject)\n          .finally(() => {\n            this.connectPromise = undefined;\n          });\n      });\n      await this.connectPromise;\n    }\n    if (!this.connected) {\n      throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`);\n    }\n  }\n\n  public async restartTransport(relayUrl?: string) {\n    this.logger.debug({}, \"Restarting transport...\");\n    if (this.connectionAttemptInProgress) return;\n    this.relayUrl = relayUrl || this.relayUrl;\n    await this.confirmOnlineStateOrThrow();\n    await this.transportClose();\n    await this.transportOpen();\n  }\n\n  public async confirmOnlineStateOrThrow() {\n    if (await isOnline()) return;\n    throw new Error(\"No internet connection detected. Please restart your network and try again.\");\n  }\n\n  public async handleBatchMessageEvents(messages: RelayerTypes.MessageEvent[]) {\n    if (messages?.length === 0) {\n      this.logger.trace(\"Batch message events is empty. Ignoring...\");\n      return;\n    }\n    const sortedMessages = messages.sort((a, b) => a.publishedAt - b.publishedAt);\n    this.logger.debug(`Batch of ${sortedMessages.length} message events sorted`);\n    for (const message of sortedMessages) {\n      try {\n        await this.onMessageEvent(message);\n      } catch (e) {\n        this.logger.warn(e, \"Error while processing batch message event: \" + (e as Error)?.message);\n      }\n    }\n    this.logger.trace(`Batch of ${sortedMessages.length} message events processed`);\n  }\n\n  public async onLinkMessageEvent(\n    messageEvent: RelayerTypes.MessageEvent,\n    opts: { sessionExists: boolean },\n  ) {\n    const { topic } = messageEvent;\n\n    if (!opts.sessionExists) {\n      const expiry = calcExpiry(FIVE_MINUTES);\n      const pairing = { topic, expiry, relay: { protocol: \"irn\" }, active: false };\n      await this.core.pairing.pairings.set(topic, pairing);\n    }\n\n    this.events.emit(RELAYER_EVENTS.message, messageEvent);\n    await this.recordMessageEvent(messageEvent);\n  }\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async connect(relayUrl?: string) {\n    await this.confirmOnlineStateOrThrow();\n    if (relayUrl && relayUrl !== this.relayUrl) {\n      this.relayUrl = relayUrl;\n      await this.transportDisconnect();\n    }\n\n    this.connectionAttemptInProgress = true;\n    this.transportExplicitlyClosed = false;\n    let attempt = 1;\n    while (attempt < 6) {\n      try {\n        if (this.transportExplicitlyClosed) {\n          break;\n        }\n        this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${attempt}...`);\n        // Always create new socket instance when trying to connect because if the socket was dropped due to `socket hang up` exception\n        // It wont be able to reconnect\n        await this.createProvider();\n\n        await new Promise<void>(async (resolve, reject) => {\n          const onDisconnect = () => {\n            reject(new Error(`Connection interrupted while trying to subscribe`));\n          };\n          this.provider.once(RELAYER_PROVIDER_EVENTS.disconnect, onDisconnect);\n\n          await createExpiringPromise(\n            new Promise((resolve, reject) => {\n              this.provider.connect().then(resolve).catch(reject);\n            }),\n            this.connectTimeout,\n            `Socket stalled when trying to connect to ${this.relayUrl}`,\n          )\n            .catch((e) => {\n              reject(e);\n            })\n            .finally(() => {\n              this.provider.off(RELAYER_PROVIDER_EVENTS.disconnect, onDisconnect);\n              clearTimeout(this.reconnectTimeout);\n            });\n          await new Promise(async (resolve, reject) => {\n            const onDisconnect = () => {\n              reject(new Error(`Connection interrupted while trying to subscribe`));\n            };\n            this.provider.once(RELAYER_PROVIDER_EVENTS.disconnect, onDisconnect);\n            await this.subscriber\n              .start()\n              .then(resolve)\n              .catch(reject)\n              .finally(() => {\n                this.provider.off(RELAYER_PROVIDER_EVENTS.disconnect, onDisconnect);\n              });\n          });\n          this.hasExperiencedNetworkDisruption = false;\n          resolve();\n        });\n      } catch (e) {\n        await this.subscriber.stop();\n        const error = e as Error;\n        this.logger.warn({}, error.message);\n        this.hasExperiencedNetworkDisruption = true;\n      } finally {\n        this.connectionAttemptInProgress = false;\n      }\n\n      if (this.connected) {\n        this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${attempt}`);\n        break;\n      }\n\n      await new Promise((resolve) => setTimeout(resolve, toMiliseconds(attempt * 1)));\n      attempt++;\n    }\n  }\n\n  /*\n   * In Node, we must detect when the connection is stalled and terminate it.\n   * The logic is, if we don't receive ping from the relay within a certain time, we terminate the connection.\n   * The timer is refreshed on every message received from the relay.\n   *\n   * In the browser, ping/pong events are not exposed, so the above behaviour is handled by `subscribeToNetworkChange` and `isOnline` functions.\n   */\n  private startPingTimeout() {\n    if (!isNode()) return;\n    try {\n      //@ts-expect-error - Types are divergent between the node and browser WS API\n      if (this.provider?.connection?.socket) {\n        //@ts-expect-error\n        this.provider?.connection?.socket?.on(\"ping\", () => {\n          this.resetPingTimeout();\n        });\n      }\n      this.resetPingTimeout();\n    } catch (e) {\n      this.logger.warn(e, (e as Error)?.message);\n    }\n  }\n\n  private resetPingTimeout = () => {\n    if (!isNode()) return;\n    try {\n      clearTimeout(this.pingTimeout);\n      this.pingTimeout = setTimeout(() => {\n        this.logger.debug({}, \"pingTimeout: Connection stalled, terminating...\");\n        //@ts-expect-error\n        this.provider?.connection?.socket?.terminate();\n      }, this.heartBeatTimeout);\n    } catch (e) {\n      this.logger.warn(e, (e as Error)?.message);\n    }\n  };\n\n  private async createProvider() {\n    if (this.provider.connection) {\n      this.unregisterProviderListeners();\n    }\n    const auth = await this.core.crypto.signJWT(this.relayUrl);\n\n    this.provider = new JsonRpcProvider(\n      new WsConnection(\n        formatRelayRpcUrl({\n          sdkVersion: RELAYER_SDK_VERSION,\n          protocol: this.protocol,\n          version: this.version,\n          relayUrl: this.relayUrl,\n          projectId: this.projectId,\n          auth,\n          useOnCloseEvent: true,\n          bundleId: this.bundleId,\n          packageName: this.packageName,\n        }),\n      ),\n    );\n    this.registerProviderListeners();\n  }\n\n  private async recordMessageEvent(messageEvent: RelayerTypes.MessageEvent) {\n    const { topic, message } = messageEvent;\n    await this.messages.set(topic, message);\n  }\n\n  private async shouldIgnoreMessageEvent(\n    messageEvent: RelayerTypes.MessageEvent,\n  ): Promise<boolean> {\n    const { topic, message } = messageEvent;\n\n    // Ignore if incoming `message` is clearly invalid.\n    if (!message || message.length === 0) {\n      this.logger.warn(`Ignoring invalid/empty message: ${message}`);\n      return true;\n    }\n\n    // Ignore if `topic` is not subscribed to.\n    if (!(await this.subscriber.isSubscribed(topic))) {\n      this.logger.warn(`Ignoring message for non-subscribed topic ${topic}`);\n      return true;\n    }\n\n    // Ignore if `message` is a duplicate.\n    const exists = this.messages.has(topic, message);\n    if (exists) {\n      this.logger.warn(`Ignoring duplicate message: ${message}`);\n    }\n    return exists;\n  }\n\n  private async onProviderPayload(payload: JsonRpcPayload) {\n    this.logger.debug(`Incoming Relay Payload`);\n    this.logger.trace({ type: \"payload\", direction: \"incoming\", payload });\n    if (isJsonRpcRequest(payload)) {\n      if (!payload.method.endsWith(RELAYER_SUBSCRIBER_SUFFIX)) return;\n      const event = (payload as JsonRpcRequest<RelayJsonRpc.SubscriptionParams>).params;\n      const { topic, message, publishedAt, attestation } = event.data;\n      const messageEvent: RelayerTypes.MessageEvent = {\n        topic,\n        message,\n        publishedAt,\n        transportType: TRANSPORT_TYPES.relay,\n        attestation,\n      };\n      this.logger.debug(`Emitting Relayer Payload`);\n      this.logger.trace({ type: \"event\", event: event.id, ...messageEvent });\n      this.events.emit(event.id, messageEvent);\n      await this.acknowledgePayload(payload);\n      await this.onMessageEvent(messageEvent);\n    } else if (isJsonRpcResponse(payload)) {\n      this.events.emit(RELAYER_EVENTS.message_ack, payload);\n    }\n  }\n\n  private async onMessageEvent(messageEvent: RelayerTypes.MessageEvent) {\n    if (await this.shouldIgnoreMessageEvent(messageEvent)) {\n      return;\n    }\n    this.events.emit(RELAYER_EVENTS.message, messageEvent);\n    await this.recordMessageEvent(messageEvent);\n  }\n\n  private async acknowledgePayload(payload: JsonRpcPayload) {\n    const response = formatJsonRpcResult(payload.id, true);\n    await this.provider.connection.send(response);\n  }\n\n  // ---------- Events Handlers ----------------------------------------------- //\n  private onPayloadHandler = (payload: JsonRpcPayload) => {\n    this.onProviderPayload(payload);\n    this.resetPingTimeout();\n  };\n\n  private onConnectHandler = () => {\n    this.logger.warn({}, \"Relayer connected \");\n    this.startPingTimeout();\n    this.events.emit(RELAYER_EVENTS.connect);\n  };\n\n  private onDisconnectHandler = () => {\n    this.logger.warn({}, `Relayer disconnected `);\n    this.requestsInFlight = [];\n    this.onProviderDisconnect();\n  };\n\n  private onProviderErrorHandler = (error: Error) => {\n    this.logger.fatal(`Fatal socket error: ${error.message}`);\n    this.events.emit(RELAYER_EVENTS.error, error);\n    // close the transport when a fatal error is received as there's no way to recover from it\n    // usual cases are missing/invalid projectId, expired jwt token, invalid origin etc\n    this.logger.fatal(\"Fatal socket error received, closing transport\");\n    this.transportClose();\n  };\n\n  private registerProviderListeners = () => {\n    this.provider.on(RELAYER_PROVIDER_EVENTS.payload, this.onPayloadHandler);\n    this.provider.on(RELAYER_PROVIDER_EVENTS.connect, this.onConnectHandler);\n    this.provider.on(RELAYER_PROVIDER_EVENTS.disconnect, this.onDisconnectHandler);\n    this.provider.on(RELAYER_PROVIDER_EVENTS.error, this.onProviderErrorHandler);\n  };\n\n  private unregisterProviderListeners() {\n    this.provider.off(RELAYER_PROVIDER_EVENTS.payload, this.onPayloadHandler);\n    this.provider.off(RELAYER_PROVIDER_EVENTS.connect, this.onConnectHandler);\n    this.provider.off(RELAYER_PROVIDER_EVENTS.disconnect, this.onDisconnectHandler);\n    this.provider.off(RELAYER_PROVIDER_EVENTS.error, this.onProviderErrorHandler);\n    clearTimeout(this.pingTimeout);\n  }\n\n  private async registerEventListeners() {\n    let lastConnectedState = await isOnline();\n    subscribeToNetworkChange(async (connected: boolean) => {\n      // sometimes the network change event is triggered multiple times so avoid reacting to the samFe value\n      if (lastConnectedState === connected) return;\n\n      lastConnectedState = connected;\n      if (!connected) {\n        // when the device network is restarted, the socket might stay in false `connected` state\n        this.hasExperiencedNetworkDisruption = true;\n        await this.transportDisconnect();\n        this.transportExplicitlyClosed = false;\n      } else {\n        await this.transportOpen().catch((error) =>\n          this.logger.error(error, (error as Error)?.message),\n        );\n      }\n    });\n  }\n\n  private async onProviderDisconnect() {\n    clearTimeout(this.pingTimeout);\n    this.events.emit(RELAYER_EVENTS.disconnect);\n    this.connectionAttemptInProgress = false;\n    if (this.reconnectInProgress) return;\n\n    this.reconnectInProgress = true;\n    await this.subscriber.stop();\n\n    if (!this.subscriber.hasAnyTopics) return;\n    if (this.transportExplicitlyClosed) return;\n\n    this.reconnectTimeout = setTimeout(async () => {\n      await this.transportOpen().catch((error) =>\n        this.logger.error(error, (error as Error)?.message),\n      );\n      this.reconnectTimeout = undefined;\n      this.reconnectInProgress = false;\n    }, toMiliseconds(RELAYER_RECONNECT_TIMEOUT));\n  }\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n\n  private async toEstablishConnection() {\n    await this.confirmOnlineStateOrThrow();\n    if (this.connected) return;\n    await this.connect();\n  }\n}\n","import { generateChildLogger, getLoggerContext, Logger } from \"@walletconnect/logger\";\nimport { ICore, IStore } from \"@walletconnect/types\";\nimport {\n  getInternalError,\n  isProposalStruct,\n  isSessionStruct,\n  isUndefined,\n} from \"@walletconnect/utils\";\nimport { CORE_STORAGE_PREFIX, STORE_STORAGE_VERSION } from \"../constants\";\nimport isEqual from \"lodash.isequal\";\n\nexport class Store<Key, Data extends Record<string, any>> extends IStore<Key, Data> {\n  public map = new Map<Key, Data>();\n  public version = STORE_STORAGE_VERSION;\n\n  private cached: Data[] = [];\n  private initialized = false;\n\n  /**\n   * Regenerates the value key to retrieve it from cache\n   */\n  private getKey: ((data: Data) => Key) | undefined;\n\n  private storagePrefix = CORE_STORAGE_PREFIX;\n\n  // stores recently deleted key to return different rejection message when key is not found\n  private recentlyDeleted: Key[] = [];\n  private recentlyDeletedLimit = 200;\n\n  /**\n   * @param {ICore} core Core\n   * @param {Logger} logger Logger\n   * @param {string} name Store's name\n   * @param {Store<Key, Data>[\"getKey\"]} getKey Regenerates the value key to retrieve it from cache\n   * @param {string} storagePrefix Prefixes value keys\n   */\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n    public name: string,\n    storagePrefix: string = CORE_STORAGE_PREFIX,\n    getKey: Store<Key, Data>[\"getKey\"] = undefined,\n  ) {\n    super(core, logger, name, storagePrefix);\n    this.logger = generateChildLogger(logger, this.name);\n    this.storagePrefix = storagePrefix;\n    this.getKey = getKey;\n  }\n\n  public init: IStore<Key, Data>[\"init\"] = async () => {\n    if (!this.initialized) {\n      this.logger.trace(`Initialized`);\n\n      await this.restore();\n\n      this.cached.forEach((value) => {\n        if (this.getKey && value !== null && !isUndefined(value)) {\n          this.map.set(this.getKey(value), value);\n        } else if (isProposalStruct(value)) {\n          // TODO(pedro) revert type casting as any\n          this.map.set(value.id as any, value);\n        } else if (isSessionStruct(value)) {\n          // TODO(pedro) revert type casting as any\n          this.map.set(value.topic as any, value);\n        }\n      });\n\n      this.cached = [];\n      this.initialized = true;\n    }\n  };\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  get storageKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + this.name;\n  }\n\n  get length() {\n    return this.map.size;\n  }\n\n  get keys() {\n    return Array.from(this.map.keys());\n  }\n\n  get values() {\n    return Array.from(this.map.values());\n  }\n\n  public set: IStore<Key, Data>[\"set\"] = async (key, value) => {\n    this.isInitialized();\n    if (this.map.has(key)) {\n      await this.update(key, value);\n    } else {\n      this.logger.debug(`Setting value`);\n      this.logger.trace({ type: \"method\", method: \"set\", key, value });\n      this.map.set(key, value);\n      await this.persist();\n    }\n  };\n\n  public get: IStore<Key, Data>[\"get\"] = (key) => {\n    this.isInitialized();\n    this.logger.debug(`Getting value`);\n    this.logger.trace({ type: \"method\", method: \"get\", key });\n    const value = this.getData(key);\n    return value;\n  };\n\n  public getAll: IStore<Key, Data>[\"getAll\"] = (filter) => {\n    this.isInitialized();\n    if (!filter) return this.values;\n\n    return this.values.filter((value) =>\n      Object.keys(filter).every((key) => isEqual(value[key], filter[key])),\n    );\n  };\n\n  public update: IStore<Key, Data>[\"update\"] = async (key, update) => {\n    this.isInitialized();\n    this.logger.debug(`Updating value`);\n    this.logger.trace({ type: \"method\", method: \"update\", key, update });\n    const value = { ...this.getData(key), ...update };\n    this.map.set(key, value);\n    await this.persist();\n  };\n\n  public delete: IStore<Key, Data>[\"delete\"] = async (key, reason) => {\n    this.isInitialized();\n    if (!this.map.has(key)) return;\n    this.logger.debug(`Deleting value`);\n    this.logger.trace({ type: \"method\", method: \"delete\", key, reason });\n    this.map.delete(key);\n    this.addToRecentlyDeleted(key);\n    await this.persist();\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private addToRecentlyDeleted(key: Key) {\n    this.recentlyDeleted.push(key);\n    // limit the size of the recentlyDeleted array, truncate the 100 oldest entries.\n    if (this.recentlyDeleted.length >= this.recentlyDeletedLimit) {\n      this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);\n    }\n  }\n\n  private async setDataStore(value: Data[]) {\n    await this.core.storage.setItem<Data[]>(this.storageKey, value);\n  }\n\n  private async getDataStore() {\n    const value = await this.core.storage.getItem<Data[]>(this.storageKey);\n    return value;\n  }\n\n  private getData(key: Key) {\n    const value = this.map.get(key);\n    if (!value) {\n      if (this.recentlyDeleted.includes(key)) {\n        const { message } = getInternalError(\n          \"MISSING_OR_INVALID\",\n          `Record was recently deleted - ${this.name}: ${key}`,\n        );\n        this.logger.error(message);\n        throw new Error(message);\n      }\n\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `${this.name}: ${key}`);\n      this.logger.error(message);\n      throw new Error(message);\n    }\n    return value;\n  }\n\n  private async persist() {\n    await this.setDataStore(this.values);\n  }\n\n  private async restore() {\n    try {\n      const persisted = await this.getDataStore();\n      if (typeof persisted === \"undefined\") return;\n      if (!persisted.length) return;\n      if (this.map.size) {\n        const { message } = getInternalError(\"RESTORE_WILL_OVERRIDE\", this.name);\n        this.logger.error(message);\n        throw new Error(message);\n      }\n      this.cached = persisted;\n      this.logger.debug(`Successfully Restored value for ${this.name}`);\n      this.logger.trace({ type: \"method\", method: \"restore\", value: this.values });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore value for ${this.name}`);\n      this.logger.error(e as any);\n    }\n  }\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n}\n","import { generateChildLogger, getLoggerContext, Logger } from \"@walletconnect/logger\";\nimport {\n  ICore,\n  PairingTypes,\n  IPairing,\n  IPairingPrivate,\n  IStore,\n  RelayerTypes,\n  PairingJsonRpcTypes,\n  ExpirerTypes,\n  EventClientTypes,\n} from \"@walletconnect/types\";\nimport {\n  getInternalError,\n  parseUri,\n  calcExpiry,\n  generateRandomBytes32,\n  formatUri,\n  getSdkError,\n  engineEvent,\n  createDelayedPromise,\n  isValidParams,\n  isValidUrl,\n  isValidString,\n  isExpired,\n  parseExpirerTarget,\n  TYPE_1,\n} from \"@walletconnect/utils\";\nimport {\n  formatJsonRpcRequest,\n  formatJsonRpcResult,\n  formatJsonRpcError,\n  isJsonRpcRequest,\n  isJsonRpcResponse,\n  isJsonRpcResult,\n  isJsonRpcError,\n} from \"@walletconnect/jsonrpc-utils\";\nimport { FIVE_MINUTES, toMiliseconds } from \"@walletconnect/time\";\nimport EventEmitter from \"events\";\nimport {\n  PAIRING_CONTEXT,\n  PAIRING_STORAGE_VERSION,\n  CORE_STORAGE_PREFIX,\n  RELAYER_DEFAULT_PROTOCOL,\n  PAIRING_RPC_OPTS,\n  RELAYER_EVENTS,\n  EXPIRER_EVENTS,\n  PAIRING_EVENTS,\n  EVENT_CLIENT_PAIRING_TRACES,\n  EVENT_CLIENT_PAIRING_ERRORS,\n  TRANSPORT_TYPES,\n} from \"../constants\";\nimport { Store } from \"../controllers/store\";\n\nexport class Pairing implements IPairing {\n  public name = PAIRING_CONTEXT;\n  public version = PAIRING_STORAGE_VERSION;\n\n  public events = new EventEmitter();\n  public pairings: IStore<string, PairingTypes.Struct>;\n\n  private initialized = false;\n  private storagePrefix = CORE_STORAGE_PREFIX;\n  private ignoredPayloadTypes = [TYPE_1];\n  private registeredMethods: string[] = [];\n\n  constructor(public core: ICore, public logger: Logger) {\n    this.core = core;\n    this.logger = generateChildLogger(logger, this.name);\n    this.pairings = new Store(this.core, this.logger, this.name, this.storagePrefix);\n  }\n\n  public init: IPairing[\"init\"] = async () => {\n    if (!this.initialized) {\n      await this.pairings.init();\n      await this.cleanup();\n      this.registerRelayerEvents();\n      this.registerExpirerEvents();\n      this.initialized = true;\n      this.logger.trace(`Initialized`);\n    }\n  };\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  public register: IPairing[\"register\"] = ({ methods }) => {\n    this.isInitialized();\n    this.registeredMethods = [...new Set([...this.registeredMethods, ...methods])];\n  };\n\n  public create: IPairing[\"create\"] = async (params) => {\n    this.isInitialized();\n    const symKey = generateRandomBytes32();\n    const topic = await this.core.crypto.setSymKey(symKey);\n    const expiry = calcExpiry(FIVE_MINUTES);\n    const relay = { protocol: RELAYER_DEFAULT_PROTOCOL };\n    const pairing = { topic, expiry, relay, active: false, methods: params?.methods };\n    const uri = formatUri({\n      protocol: this.core.protocol,\n      version: this.core.version,\n      topic,\n      symKey,\n      relay,\n      expiryTimestamp: expiry,\n      methods: params?.methods,\n    });\n    this.events.emit(PAIRING_EVENTS.create, pairing);\n    this.core.expirer.set(topic, expiry);\n    await this.pairings.set(topic, pairing);\n    await this.core.relayer.subscribe(topic, { transportType: params?.transportType });\n\n    return { topic, uri };\n  };\n\n  public pair: IPairing[\"pair\"] = async (params) => {\n    this.isInitialized();\n\n    const event = this.core.eventClient.createEvent({\n      properties: {\n        topic: params?.uri,\n        trace: [EVENT_CLIENT_PAIRING_TRACES.pairing_started],\n      },\n    });\n\n    this.isValidPair(params, event);\n\n    const { topic, symKey, relay, expiryTimestamp, methods } = parseUri(params.uri);\n\n    event.props.properties.topic = topic;\n    event.addTrace(EVENT_CLIENT_PAIRING_TRACES.pairing_uri_validation_success);\n    event.addTrace(EVENT_CLIENT_PAIRING_TRACES.pairing_uri_not_expired);\n\n    let existingPairing;\n    if (this.pairings.keys.includes(topic)) {\n      existingPairing = this.pairings.get(topic);\n      event.addTrace(EVENT_CLIENT_PAIRING_TRACES.existing_pairing);\n      if (existingPairing.active) {\n        event.setError(EVENT_CLIENT_PAIRING_ERRORS.active_pairing_already_exists);\n        throw new Error(\n          `Pairing already exists: ${topic}. Please try again with a new connection URI.`,\n        );\n      } else {\n        event.addTrace(EVENT_CLIENT_PAIRING_TRACES.pairing_not_expired);\n      }\n    }\n\n    const expiry = expiryTimestamp || calcExpiry(FIVE_MINUTES);\n    const pairing = { topic, relay, expiry, active: false, methods };\n    this.core.expirer.set(topic, expiry);\n    await this.pairings.set(topic, pairing);\n\n    event.addTrace(EVENT_CLIENT_PAIRING_TRACES.store_new_pairing);\n\n    if (params.activatePairing) {\n      await this.activate({ topic });\n    }\n\n    this.events.emit(PAIRING_EVENTS.create, pairing);\n\n    event.addTrace(EVENT_CLIENT_PAIRING_TRACES.emit_inactive_pairing);\n\n    // avoid overwriting keychain pairing already exists\n    if (!this.core.crypto.keychain.has(topic)) {\n      await this.core.crypto.setSymKey(symKey, topic);\n    }\n    event.addTrace(EVENT_CLIENT_PAIRING_TRACES.subscribing_pairing_topic);\n\n    try {\n      await this.core.relayer.confirmOnlineStateOrThrow();\n    } catch (error) {\n      event.setError(EVENT_CLIENT_PAIRING_ERRORS.no_internet_connection);\n    }\n\n    try {\n      await this.core.relayer.subscribe(topic, { relay });\n    } catch (error) {\n      event.setError(EVENT_CLIENT_PAIRING_ERRORS.subscribe_pairing_topic_failure);\n      throw error;\n    }\n\n    event.addTrace(EVENT_CLIENT_PAIRING_TRACES.subscribe_pairing_topic_success);\n\n    return pairing;\n  };\n\n  public activate: IPairing[\"activate\"] = async ({ topic }) => {\n    this.isInitialized();\n    const expiry = calcExpiry(FIVE_MINUTES);\n    this.core.expirer.set(topic, expiry);\n    await this.pairings.update(topic, { active: true, expiry });\n  };\n\n  /**\n   * @deprecated Ping will be removed in the next major release.\n   */\n  public ping: IPairing[\"ping\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidPing(params);\n    this.logger.warn(\"ping() is deprecated and will be removed in the next major release.\");\n    const { topic } = params;\n    if (this.pairings.keys.includes(topic)) {\n      const id = await this.sendRequest(topic, \"wc_pairingPing\", {});\n      const { done, resolve, reject } = createDelayedPromise<void>();\n      this.events.once(engineEvent(\"pairing_ping\", id), ({ error }) => {\n        if (error) reject(error);\n        else resolve();\n      });\n      await done();\n    }\n  };\n\n  public updateExpiry: IPairing[\"updateExpiry\"] = async ({ topic, expiry }) => {\n    this.isInitialized();\n    await this.pairings.update(topic, { expiry });\n  };\n\n  public updateMetadata: IPairing[\"updateMetadata\"] = async ({ topic, metadata }) => {\n    this.isInitialized();\n    await this.pairings.update(topic, { peerMetadata: metadata });\n  };\n\n  public getPairings: IPairing[\"getPairings\"] = () => {\n    this.isInitialized();\n    return this.pairings.values;\n  };\n\n  public disconnect: IPairing[\"disconnect\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidDisconnect(params);\n    const { topic } = params;\n    if (this.pairings.keys.includes(topic)) {\n      await this.sendRequest(topic, \"wc_pairingDelete\", getSdkError(\"USER_DISCONNECTED\"));\n      await this.deletePairing(topic);\n    }\n  };\n\n  public formatUriFromPairing: IPairing[\"formatUriFromPairing\"] = (pairing) => {\n    this.isInitialized();\n    const { topic, relay, expiry, methods } = pairing;\n    const symKey = this.core.crypto.keychain.get(topic);\n    return formatUri({\n      protocol: this.core.protocol,\n      version: this.core.version,\n      topic,\n      symKey,\n      relay,\n      expiryTimestamp: expiry,\n      methods,\n    });\n  };\n\n  // ---------- Private Helpers ----------------------------------------------- //\n\n  private sendRequest: IPairingPrivate[\"sendRequest\"] = async (topic, method, params) => {\n    const payload = formatJsonRpcRequest(method, params);\n    const message = await this.core.crypto.encode(topic, payload);\n    const opts = PAIRING_RPC_OPTS[method].req;\n    this.core.history.set(topic, payload);\n    this.core.relayer.publish(topic, message, opts);\n    return payload.id;\n  };\n\n  private sendResult: IPairingPrivate[\"sendResult\"] = async (id, topic, result) => {\n    const payload = formatJsonRpcResult(id, result);\n    const message = await this.core.crypto.encode(topic, payload);\n    const record = await this.core.history.get(topic, id);\n    const method = record.request.method as PairingJsonRpcTypes.WcMethod;\n    const opts = PAIRING_RPC_OPTS[method].res;\n    await this.core.relayer.publish(topic, message, opts);\n    await this.core.history.resolve(payload);\n  };\n\n  private sendError: IPairingPrivate[\"sendError\"] = async (id, topic, error) => {\n    const payload = formatJsonRpcError(id, error);\n    const message = await this.core.crypto.encode(topic, payload);\n    const record = await this.core.history.get(topic, id);\n    const method = record.request.method as PairingJsonRpcTypes.WcMethod;\n\n    const opts = PAIRING_RPC_OPTS[method]\n      ? PAIRING_RPC_OPTS[method].res\n      : PAIRING_RPC_OPTS.unregistered_method.res;\n\n    await this.core.relayer.publish(topic, message, opts);\n    await this.core.history.resolve(payload);\n  };\n\n  private deletePairing: IPairingPrivate[\"deletePairing\"] = async (topic, expirerHasDeleted) => {\n    // Await the unsubscribe first to avoid deleting the symKey too early below.\n    await this.core.relayer.unsubscribe(topic);\n    await Promise.all([\n      this.pairings.delete(topic, getSdkError(\"USER_DISCONNECTED\")),\n      this.core.crypto.deleteSymKey(topic),\n      expirerHasDeleted ? Promise.resolve() : this.core.expirer.del(topic),\n    ]);\n  };\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n\n  private cleanup = async () => {\n    const expiredPairings = this.pairings.getAll().filter((pairing) => isExpired(pairing.expiry));\n    await Promise.all(expiredPairings.map((pairing) => this.deletePairing(pairing.topic)));\n  };\n\n  // ---------- Relay Events Router ----------------------------------- //\n\n  private registerRelayerEvents() {\n    this.core.relayer.on(RELAYER_EVENTS.message, async (event: RelayerTypes.MessageEvent) => {\n      const { topic, message, transportType } = event;\n\n      // Do not handle if the topic is not related to known pairing topics.\n      if (!this.pairings.keys.includes(topic)) return;\n\n      // Do not handle link-mode messages\n      if (transportType === TRANSPORT_TYPES.link_mode) return;\n\n      // messages of certain types should be ignored as they are handled by their respective SDKs\n      if (this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(message))) return;\n\n      const payload = await this.core.crypto.decode(topic, message);\n\n      try {\n        if (isJsonRpcRequest(payload)) {\n          this.core.history.set(topic, payload);\n          this.onRelayEventRequest({ topic, payload });\n        } else if (isJsonRpcResponse(payload)) {\n          await this.core.history.resolve(payload);\n          await this.onRelayEventResponse({ topic, payload });\n          this.core.history.delete(topic, payload.id);\n        }\n      } catch (error) {\n        this.logger.error(error);\n      }\n    });\n  }\n\n  private onRelayEventRequest: IPairingPrivate[\"onRelayEventRequest\"] = (event) => {\n    const { topic, payload } = event;\n    const reqMethod = payload.method as PairingJsonRpcTypes.WcMethod;\n\n    switch (reqMethod) {\n      case \"wc_pairingPing\":\n        return this.onPairingPingRequest(topic, payload);\n      case \"wc_pairingDelete\":\n        return this.onPairingDeleteRequest(topic, payload);\n      default:\n        return this.onUnknownRpcMethodRequest(topic, payload);\n    }\n  };\n\n  private onRelayEventResponse: IPairingPrivate[\"onRelayEventResponse\"] = async (event) => {\n    const { topic, payload } = event;\n    const record = await this.core.history.get(topic, payload.id);\n    const resMethod = record.request.method as PairingJsonRpcTypes.WcMethod;\n\n    switch (resMethod) {\n      case \"wc_pairingPing\":\n        return this.onPairingPingResponse(topic, payload);\n      default:\n        return this.onUnknownRpcMethodResponse(resMethod);\n    }\n  };\n\n  private onPairingPingRequest: IPairingPrivate[\"onPairingPingRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    try {\n      this.isValidPing({ topic });\n      await this.sendResult<\"wc_pairingPing\">(id, topic, true);\n      this.events.emit(PAIRING_EVENTS.ping, { id, topic });\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.logger.error(err);\n    }\n  };\n\n  private onPairingPingResponse: IPairingPrivate[\"onPairingPingResponse\"] = (_topic, payload) => {\n    const { id } = payload;\n    // put at the end of the stack to avoid a race condition\n    // where pairing_ping listener is not yet initialized\n    setTimeout(() => {\n      if (isJsonRpcResult(payload)) {\n        this.events.emit(engineEvent(\"pairing_ping\", id), {});\n      } else if (isJsonRpcError(payload)) {\n        this.events.emit(engineEvent(\"pairing_ping\", id), { error: payload.error });\n      }\n    }, 500);\n  };\n\n  private onPairingDeleteRequest: IPairingPrivate[\"onPairingDeleteRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    try {\n      this.isValidDisconnect({ topic });\n      await this.deletePairing(topic);\n      this.events.emit(PAIRING_EVENTS.delete, { id, topic });\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.logger.error(err);\n    }\n  };\n\n  private onUnknownRpcMethodRequest: IPairingPrivate[\"onUnknownRpcMethodRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id, method } = payload;\n\n    try {\n      // Ignore if the implementing client has registered this method as known.\n      if (this.registeredMethods.includes(method)) return;\n      const error = getSdkError(\"WC_METHOD_UNSUPPORTED\", method);\n      await this.sendError(id, topic, error);\n      this.logger.error(error);\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.logger.error(err);\n    }\n  };\n\n  private onUnknownRpcMethodResponse: IPairingPrivate[\"onUnknownRpcMethodResponse\"] = (method) => {\n    // Ignore if the implementing client has registered this method as known.\n    if (this.registeredMethods.includes(method)) return;\n    this.logger.error(getSdkError(\"WC_METHOD_UNSUPPORTED\", method));\n  };\n\n  // ---------- Expirer Events ---------------------------------------- //\n\n  private registerExpirerEvents() {\n    this.core.expirer.on(EXPIRER_EVENTS.expired, async (event: ExpirerTypes.Expiration) => {\n      const { topic } = parseExpirerTarget(event.target);\n      if (!topic) return;\n      if (!this.pairings.keys.includes(topic)) return;\n      await this.deletePairing(topic, true);\n      this.events.emit(PAIRING_EVENTS.expire, { topic });\n    });\n  }\n\n  // ---------- Validation Helpers ----------------------------------- //\n\n  private isValidPair = (params: { uri: string }, event: EventClientTypes.Event) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `pair() params: ${params}`);\n      event.setError(EVENT_CLIENT_PAIRING_ERRORS.malformed_pairing_uri);\n      throw new Error(message);\n    }\n    if (!isValidUrl(params.uri)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `pair() uri: ${params.uri}`);\n      event.setError(EVENT_CLIENT_PAIRING_ERRORS.malformed_pairing_uri);\n      throw new Error(message);\n    }\n    const uri = parseUri(params?.uri);\n    if (!uri?.relay?.protocol) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `pair() uri#relay-protocol`);\n      event.setError(EVENT_CLIENT_PAIRING_ERRORS.malformed_pairing_uri);\n      throw new Error(message);\n    }\n    if (!uri?.symKey) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `pair() uri#symKey`);\n      event.setError(EVENT_CLIENT_PAIRING_ERRORS.malformed_pairing_uri);\n      throw new Error(message);\n    }\n    if (uri?.expiryTimestamp) {\n      const expiration = toMiliseconds(uri?.expiryTimestamp);\n      if (expiration < Date.now()) {\n        event.setError(EVENT_CLIENT_PAIRING_ERRORS.pairing_expired);\n        const { message } = getInternalError(\n          \"EXPIRED\",\n          `pair() URI has expired. Please try again with a new connection URI.`,\n        );\n        throw new Error(message);\n      }\n    }\n  };\n\n  private isValidPing = async (params: { topic: string }) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `ping() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n    await this.isValidPairingTopic(topic);\n  };\n\n  private isValidDisconnect = async (params: { topic: string }) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `disconnect() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n    await this.isValidPairingTopic(topic);\n  };\n\n  private isValidPairingTopic = async (topic: any) => {\n    if (!isValidString(topic, false)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `pairing topic should be a string: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (!this.pairings.keys.includes(topic)) {\n      const { message } = getInternalError(\n        \"NO_MATCHING_KEY\",\n        `pairing topic doesn't exist: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (isExpired(this.pairings.get(topic).expiry)) {\n      await this.deletePairing(topic);\n      const { message } = getInternalError(\"EXPIRED\", `pairing topic: ${topic}`);\n      throw new Error(message);\n    }\n  };\n}\n","import { formatJsonRpcRequest, isJsonRpcError } from \"@walletconnect/jsonrpc-utils\";\nimport { generateChildLogger, getLoggerContext, Logger } from \"@walletconnect/logger\";\nimport { IJsonRpcHistory, JsonRpcRecord, RequestEvent, ICore } from \"@walletconnect/types\";\nimport { calcExpiry, getInternalError } from \"@walletconnect/utils\";\nimport { EventEmitter } from \"events\";\nimport { THIRTY_DAYS, toMiliseconds } from \"@walletconnect/time\";\nimport { HEARTBEAT_EVENTS } from \"@walletconnect/heartbeat\";\nimport {\n  CORE_STORAGE_PREFIX,\n  HISTORY_CONTEXT,\n  HISTORY_EVENTS,\n  HISTORY_STORAGE_VERSION,\n} from \"../constants\";\n\nexport class JsonRpcHistory extends IJsonRpcHistory {\n  public records = new Map<number, JsonRpcRecord>();\n  public events = new EventEmitter();\n  public name = HISTORY_CONTEXT;\n  public version = HISTORY_STORAGE_VERSION;\n\n  private cached: JsonRpcRecord[] = [];\n  private initialized = false;\n  private storagePrefix = CORE_STORAGE_PREFIX;\n\n  constructor(public core: ICore, public logger: Logger) {\n    super(core, logger);\n    this.logger = generateChildLogger(logger, this.name);\n  }\n\n  public init: IJsonRpcHistory[\"init\"] = async () => {\n    if (!this.initialized) {\n      this.logger.trace(`Initialized`);\n      await this.restore();\n      this.cached.forEach((record) => this.records.set(record.id, record));\n      this.cached = [];\n      this.registerEventListeners();\n      this.initialized = true;\n    }\n  };\n\n  get context(): string {\n    return getLoggerContext(this.logger);\n  }\n\n  get storageKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + this.name;\n  }\n\n  get size(): number {\n    return this.records.size;\n  }\n\n  get keys(): number[] {\n    return Array.from(this.records.keys());\n  }\n\n  get values() {\n    return Array.from(this.records.values());\n  }\n\n  get pending(): RequestEvent[] {\n    const requests: RequestEvent[] = [];\n    this.values.forEach((record) => {\n      if (typeof record.response !== \"undefined\") return;\n      const requestEvent: RequestEvent = {\n        topic: record.topic,\n        request: formatJsonRpcRequest(record.request.method, record.request.params, record.id),\n        chainId: record.chainId,\n      };\n      return requests.push(requestEvent);\n    });\n    return requests;\n  }\n\n  public set: IJsonRpcHistory[\"set\"] = (topic, request, chainId) => {\n    this.isInitialized();\n    this.logger.debug(`Setting JSON-RPC request history record`);\n    this.logger.trace({ type: \"method\", method: \"set\", topic, request, chainId });\n    if (this.records.has(request.id)) return;\n    const record: JsonRpcRecord = {\n      id: request.id,\n      topic,\n      request: { method: request.method, params: request.params || null },\n      chainId,\n      expiry: calcExpiry(THIRTY_DAYS),\n    };\n    this.records.set(record.id, record);\n    this.persist();\n    this.events.emit(HISTORY_EVENTS.created, record);\n  };\n\n  public resolve: IJsonRpcHistory[\"resolve\"] = async (response) => {\n    this.isInitialized();\n    this.logger.debug(`Updating JSON-RPC response history record`);\n    this.logger.trace({ type: \"method\", method: \"update\", response });\n    if (!this.records.has(response.id)) return;\n    const record = await this.getRecord(response.id);\n    if (typeof record.response !== \"undefined\") return;\n    record.response = isJsonRpcError(response)\n      ? { error: response.error }\n      : { result: response.result };\n    this.records.set(record.id, record);\n    this.persist();\n    this.events.emit(HISTORY_EVENTS.updated, record);\n  };\n\n  public get: IJsonRpcHistory[\"get\"] = async (topic, id) => {\n    this.isInitialized();\n    this.logger.debug(`Getting record`);\n    this.logger.trace({ type: \"method\", method: \"get\", topic, id });\n    const record = await this.getRecord(id);\n    return record;\n  };\n\n  public delete: IJsonRpcHistory[\"delete\"] = (topic, id) => {\n    this.isInitialized();\n    this.logger.debug(`Deleting record`);\n    this.logger.trace({ type: \"method\", method: \"delete\", id });\n    this.values.forEach((record: JsonRpcRecord) => {\n      if (record.topic === topic) {\n        if (typeof id !== \"undefined\" && record.id !== id) return;\n        this.records.delete(record.id);\n        this.events.emit(HISTORY_EVENTS.deleted, record);\n      }\n    });\n    this.persist();\n  };\n\n  public exists: IJsonRpcHistory[\"exists\"] = async (topic, id) => {\n    this.isInitialized();\n    if (!this.records.has(id)) return false;\n    const record = await this.getRecord(id);\n    return record.topic === topic;\n  };\n\n  public on: IJsonRpcHistory[\"on\"] = (event, listener) => {\n    this.events.on(event, listener);\n  };\n\n  public once: IJsonRpcHistory[\"once\"] = (event, listener) => {\n    this.events.once(event, listener);\n  };\n\n  public off: IJsonRpcHistory[\"off\"] = (event, listener) => {\n    this.events.off(event, listener);\n  };\n\n  public removeListener: IJsonRpcHistory[\"removeListener\"] = (event, listener) => {\n    this.events.removeListener(event, listener);\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async setJsonRpcRecords(records: JsonRpcRecord[]): Promise<void> {\n    await this.core.storage.setItem<JsonRpcRecord[]>(this.storageKey, records);\n  }\n\n  private async getJsonRpcRecords(): Promise<JsonRpcRecord[] | undefined> {\n    const records = await this.core.storage.getItem<JsonRpcRecord[]>(this.storageKey);\n    return records;\n  }\n\n  private getRecord(id: number) {\n    this.isInitialized();\n    const record = this.records.get(id);\n    if (!record) {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `${this.name}: ${id}`);\n      throw new Error(message);\n    }\n    return record;\n  }\n\n  private async persist() {\n    await this.setJsonRpcRecords(this.values);\n    this.events.emit(HISTORY_EVENTS.sync);\n  }\n\n  private async restore() {\n    try {\n      const persisted = await this.getJsonRpcRecords();\n      if (typeof persisted === \"undefined\") return;\n      if (!persisted.length) return;\n      if (this.records.size) {\n        const { message } = getInternalError(\"RESTORE_WILL_OVERRIDE\", this.name);\n        this.logger.error(message);\n        throw new Error(message);\n      }\n      this.cached = persisted;\n      this.logger.debug(`Successfully Restored records for ${this.name}`);\n      this.logger.trace({ type: \"method\", method: \"restore\", records: this.values });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore records for ${this.name}`);\n      this.logger.error(e as any);\n    }\n  }\n\n  private registerEventListeners(): void {\n    this.events.on(HISTORY_EVENTS.created, (record: JsonRpcRecord) => {\n      const eventName = HISTORY_EVENTS.created;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({ type: \"event\", event: eventName, record });\n    });\n    this.events.on(HISTORY_EVENTS.updated, (record: JsonRpcRecord) => {\n      const eventName = HISTORY_EVENTS.updated;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({ type: \"event\", event: eventName, record });\n    });\n\n    this.events.on(HISTORY_EVENTS.deleted, (record: JsonRpcRecord) => {\n      const eventName = HISTORY_EVENTS.deleted;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({ type: \"event\", event: eventName, record });\n    });\n\n    this.core.heartbeat.on(HEARTBEAT_EVENTS.pulse, () => {\n      this.cleanup();\n    });\n  }\n\n  private cleanup() {\n    try {\n      this.isInitialized();\n      let deleted = false;\n      this.records.forEach((record: JsonRpcRecord) => {\n        const msToExpiry = toMiliseconds(record.expiry || 0) - Date.now();\n        if (msToExpiry <= 0) {\n          this.logger.info(`Deleting expired history log: ${record.id}`);\n          this.records.delete(record.id);\n          this.events.emit(HISTORY_EVENTS.deleted, record, false);\n          deleted = true;\n        }\n      });\n      if (deleted) {\n        this.persist();\n      }\n    } catch (e) {\n      this.logger.warn(e);\n    }\n  }\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n}\n","import { HEARTBEAT_EVENTS } from \"@walletconnect/heartbeat\";\nimport { generateChildLogger, getLoggerContext, Logger } from \"@walletconnect/logger\";\nimport { toMiliseconds } from \"@walletconnect/time\";\nimport { ExpirerTypes, ICore, IExpirer } from \"@walletconnect/types\";\nimport { getInternalError, formatIdTarget, formatTopicTarget } from \"@walletconnect/utils\";\nimport { EventEmitter } from \"events\";\nimport {\n  CORE_STORAGE_PREFIX,\n  EXPIRER_CONTEXT,\n  EXPIRER_EVENTS,\n  EXPIRER_STORAGE_VERSION,\n} from \"../constants\";\n\nexport class Expirer extends IExpirer {\n  public expirations = new Map<string, ExpirerTypes.Expiration>();\n  public events = new EventEmitter();\n  public name = EXPIRER_CONTEXT;\n  public version = EXPIRER_STORAGE_VERSION;\n\n  private cached: ExpirerTypes.Expiration[] = [];\n  private initialized = false;\n\n  private storagePrefix = CORE_STORAGE_PREFIX;\n\n  constructor(public core: ICore, public logger: Logger) {\n    super(core, logger);\n    this.logger = generateChildLogger(logger, this.name);\n  }\n\n  public init: IExpirer[\"init\"] = async () => {\n    if (!this.initialized) {\n      this.logger.trace(`Initialized`);\n      await this.restore();\n      this.cached.forEach((expiration) => this.expirations.set(expiration.target, expiration));\n      this.cached = [];\n      this.registerEventListeners();\n      this.initialized = true;\n    }\n  };\n\n  get context(): string {\n    return getLoggerContext(this.logger);\n  }\n\n  get storageKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + this.name;\n  }\n\n  get length(): number {\n    return this.expirations.size;\n  }\n\n  get keys(): string[] {\n    return Array.from(this.expirations.keys());\n  }\n\n  get values(): ExpirerTypes.Expiration[] {\n    return Array.from(this.expirations.values());\n  }\n\n  public has: IExpirer[\"has\"] = (key) => {\n    try {\n      const target = this.formatTarget(key);\n      const expiration = this.getExpiration(target);\n      return typeof expiration !== \"undefined\";\n    } catch (e) {\n      // ignore\n      return false;\n    }\n  };\n\n  public set: IExpirer[\"set\"] = (key, expiry) => {\n    this.isInitialized();\n    const target = this.formatTarget(key);\n    const expiration = { target, expiry };\n    this.expirations.set(target, expiration);\n    this.checkExpiry(target, expiration);\n    this.events.emit(EXPIRER_EVENTS.created, {\n      target,\n      expiration,\n    } as ExpirerTypes.Created);\n  };\n\n  public get: IExpirer[\"get\"] = (key) => {\n    this.isInitialized();\n    const target = this.formatTarget(key);\n    return this.getExpiration(target);\n  };\n\n  public del: IExpirer[\"del\"] = (key) => {\n    this.isInitialized();\n    const exists = this.has(key);\n    if (exists) {\n      const target = this.formatTarget(key);\n      const expiration = this.getExpiration(target);\n      this.expirations.delete(target);\n      this.events.emit(EXPIRER_EVENTS.deleted, {\n        target,\n        expiration,\n      } as ExpirerTypes.Deleted);\n    }\n  };\n\n  public on: IExpirer[\"on\"] = (event, listener) => {\n    this.events.on(event, listener);\n  };\n\n  public once: IExpirer[\"once\"] = (event, listener) => {\n    this.events.once(event, listener);\n  };\n\n  public off: IExpirer[\"off\"] = (event, listener) => {\n    this.events.off(event, listener);\n  };\n\n  public removeListener: IExpirer[\"removeListener\"] = (event, listener) => {\n    this.events.removeListener(event, listener);\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private formatTarget(key: string | number) {\n    if (typeof key === \"string\") {\n      return formatTopicTarget(key);\n    } else if (typeof key === \"number\") {\n      return formatIdTarget(key);\n    }\n    const { message } = getInternalError(\"UNKNOWN_TYPE\", `Target type: ${typeof key}`);\n    throw new Error(message);\n  }\n\n  private async setExpirations(expirations: ExpirerTypes.Expiration[]): Promise<void> {\n    await this.core.storage.setItem<ExpirerTypes.Expiration[]>(this.storageKey, expirations);\n  }\n\n  private async getExpirations(): Promise<ExpirerTypes.Expiration[] | undefined> {\n    const expirations = await this.core.storage.getItem<ExpirerTypes.Expiration[]>(this.storageKey);\n    return expirations;\n  }\n\n  private async persist() {\n    await this.setExpirations(this.values);\n    this.events.emit(EXPIRER_EVENTS.sync);\n  }\n\n  private async restore() {\n    try {\n      const persisted = await this.getExpirations();\n      if (typeof persisted === \"undefined\") return;\n      if (!persisted.length) return;\n      if (this.expirations.size) {\n        const { message } = getInternalError(\"RESTORE_WILL_OVERRIDE\", this.name);\n        this.logger.error(message);\n        throw new Error(message);\n      }\n      this.cached = persisted;\n      this.logger.debug(`Successfully Restored expirations for ${this.name}`);\n      this.logger.trace({ type: \"method\", method: \"restore\", expirations: this.values });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore expirations for ${this.name}`);\n      this.logger.error(e as any);\n    }\n  }\n\n  private getExpiration(target: string): ExpirerTypes.Expiration {\n    const expiration = this.expirations.get(target);\n    if (!expiration) {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `${this.name}: ${target}`);\n      this.logger.warn(message);\n      throw new Error(message);\n    }\n    return expiration;\n  }\n\n  private checkExpiry(target: string, expiration: ExpirerTypes.Expiration): void {\n    const { expiry } = expiration;\n    const msToTimeout = toMiliseconds(expiry) - Date.now();\n    if (msToTimeout <= 0) this.expire(target, expiration);\n  }\n\n  private expire(target: string, expiration: ExpirerTypes.Expiration): void {\n    this.expirations.delete(target);\n    this.events.emit(EXPIRER_EVENTS.expired, {\n      target,\n      expiration,\n    } as ExpirerTypes.Expired);\n  }\n\n  private checkExpirations(): void {\n    // avoid auto expiring if the relayer is not connected\n    if (!this.core.relayer.connected) return;\n    this.expirations.forEach((expiration, target) => this.checkExpiry(target, expiration));\n  }\n\n  private registerEventListeners(): void {\n    this.core.heartbeat.on(HEARTBEAT_EVENTS.pulse, () => this.checkExpirations());\n    this.events.on(EXPIRER_EVENTS.created, (createdEvent: ExpirerTypes.Created) => {\n      const eventName = EXPIRER_EVENTS.created;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({ type: \"event\", event: eventName, data: createdEvent });\n      this.persist();\n    });\n    this.events.on(EXPIRER_EVENTS.expired, (expiredEvent: ExpirerTypes.Expired) => {\n      const eventName = EXPIRER_EVENTS.expired;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({ type: \"event\", event: eventName, data: expiredEvent });\n      this.persist();\n    });\n    this.events.on(EXPIRER_EVENTS.deleted, (deletedEvent: ExpirerTypes.Deleted) => {\n      const eventName = EXPIRER_EVENTS.deleted;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({ type: \"event\", event: eventName, data: deletedEvent });\n      this.persist();\n    });\n  }\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n}\n","import { generateChildLogger, getLoggerContext, Logger } from \"@walletconnect/logger\";\nimport { ICore, IVerify } from \"@walletconnect/types\";\nimport { isBrowser, isTestRun, P256KeyDataType, verifyP256Jwt } from \"@walletconnect/utils\";\nimport { FIVE_SECONDS, ONE_SECOND, toMiliseconds } from \"@walletconnect/time\";\nimport { getDocument } from \"@walletconnect/window-getters\";\nimport { decodeJWT } from \"@walletconnect/relay-auth\";\n\nimport {\n  CORE_STORAGE_PREFIX,\n  CORE_VERSION,\n  TRUSTED_VERIFY_URLS,\n  VERIFY_CONTEXT,\n  VERIFY_SERVER,\n  VERIFY_SERVER_V3,\n} from \"../constants\";\nimport { IKeyValueStorage } from \"@walletconnect/keyvaluestorage\";\n\ntype Jwk = {\n  publicKey: P256KeyDataType;\n  expiresAt: number;\n};\ntype JwkPayload = {\n  exp: number;\n  id: string;\n  origin: string;\n  isScam: boolean;\n  isVerified: boolean;\n};\nexport class Verify extends IVerify {\n  public name = VERIFY_CONTEXT;\n  private abortController: AbortController;\n  private isDevEnv;\n  private verifyUrlV3 = VERIFY_SERVER_V3;\n  private storagePrefix = CORE_STORAGE_PREFIX;\n  private version = CORE_VERSION;\n  private publicKey?: Jwk;\n  private fetchPromise?: Promise<Jwk>;\n\n  constructor(public core: ICore, public logger: Logger, public store: IKeyValueStorage) {\n    super(core, logger, store);\n    this.logger = generateChildLogger(logger, this.name);\n    this.abortController = new AbortController();\n    this.isDevEnv = isTestRun();\n    this.init();\n  }\n\n  get storeKey(): string {\n    return (\n      this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + `verify:public:key`\n    );\n  }\n\n  public init = async () => {\n    if (this.isDevEnv) return;\n    this.publicKey = await this.store.getItem(this.storeKey);\n    if (this.publicKey && toMiliseconds(this.publicKey?.expiresAt) < Date.now()) {\n      this.logger.debug(\"verify v2 public key expired\");\n      await this.removePublicKey();\n    }\n  };\n\n  public register: IVerify[\"register\"] = async (params) => {\n    if (!isBrowser() || this.isDevEnv) return;\n    const origin = window.location.origin;\n    const { id, decryptedId } = params;\n    const src = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${origin}&id=${id}&decryptedId=${decryptedId}`;\n    try {\n      const document = getDocument() as Document;\n      const abortTimeout = this.startAbortTimer(ONE_SECOND * 5);\n      const attestationJwt = await new Promise((resolve, reject) => {\n        const abortListener = () => {\n          window.removeEventListener(\"message\", listener);\n          document.body.removeChild(iframe);\n          reject(\"attestation aborted\");\n        };\n        this.abortController.signal.addEventListener(\"abort\", abortListener);\n        const iframe = document.createElement(\"iframe\");\n        iframe.src = src;\n        iframe.style.display = \"none\";\n        iframe.addEventListener(\"error\", abortListener, { signal: this.abortController.signal });\n        const listener = (event: MessageEvent) => {\n          if (!event.data) return;\n          if (typeof event.data !== \"string\") return;\n          try {\n            const data = JSON.parse(event.data);\n            if (data.type === \"verify_attestation\") {\n              const decoded = decodeJWT(data.attestation) as unknown as { payload: JwkPayload };\n              if (decoded.payload.id !== id) return;\n\n              clearInterval(abortTimeout);\n              document.body.removeChild(iframe);\n              this.abortController.signal.removeEventListener(\"abort\", abortListener);\n              window.removeEventListener(\"message\", listener);\n              resolve(data.attestation === null ? \"\" : data.attestation);\n            }\n          } catch (e) {\n            this.logger.warn(e);\n          }\n        };\n        document.body.appendChild(iframe);\n        window.addEventListener(\"message\", listener, { signal: this.abortController.signal });\n      });\n      this.logger.debug(\"jwt attestation\", attestationJwt);\n      return attestationJwt as string;\n    } catch (e) {\n      this.logger.warn(e);\n    }\n    return \"\";\n  };\n\n  public resolve: IVerify[\"resolve\"] = async (params) => {\n    if (this.isDevEnv) return \"\";\n    const { attestationId, hash, encryptedId } = params;\n    if (attestationId === \"\") {\n      this.logger.debug(\"resolve: attestationId is empty, skipping\");\n      return;\n    }\n\n    if (attestationId) {\n      const decoded = decodeJWT(attestationId) as unknown as { payload: JwkPayload };\n      if (decoded.payload.id !== encryptedId) return;\n      const validation = await this.isValidJwtAttestation(attestationId);\n      if (validation) {\n        if (!validation.isVerified) {\n          this.logger.warn(\"resolve: jwt attestation: origin url not verified\");\n          return;\n        }\n        return validation;\n      }\n    }\n    if (!hash) return;\n    const verifyUrl = this.getVerifyUrl(params?.verifyUrl);\n    return this.fetchAttestation(hash, verifyUrl);\n  };\n\n  get context(): string {\n    return getLoggerContext(this.logger);\n  }\n\n  private fetchAttestation = async (attestationId: string, url: string) => {\n    this.logger.debug(`resolving attestation: ${attestationId} from url: ${url}`);\n    // set artificial timeout to prevent hanging\n    const timeout = this.startAbortTimer(ONE_SECOND * 5);\n    const result = await fetch(`${url}/attestation/${attestationId}?v2Supported=true`, {\n      signal: this.abortController.signal,\n    });\n    clearTimeout(timeout);\n    return result.status === 200 ? await result.json() : undefined;\n  };\n\n  private startAbortTimer(timer: number) {\n    this.abortController = new AbortController();\n    return setTimeout(() => this.abortController.abort(), toMiliseconds(timer));\n  }\n\n  private getVerifyUrl = (verifyUrl?: string) => {\n    let url = verifyUrl || VERIFY_SERVER;\n    if (!TRUSTED_VERIFY_URLS.includes(url)) {\n      this.logger.info(\n        `verify url: ${url}, not included in trusted list, assigning default: ${VERIFY_SERVER}`,\n      );\n      url = VERIFY_SERVER;\n    }\n    return url;\n  };\n\n  private fetchPublicKey = async () => {\n    try {\n      this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);\n      const timeout = this.startAbortTimer(FIVE_SECONDS);\n      const result = await fetch(`${this.verifyUrlV3}/public-key`, {\n        signal: this.abortController.signal,\n      });\n      clearTimeout(timeout);\n      return (await result.json()) as Jwk;\n    } catch (e) {\n      this.logger.warn(e);\n    }\n    return undefined;\n  };\n\n  private persistPublicKey = async (publicKey: Jwk) => {\n    this.logger.debug(`persisting public key to local storage`, publicKey);\n    await this.store.setItem(this.storeKey, publicKey);\n    this.publicKey = publicKey;\n  };\n\n  private removePublicKey = async () => {\n    this.logger.debug(`removing verify v2 public key from storage`);\n    await this.store.removeItem(this.storeKey);\n    this.publicKey = undefined;\n  };\n\n  private isValidJwtAttestation = async (attestation: string) => {\n    const key = await this.getPublicKey();\n    try {\n      if (key) {\n        const validation = this.validateAttestation(attestation, key);\n        return validation;\n      }\n    } catch (e) {\n      this.logger.error(e);\n      this.logger.warn(\"error validating attestation\");\n    }\n    const newKey = await this.fetchAndPersistPublicKey();\n    try {\n      if (newKey) {\n        const validation = this.validateAttestation(attestation, newKey);\n        return validation;\n      }\n    } catch (e) {\n      this.logger.error(e);\n      this.logger.warn(\"error validating attestation\");\n    }\n    return undefined;\n  };\n\n  private getPublicKey = async () => {\n    if (this.publicKey) return this.publicKey;\n    return await this.fetchAndPersistPublicKey();\n  };\n\n  private fetchAndPersistPublicKey = async () => {\n    if (this.fetchPromise) {\n      await this.fetchPromise;\n      return this.publicKey;\n    }\n    this.fetchPromise = new Promise(async (resolve) => {\n      const key = await this.fetchPublicKey();\n      if (!key) return;\n      await this.persistPublicKey(key);\n      resolve(key);\n    });\n    const key = await this.fetchPromise;\n    this.fetchPromise = undefined;\n    return key;\n  };\n\n  private validateAttestation = (attestation: string, key: Jwk) => {\n    const result = verifyP256Jwt<JwkPayload>(attestation, key.publicKey);\n    const validation = {\n      hasExpired: toMiliseconds(result.exp) < Date.now(),\n      payload: result,\n    };\n\n    if (validation.hasExpired) {\n      this.logger.warn(\"resolve: jwt attestation expired\");\n      throw new Error(\"JWT attestation expired\");\n    }\n\n    return {\n      origin: validation.payload.origin,\n      isScam: validation.payload.isScam,\n      isVerified: validation.payload.isVerified,\n    };\n  };\n}\n","import { generateChildLogger, Logger } from \"@walletconnect/logger\";\nimport { IEchoClient } from \"@walletconnect/types\";\nimport { ECHO_CONTEXT, ECHO_URL } from \"../constants\";\n\nexport class EchoClient extends IEchoClient {\n  public readonly context = ECHO_CONTEXT;\n  constructor(public projectId: string, public logger: Logger) {\n    super(projectId, logger);\n    this.logger = generateChildLogger(logger, this.context);\n  }\n\n  public registerDeviceToken: IEchoClient[\"registerDeviceToken\"] = async (params) => {\n    const { clientId, token, notificationType, enableEncrypted = false } = params;\n\n    const echoUrl = `${ECHO_URL}/${this.projectId}/clients`;\n\n    await fetch(echoUrl, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        client_id: clientId,\n        type: notificationType,\n        token,\n        always_raw: enableEncrypted,\n      }),\n    });\n  };\n}\n","import { generateChildLogger, Logger } from \"@walletconnect/logger\";\nimport { ICore, IEventClient, EventClientTypes } from \"@walletconnect/types\";\nimport { formatUA, isTestRun, uuidv4, getAppMetadata } from \"@walletconnect/utils\";\nimport {\n  CORE_STORAGE_PREFIX,\n  EVENTS_CLIENT_API_URL,\n  EVENTS_STORAGE_CLEANUP_INTERVAL,\n  EVENTS_STORAGE_CONTEXT,\n  EVENTS_STORAGE_VERSION,\n  RELAYER_SDK_VERSION,\n} from \"../constants\";\nimport { HEARTBEAT_EVENTS } from \"@walletconnect/heartbeat\";\nimport { fromMiliseconds } from \"@walletconnect/time\";\n\nexport class EventClient extends IEventClient {\n  public readonly context = EVENTS_STORAGE_CONTEXT;\n  private readonly storagePrefix = CORE_STORAGE_PREFIX;\n  private readonly storageVersion = EVENTS_STORAGE_VERSION;\n  private events = new Map<string, EventClientTypes.Event>();\n  private shouldPersist = false;\n  constructor(public core: ICore, public logger: Logger, telemetryEnabled = true) {\n    super(core, logger, telemetryEnabled);\n    this.logger = generateChildLogger(logger, this.context);\n    this.telemetryEnabled = telemetryEnabled;\n    if (telemetryEnabled) {\n      this.restore().then(async () => {\n        await this.submit();\n        this.setEventListeners();\n      });\n    } else {\n      // overwrite any persisted events with an empty array\n      this.persist();\n    }\n  }\n\n  get storageKey() {\n    return (\n      this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + \"//\" + this.context\n    );\n  }\n\n  public init: IEventClient[\"init\"] = async () => {\n    if (isTestRun()) return;\n    try {\n      const initEvent = {\n        eventId: uuidv4(),\n        timestamp: Date.now(),\n        domain: this.getAppDomain(),\n        props: {\n          event: \"INIT\",\n          type: \"\",\n          properties: {\n            client_id: await this.core.crypto.getClientId(),\n            user_agent: formatUA(\n              this.core.relayer.protocol,\n              this.core.relayer.version,\n              RELAYER_SDK_VERSION,\n            ),\n          },\n        },\n      };\n      await this.sendEvent([initEvent] as unknown as EventClientTypes.Event[]);\n    } catch (error) {\n      this.logger.warn(error);\n    }\n  };\n\n  public createEvent: IEventClient[\"createEvent\"] = (params) => {\n    const {\n      event = \"ERROR\",\n      type = \"\",\n      properties: { topic, trace },\n    } = params;\n    const eventId = uuidv4();\n    const bundleId = this.core.projectId || \"\";\n    const timestamp = Date.now();\n    const props = {\n      event,\n      type,\n      properties: {\n        topic,\n        trace,\n      },\n    };\n    const eventObj = {\n      eventId,\n      timestamp,\n      props,\n      bundleId,\n      domain: this.getAppDomain(),\n      ...this.setMethods(eventId),\n    };\n    if (this.telemetryEnabled) {\n      this.events.set(eventId, eventObj);\n      this.shouldPersist = true;\n    }\n\n    return eventObj;\n  };\n\n  public getEvent: IEventClient[\"getEvent\"] = (params) => {\n    const { eventId, topic } = params;\n    if (eventId) {\n      return this.events.get(eventId);\n    }\n    const event = Array.from(this.events.values()).find(\n      (event) => event.props.properties.topic === topic,\n    );\n\n    if (!event) return;\n\n    return {\n      ...event,\n      ...this.setMethods(event.eventId),\n    };\n  };\n\n  public deleteEvent: IEventClient[\"deleteEvent\"] = (params) => {\n    const { eventId } = params;\n    this.events.delete(eventId);\n    this.shouldPersist = true;\n  };\n\n  private setEventListeners = () => {\n    this.core.heartbeat.on(HEARTBEAT_EVENTS.pulse, async () => {\n      if (this.shouldPersist) await this.persist();\n      // cleanup events older than EVENTS_STORAGE_CLEANUP_INTERVAL\n      this.events.forEach((event) => {\n        if (\n          fromMiliseconds(Date.now()) - fromMiliseconds(event.timestamp) >\n          EVENTS_STORAGE_CLEANUP_INTERVAL\n        ) {\n          this.events.delete(event.eventId);\n          this.shouldPersist = true;\n        }\n      });\n    });\n  };\n\n  private setMethods = (eventId: string) => {\n    return {\n      addTrace: (trace: string) => this.addTrace(eventId, trace),\n      setError: (errorType: string) => this.setError(eventId, errorType),\n    };\n  };\n\n  private addTrace = (eventId: string, trace: string) => {\n    const event = this.events.get(eventId);\n    if (!event) return;\n    event.props.properties.trace.push(trace);\n    this.events.set(eventId, event);\n    this.shouldPersist = true;\n  };\n\n  private setError = (eventId: string, errorType: string) => {\n    const event = this.events.get(eventId);\n    if (!event) return;\n    event.props.type = errorType;\n    event.timestamp = Date.now();\n    this.events.set(eventId, event);\n    this.shouldPersist = true;\n  };\n\n  private persist = async () => {\n    await this.core.storage.setItem(this.storageKey, Array.from(this.events.values()));\n    this.shouldPersist = false;\n  };\n\n  private restore = async () => {\n    try {\n      const events =\n        (await this.core.storage.getItem<EventClientTypes.Event[]>(this.storageKey)) || [];\n      if (!events.length) return;\n      events.forEach((event) => {\n        this.events.set(event.eventId, {\n          ...event,\n          ...this.setMethods(event.eventId),\n        });\n      });\n    } catch (error) {\n      this.logger.warn(error);\n    }\n  };\n\n  private submit = async () => {\n    if (!this.telemetryEnabled) return;\n\n    if (this.events.size === 0) return;\n\n    const eventsToSend: EventClientTypes.Event[] = [];\n    // exclude events without type as they can be considered `in progress`\n    for (const [_, event] of this.events) {\n      if (event.props.type) {\n        eventsToSend.push(event);\n      }\n    }\n\n    if (eventsToSend.length === 0) return;\n\n    try {\n      const response = await this.sendEvent(eventsToSend);\n      if (response.ok) {\n        for (const event of eventsToSend) {\n          this.events.delete(event.eventId);\n          this.shouldPersist = true;\n        }\n      }\n    } catch (error) {\n      this.logger.warn(error);\n    }\n  };\n\n  private sendEvent = async (events: EventClientTypes.Event[]) => {\n    // if domain isn't available, set `sp` as `desktop` so data would be extracted on api side\n    const platform = this.getAppDomain() ? \"\" : \"&sp=desktop\";\n    const response = await fetch(\n      `${EVENTS_CLIENT_API_URL}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${RELAYER_SDK_VERSION}${platform}`,\n      {\n        method: \"POST\",\n        body: JSON.stringify(events),\n      },\n    );\n    return response;\n  };\n\n  private getAppDomain = () => {\n    return getAppMetadata().url;\n  };\n}\n","import { EventEmitter } from \"events\";\n\nimport { HeartBeat } from \"@walletconnect/heartbeat\";\nimport KeyValueStorage from \"@walletconnect/keyvaluestorage\";\nimport {\n  ChunkLoggerController,\n  generateChildLogger,\n  generatePlatformLogger,\n  getDefaultLoggerOptions,\n  getLoggerContext,\n} from \"@walletconnect/logger\";\nimport { CoreTypes, ICore } from \"@walletconnect/types\";\n\nimport {\n  CORE_CONTEXT,\n  CORE_DEFAULT,\n  CORE_PROTOCOL,\n  CORE_STORAGE_OPTIONS,\n  CORE_VERSION,\n  RELAYER_DEFAULT_RELAY_URL,\n  TRANSPORT_TYPES,\n  WALLETCONNECT_CLIENT_ID,\n  WALLETCONNECT_LINK_MODE_APPS,\n} from \"./constants\";\nimport {\n  Crypto,\n  EchoClient,\n  EventClient,\n  Expirer,\n  JsonRpcHistory,\n  Pairing,\n  Relayer,\n  Verify,\n} from \"./controllers\";\n\nexport class Core extends ICore {\n  public readonly protocol = CORE_PROTOCOL;\n  public readonly version = CORE_VERSION;\n\n  public readonly name: ICore[\"name\"] = CORE_CONTEXT;\n  public readonly relayUrl: ICore[\"relayUrl\"];\n  public readonly projectId: ICore[\"projectId\"];\n  public readonly customStoragePrefix: ICore[\"customStoragePrefix\"];\n  public events: ICore[\"events\"] = new EventEmitter();\n  public logger: ICore[\"logger\"];\n  public heartbeat: ICore[\"heartbeat\"];\n  public relayer: ICore[\"relayer\"];\n  public crypto: ICore[\"crypto\"];\n  public storage: ICore[\"storage\"];\n  public history: ICore[\"history\"];\n  public expirer: ICore[\"expirer\"];\n  public pairing: ICore[\"pairing\"];\n  public verify: ICore[\"verify\"];\n  public echoClient: ICore[\"echoClient\"];\n  public linkModeSupportedApps: ICore[\"linkModeSupportedApps\"];\n  public eventClient: ICore[\"eventClient\"];\n\n  private initialized = false;\n  private logChunkController: ChunkLoggerController | null;\n\n  static async init(opts?: CoreTypes.Options) {\n    const core = new Core(opts);\n    await core.initialize();\n    const clientId = await core.crypto.getClientId();\n    await core.storage.setItem(WALLETCONNECT_CLIENT_ID, clientId);\n\n    return core;\n  }\n\n  constructor(opts?: CoreTypes.Options) {\n    super(opts);\n    this.projectId = opts?.projectId;\n    this.relayUrl = opts?.relayUrl || RELAYER_DEFAULT_RELAY_URL;\n    this.customStoragePrefix = opts?.customStoragePrefix ? `:${opts.customStoragePrefix}` : \"\";\n\n    const loggerOptions = getDefaultLoggerOptions({\n      level: typeof opts?.logger === \"string\" && opts.logger ? opts.logger : CORE_DEFAULT.logger,\n      name: CORE_CONTEXT,\n    });\n\n    const { logger, chunkLoggerController } = generatePlatformLogger({\n      opts: loggerOptions,\n      maxSizeInBytes: opts?.maxLogBlobSizeInBytes,\n      loggerOverride: opts?.logger,\n    });\n\n    this.logChunkController = chunkLoggerController;\n\n    if (this.logChunkController?.downloadLogsBlobInBrowser) {\n      // @ts-ignore\n      window.downloadLogsBlobInBrowser = async () => {\n        // Have to null check twice becquse there is no guarantee\n        // this.logChunkController.downloadLogsBlobInBrowser is always truthy\n        if (this.logChunkController?.downloadLogsBlobInBrowser) {\n          this.logChunkController?.downloadLogsBlobInBrowser({\n            clientId: await this.crypto.getClientId(),\n          });\n        }\n      };\n    }\n\n    this.logger = generateChildLogger(logger, this.name);\n    this.heartbeat = new HeartBeat();\n    this.crypto = new Crypto(this, this.logger, opts?.keychain);\n    this.history = new JsonRpcHistory(this, this.logger);\n    this.expirer = new Expirer(this, this.logger);\n    this.storage = opts?.storage\n      ? opts.storage\n      : new KeyValueStorage({ ...CORE_STORAGE_OPTIONS, ...opts?.storageOptions });\n    this.relayer = new Relayer({\n      core: this,\n      logger: this.logger,\n      relayUrl: this.relayUrl,\n      projectId: this.projectId,\n    });\n    this.pairing = new Pairing(this, this.logger);\n    this.verify = new Verify(this, this.logger, this.storage);\n    this.echoClient = new EchoClient(this.projectId || \"\", this.logger);\n    this.linkModeSupportedApps = [];\n    this.eventClient = new EventClient(this, this.logger, opts?.telemetryEnabled);\n  }\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  // ---------- Public ----------------------------------------------- //\n\n  public async start() {\n    if (this.initialized) return;\n    await this.initialize();\n  }\n\n  public async getLogsBlob() {\n    return this.logChunkController?.logsToBlob({\n      clientId: await this.crypto.getClientId(),\n    });\n  }\n\n  public async addLinkModeSupportedApp(universalLink: string) {\n    if (this.linkModeSupportedApps.includes(universalLink)) return;\n    this.linkModeSupportedApps.push(universalLink);\n    await this.storage.setItem(WALLETCONNECT_LINK_MODE_APPS, this.linkModeSupportedApps);\n  }\n\n  // ---------- Events ----------------------------------------------- //\n\n  public on = (name: any, listener: any) => {\n    return this.events.on(name, listener);\n  };\n\n  public once = (name: any, listener: any) => {\n    return this.events.once(name, listener);\n  };\n\n  public off = (name: any, listener: any) => {\n    return this.events.off(name, listener);\n  };\n\n  public removeListener = (name: any, listener: any) => {\n    return this.events.removeListener(name, listener);\n  };\n\n  // ---------- Link-mode ----------------------------------------------- //\n\n  public dispatchEnvelope = ({\n    topic,\n    message,\n    sessionExists,\n  }: {\n    topic: string;\n    message: string;\n    sessionExists: boolean;\n  }) => {\n    if (!topic || !message) return;\n\n    const payload = {\n      topic,\n      message,\n      publishedAt: Date.now(),\n      transportType: TRANSPORT_TYPES.link_mode,\n    };\n\n    this.relayer.onLinkMessageEvent(payload, { sessionExists });\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async initialize() {\n    this.logger.trace(`Initialized`);\n    try {\n      await this.crypto.init();\n      await this.history.init();\n      await this.expirer.init();\n      await this.relayer.init();\n      await this.heartbeat.init();\n      await this.pairing.init();\n      this.linkModeSupportedApps = (await this.storage.getItem(WALLETCONNECT_LINK_MODE_APPS)) || [];\n\n      this.initialized = true;\n      this.logger.info(`Core Initialization Success`);\n    } catch (error) {\n      this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, error);\n      this.logger.error((error as any).message);\n      throw error;\n    }\n  }\n}\n","import { Core as WalletConnectCore } from \"./core\";\n\nexport * from \"./constants\";\nexport * from \"./controllers\";\n\nexport const Core = WalletConnectCore;\nexport default WalletConnectCore;\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}