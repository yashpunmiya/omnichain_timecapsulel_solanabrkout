{"ast":null,"code":"import * as Hex from '../Hex.js';\n/** @internal */\nexport function assertSize(hex, size_) {\n  if (Hex.size(hex) > size_) throw new Hex.SizeOverflowError({\n    givenSize: Hex.size(hex),\n    maxSize: size_\n  });\n}\n/** @internal */\nexport function assertStartOffset(value, start) {\n  if (typeof start === 'number' && start > 0 && start > Hex.size(value) - 1) throw new Hex.SliceOffsetOutOfBoundsError({\n    offset: start,\n    position: 'start',\n    size: Hex.size(value)\n  });\n}\n/** @internal */\nexport function assertEndOffset(value, start, end) {\n  if (typeof start === 'number' && typeof end === 'number' && Hex.size(value) !== end - start) {\n    throw new Hex.SliceOffsetOutOfBoundsError({\n      offset: end,\n      position: 'end',\n      size: Hex.size(value)\n    });\n  }\n}\n/** @internal */\nexport function pad(hex_, options = {}) {\n  const {\n    dir,\n    size = 32\n  } = options;\n  if (size === 0) return hex_;\n  const hex = hex_.replace('0x', '');\n  if (hex.length > size * 2) throw new Hex.SizeExceedsPaddingSizeError({\n    size: Math.ceil(hex.length / 2),\n    targetSize: size,\n    type: 'Hex'\n  });\n  return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](size * 2, '0')}`;\n}\n/** @internal */\nexport function trim(value, options = {}) {\n  const {\n    dir = 'left'\n  } = options;\n  let data = value.replace('0x', '');\n  let sliceLength = 0;\n  for (let i = 0; i < data.length - 1; i++) {\n    if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0') sliceLength++;else break;\n  }\n  data = dir === 'left' ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);\n  if (data === '0') return '0x';\n  if (dir === 'right' && data.length % 2 === 1) return `0x${data}0`;\n  return `0x${data}`;\n}\n//# sourceMappingURL=hex.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}