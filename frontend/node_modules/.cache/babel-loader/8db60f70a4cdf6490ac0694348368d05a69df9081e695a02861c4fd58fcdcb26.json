{"ast":null,"code":"import { multicall3Abi } from '../../constants/abis.js';\nimport { AbiDecodingZeroDataError } from '../../errors/abi.js';\nimport { BaseError } from '../../errors/base.js';\nimport { RawContractError } from '../../errors/contract.js';\nimport { decodeFunctionResult } from '../../utils/abi/decodeFunctionResult.js';\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js';\nimport { getChainContractAddress } from '../../utils/chain/getChainContractAddress.js';\nimport { getContractError } from '../../utils/errors/getContractError.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { readContract } from './readContract.js';\n/**\n * Similar to [`readContract`](https://viem.sh/docs/contract/readContract), but batches up multiple functions on a contract in a single RPC call via the [`multicall3` contract](https://github.com/mds1/multicall).\n *\n * - Docs: https://viem.sh/docs/contract/multicall\n *\n * @param client - Client to use\n * @param parameters - {@link MulticallParameters}\n * @returns An array of results with accompanying status. {@link MulticallReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { multicall } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const abi = parseAbi([\n *   'function balanceOf(address) view returns (uint256)',\n *   'function totalSupply() view returns (uint256)',\n * ])\n * const results = await multicall(client, {\n *   contracts: [\n *     {\n *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *       abi,\n *       functionName: 'balanceOf',\n *       args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n *     },\n *     {\n *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *       abi,\n *       functionName: 'totalSupply',\n *     },\n *   ],\n * })\n * // [{ result: 424122n, status: 'success' }, { result: 1000000n, status: 'success' }]\n */\nexport async function multicall(client, parameters) {\n  const {\n    allowFailure = true,\n    batchSize: batchSize_,\n    blockNumber,\n    blockTag,\n    multicallAddress: multicallAddress_,\n    stateOverride\n  } = parameters;\n  const contracts = parameters.contracts;\n  const batchSize = batchSize_ ?? (typeof client.batch?.multicall === 'object' && client.batch.multicall.batchSize || 1_024);\n  let multicallAddress = multicallAddress_;\n  if (!multicallAddress) {\n    if (!client.chain) throw new Error('client chain not configured. multicallAddress is required.');\n    multicallAddress = getChainContractAddress({\n      blockNumber,\n      chain: client.chain,\n      contract: 'multicall3'\n    });\n  }\n  const chunkedCalls = [[]];\n  let currentChunk = 0;\n  let currentChunkSize = 0;\n  for (let i = 0; i < contracts.length; i++) {\n    const {\n      abi,\n      address,\n      args,\n      functionName\n    } = contracts[i];\n    try {\n      const callData = encodeFunctionData({\n        abi,\n        args,\n        functionName\n      });\n      currentChunkSize += (callData.length - 2) / 2;\n      // Check to see if we need to create a new chunk.\n      if (\n      // Check if batching is enabled.\n      batchSize > 0 &&\n      // Check if the current size of the batch exceeds the size limit.\n      currentChunkSize > batchSize &&\n      // Check if the current chunk is not already empty.\n      chunkedCalls[currentChunk].length > 0) {\n        currentChunk++;\n        currentChunkSize = (callData.length - 2) / 2;\n        chunkedCalls[currentChunk] = [];\n      }\n      chunkedCalls[currentChunk] = [...chunkedCalls[currentChunk], {\n        allowFailure: true,\n        callData,\n        target: address\n      }];\n    } catch (err) {\n      const error = getContractError(err, {\n        abi,\n        address,\n        args,\n        docsPath: '/docs/contract/multicall',\n        functionName\n      });\n      if (!allowFailure) throw error;\n      chunkedCalls[currentChunk] = [...chunkedCalls[currentChunk], {\n        allowFailure: true,\n        callData: '0x',\n        target: address\n      }];\n    }\n  }\n  const aggregate3Results = await Promise.allSettled(chunkedCalls.map(calls => getAction(client, readContract, 'readContract')({\n    abi: multicall3Abi,\n    address: multicallAddress,\n    args: [calls],\n    blockNumber,\n    blockTag,\n    functionName: 'aggregate3',\n    stateOverride\n  })));\n  const results = [];\n  for (let i = 0; i < aggregate3Results.length; i++) {\n    const result = aggregate3Results[i];\n    // If an error occurred in a `readContract` invocation (ie. network error),\n    // then append the failure reason to each contract result.\n    if (result.status === 'rejected') {\n      if (!allowFailure) throw result.reason;\n      for (let j = 0; j < chunkedCalls[i].length; j++) {\n        results.push({\n          status: 'failure',\n          error: result.reason,\n          result: undefined\n        });\n      }\n      continue;\n    }\n    // If the `readContract` call was successful, then decode the results.\n    const aggregate3Result = result.value;\n    for (let j = 0; j < aggregate3Result.length; j++) {\n      // Extract the response from `readContract`\n      const {\n        returnData,\n        success\n      } = aggregate3Result[j];\n      // Extract the request call data from the original call.\n      const {\n        callData\n      } = chunkedCalls[i][j];\n      // Extract the contract config for this call from the `contracts` argument\n      // for decoding.\n      const {\n        abi,\n        address,\n        functionName,\n        args\n      } = contracts[results.length];\n      try {\n        if (callData === '0x') throw new AbiDecodingZeroDataError();\n        if (!success) throw new RawContractError({\n          data: returnData\n        });\n        const result = decodeFunctionResult({\n          abi,\n          args,\n          data: returnData,\n          functionName\n        });\n        results.push(allowFailure ? {\n          result,\n          status: 'success'\n        } : result);\n      } catch (err) {\n        const error = getContractError(err, {\n          abi,\n          address,\n          args,\n          docsPath: '/docs/contract/multicall',\n          functionName\n        });\n        if (!allowFailure) throw error;\n        results.push({\n          error,\n          result: undefined,\n          status: 'failure'\n        });\n      }\n    }\n  }\n  if (results.length !== contracts.length) throw new BaseError('multicall results mismatch');\n  return results;\n}","map":{"version":3,"names":["multicall3Abi","AbiDecodingZeroDataError","BaseError","RawContractError","decodeFunctionResult","encodeFunctionData","getChainContractAddress","getContractError","getAction","readContract","multicall","client","parameters","allowFailure","batchSize","batchSize_","blockNumber","blockTag","multicallAddress","multicallAddress_","stateOverride","contracts","batch","chain","Error","contract","chunkedCalls","currentChunk","currentChunkSize","i","length","abi","address","args","functionName","callData","target","err","error","docsPath","aggregate3Results","Promise","allSettled","map","calls","results","result","status","reason","j","push","undefined","aggregate3Result","value","returnData","success","data"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\utils\\node_modules\\viem\\actions\\public\\multicall.ts"],"sourcesContent":["import type { AbiStateMutability, Address, Narrow } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { multicall3Abi } from '../../constants/abis.js'\nimport { AbiDecodingZeroDataError } from '../../errors/abi.js'\nimport { BaseError } from '../../errors/base.js'\nimport { RawContractError } from '../../errors/contract.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { ContractFunctionParameters } from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type {\n  MulticallContracts,\n  MulticallResults,\n} from '../../types/multicall.js'\nimport {\n  type DecodeFunctionResultErrorType,\n  decodeFunctionResult,\n} from '../../utils/abi/decodeFunctionResult.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport {\n  type GetChainContractAddressErrorType,\n  getChainContractAddress,\n} from '../../utils/chain/getChainContractAddress.js'\nimport {\n  type GetContractErrorReturnType,\n  getContractError,\n} from '../../utils/errors/getContractError.js'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport { getAction } from '../../utils/getAction.js'\nimport type { CallParameters } from './call.js'\nimport { type ReadContractErrorType, readContract } from './readContract.js'\n\nexport type MulticallParameters<\n  contracts extends readonly unknown[] = readonly ContractFunctionParameters[],\n  allowFailure extends boolean = true,\n  options extends {\n    optional?: boolean\n    properties?: Record<string, any>\n  } = {},\n> = Pick<CallParameters, 'blockNumber' | 'blockTag' | 'stateOverride'> & {\n  allowFailure?: allowFailure | boolean | undefined\n  batchSize?: number | undefined\n  contracts: MulticallContracts<\n    Narrow<contracts>,\n    { mutability: AbiStateMutability } & options\n  >\n  multicallAddress?: Address | undefined\n}\n\nexport type MulticallReturnType<\n  contracts extends readonly unknown[] = readonly ContractFunctionParameters[],\n  allowFailure extends boolean = true,\n  options extends {\n    error?: Error\n  } = { error: Error },\n> = MulticallResults<\n  Narrow<contracts>,\n  allowFailure,\n  { mutability: AbiStateMutability } & options\n>\n\nexport type MulticallErrorType =\n  | GetChainContractAddressErrorType\n  | ReadContractErrorType\n  | GetContractErrorReturnType<\n      EncodeFunctionDataErrorType | DecodeFunctionResultErrorType\n    >\n  | ErrorType\n\n/**\n * Similar to [`readContract`](https://viem.sh/docs/contract/readContract), but batches up multiple functions on a contract in a single RPC call via the [`multicall3` contract](https://github.com/mds1/multicall).\n *\n * - Docs: https://viem.sh/docs/contract/multicall\n *\n * @param client - Client to use\n * @param parameters - {@link MulticallParameters}\n * @returns An array of results with accompanying status. {@link MulticallReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { multicall } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const abi = parseAbi([\n *   'function balanceOf(address) view returns (uint256)',\n *   'function totalSupply() view returns (uint256)',\n * ])\n * const results = await multicall(client, {\n *   contracts: [\n *     {\n *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *       abi,\n *       functionName: 'balanceOf',\n *       args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n *     },\n *     {\n *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *       abi,\n *       functionName: 'totalSupply',\n *     },\n *   ],\n * })\n * // [{ result: 424122n, status: 'success' }, { result: 1000000n, status: 'success' }]\n */\nexport async function multicall<\n  const contracts extends readonly unknown[],\n  chain extends Chain | undefined,\n  allowFailure extends boolean = true,\n>(\n  client: Client<Transport, chain>,\n  parameters: MulticallParameters<contracts, allowFailure>,\n): Promise<MulticallReturnType<contracts, allowFailure>> {\n  const {\n    allowFailure = true,\n    batchSize: batchSize_,\n    blockNumber,\n    blockTag,\n    multicallAddress: multicallAddress_,\n    stateOverride,\n  } = parameters\n  const contracts = parameters.contracts as ContractFunctionParameters[]\n\n  const batchSize =\n    batchSize_ ??\n    ((typeof client.batch?.multicall === 'object' &&\n      client.batch.multicall.batchSize) ||\n      1_024)\n\n  let multicallAddress = multicallAddress_\n  if (!multicallAddress) {\n    if (!client.chain)\n      throw new Error(\n        'client chain not configured. multicallAddress is required.',\n      )\n\n    multicallAddress = getChainContractAddress({\n      blockNumber,\n      chain: client.chain,\n      contract: 'multicall3',\n    })\n  }\n\n  type Aggregate3Calls = {\n    allowFailure: boolean\n    callData: Hex\n    target: Address\n  }[]\n\n  const chunkedCalls: Aggregate3Calls[] = [[]]\n  let currentChunk = 0\n  let currentChunkSize = 0\n  for (let i = 0; i < contracts.length; i++) {\n    const { abi, address, args, functionName } = contracts[i]\n    try {\n      const callData = encodeFunctionData({ abi, args, functionName })\n\n      currentChunkSize += (callData.length - 2) / 2\n      // Check to see if we need to create a new chunk.\n      if (\n        // Check if batching is enabled.\n        batchSize > 0 &&\n        // Check if the current size of the batch exceeds the size limit.\n        currentChunkSize > batchSize &&\n        // Check if the current chunk is not already empty.\n        chunkedCalls[currentChunk].length > 0\n      ) {\n        currentChunk++\n        currentChunkSize = (callData.length - 2) / 2\n        chunkedCalls[currentChunk] = []\n      }\n\n      chunkedCalls[currentChunk] = [\n        ...chunkedCalls[currentChunk],\n        {\n          allowFailure: true,\n          callData,\n          target: address,\n        },\n      ]\n    } catch (err) {\n      const error = getContractError(err as BaseError, {\n        abi,\n        address,\n        args,\n        docsPath: '/docs/contract/multicall',\n        functionName,\n      })\n      if (!allowFailure) throw error\n      chunkedCalls[currentChunk] = [\n        ...chunkedCalls[currentChunk],\n        {\n          allowFailure: true,\n          callData: '0x' as Hex,\n          target: address,\n        },\n      ]\n    }\n  }\n\n  const aggregate3Results = await Promise.allSettled(\n    chunkedCalls.map((calls) =>\n      getAction(\n        client,\n        readContract,\n        'readContract',\n      )({\n        abi: multicall3Abi,\n        address: multicallAddress!,\n        args: [calls],\n        blockNumber,\n        blockTag,\n        functionName: 'aggregate3',\n        stateOverride,\n      }),\n    ),\n  )\n\n  const results = []\n  for (let i = 0; i < aggregate3Results.length; i++) {\n    const result = aggregate3Results[i]\n\n    // If an error occurred in a `readContract` invocation (ie. network error),\n    // then append the failure reason to each contract result.\n    if (result.status === 'rejected') {\n      if (!allowFailure) throw result.reason\n      for (let j = 0; j < chunkedCalls[i].length; j++) {\n        results.push({\n          status: 'failure',\n          error: result.reason,\n          result: undefined,\n        })\n      }\n      continue\n    }\n\n    // If the `readContract` call was successful, then decode the results.\n    const aggregate3Result = result.value\n    for (let j = 0; j < aggregate3Result.length; j++) {\n      // Extract the response from `readContract`\n      const { returnData, success } = aggregate3Result[j]\n\n      // Extract the request call data from the original call.\n      const { callData } = chunkedCalls[i][j]\n\n      // Extract the contract config for this call from the `contracts` argument\n      // for decoding.\n      const { abi, address, functionName, args } = contracts[\n        results.length\n      ] as ContractFunctionParameters\n\n      try {\n        if (callData === '0x') throw new AbiDecodingZeroDataError()\n        if (!success) throw new RawContractError({ data: returnData })\n        const result = decodeFunctionResult({\n          abi,\n          args,\n          data: returnData,\n          functionName,\n        })\n        results.push(allowFailure ? { result, status: 'success' } : result)\n      } catch (err) {\n        const error = getContractError(err as BaseError, {\n          abi,\n          address,\n          args,\n          docsPath: '/docs/contract/multicall',\n          functionName,\n        })\n        if (!allowFailure) throw error\n        results.push({ error, result: undefined, status: 'failure' })\n      }\n    }\n  }\n\n  if (results.length !== contracts.length)\n    throw new BaseError('multicall results mismatch')\n  return results as MulticallReturnType<contracts, allowFailure>\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}