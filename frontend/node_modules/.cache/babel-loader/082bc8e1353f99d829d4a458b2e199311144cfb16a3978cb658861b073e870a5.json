{"ast":null,"code":"import { AbiEncodingLengthMismatchError, BytesSizeMismatchError, UnsupportedPackedAbiType } from '../../errors/abi.js';\nimport { InvalidAddressError } from '../../errors/address.js';\nimport { isAddress } from '../address/isAddress.js';\nimport { concatHex } from '../data/concat.js';\nimport { pad } from '../data/pad.js';\nimport { boolToHex, numberToHex, stringToHex } from '../encoding/toHex.js';\nimport { arrayRegex, bytesRegex, integerRegex } from '../regex.js';\nexport function encodePacked(types, values) {\n  if (types.length !== values.length) throw new AbiEncodingLengthMismatchError({\n    expectedLength: types.length,\n    givenLength: values.length\n  });\n  const data = [];\n  for (let i = 0; i < types.length; i++) {\n    const type = types[i];\n    const value = values[i];\n    data.push(encode(type, value));\n  }\n  return concatHex(data);\n}\nfunction encode(type, value, isArray = false) {\n  if (type === 'address') {\n    const address = value;\n    if (!isAddress(address)) throw new InvalidAddressError({\n      address\n    });\n    return pad(address.toLowerCase(), {\n      size: isArray ? 32 : null\n    });\n  }\n  if (type === 'string') return stringToHex(value);\n  if (type === 'bytes') return value;\n  if (type === 'bool') return pad(boolToHex(value), {\n    size: isArray ? 32 : 1\n  });\n  const intMatch = type.match(integerRegex);\n  if (intMatch) {\n    const [_type, baseType, bits = '256'] = intMatch;\n    const size = Number.parseInt(bits) / 8;\n    return numberToHex(value, {\n      size: isArray ? 32 : size,\n      signed: baseType === 'int'\n    });\n  }\n  const bytesMatch = type.match(bytesRegex);\n  if (bytesMatch) {\n    const [_type, size] = bytesMatch;\n    if (Number.parseInt(size) !== (value.length - 2) / 2) throw new BytesSizeMismatchError({\n      expectedSize: Number.parseInt(size),\n      givenSize: (value.length - 2) / 2\n    });\n    return pad(value, {\n      dir: 'right',\n      size: isArray ? 32 : null\n    });\n  }\n  const arrayMatch = type.match(arrayRegex);\n  if (arrayMatch && Array.isArray(value)) {\n    const [_type, childType] = arrayMatch;\n    const data = [];\n    for (let i = 0; i < value.length; i++) {\n      data.push(encode(childType, value[i], true));\n    }\n    if (data.length === 0) return '0x';\n    return concatHex(data);\n  }\n  throw new UnsupportedPackedAbiType(type);\n}","map":{"version":3,"names":["AbiEncodingLengthMismatchError","BytesSizeMismatchError","UnsupportedPackedAbiType","InvalidAddressError","isAddress","concatHex","pad","boolToHex","numberToHex","stringToHex","arrayRegex","bytesRegex","integerRegex","encodePacked","types","values","length","expectedLength","givenLength","data","i","type","value","push","encode","isArray","address","toLowerCase","size","intMatch","match","_type","baseType","bits","Number","parseInt","signed","bytesMatch","expectedSize","givenSize","dir","arrayMatch","Array","childType"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\viem\\utils\\abi\\encodePacked.ts"],"sourcesContent":["import type {\n  AbiParameterToPrimitiveType,\n  AbiType,\n  Address,\n  SolidityAddress,\n  SolidityArrayWithoutTuple,\n  SolidityBool,\n  SolidityBytes,\n  SolidityInt,\n  SolidityString,\n} from 'abitype'\n\nimport {\n  AbiEncodingLengthMismatchError,\n  type AbiEncodingLengthMismatchErrorType,\n  BytesSizeMismatchError,\n  type BytesSizeMismatchErrorType,\n  UnsupportedPackedAbiType,\n} from '../../errors/abi.js'\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport { type ConcatHexErrorType, concatHex } from '../data/concat.js'\nimport { type PadErrorType, pad } from '../data/pad.js'\nimport {\n  type BoolToHexErrorType,\n  type NumberToHexErrorType,\n  type StringToHexErrorType,\n  boolToHex,\n  numberToHex,\n  stringToHex,\n} from '../encoding/toHex.js'\nimport { arrayRegex, bytesRegex, integerRegex } from '../regex.js'\n\ntype PackedAbiType =\n  | SolidityAddress\n  | SolidityBool\n  | SolidityBytes\n  | SolidityInt\n  | SolidityString\n  | SolidityArrayWithoutTuple\n\ntype EncodePackedValues<\n  packedAbiTypes extends readonly PackedAbiType[] | readonly unknown[],\n> = {\n  [K in keyof packedAbiTypes]: packedAbiTypes[K] extends AbiType\n    ? AbiParameterToPrimitiveType<{ type: packedAbiTypes[K] }>\n    : unknown\n}\n\nexport type EncodePackedErrorType =\n  | AbiEncodingLengthMismatchErrorType\n  | ConcatHexErrorType\n  | EncodeErrorType\n  | ErrorType\n\nexport function encodePacked<\n  const packedAbiTypes extends readonly PackedAbiType[] | readonly unknown[],\n>(types: packedAbiTypes, values: EncodePackedValues<packedAbiTypes>): Hex {\n  if (types.length !== values.length)\n    throw new AbiEncodingLengthMismatchError({\n      expectedLength: types.length as number,\n      givenLength: values.length as number,\n    })\n\n  const data: Hex[] = []\n  for (let i = 0; i < (types as unknown[]).length; i++) {\n    const type = types[i]\n    const value = values[i]\n    data.push(encode(type, value))\n  }\n  return concatHex(data)\n}\n\ntype EncodeErrorType =\n  | BoolToHexErrorType\n  | BytesSizeMismatchErrorType\n  | InvalidAddressErrorType\n  | IsAddressErrorType\n  | NumberToHexErrorType\n  | PadErrorType\n  | StringToHexErrorType\n  | UnsupportedPackedAbiType\n  | ErrorType\n\nfunction encode<const packedAbiType extends PackedAbiType | unknown>(\n  type: packedAbiType,\n  value: EncodePackedValues<[packedAbiType]>[0],\n  isArray = false,\n): Hex {\n  if (type === 'address') {\n    const address = value as Address\n    if (!isAddress(address)) throw new InvalidAddressError({ address })\n    return pad(address.toLowerCase() as Hex, {\n      size: isArray ? 32 : null,\n    }) as Address\n  }\n  if (type === 'string') return stringToHex(value as string)\n  if (type === 'bytes') return value as Hex\n  if (type === 'bool')\n    return pad(boolToHex(value as boolean), { size: isArray ? 32 : 1 })\n\n  const intMatch = (type as string).match(integerRegex)\n  if (intMatch) {\n    const [_type, baseType, bits = '256'] = intMatch\n    const size = Number.parseInt(bits) / 8\n    return numberToHex(value as number, {\n      size: isArray ? 32 : size,\n      signed: baseType === 'int',\n    })\n  }\n\n  const bytesMatch = (type as string).match(bytesRegex)\n  if (bytesMatch) {\n    const [_type, size] = bytesMatch\n    if (Number.parseInt(size) !== ((value as Hex).length - 2) / 2)\n      throw new BytesSizeMismatchError({\n        expectedSize: Number.parseInt(size),\n        givenSize: ((value as Hex).length - 2) / 2,\n      })\n    return pad(value as Hex, { dir: 'right', size: isArray ? 32 : null }) as Hex\n  }\n\n  const arrayMatch = (type as string).match(arrayRegex)\n  if (arrayMatch && Array.isArray(value)) {\n    const [_type, childType] = arrayMatch\n    const data: Hex[] = []\n    for (let i = 0; i < value.length; i++) {\n      data.push(encode(childType, value[i], true))\n    }\n    if (data.length === 0) return '0x'\n    return concatHex(data)\n  }\n\n  throw new UnsupportedPackedAbiType(type)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}