{"ast":null,"code":"import { BaseSignInMessageSignerWalletAdapter, WalletReadyState, WalletPublicKeyError, WalletConnectionError, WalletNotReadyError, WalletSignMessageError, WalletSendTransactionError, WalletSignTransactionError, WalletNotConnectedError } from '@solana/wallet-adapter-base';\nimport { PublicKey, VersionedMessage, Transaction, VersionedTransaction } from '@solana/web3.js';\nimport { SolanaSignIn, SolanaSignMessage, SolanaSignAndSendTransaction, SolanaSignTransaction } from '@solana/wallet-standard-features';\nimport { LocalSolanaMobileWalletAdapterWallet, createDefaultChainSelector, RemoteSolanaMobileWalletAdapterWallet, createDefaultAuthorizationCache, defaultErrorModalWalletNotFoundHandler } from '@solana-mobile/wallet-standard-mobile';\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n}\nundefined && undefined.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nundefined && undefined.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\n\n/** Name of the feature. */\nconst StandardConnect = 'standard:connect';\n\n/** Name of the feature. */\nconst StandardDisconnect = 'standard:disconnect';\n\n/** Name of the feature. */\nconst StandardEvents = 'standard:events';\nundefined && undefined.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nundefined && undefined.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nundefined && undefined.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nundefined && undefined.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nfunction fromUint8Array(byteArray) {\n  return window.btoa(String.fromCharCode.call(null, ...byteArray));\n}\nfunction getIsSupported() {\n  return typeof window !== 'undefined' && window.isSecureContext && typeof document !== 'undefined' && /android/i.test(navigator.userAgent);\n}\nvar _BaseSolanaMobileWalletAdapter_instances, _BaseSolanaMobileWalletAdapter_wallet, _BaseSolanaMobileWalletAdapter_connecting, _BaseSolanaMobileWalletAdapter_readyState, _BaseSolanaMobileWalletAdapter_accountSelector, _BaseSolanaMobileWalletAdapter_selectedAccount, _BaseSolanaMobileWalletAdapter_publicKey, _BaseSolanaMobileWalletAdapter_handleChangeEvent, _BaseSolanaMobileWalletAdapter_connect, _BaseSolanaMobileWalletAdapter_declareWalletAsInstalled, _BaseSolanaMobileWalletAdapter_assertIsAuthorized, _BaseSolanaMobileWalletAdapter_performSignTransactions, _BaseSolanaMobileWalletAdapter_runWithGuard;\nconst SolanaMobileWalletAdapterWalletName = 'Mobile Wallet Adapter';\nconst SIGNATURE_LENGTH_IN_BYTES = 64;\nfunction isVersionedTransaction(transaction) {\n  return 'version' in transaction;\n}\nfunction chainOrClusterToChainId(chain) {\n  switch (chain) {\n    case 'mainnet-beta':\n      return 'solana:mainnet';\n    case 'testnet':\n      return 'solana:testnet';\n    case 'devnet':\n      return 'solana:devnet';\n    default:\n      return chain;\n  }\n}\nclass BaseSolanaMobileWalletAdapter extends BaseSignInMessageSignerWalletAdapter {\n  constructor(wallet, config) {\n    super();\n    _BaseSolanaMobileWalletAdapter_instances.add(this);\n    this.supportedTransactionVersions = new Set(\n    // FIXME(#244): We can't actually know what versions are supported until we know which wallet we're talking to.\n    ['legacy', 0]);\n    _BaseSolanaMobileWalletAdapter_wallet.set(this, void 0);\n    _BaseSolanaMobileWalletAdapter_connecting.set(this, false);\n    _BaseSolanaMobileWalletAdapter_readyState.set(this, getIsSupported() ? WalletReadyState.Loadable : WalletReadyState.Unsupported);\n    _BaseSolanaMobileWalletAdapter_accountSelector.set(this, void 0);\n    _BaseSolanaMobileWalletAdapter_selectedAccount.set(this, void 0);\n    _BaseSolanaMobileWalletAdapter_publicKey.set(this, void 0);\n    _BaseSolanaMobileWalletAdapter_handleChangeEvent.set(this, properties => __awaiter(this, void 0, void 0, function* () {\n      if (properties.accounts && properties.accounts.length > 0) {\n        __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_instances, \"m\", _BaseSolanaMobileWalletAdapter_declareWalletAsInstalled).call(this);\n        const nextSelectedAccount = yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_accountSelector, \"f\").call(this, properties.accounts);\n        if (nextSelectedAccount !== __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_selectedAccount, \"f\")) {\n          __classPrivateFieldSet(this, _BaseSolanaMobileWalletAdapter_selectedAccount, nextSelectedAccount, \"f\");\n          __classPrivateFieldSet(this, _BaseSolanaMobileWalletAdapter_publicKey, undefined, \"f\");\n          this.emit('connect',\n          // Having just set `this.#selectedAccount`, `this.publicKey` is definitely non-null\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          this.publicKey);\n        }\n      }\n    }));\n    // this.#chain = chainOrClusterToChainId(config.chain);\n    __classPrivateFieldSet(this, _BaseSolanaMobileWalletAdapter_accountSelector, accounts => __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      const selectedBase64EncodedAddress = yield config.addressSelector.select(accounts.map(({\n        publicKey\n      }) => fromUint8Array(publicKey)));\n      return (_a = accounts.find(({\n        publicKey\n      }) => fromUint8Array(publicKey) === selectedBase64EncodedAddress)) !== null && _a !== void 0 ? _a : accounts[0];\n    }), \"f\");\n    __classPrivateFieldSet(this, _BaseSolanaMobileWalletAdapter_wallet, wallet, \"f\");\n    __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").features[StandardEvents].on('change', __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_handleChangeEvent, \"f\"));\n    this.name = __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").name;\n    this.icon = __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").icon;\n    this.url = __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").url;\n    // TODO: evaluate if this logic should be kept - it seems to create a nasty bug where \n    //  the wallet tries to auto connect on page load and gets blocked by the popup blocker\n    // if (this.#readyState !== WalletReadyState.Unsupported) {\n    //     config.authorizationResultCache.get().then((authorizationResult) => {\n    //         if (authorizationResult) {\n    //             // Having a prior authorization result is, right now, the best\n    //             // indication that a mobile wallet is installed. There is no API\n    //             // we can use to test for whether the association URI is supported.\n    //             this.#declareWalletAsInstalled();\n    //         }\n    //     });\n    // }\n  }\n  get publicKey() {\n    var _a;\n    if (!__classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_publicKey, \"f\") && __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_selectedAccount, \"f\")) {\n      try {\n        __classPrivateFieldSet(this, _BaseSolanaMobileWalletAdapter_publicKey, new PublicKey(__classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_selectedAccount, \"f\").publicKey), \"f\");\n      } catch (e) {\n        throw new WalletPublicKeyError(e instanceof Error && (e === null || e === void 0 ? void 0 : e.message) || 'Unknown error', e);\n      }\n    }\n    return (_a = __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_publicKey, \"f\")) !== null && _a !== void 0 ? _a : null;\n  }\n  get connected() {\n    return __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").connected;\n  }\n  get connecting() {\n    return __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_connecting, \"f\");\n  }\n  get readyState() {\n    return __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_readyState, \"f\");\n  }\n  /** @deprecated Use `autoConnect()` instead. */\n  autoConnect_DO_NOT_USE_OR_YOU_WILL_BE_FIRED() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.autoConnect();\n    });\n  }\n  autoConnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_instances, \"m\", _BaseSolanaMobileWalletAdapter_connect).call(this, true);\n    });\n  }\n  connect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_instances, \"m\", _BaseSolanaMobileWalletAdapter_connect).call(this);\n    });\n  }\n  /** @deprecated Use `connect()` or `autoConnect()` instead. */\n  performAuthorization(signInPayload) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const cachedAuthorizationResult = yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").cachedAuthorizationResult;\n        if (cachedAuthorizationResult) {\n          yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").features[StandardConnect].connect({\n            silent: true\n          });\n          return cachedAuthorizationResult;\n        }\n        if (signInPayload) {\n          yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").features[SolanaSignIn].signIn(signInPayload);\n        } else yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").features[StandardConnect].connect();\n        const authorizationResult = yield yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").cachedAuthorizationResult;\n        return authorizationResult;\n      } catch (e) {\n        throw new WalletConnectionError(e instanceof Error && e.message || 'Unknown error', e);\n      }\n    });\n  }\n  disconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      // return await this.#runWithGuard(this.#wallet.features[StandardDisconnect].disconnect);\n      return yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_instances, \"m\", _BaseSolanaMobileWalletAdapter_runWithGuard).call(this, () => __awaiter(this, void 0, void 0, function* () {\n        __classPrivateFieldSet(this, _BaseSolanaMobileWalletAdapter_connecting, false, \"f\");\n        __classPrivateFieldSet(this, _BaseSolanaMobileWalletAdapter_publicKey, undefined, \"f\");\n        __classPrivateFieldSet(this, _BaseSolanaMobileWalletAdapter_selectedAccount, undefined, \"f\");\n        yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").features[StandardDisconnect].disconnect();\n        this.emit('disconnect');\n      }));\n    });\n  }\n  signIn(input) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_instances, \"m\", _BaseSolanaMobileWalletAdapter_runWithGuard).call(this, () => __awaiter(this, void 0, void 0, function* () {\n        var _a;\n        if (__classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_readyState, \"f\") !== WalletReadyState.Installed && __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_readyState, \"f\") !== WalletReadyState.Loadable) {\n          throw new WalletNotReadyError();\n        }\n        __classPrivateFieldSet(this, _BaseSolanaMobileWalletAdapter_connecting, true, \"f\");\n        try {\n          const outputs = yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").features[SolanaSignIn].signIn(Object.assign(Object.assign({}, input), {\n            domain: (_a = input === null || input === void 0 ? void 0 : input.domain) !== null && _a !== void 0 ? _a : window.location.host\n          }));\n          if (outputs.length > 0) {\n            return outputs[0];\n          } else {\n            throw new Error(\"Sign in failed, no sign in result returned by wallet\");\n          }\n        } catch (e) {\n          throw new WalletConnectionError(e instanceof Error && e.message || 'Unknown error', e);\n        } finally {\n          __classPrivateFieldSet(this, _BaseSolanaMobileWalletAdapter_connecting, false, \"f\");\n        }\n      }));\n    });\n  }\n  signMessage(message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_instances, \"m\", _BaseSolanaMobileWalletAdapter_runWithGuard).call(this, () => __awaiter(this, void 0, void 0, function* () {\n        const account = __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_instances, \"m\", _BaseSolanaMobileWalletAdapter_assertIsAuthorized).call(this);\n        try {\n          const outputs = yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").features[SolanaSignMessage].signMessage({\n            account,\n            message: message\n          });\n          return outputs[0].signature;\n        } catch (error) {\n          throw new WalletSignMessageError(error === null || error === void 0 ? void 0 : error.message, error);\n        }\n      }));\n    });\n  }\n  sendTransaction(transaction, connection, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_instances, \"m\", _BaseSolanaMobileWalletAdapter_runWithGuard).call(this, () => __awaiter(this, void 0, void 0, function* () {\n        const account = __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_instances, \"m\", _BaseSolanaMobileWalletAdapter_assertIsAuthorized).call(this);\n        try {\n          function getTargetCommitment() {\n            let targetCommitment;\n            switch (connection.commitment) {\n              case 'confirmed':\n              case 'finalized':\n              case 'processed':\n                targetCommitment = connection.commitment;\n                break;\n              default:\n                targetCommitment = 'finalized';\n            }\n            let targetPreflightCommitment;\n            switch (options === null || options === void 0 ? void 0 : options.preflightCommitment) {\n              case 'confirmed':\n              case 'finalized':\n              case 'processed':\n                targetPreflightCommitment = options.preflightCommitment;\n                break;\n              case undefined:\n                targetPreflightCommitment = targetCommitment;\n                break;\n              default:\n                targetPreflightCommitment = 'finalized';\n            }\n            const preflightCommitmentScore = targetPreflightCommitment === 'finalized' ? 2 : targetPreflightCommitment === 'confirmed' ? 1 : 0;\n            const targetCommitmentScore = targetCommitment === 'finalized' ? 2 : targetCommitment === 'confirmed' ? 1 : 0;\n            return preflightCommitmentScore < targetCommitmentScore ? targetPreflightCommitment : targetCommitment;\n          }\n          if (SolanaSignAndSendTransaction in __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").features) {\n            const chain = chainOrClusterToChainId(__classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").currentAuthorization.chain);\n            const [signature] = (yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").features[SolanaSignAndSendTransaction].signAndSendTransaction({\n              account,\n              transaction: transaction.serialize(),\n              chain: chain,\n              options: options ? {\n                skipPreflight: options.skipPreflight,\n                maxRetries: options.maxRetries\n              } : undefined\n            })).map(output => {\n              return fromUint8Array(output.signature);\n            });\n            return signature;\n          } else {\n            const [signedTransaction] = yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_instances, \"m\", _BaseSolanaMobileWalletAdapter_performSignTransactions).call(this, [transaction]);\n            if (isVersionedTransaction(signedTransaction)) {\n              return yield connection.sendTransaction(signedTransaction);\n            } else {\n              const serializedTransaction = signedTransaction.serialize();\n              return yield connection.sendRawTransaction(serializedTransaction, Object.assign(Object.assign({}, options), {\n                preflightCommitment: getTargetCommitment()\n              }));\n            }\n          }\n        } catch (error) {\n          throw new WalletSendTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n        }\n      }));\n    });\n  }\n  signTransaction(transaction) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_instances, \"m\", _BaseSolanaMobileWalletAdapter_runWithGuard).call(this, () => __awaiter(this, void 0, void 0, function* () {\n        const [signedTransaction] = yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_instances, \"m\", _BaseSolanaMobileWalletAdapter_performSignTransactions).call(this, [transaction]);\n        return signedTransaction;\n      }));\n    });\n  }\n  signAllTransactions(transactions) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_instances, \"m\", _BaseSolanaMobileWalletAdapter_runWithGuard).call(this, () => __awaiter(this, void 0, void 0, function* () {\n        const signedTransactions = yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_instances, \"m\", _BaseSolanaMobileWalletAdapter_performSignTransactions).call(this, transactions);\n        return signedTransactions;\n      }));\n    });\n  }\n}\n_BaseSolanaMobileWalletAdapter_wallet = new WeakMap(), _BaseSolanaMobileWalletAdapter_connecting = new WeakMap(), _BaseSolanaMobileWalletAdapter_readyState = new WeakMap(), _BaseSolanaMobileWalletAdapter_accountSelector = new WeakMap(), _BaseSolanaMobileWalletAdapter_selectedAccount = new WeakMap(), _BaseSolanaMobileWalletAdapter_publicKey = new WeakMap(), _BaseSolanaMobileWalletAdapter_handleChangeEvent = new WeakMap(), _BaseSolanaMobileWalletAdapter_instances = new WeakSet(), _BaseSolanaMobileWalletAdapter_connect = function _BaseSolanaMobileWalletAdapter_connect(autoConnect = false) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (this.connecting || this.connected) {\n      return;\n    }\n    return yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_instances, \"m\", _BaseSolanaMobileWalletAdapter_runWithGuard).call(this, () => __awaiter(this, void 0, void 0, function* () {\n      if (__classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_readyState, \"f\") !== WalletReadyState.Installed && __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_readyState, \"f\") !== WalletReadyState.Loadable) {\n        throw new WalletNotReadyError();\n      }\n      __classPrivateFieldSet(this, _BaseSolanaMobileWalletAdapter_connecting, true, \"f\");\n      try {\n        yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").features[StandardConnect].connect({\n          silent: autoConnect\n        });\n      } catch (e) {\n        throw new WalletConnectionError(e instanceof Error && e.message || 'Unknown error', e);\n      } finally {\n        __classPrivateFieldSet(this, _BaseSolanaMobileWalletAdapter_connecting, false, \"f\");\n      }\n    }));\n  });\n}, _BaseSolanaMobileWalletAdapter_declareWalletAsInstalled = function _BaseSolanaMobileWalletAdapter_declareWalletAsInstalled() {\n  if (__classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_readyState, \"f\") !== WalletReadyState.Installed) {\n    this.emit('readyStateChange', __classPrivateFieldSet(this, _BaseSolanaMobileWalletAdapter_readyState, WalletReadyState.Installed, \"f\"));\n  }\n}, _BaseSolanaMobileWalletAdapter_assertIsAuthorized = function _BaseSolanaMobileWalletAdapter_assertIsAuthorized() {\n  if (!__classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").isAuthorized || !__classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_selectedAccount, \"f\")) throw new WalletNotConnectedError();\n  return __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_selectedAccount, \"f\");\n}, _BaseSolanaMobileWalletAdapter_performSignTransactions = function _BaseSolanaMobileWalletAdapter_performSignTransactions(transactions) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const account = __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_instances, \"m\", _BaseSolanaMobileWalletAdapter_assertIsAuthorized).call(this);\n    try {\n      if (SolanaSignTransaction in __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").features) {\n        return __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").features[SolanaSignTransaction].signTransaction(...transactions.map(value => {\n          return {\n            account,\n            transaction: value.serialize()\n          };\n        })).then(outputs => {\n          return outputs.map(output => {\n            const byteArray = output.signedTransaction;\n            const numSignatures = byteArray[0];\n            const messageOffset = numSignatures * SIGNATURE_LENGTH_IN_BYTES + 1;\n            const version = VersionedMessage.deserializeMessageVersion(byteArray.slice(messageOffset, byteArray.length));\n            if (version === 'legacy') {\n              return Transaction.from(byteArray);\n            } else {\n              return VersionedTransaction.deserialize(byteArray);\n            }\n          });\n        });\n      } else {\n        throw new Error('Connected wallet does not support signing transactions');\n      }\n    } catch (error) {\n      throw new WalletSignTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n    }\n  });\n}, _BaseSolanaMobileWalletAdapter_runWithGuard = function _BaseSolanaMobileWalletAdapter_runWithGuard(callback) {\n  return __awaiter(this, void 0, void 0, function* () {\n    try {\n      return yield callback();\n    } catch (e) {\n      this.emit('error', e);\n      throw e;\n    }\n  });\n};\nclass LocalSolanaMobileWalletAdapter extends BaseSolanaMobileWalletAdapter {\n  constructor(config) {\n    var _a;\n    const chain = chainOrClusterToChainId((_a = config.chain) !== null && _a !== void 0 ? _a : config.cluster);\n    super(new LocalSolanaMobileWalletAdapterWallet({\n      appIdentity: config.appIdentity,\n      authorizationCache: {\n        set: config.authorizationResultCache.set,\n        get: () => __awaiter(this, void 0, void 0, function* () {\n          const authorizationResult = yield config.authorizationResultCache.get();\n          if (authorizationResult && 'chain' in authorizationResult) {\n            return authorizationResult;\n          } else if (authorizationResult) {\n            return Object.assign(Object.assign({}, authorizationResult), {\n              chain: chain\n            });\n          } else return undefined;\n        }),\n        clear: config.authorizationResultCache.clear\n      },\n      chains: [chain],\n      chainSelector: createDefaultChainSelector(),\n      onWalletNotFound: () => __awaiter(this, void 0, void 0, function* () {\n        config.onWalletNotFound(this);\n      })\n    }), {\n      addressSelector: config.addressSelector,\n      chain: chain\n    });\n  }\n}\nclass RemoteSolanaMobileWalletAdapter extends BaseSolanaMobileWalletAdapter {\n  constructor(config) {\n    const chain = chainOrClusterToChainId(config.chain);\n    super(new RemoteSolanaMobileWalletAdapterWallet({\n      appIdentity: config.appIdentity,\n      authorizationCache: {\n        set: config.authorizationResultCache.set,\n        get: () => __awaiter(this, void 0, void 0, function* () {\n          const authorizationResult = yield config.authorizationResultCache.get();\n          if (authorizationResult && 'chain' in authorizationResult) {\n            return authorizationResult;\n          } else if (authorizationResult) {\n            return Object.assign(Object.assign({}, authorizationResult), {\n              chain: chain\n            });\n          } else return undefined;\n        }),\n        clear: config.authorizationResultCache.clear\n      },\n      chains: [chain],\n      chainSelector: createDefaultChainSelector(),\n      remoteHostAuthority: config.remoteHostAuthority,\n      onWalletNotFound: () => __awaiter(this, void 0, void 0, function* () {\n        config.onWalletNotFound(this);\n      })\n    }), {\n      addressSelector: config.addressSelector,\n      chain: chain\n    });\n  }\n}\nclass SolanaMobileWalletAdapter extends LocalSolanaMobileWalletAdapter {}\nfunction createDefaultAddressSelector() {\n  return {\n    select(addresses) {\n      return __awaiter(this, void 0, void 0, function* () {\n        return addresses[0];\n      });\n    }\n  };\n}\nfunction createDefaultAuthorizationResultCache() {\n  return createDefaultAuthorizationCache();\n}\nfunction defaultWalletNotFoundHandler(mobileWalletAdapter) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return defaultErrorModalWalletNotFoundHandler();\n  });\n}\nfunction createDefaultWalletNotFoundHandler() {\n  return defaultWalletNotFoundHandler;\n}\nexport { LocalSolanaMobileWalletAdapter, RemoteSolanaMobileWalletAdapter, SolanaMobileWalletAdapter, SolanaMobileWalletAdapterWalletName, createDefaultAddressSelector, createDefaultAuthorizationResultCache, createDefaultWalletNotFoundHandler };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}