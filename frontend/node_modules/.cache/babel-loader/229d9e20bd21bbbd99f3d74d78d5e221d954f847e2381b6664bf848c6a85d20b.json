{"ast":null,"code":"/** @internal */\nexport const promiseCache = /*#__PURE__*/new Map();\n/** @internal */\nexport const responseCache = /*#__PURE__*/new Map();\nexport function getCache(cacheKey) {\n  const buildCache = (cacheKey, cache) => ({\n    clear: () => cache.delete(cacheKey),\n    get: () => cache.get(cacheKey),\n    set: data => cache.set(cacheKey, data)\n  });\n  const promise = buildCache(cacheKey, promiseCache);\n  const response = buildCache(cacheKey, responseCache);\n  return {\n    clear: () => {\n      promise.clear();\n      response.clear();\n    },\n    promise,\n    response\n  };\n}\n/**\n * @description Returns the result of a given promise, and caches the result for\n * subsequent invocations against a provided cache key.\n */\nexport async function withCache(fn, {\n  cacheKey,\n  cacheTime = Number.POSITIVE_INFINITY\n}) {\n  const cache = getCache(cacheKey);\n  // If a response exists in the cache, and it's not expired, return it\n  // and do not invoke the promise.\n  // If the max age is 0, the cache is disabled.\n  const response = cache.response.get();\n  if (response && cacheTime > 0) {\n    const age = new Date().getTime() - response.created.getTime();\n    if (age < cacheTime) return response.data;\n  }\n  let promise = cache.promise.get();\n  if (!promise) {\n    promise = fn();\n    // Store the promise in the cache so that subsequent invocations\n    // will wait for the same promise to resolve (deduping).\n    cache.promise.set(promise);\n  }\n  try {\n    const data = await promise;\n    // Store the response in the cache so that subsequent invocations\n    // will return the same response.\n    cache.response.set({\n      created: new Date(),\n      data\n    });\n    return data;\n  } finally {\n    // Clear the promise cache so that subsequent invocations will\n    // invoke the promise again.\n    cache.promise.clear();\n  }\n}","map":{"version":3,"names":["promiseCache","Map","responseCache","getCache","cacheKey","buildCache","cache","clear","delete","get","set","data","promise","response","withCache","fn","cacheTime","Number","POSITIVE_INFINITY","age","Date","getTime","created"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@reown\\appkit\\node_modules\\@walletconnect\\utils\\node_modules\\viem\\utils\\promise\\withCache.ts"],"sourcesContent":["import type { ErrorType } from '../../errors/utils.js'\n\n/** @internal */\nexport const promiseCache = /*#__PURE__*/ new Map()\n/** @internal */\nexport const responseCache = /*#__PURE__*/ new Map()\n\nexport type GetCacheErrorType = ErrorType\n\nexport function getCache<data>(cacheKey: string) {\n  const buildCache = <data>(cacheKey: string, cache: Map<string, data>) => ({\n    clear: () => cache.delete(cacheKey),\n    get: () => cache.get(cacheKey),\n    set: (data: data) => cache.set(cacheKey, data),\n  })\n\n  const promise = buildCache<Promise<data>>(cacheKey, promiseCache)\n  const response = buildCache<{ created: Date; data: data }>(\n    cacheKey,\n    responseCache,\n  )\n\n  return {\n    clear: () => {\n      promise.clear()\n      response.clear()\n    },\n    promise,\n    response,\n  }\n}\n\ntype WithCacheParameters = {\n  /** The key to cache the data against. */\n  cacheKey: string\n  /** The time that cached data will remain in memory. Default: Infinity (no expiry) */\n  cacheTime?: number | undefined\n}\n\n/**\n * @description Returns the result of a given promise, and caches the result for\n * subsequent invocations against a provided cache key.\n */\nexport async function withCache<data>(\n  fn: () => Promise<data>,\n  { cacheKey, cacheTime = Number.POSITIVE_INFINITY }: WithCacheParameters,\n) {\n  const cache = getCache<data>(cacheKey)\n\n  // If a response exists in the cache, and it's not expired, return it\n  // and do not invoke the promise.\n  // If the max age is 0, the cache is disabled.\n  const response = cache.response.get()\n  if (response && cacheTime > 0) {\n    const age = new Date().getTime() - response.created.getTime()\n    if (age < cacheTime) return response.data\n  }\n\n  let promise = cache.promise.get()\n  if (!promise) {\n    promise = fn()\n\n    // Store the promise in the cache so that subsequent invocations\n    // will wait for the same promise to resolve (deduping).\n    cache.promise.set(promise)\n  }\n\n  try {\n    const data = await promise\n\n    // Store the response in the cache so that subsequent invocations\n    // will return the same response.\n    cache.response.set({ created: new Date(), data })\n\n    return data\n  } finally {\n    // Clear the promise cache so that subsequent invocations will\n    // invoke the promise again.\n    cache.promise.clear()\n  }\n}\n"],"mappings":"AAEA;AACA,OAAO,MAAMA,YAAY,GAAG,aAAc,IAAIC,GAAG,EAAE;AACnD;AACA,OAAO,MAAMC,aAAa,GAAG,aAAc,IAAID,GAAG,EAAE;AAIpD,OAAM,SAAUE,QAAQA,CAAOC,QAAgB;EAC7C,MAAMC,UAAU,GAAGA,CAAOD,QAAgB,EAAEE,KAAwB,MAAM;IACxEC,KAAK,EAAEA,CAAA,KAAMD,KAAK,CAACE,MAAM,CAACJ,QAAQ,CAAC;IACnCK,GAAG,EAAEA,CAAA,KAAMH,KAAK,CAACG,GAAG,CAACL,QAAQ,CAAC;IAC9BM,GAAG,EAAGC,IAAU,IAAKL,KAAK,CAACI,GAAG,CAACN,QAAQ,EAAEO,IAAI;GAC9C,CAAC;EAEF,MAAMC,OAAO,GAAGP,UAAU,CAAgBD,QAAQ,EAAEJ,YAAY,CAAC;EACjE,MAAMa,QAAQ,GAAGR,UAAU,CACzBD,QAAQ,EACRF,aAAa,CACd;EAED,OAAO;IACLK,KAAK,EAAEA,CAAA,KAAK;MACVK,OAAO,CAACL,KAAK,EAAE;MACfM,QAAQ,CAACN,KAAK,EAAE;IAClB,CAAC;IACDK,OAAO;IACPC;GACD;AACH;AASA;;;;AAIA,OAAO,eAAeC,SAASA,CAC7BC,EAAuB,EACvB;EAAEX,QAAQ;EAAEY,SAAS,GAAGC,MAAM,CAACC;AAAiB,CAAuB;EAEvE,MAAMZ,KAAK,GAAGH,QAAQ,CAAOC,QAAQ,CAAC;EAEtC;EACA;EACA;EACA,MAAMS,QAAQ,GAAGP,KAAK,CAACO,QAAQ,CAACJ,GAAG,EAAE;EACrC,IAAII,QAAQ,IAAIG,SAAS,GAAG,CAAC,EAAE;IAC7B,MAAMG,GAAG,GAAG,IAAIC,IAAI,EAAE,CAACC,OAAO,EAAE,GAAGR,QAAQ,CAACS,OAAO,CAACD,OAAO,EAAE;IAC7D,IAAIF,GAAG,GAAGH,SAAS,EAAE,OAAOH,QAAQ,CAACF,IAAI;EAC3C;EAEA,IAAIC,OAAO,GAAGN,KAAK,CAACM,OAAO,CAACH,GAAG,EAAE;EACjC,IAAI,CAACG,OAAO,EAAE;IACZA,OAAO,GAAGG,EAAE,EAAE;IAEd;IACA;IACAT,KAAK,CAACM,OAAO,CAACF,GAAG,CAACE,OAAO,CAAC;EAC5B;EAEA,IAAI;IACF,MAAMD,IAAI,GAAG,MAAMC,OAAO;IAE1B;IACA;IACAN,KAAK,CAACO,QAAQ,CAACH,GAAG,CAAC;MAAEY,OAAO,EAAE,IAAIF,IAAI,EAAE;MAAET;IAAI,CAAE,CAAC;IAEjD,OAAOA,IAAI;EACb,CAAC,SAAS;IACR;IACA;IACAL,KAAK,CAACM,OAAO,CAACL,KAAK,EAAE;EACvB;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}