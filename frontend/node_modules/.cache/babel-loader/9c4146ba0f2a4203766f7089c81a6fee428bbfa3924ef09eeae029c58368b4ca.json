{"ast":null,"code":"import { fromMiliseconds as bn } from \"@walletconnect/time\";\nimport { safeJsonParse as pn, safeJsonStringify as wn } from \"@walletconnect/safe-json\";\nfunction En(t) {\n  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === \"Uint8Array\";\n}\nfunction fe(t, ...e) {\n  if (!En(t)) throw new Error(\"Uint8Array expected\");\n  if (e.length > 0 && !e.includes(t.length)) throw new Error(\"Uint8Array expected of length \" + e + \", got length=\" + t.length);\n}\nfunction De(t, e = !0) {\n  if (t.destroyed) throw new Error(\"Hash instance has been destroyed\");\n  if (e && t.finished) throw new Error(\"Hash#digest() has already been called\");\n}\nfunction gn(t, e) {\n  fe(t);\n  const n = e.outputLen;\n  if (t.length < n) throw new Error(\"digestInto() expects output buffer of length at least \" + n);\n}\nconst it = typeof globalThis == \"object\" && \"crypto\" in globalThis ? globalThis.crypto : void 0; /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst _t = t => new DataView(t.buffer, t.byteOffset, t.byteLength);\nfunction yn(t) {\n  if (typeof t != \"string\") throw new Error(\"utf8ToBytes expected string, got \" + typeof t);\n  return new Uint8Array(new TextEncoder().encode(t));\n}\nfunction de(t) {\n  return typeof t == \"string\" && (t = yn(t)), fe(t), t;\n}\nclass xn {\n  clone() {\n    return this._cloneInto();\n  }\n}\nfunction Bn(t) {\n  const e = r => t().update(de(r)).digest(),\n    n = t();\n  return e.outputLen = n.outputLen, e.blockLen = n.blockLen, e.create = () => t(), e;\n}\nfunction he(t = 32) {\n  if (it && typeof it.getRandomValues == \"function\") return it.getRandomValues(new Uint8Array(t));\n  if (it && typeof it.randomBytes == \"function\") return it.randomBytes(t);\n  throw new Error(\"crypto.getRandomValues must be defined\");\n}\nfunction Cn(t, e, n, r) {\n  if (typeof t.setBigUint64 == \"function\") return t.setBigUint64(e, n, r);\n  const o = BigInt(32),\n    s = BigInt(4294967295),\n    a = Number(n >> o & s),\n    u = Number(n & s),\n    i = r ? 4 : 0,\n    D = r ? 0 : 4;\n  t.setUint32(e + i, a, r), t.setUint32(e + D, u, r);\n}\nclass An extends xn {\n  constructor(e, n, r, o) {\n    super(), this.blockLen = e, this.outputLen = n, this.padOffset = r, this.isLE = o, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = _t(this.buffer);\n  }\n  update(e) {\n    De(this);\n    const {\n      view: n,\n      buffer: r,\n      blockLen: o\n    } = this;\n    e = de(e);\n    const s = e.length;\n    for (let a = 0; a < s;) {\n      const u = Math.min(o - this.pos, s - a);\n      if (u === o) {\n        const i = _t(e);\n        for (; o <= s - a; a += o) this.process(i, a);\n        continue;\n      }\n      r.set(e.subarray(a, a + u), this.pos), this.pos += u, a += u, this.pos === o && (this.process(n, 0), this.pos = 0);\n    }\n    return this.length += e.length, this.roundClean(), this;\n  }\n  digestInto(e) {\n    De(this), gn(e, this), this.finished = !0;\n    const {\n      buffer: n,\n      view: r,\n      blockLen: o,\n      isLE: s\n    } = this;\n    let {\n      pos: a\n    } = this;\n    n[a++] = 128, this.buffer.subarray(a).fill(0), this.padOffset > o - a && (this.process(r, 0), a = 0);\n    for (let l = a; l < o; l++) n[l] = 0;\n    Cn(r, o - 8, BigInt(this.length * 8), s), this.process(r, 0);\n    const u = _t(e),\n      i = this.outputLen;\n    if (i % 4) throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n    const D = i / 4,\n      c = this.get();\n    if (D > c.length) throw new Error(\"_sha2: outputLen bigger than state\");\n    for (let l = 0; l < D; l++) u.setUint32(4 * l, c[l], s);\n  }\n  digest() {\n    const {\n      buffer: e,\n      outputLen: n\n    } = this;\n    this.digestInto(e);\n    const r = e.slice(0, n);\n    return this.destroy(), r;\n  }\n  _cloneInto(e) {\n    e || (e = new this.constructor()), e.set(...this.get());\n    const {\n      blockLen: n,\n      buffer: r,\n      length: o,\n      finished: s,\n      destroyed: a,\n      pos: u\n    } = this;\n    return e.length = o, e.pos = u, e.finished = s, e.destroyed = a, o % n && e.buffer.set(r), e;\n  }\n}\nconst wt = BigInt(2 ** 32 - 1),\n  St = BigInt(32);\nfunction le(t, e = !1) {\n  return e ? {\n    h: Number(t & wt),\n    l: Number(t >> St & wt)\n  } : {\n    h: Number(t >> St & wt) | 0,\n    l: Number(t & wt) | 0\n  };\n}\nfunction mn(t, e = !1) {\n  let n = new Uint32Array(t.length),\n    r = new Uint32Array(t.length);\n  for (let o = 0; o < t.length; o++) {\n    const {\n      h: s,\n      l: a\n    } = le(t[o], e);\n    [n[o], r[o]] = [s, a];\n  }\n  return [n, r];\n}\nconst _n = (t, e) => BigInt(t >>> 0) << St | BigInt(e >>> 0),\n  Sn = (t, e, n) => t >>> n,\n  vn = (t, e, n) => t << 32 - n | e >>> n,\n  In = (t, e, n) => t >>> n | e << 32 - n,\n  Un = (t, e, n) => t << 32 - n | e >>> n,\n  Tn = (t, e, n) => t << 64 - n | e >>> n - 32,\n  Fn = (t, e, n) => t >>> n - 32 | e << 64 - n,\n  Nn = (t, e) => e,\n  Ln = (t, e) => t,\n  On = (t, e, n) => t << n | e >>> 32 - n,\n  Hn = (t, e, n) => e << n | t >>> 32 - n,\n  zn = (t, e, n) => e << n - 32 | t >>> 64 - n,\n  Mn = (t, e, n) => t << n - 32 | e >>> 64 - n;\nfunction qn(t, e, n, r) {\n  const o = (e >>> 0) + (r >>> 0);\n  return {\n    h: t + n + (o / 2 ** 32 | 0) | 0,\n    l: o | 0\n  };\n}\nconst $n = (t, e, n) => (t >>> 0) + (e >>> 0) + (n >>> 0),\n  kn = (t, e, n, r) => e + n + r + (t / 2 ** 32 | 0) | 0,\n  Rn = (t, e, n, r) => (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0),\n  jn = (t, e, n, r, o) => e + n + r + o + (t / 2 ** 32 | 0) | 0,\n  Zn = (t, e, n, r, o) => (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0) + (o >>> 0),\n  Gn = (t, e, n, r, o, s) => e + n + r + o + s + (t / 2 ** 32 | 0) | 0,\n  x = {\n    fromBig: le,\n    split: mn,\n    toBig: _n,\n    shrSH: Sn,\n    shrSL: vn,\n    rotrSH: In,\n    rotrSL: Un,\n    rotrBH: Tn,\n    rotrBL: Fn,\n    rotr32H: Nn,\n    rotr32L: Ln,\n    rotlSH: On,\n    rotlSL: Hn,\n    rotlBH: zn,\n    rotlBL: Mn,\n    add: qn,\n    add3L: $n,\n    add3H: kn,\n    add4L: Rn,\n    add4H: jn,\n    add5H: Gn,\n    add5L: Zn\n  },\n  [Vn, Yn] = (() => x.split([\"0x428a2f98d728ae22\", \"0x7137449123ef65cd\", \"0xb5c0fbcfec4d3b2f\", \"0xe9b5dba58189dbbc\", \"0x3956c25bf348b538\", \"0x59f111f1b605d019\", \"0x923f82a4af194f9b\", \"0xab1c5ed5da6d8118\", \"0xd807aa98a3030242\", \"0x12835b0145706fbe\", \"0x243185be4ee4b28c\", \"0x550c7dc3d5ffb4e2\", \"0x72be5d74f27b896f\", \"0x80deb1fe3b1696b1\", \"0x9bdc06a725c71235\", \"0xc19bf174cf692694\", \"0xe49b69c19ef14ad2\", \"0xefbe4786384f25e3\", \"0x0fc19dc68b8cd5b5\", \"0x240ca1cc77ac9c65\", \"0x2de92c6f592b0275\", \"0x4a7484aa6ea6e483\", \"0x5cb0a9dcbd41fbd4\", \"0x76f988da831153b5\", \"0x983e5152ee66dfab\", \"0xa831c66d2db43210\", \"0xb00327c898fb213f\", \"0xbf597fc7beef0ee4\", \"0xc6e00bf33da88fc2\", \"0xd5a79147930aa725\", \"0x06ca6351e003826f\", \"0x142929670a0e6e70\", \"0x27b70a8546d22ffc\", \"0x2e1b21385c26c926\", \"0x4d2c6dfc5ac42aed\", \"0x53380d139d95b3df\", \"0x650a73548baf63de\", \"0x766a0abb3c77b2a8\", \"0x81c2c92e47edaee6\", \"0x92722c851482353b\", \"0xa2bfe8a14cf10364\", \"0xa81a664bbc423001\", \"0xc24b8b70d0f89791\", \"0xc76c51a30654be30\", \"0xd192e819d6ef5218\", \"0xd69906245565a910\", \"0xf40e35855771202a\", \"0x106aa07032bbd1b8\", \"0x19a4c116b8d2d0c8\", \"0x1e376c085141ab53\", \"0x2748774cdf8eeb99\", \"0x34b0bcb5e19b48a8\", \"0x391c0cb3c5c95a63\", \"0x4ed8aa4ae3418acb\", \"0x5b9cca4f7763e373\", \"0x682e6ff3d6b2b8a3\", \"0x748f82ee5defb2fc\", \"0x78a5636f43172f60\", \"0x84c87814a1f0ab72\", \"0x8cc702081a6439ec\", \"0x90befffa23631e28\", \"0xa4506cebde82bde9\", \"0xbef9a3f7b2c67915\", \"0xc67178f2e372532b\", \"0xca273eceea26619c\", \"0xd186b8c721c0c207\", \"0xeada7dd6cde0eb1e\", \"0xf57d4f7fee6ed178\", \"0x06f067aa72176fba\", \"0x0a637dc5a2c898a6\", \"0x113f9804bef90dae\", \"0x1b710b35131c471b\", \"0x28db77f523047d84\", \"0x32caab7b40c72493\", \"0x3c9ebe0a15c9bebc\", \"0x431d67c49c100d4c\", \"0x4cc5d4becb3e42b6\", \"0x597f299cfc657e2a\", \"0x5fcb6fab3ad6faec\", \"0x6c44198c4a475817\"].map(t => BigInt(t))))(),\n  P = new Uint32Array(80),\n  Q = new Uint32Array(80);\nclass Jn extends An {\n  constructor() {\n    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;\n  }\n  get() {\n    const {\n      Ah: e,\n      Al: n,\n      Bh: r,\n      Bl: o,\n      Ch: s,\n      Cl: a,\n      Dh: u,\n      Dl: i,\n      Eh: D,\n      El: c,\n      Fh: l,\n      Fl: p,\n      Gh: w,\n      Gl: h,\n      Hh: g,\n      Hl: S\n    } = this;\n    return [e, n, r, o, s, a, u, i, D, c, l, p, w, h, g, S];\n  }\n  set(e, n, r, o, s, a, u, i, D, c, l, p, w, h, g, S) {\n    this.Ah = e | 0, this.Al = n | 0, this.Bh = r | 0, this.Bl = o | 0, this.Ch = s | 0, this.Cl = a | 0, this.Dh = u | 0, this.Dl = i | 0, this.Eh = D | 0, this.El = c | 0, this.Fh = l | 0, this.Fl = p | 0, this.Gh = w | 0, this.Gl = h | 0, this.Hh = g | 0, this.Hl = S | 0;\n  }\n  process(e, n) {\n    for (let d = 0; d < 16; d++, n += 4) P[d] = e.getUint32(n), Q[d] = e.getUint32(n += 4);\n    for (let d = 16; d < 80; d++) {\n      const m = P[d - 15] | 0,\n        F = Q[d - 15] | 0,\n        q = x.rotrSH(m, F, 1) ^ x.rotrSH(m, F, 8) ^ x.shrSH(m, F, 7),\n        z = x.rotrSL(m, F, 1) ^ x.rotrSL(m, F, 8) ^ x.shrSL(m, F, 7),\n        I = P[d - 2] | 0,\n        O = Q[d - 2] | 0,\n        ot = x.rotrSH(I, O, 19) ^ x.rotrBH(I, O, 61) ^ x.shrSH(I, O, 6),\n        tt = x.rotrSL(I, O, 19) ^ x.rotrBL(I, O, 61) ^ x.shrSL(I, O, 6),\n        st = x.add4L(z, tt, Q[d - 7], Q[d - 16]),\n        at = x.add4H(st, q, ot, P[d - 7], P[d - 16]);\n      P[d] = at | 0, Q[d] = st | 0;\n    }\n    let {\n      Ah: r,\n      Al: o,\n      Bh: s,\n      Bl: a,\n      Ch: u,\n      Cl: i,\n      Dh: D,\n      Dl: c,\n      Eh: l,\n      El: p,\n      Fh: w,\n      Fl: h,\n      Gh: g,\n      Gl: S,\n      Hh: v,\n      Hl: L\n    } = this;\n    for (let d = 0; d < 80; d++) {\n      const m = x.rotrSH(l, p, 14) ^ x.rotrSH(l, p, 18) ^ x.rotrBH(l, p, 41),\n        F = x.rotrSL(l, p, 14) ^ x.rotrSL(l, p, 18) ^ x.rotrBL(l, p, 41),\n        q = l & w ^ ~l & g,\n        z = p & h ^ ~p & S,\n        I = x.add5L(L, F, z, Yn[d], Q[d]),\n        O = x.add5H(I, v, m, q, Vn[d], P[d]),\n        ot = I | 0,\n        tt = x.rotrSH(r, o, 28) ^ x.rotrBH(r, o, 34) ^ x.rotrBH(r, o, 39),\n        st = x.rotrSL(r, o, 28) ^ x.rotrBL(r, o, 34) ^ x.rotrBL(r, o, 39),\n        at = r & s ^ r & u ^ s & u,\n        Ct = o & a ^ o & i ^ a & i;\n      v = g | 0, L = S | 0, g = w | 0, S = h | 0, w = l | 0, h = p | 0, {\n        h: l,\n        l: p\n      } = x.add(D | 0, c | 0, O | 0, ot | 0), D = u | 0, c = i | 0, u = s | 0, i = a | 0, s = r | 0, a = o | 0;\n      const At = x.add3L(ot, st, Ct);\n      r = x.add3H(At, O, tt, at), o = At | 0;\n    }\n    ({\n      h: r,\n      l: o\n    } = x.add(this.Ah | 0, this.Al | 0, r | 0, o | 0)), {\n      h: s,\n      l: a\n    } = x.add(this.Bh | 0, this.Bl | 0, s | 0, a | 0), {\n      h: u,\n      l: i\n    } = x.add(this.Ch | 0, this.Cl | 0, u | 0, i | 0), {\n      h: D,\n      l: c\n    } = x.add(this.Dh | 0, this.Dl | 0, D | 0, c | 0), {\n      h: l,\n      l: p\n    } = x.add(this.Eh | 0, this.El | 0, l | 0, p | 0), {\n      h: w,\n      l: h\n    } = x.add(this.Fh | 0, this.Fl | 0, w | 0, h | 0), {\n      h: g,\n      l: S\n    } = x.add(this.Gh | 0, this.Gl | 0, g | 0, S | 0), {\n      h: v,\n      l: L\n    } = x.add(this.Hh | 0, this.Hl | 0, v | 0, L | 0), this.set(r, o, s, a, u, i, D, c, l, p, w, h, g, S, v, L);\n  }\n  roundClean() {\n    P.fill(0), Q.fill(0);\n  }\n  destroy() {\n    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\nconst Kn = Bn(() => new Jn()); /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst vt = BigInt(0),\n  be = BigInt(1),\n  Wn = BigInt(2);\nfunction It(t) {\n  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === \"Uint8Array\";\n}\nfunction Ut(t) {\n  if (!It(t)) throw new Error(\"Uint8Array expected\");\n}\nfunction Tt(t, e) {\n  if (typeof e != \"boolean\") throw new Error(t + \" boolean expected, got \" + e);\n}\nconst Xn = Array.from({\n  length: 256\n}, (t, e) => e.toString(16).padStart(2, \"0\"));\nfunction Ft(t) {\n  Ut(t);\n  let e = \"\";\n  for (let n = 0; n < t.length; n++) e += Xn[t[n]];\n  return e;\n}\nfunction pe(t) {\n  if (typeof t != \"string\") throw new Error(\"hex string expected, got \" + typeof t);\n  return t === \"\" ? vt : BigInt(\"0x\" + t);\n}\nconst K = {\n  _0: 48,\n  _9: 57,\n  A: 65,\n  F: 70,\n  a: 97,\n  f: 102\n};\nfunction we(t) {\n  if (t >= K._0 && t <= K._9) return t - K._0;\n  if (t >= K.A && t <= K.F) return t - (K.A - 10);\n  if (t >= K.a && t <= K.f) return t - (K.a - 10);\n}\nfunction Ee(t) {\n  if (typeof t != \"string\") throw new Error(\"hex string expected, got \" + typeof t);\n  const e = t.length,\n    n = e / 2;\n  if (e % 2) throw new Error(\"hex string expected, got unpadded hex of length \" + e);\n  const r = new Uint8Array(n);\n  for (let o = 0, s = 0; o < n; o++, s += 2) {\n    const a = we(t.charCodeAt(s)),\n      u = we(t.charCodeAt(s + 1));\n    if (a === void 0 || u === void 0) {\n      const i = t[s] + t[s + 1];\n      throw new Error('hex string expected, got non-hex character \"' + i + '\" at index ' + s);\n    }\n    r[o] = a * 16 + u;\n  }\n  return r;\n}\nfunction Pn(t) {\n  return pe(Ft(t));\n}\nfunction Et(t) {\n  return Ut(t), pe(Ft(Uint8Array.from(t).reverse()));\n}\nfunction ge(t, e) {\n  return Ee(t.toString(16).padStart(e * 2, \"0\"));\n}\nfunction Nt(t, e) {\n  return ge(t, e).reverse();\n}\nfunction W(t, e, n) {\n  let r;\n  if (typeof e == \"string\") try {\n    r = Ee(e);\n  } catch (s) {\n    throw new Error(t + \" must be hex string or Uint8Array, cause: \" + s);\n  } else if (It(e)) r = Uint8Array.from(e);else throw new Error(t + \" must be hex string or Uint8Array\");\n  const o = r.length;\n  if (typeof n == \"number\" && o !== n) throw new Error(t + \" of length \" + n + \" expected, got \" + o);\n  return r;\n}\nfunction ye(...t) {\n  let e = 0;\n  for (let r = 0; r < t.length; r++) {\n    const o = t[r];\n    Ut(o), e += o.length;\n  }\n  const n = new Uint8Array(e);\n  for (let r = 0, o = 0; r < t.length; r++) {\n    const s = t[r];\n    n.set(s, o), o += s.length;\n  }\n  return n;\n}\nconst Lt = t => typeof t == \"bigint\" && vt <= t;\nfunction Qn(t, e, n) {\n  return Lt(t) && Lt(e) && Lt(n) && e <= t && t < n;\n}\nfunction ft(t, e, n, r) {\n  if (!Qn(e, n, r)) throw new Error(\"expected valid \" + t + \": \" + n + \" <= n < \" + r + \", got \" + e);\n}\nfunction tr(t) {\n  let e;\n  for (e = 0; t > vt; t >>= be, e += 1);\n  return e;\n}\nconst er = t => (Wn << BigInt(t - 1)) - be,\n  nr = {\n    bigint: t => typeof t == \"bigint\",\n    function: t => typeof t == \"function\",\n    boolean: t => typeof t == \"boolean\",\n    string: t => typeof t == \"string\",\n    stringOrUint8Array: t => typeof t == \"string\" || It(t),\n    isSafeInteger: t => Number.isSafeInteger(t),\n    array: t => Array.isArray(t),\n    field: (t, e) => e.Fp.isValid(t),\n    hash: t => typeof t == \"function\" && Number.isSafeInteger(t.outputLen)\n  };\nfunction Ot(t, e, n = {}) {\n  const r = (o, s, a) => {\n    const u = nr[s];\n    if (typeof u != \"function\") throw new Error(\"invalid validator function\");\n    const i = t[o];\n    if (!(a && i === void 0) && !u(i, t)) throw new Error(\"param \" + String(o) + \" is invalid. Expected \" + s + \", got \" + i);\n  };\n  for (const [o, s] of Object.entries(e)) r(o, s, !1);\n  for (const [o, s] of Object.entries(n)) r(o, s, !0);\n  return t;\n}\nfunction xe(t) {\n  const e = new WeakMap();\n  return (n, ...r) => {\n    const o = e.get(n);\n    if (o !== void 0) return o;\n    const s = t(n, ...r);\n    return e.set(n, s), s;\n  };\n}\nconst M = BigInt(0),\n  N = BigInt(1),\n  nt = BigInt(2),\n  rr = BigInt(3),\n  Ht = BigInt(4),\n  Be = BigInt(5),\n  Ce = BigInt(8);\nfunction H(t, e) {\n  const n = t % e;\n  return n >= M ? n : e + n;\n}\nfunction or(t, e, n) {\n  if (e < M) throw new Error(\"invalid exponent, negatives unsupported\");\n  if (n <= M) throw new Error(\"invalid modulus\");\n  if (n === N) return M;\n  let r = N;\n  for (; e > M;) e & N && (r = r * t % n), t = t * t % n, e >>= N;\n  return r;\n}\nfunction J(t, e, n) {\n  let r = t;\n  for (; e-- > M;) r *= r, r %= n;\n  return r;\n}\nfunction Ae(t, e) {\n  if (t === M) throw new Error(\"invert: expected non-zero number\");\n  if (e <= M) throw new Error(\"invert: expected positive modulus, got \" + e);\n  let n = H(t, e),\n    r = e,\n    o = M,\n    s = N;\n  for (; n !== M;) {\n    const u = r / n,\n      i = r % n,\n      D = o - s * u;\n    r = n, n = i, o = s, s = D;\n  }\n  if (r !== N) throw new Error(\"invert: does not exist\");\n  return H(o, e);\n}\nfunction sr(t) {\n  const e = (t - N) / nt;\n  let n, r, o;\n  for (n = t - N, r = 0; n % nt === M; n /= nt, r++);\n  for (o = nt; o < t && or(o, e, t) !== t - N; o++) if (o > 1e3) throw new Error(\"Cannot find square root: likely non-prime P\");\n  if (r === 1) {\n    const a = (t + N) / Ht;\n    return function (i, D) {\n      const c = i.pow(D, a);\n      if (!i.eql(i.sqr(c), D)) throw new Error(\"Cannot find square root\");\n      return c;\n    };\n  }\n  const s = (n + N) / nt;\n  return function (u, i) {\n    if (u.pow(i, e) === u.neg(u.ONE)) throw new Error(\"Cannot find square root\");\n    let D = r,\n      c = u.pow(u.mul(u.ONE, o), n),\n      l = u.pow(i, s),\n      p = u.pow(i, n);\n    for (; !u.eql(p, u.ONE);) {\n      if (u.eql(p, u.ZERO)) return u.ZERO;\n      let w = 1;\n      for (let g = u.sqr(p); w < D && !u.eql(g, u.ONE); w++) g = u.sqr(g);\n      const h = u.pow(c, N << BigInt(D - w - 1));\n      c = u.sqr(h), l = u.mul(l, h), p = u.mul(p, c), D = w;\n    }\n    return l;\n  };\n}\nfunction ir(t) {\n  if (t % Ht === rr) {\n    const e = (t + N) / Ht;\n    return function (r, o) {\n      const s = r.pow(o, e);\n      if (!r.eql(r.sqr(s), o)) throw new Error(\"Cannot find square root\");\n      return s;\n    };\n  }\n  if (t % Ce === Be) {\n    const e = (t - Be) / Ce;\n    return function (r, o) {\n      const s = r.mul(o, nt),\n        a = r.pow(s, e),\n        u = r.mul(o, a),\n        i = r.mul(r.mul(u, nt), a),\n        D = r.mul(u, r.sub(i, r.ONE));\n      if (!r.eql(r.sqr(D), o)) throw new Error(\"Cannot find square root\");\n      return D;\n    };\n  }\n  return sr(t);\n}\nconst ur = (t, e) => (H(t, e) & N) === N,\n  cr = [\"create\", \"isValid\", \"is0\", \"neg\", \"inv\", \"sqrt\", \"sqr\", \"eql\", \"add\", \"sub\", \"mul\", \"pow\", \"div\", \"addN\", \"subN\", \"mulN\", \"sqrN\"];\nfunction ar(t) {\n  const e = {\n      ORDER: \"bigint\",\n      MASK: \"bigint\",\n      BYTES: \"isSafeInteger\",\n      BITS: \"isSafeInteger\"\n    },\n    n = cr.reduce((r, o) => (r[o] = \"function\", r), e);\n  return Ot(t, n);\n}\nfunction fr(t, e, n) {\n  if (n < M) throw new Error(\"invalid exponent, negatives unsupported\");\n  if (n === M) return t.ONE;\n  if (n === N) return e;\n  let r = t.ONE,\n    o = e;\n  for (; n > M;) n & N && (r = t.mul(r, o)), o = t.sqr(o), n >>= N;\n  return r;\n}\nfunction Dr(t, e) {\n  const n = new Array(e.length),\n    r = e.reduce((s, a, u) => t.is0(a) ? s : (n[u] = s, t.mul(s, a)), t.ONE),\n    o = t.inv(r);\n  return e.reduceRight((s, a, u) => t.is0(a) ? s : (n[u] = t.mul(s, n[u]), t.mul(s, a)), o), n;\n}\nfunction me(t, e) {\n  const n = e !== void 0 ? e : t.toString(2).length,\n    r = Math.ceil(n / 8);\n  return {\n    nBitLength: n,\n    nByteLength: r\n  };\n}\nfunction _e(t, e, n = !1, r = {}) {\n  if (t <= M) throw new Error(\"invalid field: expected ORDER > 0, got \" + t);\n  const {\n    nBitLength: o,\n    nByteLength: s\n  } = me(t, e);\n  if (s > 2048) throw new Error(\"invalid field: expected ORDER of <= 2048 bytes\");\n  let a;\n  const u = Object.freeze({\n    ORDER: t,\n    isLE: n,\n    BITS: o,\n    BYTES: s,\n    MASK: er(o),\n    ZERO: M,\n    ONE: N,\n    create: i => H(i, t),\n    isValid: i => {\n      if (typeof i != \"bigint\") throw new Error(\"invalid field element: expected bigint, got \" + typeof i);\n      return M <= i && i < t;\n    },\n    is0: i => i === M,\n    isOdd: i => (i & N) === N,\n    neg: i => H(-i, t),\n    eql: (i, D) => i === D,\n    sqr: i => H(i * i, t),\n    add: (i, D) => H(i + D, t),\n    sub: (i, D) => H(i - D, t),\n    mul: (i, D) => H(i * D, t),\n    pow: (i, D) => fr(u, i, D),\n    div: (i, D) => H(i * Ae(D, t), t),\n    sqrN: i => i * i,\n    addN: (i, D) => i + D,\n    subN: (i, D) => i - D,\n    mulN: (i, D) => i * D,\n    inv: i => Ae(i, t),\n    sqrt: r.sqrt || (i => (a || (a = ir(t)), a(u, i))),\n    invertBatch: i => Dr(u, i),\n    cmov: (i, D, c) => c ? D : i,\n    toBytes: i => n ? Nt(i, s) : ge(i, s),\n    fromBytes: i => {\n      if (i.length !== s) throw new Error(\"Field.fromBytes: expected \" + s + \" bytes, got \" + i.length);\n      return n ? Et(i) : Pn(i);\n    }\n  });\n  return Object.freeze(u);\n}\nconst Se = BigInt(0),\n  gt = BigInt(1);\nfunction zt(t, e) {\n  const n = e.negate();\n  return t ? n : e;\n}\nfunction ve(t, e) {\n  if (!Number.isSafeInteger(t) || t <= 0 || t > e) throw new Error(\"invalid window size, expected [1..\" + e + \"], got W=\" + t);\n}\nfunction Mt(t, e) {\n  ve(t, e);\n  const n = Math.ceil(e / t) + 1,\n    r = 2 ** (t - 1);\n  return {\n    windows: n,\n    windowSize: r\n  };\n}\nfunction dr(t, e) {\n  if (!Array.isArray(t)) throw new Error(\"array expected\");\n  t.forEach((n, r) => {\n    if (!(n instanceof e)) throw new Error(\"invalid point at index \" + r);\n  });\n}\nfunction hr(t, e) {\n  if (!Array.isArray(t)) throw new Error(\"array of scalars expected\");\n  t.forEach((n, r) => {\n    if (!e.isValid(n)) throw new Error(\"invalid scalar at index \" + r);\n  });\n}\nconst qt = new WeakMap(),\n  Ie = new WeakMap();\nfunction $t(t) {\n  return Ie.get(t) || 1;\n}\nfunction lr(t, e) {\n  return {\n    constTimeNegate: zt,\n    hasPrecomputes(n) {\n      return $t(n) !== 1;\n    },\n    unsafeLadder(n, r, o = t.ZERO) {\n      let s = n;\n      for (; r > Se;) r & gt && (o = o.add(s)), s = s.double(), r >>= gt;\n      return o;\n    },\n    precomputeWindow(n, r) {\n      const {\n          windows: o,\n          windowSize: s\n        } = Mt(r, e),\n        a = [];\n      let u = n,\n        i = u;\n      for (let D = 0; D < o; D++) {\n        i = u, a.push(i);\n        for (let c = 1; c < s; c++) i = i.add(u), a.push(i);\n        u = i.double();\n      }\n      return a;\n    },\n    wNAF(n, r, o) {\n      const {\n        windows: s,\n        windowSize: a\n      } = Mt(n, e);\n      let u = t.ZERO,\n        i = t.BASE;\n      const D = BigInt(2 ** n - 1),\n        c = 2 ** n,\n        l = BigInt(n);\n      for (let p = 0; p < s; p++) {\n        const w = p * a;\n        let h = Number(o & D);\n        o >>= l, h > a && (h -= c, o += gt);\n        const g = w,\n          S = w + Math.abs(h) - 1,\n          v = p % 2 !== 0,\n          L = h < 0;\n        h === 0 ? i = i.add(zt(v, r[g])) : u = u.add(zt(L, r[S]));\n      }\n      return {\n        p: u,\n        f: i\n      };\n    },\n    wNAFUnsafe(n, r, o, s = t.ZERO) {\n      const {\n          windows: a,\n          windowSize: u\n        } = Mt(n, e),\n        i = BigInt(2 ** n - 1),\n        D = 2 ** n,\n        c = BigInt(n);\n      for (let l = 0; l < a; l++) {\n        const p = l * u;\n        if (o === Se) break;\n        let w = Number(o & i);\n        if (o >>= c, w > u && (w -= D, o += gt), w === 0) continue;\n        let h = r[p + Math.abs(w) - 1];\n        w < 0 && (h = h.negate()), s = s.add(h);\n      }\n      return s;\n    },\n    getPrecomputes(n, r, o) {\n      let s = qt.get(r);\n      return s || (s = this.precomputeWindow(r, n), n !== 1 && qt.set(r, o(s))), s;\n    },\n    wNAFCached(n, r, o) {\n      const s = $t(n);\n      return this.wNAF(s, this.getPrecomputes(s, n, o), r);\n    },\n    wNAFCachedUnsafe(n, r, o, s) {\n      const a = $t(n);\n      return a === 1 ? this.unsafeLadder(n, r, s) : this.wNAFUnsafe(a, this.getPrecomputes(a, n, o), r, s);\n    },\n    setWindowSize(n, r) {\n      ve(r, e), Ie.set(n, r), qt.delete(n);\n    }\n  };\n}\nfunction br(t, e, n, r) {\n  if (dr(n, t), hr(r, e), n.length !== r.length) throw new Error(\"arrays of points and scalars must have equal length\");\n  const o = t.ZERO,\n    s = tr(BigInt(n.length)),\n    a = s > 12 ? s - 3 : s > 4 ? s - 2 : s ? 2 : 1,\n    u = (1 << a) - 1,\n    i = new Array(u + 1).fill(o),\n    D = Math.floor((e.BITS - 1) / a) * a;\n  let c = o;\n  for (let l = D; l >= 0; l -= a) {\n    i.fill(o);\n    for (let w = 0; w < r.length; w++) {\n      const h = r[w],\n        g = Number(h >> BigInt(l) & BigInt(u));\n      i[g] = i[g].add(n[w]);\n    }\n    let p = o;\n    for (let w = i.length - 1, h = o; w > 0; w--) h = h.add(i[w]), p = p.add(h);\n    if (c = c.add(p), l !== 0) for (let w = 0; w < a; w++) c = c.double();\n  }\n  return c;\n}\nfunction pr(t) {\n  return ar(t.Fp), Ot(t, {\n    n: \"bigint\",\n    h: \"bigint\",\n    Gx: \"field\",\n    Gy: \"field\"\n  }, {\n    nBitLength: \"isSafeInteger\",\n    nByteLength: \"isSafeInteger\"\n  }), Object.freeze({\n    ...me(t.n, t.nBitLength),\n    ...t,\n    p: t.Fp.ORDER\n  });\n}\nconst G = BigInt(0),\n  j = BigInt(1),\n  yt = BigInt(2),\n  wr = BigInt(8),\n  Er = {\n    zip215: !0\n  };\nfunction gr(t) {\n  const e = pr(t);\n  return Ot(t, {\n    hash: \"function\",\n    a: \"bigint\",\n    d: \"bigint\",\n    randomBytes: \"function\"\n  }, {\n    adjustScalarBytes: \"function\",\n    domain: \"function\",\n    uvRatio: \"function\",\n    mapToCurve: \"function\"\n  }), Object.freeze({\n    ...e\n  });\n}\nfunction yr(t) {\n  const e = gr(t),\n    {\n      Fp: n,\n      n: r,\n      prehash: o,\n      hash: s,\n      randomBytes: a,\n      nByteLength: u,\n      h: i\n    } = e,\n    D = yt << BigInt(u * 8) - j,\n    c = n.create,\n    l = _e(e.n, e.nBitLength),\n    p = e.uvRatio || ((y, f) => {\n      try {\n        return {\n          isValid: !0,\n          value: n.sqrt(y * n.inv(f))\n        };\n      } catch {\n        return {\n          isValid: !1,\n          value: G\n        };\n      }\n    }),\n    w = e.adjustScalarBytes || (y => y),\n    h = e.domain || ((y, f, b) => {\n      if (Tt(\"phflag\", b), f.length || b) throw new Error(\"Contexts/pre-hash are not supported\");\n      return y;\n    });\n  function g(y, f) {\n    ft(\"coordinate \" + y, f, G, D);\n  }\n  function S(y) {\n    if (!(y instanceof d)) throw new Error(\"ExtendedPoint expected\");\n  }\n  const v = xe((y, f) => {\n      const {\n          ex: b,\n          ey: E,\n          ez: B\n        } = y,\n        C = y.is0();\n      f == null && (f = C ? wr : n.inv(B));\n      const A = c(b * f),\n        U = c(E * f),\n        _ = c(B * f);\n      if (C) return {\n        x: G,\n        y: j\n      };\n      if (_ !== j) throw new Error(\"invZ was invalid\");\n      return {\n        x: A,\n        y: U\n      };\n    }),\n    L = xe(y => {\n      const {\n        a: f,\n        d: b\n      } = e;\n      if (y.is0()) throw new Error(\"bad point: ZERO\");\n      const {\n          ex: E,\n          ey: B,\n          ez: C,\n          et: A\n        } = y,\n        U = c(E * E),\n        _ = c(B * B),\n        T = c(C * C),\n        $ = c(T * T),\n        R = c(U * f),\n        V = c(T * c(R + _)),\n        Y = c($ + c(b * c(U * _)));\n      if (V !== Y) throw new Error(\"bad point: equation left != right (1)\");\n      const Z = c(E * B),\n        X = c(C * A);\n      if (Z !== X) throw new Error(\"bad point: equation left != right (2)\");\n      return !0;\n    });\n  class d {\n    constructor(f, b, E, B) {\n      this.ex = f, this.ey = b, this.ez = E, this.et = B, g(\"x\", f), g(\"y\", b), g(\"z\", E), g(\"t\", B), Object.freeze(this);\n    }\n    get x() {\n      return this.toAffine().x;\n    }\n    get y() {\n      return this.toAffine().y;\n    }\n    static fromAffine(f) {\n      if (f instanceof d) throw new Error(\"extended point not allowed\");\n      const {\n        x: b,\n        y: E\n      } = f || {};\n      return g(\"x\", b), g(\"y\", E), new d(b, E, j, c(b * E));\n    }\n    static normalizeZ(f) {\n      const b = n.invertBatch(f.map(E => E.ez));\n      return f.map((E, B) => E.toAffine(b[B])).map(d.fromAffine);\n    }\n    static msm(f, b) {\n      return br(d, l, f, b);\n    }\n    _setWindowSize(f) {\n      q.setWindowSize(this, f);\n    }\n    assertValidity() {\n      L(this);\n    }\n    equals(f) {\n      S(f);\n      const {\n          ex: b,\n          ey: E,\n          ez: B\n        } = this,\n        {\n          ex: C,\n          ey: A,\n          ez: U\n        } = f,\n        _ = c(b * U),\n        T = c(C * B),\n        $ = c(E * U),\n        R = c(A * B);\n      return _ === T && $ === R;\n    }\n    is0() {\n      return this.equals(d.ZERO);\n    }\n    negate() {\n      return new d(c(-this.ex), this.ey, this.ez, c(-this.et));\n    }\n    double() {\n      const {\n          a: f\n        } = e,\n        {\n          ex: b,\n          ey: E,\n          ez: B\n        } = this,\n        C = c(b * b),\n        A = c(E * E),\n        U = c(yt * c(B * B)),\n        _ = c(f * C),\n        T = b + E,\n        $ = c(c(T * T) - C - A),\n        R = _ + A,\n        V = R - U,\n        Y = _ - A,\n        Z = c($ * V),\n        X = c(R * Y),\n        et = c($ * Y),\n        pt = c(V * R);\n      return new d(Z, X, pt, et);\n    }\n    add(f) {\n      S(f);\n      const {\n          a: b,\n          d: E\n        } = e,\n        {\n          ex: B,\n          ey: C,\n          ez: A,\n          et: U\n        } = this,\n        {\n          ex: _,\n          ey: T,\n          ez: $,\n          et: R\n        } = f;\n      if (b === BigInt(-1)) {\n        const re = c((C - B) * (T + _)),\n          oe = c((C + B) * (T - _)),\n          mt = c(oe - re);\n        if (mt === G) return this.double();\n        const se = c(A * yt * R),\n          ie = c(U * yt * $),\n          ue = ie + se,\n          ce = oe + re,\n          ae = ie - se,\n          Dn = c(ue * mt),\n          dn = c(ce * ae),\n          hn = c(ue * ae),\n          ln = c(mt * ce);\n        return new d(Dn, dn, ln, hn);\n      }\n      const V = c(B * _),\n        Y = c(C * T),\n        Z = c(U * E * R),\n        X = c(A * $),\n        et = c((B + C) * (_ + T) - V - Y),\n        pt = X - Z,\n        ee = X + Z,\n        ne = c(Y - b * V),\n        un = c(et * pt),\n        cn = c(ee * ne),\n        an = c(et * ne),\n        fn = c(pt * ee);\n      return new d(un, cn, fn, an);\n    }\n    subtract(f) {\n      return this.add(f.negate());\n    }\n    wNAF(f) {\n      return q.wNAFCached(this, f, d.normalizeZ);\n    }\n    multiply(f) {\n      const b = f;\n      ft(\"scalar\", b, j, r);\n      const {\n        p: E,\n        f: B\n      } = this.wNAF(b);\n      return d.normalizeZ([E, B])[0];\n    }\n    multiplyUnsafe(f, b = d.ZERO) {\n      const E = f;\n      return ft(\"scalar\", E, G, r), E === G ? F : this.is0() || E === j ? this : q.wNAFCachedUnsafe(this, E, d.normalizeZ, b);\n    }\n    isSmallOrder() {\n      return this.multiplyUnsafe(i).is0();\n    }\n    isTorsionFree() {\n      return q.unsafeLadder(this, r).is0();\n    }\n    toAffine(f) {\n      return v(this, f);\n    }\n    clearCofactor() {\n      const {\n        h: f\n      } = e;\n      return f === j ? this : this.multiplyUnsafe(f);\n    }\n    static fromHex(f, b = !1) {\n      const {\n          d: E,\n          a: B\n        } = e,\n        C = n.BYTES;\n      f = W(\"pointHex\", f, C), Tt(\"zip215\", b);\n      const A = f.slice(),\n        U = f[C - 1];\n      A[C - 1] = U & -129;\n      const _ = Et(A),\n        T = b ? D : n.ORDER;\n      ft(\"pointHex.y\", _, G, T);\n      const $ = c(_ * _),\n        R = c($ - j),\n        V = c(E * $ - B);\n      let {\n        isValid: Y,\n        value: Z\n      } = p(R, V);\n      if (!Y) throw new Error(\"Point.fromHex: invalid y coordinate\");\n      const X = (Z & j) === j,\n        et = (U & 128) !== 0;\n      if (!b && Z === G && et) throw new Error(\"Point.fromHex: x=0 and x_0=1\");\n      return et !== X && (Z = c(-Z)), d.fromAffine({\n        x: Z,\n        y: _\n      });\n    }\n    static fromPrivateKey(f) {\n      return O(f).point;\n    }\n    toRawBytes() {\n      const {\n          x: f,\n          y: b\n        } = this.toAffine(),\n        E = Nt(b, n.BYTES);\n      return E[E.length - 1] |= f & j ? 128 : 0, E;\n    }\n    toHex() {\n      return Ft(this.toRawBytes());\n    }\n  }\n  d.BASE = new d(e.Gx, e.Gy, j, c(e.Gx * e.Gy)), d.ZERO = new d(G, j, j, G);\n  const {\n      BASE: m,\n      ZERO: F\n    } = d,\n    q = lr(d, u * 8);\n  function z(y) {\n    return H(y, r);\n  }\n  function I(y) {\n    return z(Et(y));\n  }\n  function O(y) {\n    const f = n.BYTES;\n    y = W(\"private key\", y, f);\n    const b = W(\"hashed private key\", s(y), 2 * f),\n      E = w(b.slice(0, f)),\n      B = b.slice(f, 2 * f),\n      C = I(E),\n      A = m.multiply(C),\n      U = A.toRawBytes();\n    return {\n      head: E,\n      prefix: B,\n      scalar: C,\n      point: A,\n      pointBytes: U\n    };\n  }\n  function ot(y) {\n    return O(y).pointBytes;\n  }\n  function tt(y = new Uint8Array(), ...f) {\n    const b = ye(...f);\n    return I(s(h(b, W(\"context\", y), !!o)));\n  }\n  function st(y, f, b = {}) {\n    y = W(\"message\", y), o && (y = o(y));\n    const {\n        prefix: E,\n        scalar: B,\n        pointBytes: C\n      } = O(f),\n      A = tt(b.context, E, y),\n      U = m.multiply(A).toRawBytes(),\n      _ = tt(b.context, U, C, y),\n      T = z(A + _ * B);\n    ft(\"signature.s\", T, G, r);\n    const $ = ye(U, Nt(T, n.BYTES));\n    return W(\"result\", $, n.BYTES * 2);\n  }\n  const at = Er;\n  function Ct(y, f, b, E = at) {\n    const {\n        context: B,\n        zip215: C\n      } = E,\n      A = n.BYTES;\n    y = W(\"signature\", y, 2 * A), f = W(\"message\", f), b = W(\"publicKey\", b, A), C !== void 0 && Tt(\"zip215\", C), o && (f = o(f));\n    const U = Et(y.slice(A, 2 * A));\n    let _, T, $;\n    try {\n      _ = d.fromHex(b, C), T = d.fromHex(y.slice(0, A), C), $ = m.multiplyUnsafe(U);\n    } catch {\n      return !1;\n    }\n    if (!C && _.isSmallOrder()) return !1;\n    const R = tt(B, T.toRawBytes(), _.toRawBytes(), f);\n    return T.add(_.multiplyUnsafe(R)).subtract($).clearCofactor().equals(d.ZERO);\n  }\n  return m._setWindowSize(8), {\n    CURVE: e,\n    getPublicKey: ot,\n    sign: st,\n    verify: Ct,\n    ExtendedPoint: d,\n    utils: {\n      getExtendedPublicKey: O,\n      randomPrivateKey: () => a(n.BYTES),\n      precompute(y = 8, f = d.BASE) {\n        return f._setWindowSize(y), f.multiply(BigInt(3)), f;\n      }\n    }\n  };\n}\nBigInt(0), BigInt(1);\nconst kt = BigInt(\"57896044618658097711785492504343953926634992332820282019728792003956564819949\"),\n  Ue = BigInt(\"19681161376707505956807079304988542015446066515923890162744021073123829784752\");\nBigInt(0);\nconst xr = BigInt(1),\n  Te = BigInt(2);\nBigInt(3);\nconst Br = BigInt(5),\n  Cr = BigInt(8);\nfunction Ar(t) {\n  const e = BigInt(10),\n    n = BigInt(20),\n    r = BigInt(40),\n    o = BigInt(80),\n    s = kt,\n    u = t * t % s * t % s,\n    i = J(u, Te, s) * u % s,\n    D = J(i, xr, s) * t % s,\n    c = J(D, Br, s) * D % s,\n    l = J(c, e, s) * c % s,\n    p = J(l, n, s) * l % s,\n    w = J(p, r, s) * p % s,\n    h = J(w, o, s) * w % s,\n    g = J(h, o, s) * w % s,\n    S = J(g, e, s) * c % s;\n  return {\n    pow_p_5_8: J(S, Te, s) * t % s,\n    b2: u\n  };\n}\nfunction mr(t) {\n  return t[0] &= 248, t[31] &= 127, t[31] |= 64, t;\n}\nfunction _r(t, e) {\n  const n = kt,\n    r = H(e * e * e, n),\n    o = H(r * r * e, n),\n    s = Ar(t * o).pow_p_5_8;\n  let a = H(t * r * s, n);\n  const u = H(e * a * a, n),\n    i = a,\n    D = H(a * Ue, n),\n    c = u === t,\n    l = u === H(-t, n),\n    p = u === H(-t * Ue, n);\n  return c && (a = i), (l || p) && (a = D), ur(a, n) && (a = H(-a, n)), {\n    isValid: c || l,\n    value: a\n  };\n}\nconst Sr = (() => _e(kt, void 0, !0))(),\n  vr = (() => ({\n    a: BigInt(-1),\n    d: BigInt(\"37095705934669439343138083508754565189542113879843219016388785533085940283555\"),\n    Fp: Sr,\n    n: BigInt(\"7237005577332262213973186563042994240857116359379907606001950938285454250989\"),\n    h: Cr,\n    Gx: BigInt(\"15112221349535400772501151409588531511454012693041857206046113283949847762202\"),\n    Gy: BigInt(\"46316835694926478169428394003475163141307993866256225615783033603165251855960\"),\n    hash: Kn,\n    randomBytes: he,\n    adjustScalarBytes: mr,\n    uvRatio: _r\n  }))(),\n  Rt = (() => yr(vr))(),\n  jt = \"EdDSA\",\n  Zt = \"JWT\",\n  ut = \".\",\n  Dt = \"base64url\",\n  Gt = \"utf8\",\n  xt = \"utf8\",\n  Vt = \":\",\n  Yt = \"did\",\n  Jt = \"key\",\n  dt = \"base58btc\",\n  Kt = \"z\",\n  Wt = \"K36\",\n  Fe = 32,\n  Ne = 32;\nfunction Xt(t) {\n  return globalThis.Buffer != null ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : t;\n}\nfunction Le(t = 0) {\n  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Xt(globalThis.Buffer.allocUnsafe(t)) : new Uint8Array(t);\n}\nfunction Oe(t, e) {\n  e || (e = t.reduce((o, s) => o + s.length, 0));\n  const n = Le(e);\n  let r = 0;\n  for (const o of t) n.set(o, r), r += o.length;\n  return Xt(n);\n}\nfunction Ir(t, e) {\n  if (t.length >= 255) throw new TypeError(\"Alphabet too long\");\n  for (var n = new Uint8Array(256), r = 0; r < n.length; r++) n[r] = 255;\n  for (var o = 0; o < t.length; o++) {\n    var s = t.charAt(o),\n      a = s.charCodeAt(0);\n    if (n[a] !== 255) throw new TypeError(s + \" is ambiguous\");\n    n[a] = o;\n  }\n  var u = t.length,\n    i = t.charAt(0),\n    D = Math.log(u) / Math.log(256),\n    c = Math.log(256) / Math.log(u);\n  function l(h) {\n    if (h instanceof Uint8Array || (ArrayBuffer.isView(h) ? h = new Uint8Array(h.buffer, h.byteOffset, h.byteLength) : Array.isArray(h) && (h = Uint8Array.from(h))), !(h instanceof Uint8Array)) throw new TypeError(\"Expected Uint8Array\");\n    if (h.length === 0) return \"\";\n    for (var g = 0, S = 0, v = 0, L = h.length; v !== L && h[v] === 0;) v++, g++;\n    for (var d = (L - v) * c + 1 >>> 0, m = new Uint8Array(d); v !== L;) {\n      for (var F = h[v], q = 0, z = d - 1; (F !== 0 || q < S) && z !== -1; z--, q++) F += 256 * m[z] >>> 0, m[z] = F % u >>> 0, F = F / u >>> 0;\n      if (F !== 0) throw new Error(\"Non-zero carry\");\n      S = q, v++;\n    }\n    for (var I = d - S; I !== d && m[I] === 0;) I++;\n    for (var O = i.repeat(g); I < d; ++I) O += t.charAt(m[I]);\n    return O;\n  }\n  function p(h) {\n    if (typeof h != \"string\") throw new TypeError(\"Expected String\");\n    if (h.length === 0) return new Uint8Array();\n    var g = 0;\n    if (h[g] !== \" \") {\n      for (var S = 0, v = 0; h[g] === i;) S++, g++;\n      for (var L = (h.length - g) * D + 1 >>> 0, d = new Uint8Array(L); h[g];) {\n        var m = n[h.charCodeAt(g)];\n        if (m === 255) return;\n        for (var F = 0, q = L - 1; (m !== 0 || F < v) && q !== -1; q--, F++) m += u * d[q] >>> 0, d[q] = m % 256 >>> 0, m = m / 256 >>> 0;\n        if (m !== 0) throw new Error(\"Non-zero carry\");\n        v = F, g++;\n      }\n      if (h[g] !== \" \") {\n        for (var z = L - v; z !== L && d[z] === 0;) z++;\n        for (var I = new Uint8Array(S + (L - z)), O = S; z !== L;) I[O++] = d[z++];\n        return I;\n      }\n    }\n  }\n  function w(h) {\n    var g = p(h);\n    if (g) return g;\n    throw new Error(`Non-${e} character`);\n  }\n  return {\n    encode: l,\n    decodeUnsafe: p,\n    decode: w\n  };\n}\nvar Ur = Ir,\n  Tr = Ur;\nconst He = t => {\n    if (t instanceof Uint8Array && t.constructor.name === \"Uint8Array\") return t;\n    if (t instanceof ArrayBuffer) return new Uint8Array(t);\n    if (ArrayBuffer.isView(t)) return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);\n    throw new Error(\"Unknown type, must be binary type\");\n  },\n  Fr = t => new TextEncoder().encode(t),\n  Nr = t => new TextDecoder().decode(t);\nclass Lr {\n  constructor(e, n, r) {\n    this.name = e, this.prefix = n, this.baseEncode = r;\n  }\n  encode(e) {\n    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;\n    throw Error(\"Unknown type, must be binary type\");\n  }\n}\nclass Or {\n  constructor(e, n, r) {\n    if (this.name = e, this.prefix = n, n.codePointAt(0) === void 0) throw new Error(\"Invalid prefix character\");\n    this.prefixCodePoint = n.codePointAt(0), this.baseDecode = r;\n  }\n  decode(e) {\n    if (typeof e == \"string\") {\n      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);\n      return this.baseDecode(e.slice(this.prefix.length));\n    } else throw Error(\"Can only multibase decode strings\");\n  }\n  or(e) {\n    return ze(this, e);\n  }\n}\nclass Hr {\n  constructor(e) {\n    this.decoders = e;\n  }\n  or(e) {\n    return ze(this, e);\n  }\n  decode(e) {\n    const n = e[0],\n      r = this.decoders[n];\n    if (r) return r.decode(e);\n    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);\n  }\n}\nconst ze = (t, e) => new Hr({\n  ...(t.decoders || {\n    [t.prefix]: t\n  }),\n  ...(e.decoders || {\n    [e.prefix]: e\n  })\n});\nclass zr {\n  constructor(e, n, r, o) {\n    this.name = e, this.prefix = n, this.baseEncode = r, this.baseDecode = o, this.encoder = new Lr(e, n, r), this.decoder = new Or(e, n, o);\n  }\n  encode(e) {\n    return this.encoder.encode(e);\n  }\n  decode(e) {\n    return this.decoder.decode(e);\n  }\n}\nconst Bt = ({\n    name: t,\n    prefix: e,\n    encode: n,\n    decode: r\n  }) => new zr(t, e, n, r),\n  ht = ({\n    prefix: t,\n    name: e,\n    alphabet: n\n  }) => {\n    const {\n      encode: r,\n      decode: o\n    } = Tr(n, e);\n    return Bt({\n      prefix: t,\n      name: e,\n      encode: r,\n      decode: s => He(o(s))\n    });\n  },\n  Mr = (t, e, n, r) => {\n    const o = {};\n    for (let c = 0; c < e.length; ++c) o[e[c]] = c;\n    let s = t.length;\n    for (; t[s - 1] === \"=\";) --s;\n    const a = new Uint8Array(s * n / 8 | 0);\n    let u = 0,\n      i = 0,\n      D = 0;\n    for (let c = 0; c < s; ++c) {\n      const l = o[t[c]];\n      if (l === void 0) throw new SyntaxError(`Non-${r} character`);\n      i = i << n | l, u += n, u >= 8 && (u -= 8, a[D++] = 255 & i >> u);\n    }\n    if (u >= n || 255 & i << 8 - u) throw new SyntaxError(\"Unexpected end of data\");\n    return a;\n  },\n  qr = (t, e, n) => {\n    const r = e[e.length - 1] === \"=\",\n      o = (1 << n) - 1;\n    let s = \"\",\n      a = 0,\n      u = 0;\n    for (let i = 0; i < t.length; ++i) for (u = u << 8 | t[i], a += 8; a > n;) a -= n, s += e[o & u >> a];\n    if (a && (s += e[o & u << n - a]), r) for (; s.length * n & 7;) s += \"=\";\n    return s;\n  },\n  k = ({\n    name: t,\n    prefix: e,\n    bitsPerChar: n,\n    alphabet: r\n  }) => Bt({\n    prefix: e,\n    name: t,\n    encode(o) {\n      return qr(o, r, n);\n    },\n    decode(o) {\n      return Mr(o, r, n, t);\n    }\n  }),\n  $r = Bt({\n    prefix: \"\\0\",\n    name: \"identity\",\n    encode: t => Nr(t),\n    decode: t => Fr(t)\n  });\nvar kr = Object.freeze({\n  __proto__: null,\n  identity: $r\n});\nconst Rr = k({\n  prefix: \"0\",\n  name: \"base2\",\n  alphabet: \"01\",\n  bitsPerChar: 1\n});\nvar jr = Object.freeze({\n  __proto__: null,\n  base2: Rr\n});\nconst Zr = k({\n  prefix: \"7\",\n  name: \"base8\",\n  alphabet: \"01234567\",\n  bitsPerChar: 3\n});\nvar Gr = Object.freeze({\n  __proto__: null,\n  base8: Zr\n});\nconst Vr = ht({\n  prefix: \"9\",\n  name: \"base10\",\n  alphabet: \"0123456789\"\n});\nvar Yr = Object.freeze({\n  __proto__: null,\n  base10: Vr\n});\nconst Jr = k({\n    prefix: \"f\",\n    name: \"base16\",\n    alphabet: \"0123456789abcdef\",\n    bitsPerChar: 4\n  }),\n  Kr = k({\n    prefix: \"F\",\n    name: \"base16upper\",\n    alphabet: \"0123456789ABCDEF\",\n    bitsPerChar: 4\n  });\nvar Wr = Object.freeze({\n  __proto__: null,\n  base16: Jr,\n  base16upper: Kr\n});\nconst Xr = k({\n    prefix: \"b\",\n    name: \"base32\",\n    alphabet: \"abcdefghijklmnopqrstuvwxyz234567\",\n    bitsPerChar: 5\n  }),\n  Pr = k({\n    prefix: \"B\",\n    name: \"base32upper\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\",\n    bitsPerChar: 5\n  }),\n  Qr = k({\n    prefix: \"c\",\n    name: \"base32pad\",\n    alphabet: \"abcdefghijklmnopqrstuvwxyz234567=\",\n    bitsPerChar: 5\n  }),\n  to = k({\n    prefix: \"C\",\n    name: \"base32padupper\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=\",\n    bitsPerChar: 5\n  }),\n  eo = k({\n    prefix: \"v\",\n    name: \"base32hex\",\n    alphabet: \"0123456789abcdefghijklmnopqrstuv\",\n    bitsPerChar: 5\n  }),\n  no = k({\n    prefix: \"V\",\n    name: \"base32hexupper\",\n    alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV\",\n    bitsPerChar: 5\n  }),\n  ro = k({\n    prefix: \"t\",\n    name: \"base32hexpad\",\n    alphabet: \"0123456789abcdefghijklmnopqrstuv=\",\n    bitsPerChar: 5\n  }),\n  oo = k({\n    prefix: \"T\",\n    name: \"base32hexpadupper\",\n    alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV=\",\n    bitsPerChar: 5\n  }),\n  so = k({\n    prefix: \"h\",\n    name: \"base32z\",\n    alphabet: \"ybndrfg8ejkmcpqxot1uwisza345h769\",\n    bitsPerChar: 5\n  });\nvar io = Object.freeze({\n  __proto__: null,\n  base32: Xr,\n  base32upper: Pr,\n  base32pad: Qr,\n  base32padupper: to,\n  base32hex: eo,\n  base32hexupper: no,\n  base32hexpad: ro,\n  base32hexpadupper: oo,\n  base32z: so\n});\nconst uo = ht({\n    prefix: \"k\",\n    name: \"base36\",\n    alphabet: \"0123456789abcdefghijklmnopqrstuvwxyz\"\n  }),\n  co = ht({\n    prefix: \"K\",\n    name: \"base36upper\",\n    alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  });\nvar ao = Object.freeze({\n  __proto__: null,\n  base36: uo,\n  base36upper: co\n});\nconst fo = ht({\n    name: \"base58btc\",\n    prefix: \"z\",\n    alphabet: \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n  }),\n  Do = ht({\n    name: \"base58flickr\",\n    prefix: \"Z\",\n    alphabet: \"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\"\n  });\nvar ho = Object.freeze({\n  __proto__: null,\n  base58btc: fo,\n  base58flickr: Do\n});\nconst lo = k({\n    prefix: \"m\",\n    name: \"base64\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",\n    bitsPerChar: 6\n  }),\n  bo = k({\n    prefix: \"M\",\n    name: \"base64pad\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n    bitsPerChar: 6\n  }),\n  po = k({\n    prefix: \"u\",\n    name: \"base64url\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\",\n    bitsPerChar: 6\n  }),\n  wo = k({\n    prefix: \"U\",\n    name: \"base64urlpad\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=\",\n    bitsPerChar: 6\n  });\nvar Eo = Object.freeze({\n  __proto__: null,\n  base64: lo,\n  base64pad: bo,\n  base64url: po,\n  base64urlpad: wo\n});\nconst Me = Array.from(\"\\u{1F680}\\u{1FA90}\\u2604\\u{1F6F0}\\u{1F30C}\\u{1F311}\\u{1F312}\\u{1F313}\\u{1F314}\\u{1F315}\\u{1F316}\\u{1F317}\\u{1F318}\\u{1F30D}\\u{1F30F}\\u{1F30E}\\u{1F409}\\u2600\\u{1F4BB}\\u{1F5A5}\\u{1F4BE}\\u{1F4BF}\\u{1F602}\\u2764\\u{1F60D}\\u{1F923}\\u{1F60A}\\u{1F64F}\\u{1F495}\\u{1F62D}\\u{1F618}\\u{1F44D}\\u{1F605}\\u{1F44F}\\u{1F601}\\u{1F525}\\u{1F970}\\u{1F494}\\u{1F496}\\u{1F499}\\u{1F622}\\u{1F914}\\u{1F606}\\u{1F644}\\u{1F4AA}\\u{1F609}\\u263A\\u{1F44C}\\u{1F917}\\u{1F49C}\\u{1F614}\\u{1F60E}\\u{1F607}\\u{1F339}\\u{1F926}\\u{1F389}\\u{1F49E}\\u270C\\u2728\\u{1F937}\\u{1F631}\\u{1F60C}\\u{1F338}\\u{1F64C}\\u{1F60B}\\u{1F497}\\u{1F49A}\\u{1F60F}\\u{1F49B}\\u{1F642}\\u{1F493}\\u{1F929}\\u{1F604}\\u{1F600}\\u{1F5A4}\\u{1F603}\\u{1F4AF}\\u{1F648}\\u{1F447}\\u{1F3B6}\\u{1F612}\\u{1F92D}\\u2763\\u{1F61C}\\u{1F48B}\\u{1F440}\\u{1F62A}\\u{1F611}\\u{1F4A5}\\u{1F64B}\\u{1F61E}\\u{1F629}\\u{1F621}\\u{1F92A}\\u{1F44A}\\u{1F973}\\u{1F625}\\u{1F924}\\u{1F449}\\u{1F483}\\u{1F633}\\u270B\\u{1F61A}\\u{1F61D}\\u{1F634}\\u{1F31F}\\u{1F62C}\\u{1F643}\\u{1F340}\\u{1F337}\\u{1F63B}\\u{1F613}\\u2B50\\u2705\\u{1F97A}\\u{1F308}\\u{1F608}\\u{1F918}\\u{1F4A6}\\u2714\\u{1F623}\\u{1F3C3}\\u{1F490}\\u2639\\u{1F38A}\\u{1F498}\\u{1F620}\\u261D\\u{1F615}\\u{1F33A}\\u{1F382}\\u{1F33B}\\u{1F610}\\u{1F595}\\u{1F49D}\\u{1F64A}\\u{1F639}\\u{1F5E3}\\u{1F4AB}\\u{1F480}\\u{1F451}\\u{1F3B5}\\u{1F91E}\\u{1F61B}\\u{1F534}\\u{1F624}\\u{1F33C}\\u{1F62B}\\u26BD\\u{1F919}\\u2615\\u{1F3C6}\\u{1F92B}\\u{1F448}\\u{1F62E}\\u{1F646}\\u{1F37B}\\u{1F343}\\u{1F436}\\u{1F481}\\u{1F632}\\u{1F33F}\\u{1F9E1}\\u{1F381}\\u26A1\\u{1F31E}\\u{1F388}\\u274C\\u270A\\u{1F44B}\\u{1F630}\\u{1F928}\\u{1F636}\\u{1F91D}\\u{1F6B6}\\u{1F4B0}\\u{1F353}\\u{1F4A2}\\u{1F91F}\\u{1F641}\\u{1F6A8}\\u{1F4A8}\\u{1F92C}\\u2708\\u{1F380}\\u{1F37A}\\u{1F913}\\u{1F619}\\u{1F49F}\\u{1F331}\\u{1F616}\\u{1F476}\\u{1F974}\\u25B6\\u27A1\\u2753\\u{1F48E}\\u{1F4B8}\\u2B07\\u{1F628}\\u{1F31A}\\u{1F98B}\\u{1F637}\\u{1F57A}\\u26A0\\u{1F645}\\u{1F61F}\\u{1F635}\\u{1F44E}\\u{1F932}\\u{1F920}\\u{1F927}\\u{1F4CC}\\u{1F535}\\u{1F485}\\u{1F9D0}\\u{1F43E}\\u{1F352}\\u{1F617}\\u{1F911}\\u{1F30A}\\u{1F92F}\\u{1F437}\\u260E\\u{1F4A7}\\u{1F62F}\\u{1F486}\\u{1F446}\\u{1F3A4}\\u{1F647}\\u{1F351}\\u2744\\u{1F334}\\u{1F4A3}\\u{1F438}\\u{1F48C}\\u{1F4CD}\\u{1F940}\\u{1F922}\\u{1F445}\\u{1F4A1}\\u{1F4A9}\\u{1F450}\\u{1F4F8}\\u{1F47B}\\u{1F910}\\u{1F92E}\\u{1F3BC}\\u{1F975}\\u{1F6A9}\\u{1F34E}\\u{1F34A}\\u{1F47C}\\u{1F48D}\\u{1F4E3}\\u{1F942}\"),\n  go = Me.reduce((t, e, n) => (t[n] = e, t), []),\n  yo = Me.reduce((t, e, n) => (t[e.codePointAt(0)] = n, t), []);\nfunction xo(t) {\n  return t.reduce((e, n) => (e += go[n], e), \"\");\n}\nfunction Bo(t) {\n  const e = [];\n  for (const n of t) {\n    const r = yo[n.codePointAt(0)];\n    if (r === void 0) throw new Error(`Non-base256emoji character: ${n}`);\n    e.push(r);\n  }\n  return new Uint8Array(e);\n}\nconst Co = Bt({\n  prefix: \"\\u{1F680}\",\n  name: \"base256emoji\",\n  encode: xo,\n  decode: Bo\n});\nvar Ao = Object.freeze({\n    __proto__: null,\n    base256emoji: Co\n  }),\n  mo = $e,\n  qe = 128,\n  _o = 127,\n  So = ~_o,\n  vo = Math.pow(2, 31);\nfunction $e(t, e, n) {\n  e = e || [], n = n || 0;\n  for (var r = n; t >= vo;) e[n++] = t & 255 | qe, t /= 128;\n  for (; t & So;) e[n++] = t & 255 | qe, t >>>= 7;\n  return e[n] = t | 0, $e.bytes = n - r + 1, e;\n}\nvar Io = Pt,\n  Uo = 128,\n  ke = 127;\nfunction Pt(t, r) {\n  var n = 0,\n    r = r || 0,\n    o = 0,\n    s = r,\n    a,\n    u = t.length;\n  do {\n    if (s >= u) throw Pt.bytes = 0, new RangeError(\"Could not decode varint\");\n    a = t[s++], n += o < 28 ? (a & ke) << o : (a & ke) * Math.pow(2, o), o += 7;\n  } while (a >= Uo);\n  return Pt.bytes = s - r, n;\n}\nvar To = Math.pow(2, 7),\n  Fo = Math.pow(2, 14),\n  No = Math.pow(2, 21),\n  Lo = Math.pow(2, 28),\n  Oo = Math.pow(2, 35),\n  Ho = Math.pow(2, 42),\n  zo = Math.pow(2, 49),\n  Mo = Math.pow(2, 56),\n  qo = Math.pow(2, 63),\n  $o = function (t) {\n    return t < To ? 1 : t < Fo ? 2 : t < No ? 3 : t < Lo ? 4 : t < Oo ? 5 : t < Ho ? 6 : t < zo ? 7 : t < Mo ? 8 : t < qo ? 9 : 10;\n  },\n  ko = {\n    encode: mo,\n    decode: Io,\n    encodingLength: $o\n  },\n  Re = ko;\nconst je = (t, e, n = 0) => (Re.encode(t, e, n), e),\n  Ze = t => Re.encodingLength(t),\n  Qt = (t, e) => {\n    const n = e.byteLength,\n      r = Ze(t),\n      o = r + Ze(n),\n      s = new Uint8Array(o + n);\n    return je(t, s, 0), je(n, s, r), s.set(e, o), new Ro(t, n, e, s);\n  };\nclass Ro {\n  constructor(e, n, r, o) {\n    this.code = e, this.size = n, this.digest = r, this.bytes = o;\n  }\n}\nconst Ge = ({\n  name: t,\n  code: e,\n  encode: n\n}) => new jo(t, e, n);\nclass jo {\n  constructor(e, n, r) {\n    this.name = e, this.code = n, this.encode = r;\n  }\n  digest(e) {\n    if (e instanceof Uint8Array) {\n      const n = this.encode(e);\n      return n instanceof Uint8Array ? Qt(this.code, n) : n.then(r => Qt(this.code, r));\n    } else throw Error(\"Unknown type, must be binary type\");\n  }\n}\nconst Ve = t => async e => new Uint8Array(await crypto.subtle.digest(t, e)),\n  Zo = Ge({\n    name: \"sha2-256\",\n    code: 18,\n    encode: Ve(\"SHA-256\")\n  }),\n  Go = Ge({\n    name: \"sha2-512\",\n    code: 19,\n    encode: Ve(\"SHA-512\")\n  });\nvar Vo = Object.freeze({\n  __proto__: null,\n  sha256: Zo,\n  sha512: Go\n});\nconst Ye = 0,\n  Yo = \"identity\",\n  Je = He,\n  Jo = t => Qt(Ye, Je(t)),\n  Ko = {\n    code: Ye,\n    name: Yo,\n    encode: Je,\n    digest: Jo\n  };\nvar Wo = Object.freeze({\n  __proto__: null,\n  identity: Ko\n});\nnew TextEncoder(), new TextDecoder();\nconst Ke = {\n  ...kr,\n  ...jr,\n  ...Gr,\n  ...Yr,\n  ...Wr,\n  ...io,\n  ...ao,\n  ...ho,\n  ...Eo,\n  ...Ao\n};\n({\n  ...Vo,\n  ...Wo\n});\nfunction We(t, e, n, r) {\n  return {\n    name: t,\n    prefix: e,\n    encoder: {\n      name: t,\n      prefix: e,\n      encode: n\n    },\n    decoder: {\n      decode: r\n    }\n  };\n}\nconst Xe = We(\"utf8\", \"u\", t => \"u\" + new TextDecoder(\"utf8\").decode(t), t => new TextEncoder().encode(t.substring(1))),\n  te = We(\"ascii\", \"a\", t => {\n    let e = \"a\";\n    for (let n = 0; n < t.length; n++) e += String.fromCharCode(t[n]);\n    return e;\n  }, t => {\n    t = t.substring(1);\n    const e = Le(t.length);\n    for (let n = 0; n < t.length; n++) e[n] = t.charCodeAt(n);\n    return e;\n  }),\n  Pe = {\n    utf8: Xe,\n    \"utf-8\": Xe,\n    hex: Ke.base16,\n    latin1: te,\n    ascii: te,\n    binary: te,\n    ...Ke\n  };\nfunction ct(t, e = \"utf8\") {\n  const n = Pe[e];\n  if (!n) throw new Error(`Unsupported encoding \"${e}\"`);\n  return (e === \"utf8\" || e === \"utf-8\") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(t.buffer, t.byteOffset, t.byteLength).toString(\"utf8\") : n.encoder.encode(t).substring(1);\n}\nfunction rt(t, e = \"utf8\") {\n  const n = Pe[e];\n  if (!n) throw new Error(`Unsupported encoding \"${e}\"`);\n  return (e === \"utf8\" || e === \"utf-8\") && globalThis.Buffer != null && globalThis.Buffer.from != null ? Xt(globalThis.Buffer.from(t, \"utf-8\")) : n.decoder.decode(`${n.prefix}${t}`);\n}\nfunction lt(t) {\n  return pn(ct(rt(t, Dt), Gt));\n}\nfunction bt(t) {\n  return ct(rt(wn(t), Gt), Dt);\n}\nfunction Qe(t) {\n  const e = rt(Wt, dt),\n    n = Kt + ct(Oe([e, t]), dt);\n  return [Yt, Jt, n].join(Vt);\n}\nfunction tn(t) {\n  const [e, n, r] = t.split(Vt);\n  if (e !== Yt || n !== Jt) throw new Error('Issuer must be a DID with method \"key\"');\n  if (r.slice(0, 1) !== Kt) throw new Error(\"Issuer must be a key in mulicodec format\");\n  const o = rt(r.slice(1), dt);\n  if (ct(o.slice(0, 2), dt) !== Wt) throw new Error('Issuer must be a public key with type \"Ed25519\"');\n  const s = o.slice(2);\n  if (s.length !== Fe) throw new Error(\"Issuer must be a public key with length 32 bytes\");\n  return s;\n}\nfunction en(t) {\n  return ct(t, Dt);\n}\nfunction nn(t) {\n  return rt(t, Dt);\n}\nfunction rn(t) {\n  return rt([bt(t.header), bt(t.payload)].join(ut), xt);\n}\nfunction Xo(t) {\n  const e = ct(t, xt).split(ut),\n    n = lt(e[0]),\n    r = lt(e[1]);\n  return {\n    header: n,\n    payload: r\n  };\n}\nfunction on(t) {\n  return [bt(t.header), bt(t.payload), en(t.signature)].join(ut);\n}\nfunction sn(t) {\n  const e = t.split(ut),\n    n = lt(e[0]),\n    r = lt(e[1]),\n    o = nn(e[2]),\n    s = rt(e.slice(0, 2).join(ut), xt);\n  return {\n    header: n,\n    payload: r,\n    signature: o,\n    data: s\n  };\n}\nfunction Po(t = he(Ne)) {\n  const e = Rt.getPublicKey(t);\n  return {\n    secretKey: Oe([t, e]),\n    publicKey: e\n  };\n}\nasync function Qo(t, e, n, r, o = bn(Date.now())) {\n  const s = {\n      alg: jt,\n      typ: Zt\n    },\n    a = Qe(r.publicKey),\n    u = o + n,\n    i = {\n      iss: a,\n      sub: t,\n      aud: e,\n      iat: o,\n      exp: u\n    },\n    D = rn({\n      header: s,\n      payload: i\n    }),\n    c = Rt.sign(D, r.secretKey.slice(0, 32));\n  return on({\n    header: s,\n    payload: i,\n    signature: c\n  });\n}\nasync function ts(t) {\n  const {\n    header: e,\n    payload: n,\n    data: r,\n    signature: o\n  } = sn(t);\n  if (e.alg !== jt || e.typ !== Zt) throw new Error(\"JWT must use EdDSA algorithm\");\n  const s = tn(n.iss);\n  return Rt.verify(o, r, s);\n}\nexport { xt as DATA_ENCODING, Vt as DID_DELIMITER, Jt as DID_METHOD, Yt as DID_PREFIX, Gt as JSON_ENCODING, ut as JWT_DELIMITER, Dt as JWT_ENCODING, jt as JWT_IRIDIUM_ALG, Zt as JWT_IRIDIUM_TYP, Ne as KEY_PAIR_SEED_LENGTH, Kt as MULTICODEC_ED25519_BASE, dt as MULTICODEC_ED25519_ENCODING, Wt as MULTICODEC_ED25519_HEADER, Fe as MULTICODEC_ED25519_LENGTH, Xo as decodeData, tn as decodeIss, lt as decodeJSON, sn as decodeJWT, nn as decodeSig, rn as encodeData, Qe as encodeIss, bt as encodeJSON, on as encodeJWT, en as encodeSig, Po as generateKeyPair, Qo as signJWT, ts as verifyJWT };\n//# sourceMappingURL=index.es.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}