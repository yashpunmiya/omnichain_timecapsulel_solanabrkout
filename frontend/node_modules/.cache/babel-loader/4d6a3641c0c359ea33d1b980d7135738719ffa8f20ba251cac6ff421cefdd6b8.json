{"ast":null,"code":"import { InvalidAbiParameterError } from './errors/abiParameter.js';\nimport { isStructSignature, modifiers } from './runtime/signatures.js';\nimport { parseStructs } from './runtime/structs.js';\nimport { parseAbiParameter as parseAbiParameter_ } from './runtime/utils.js';\n/**\n * Parses human-readable ABI parameter into {@link AbiParameter}\n *\n * @param param - Human-readable ABI parameter\n * @returns Parsed {@link AbiParameter}\n *\n * @example\n * const abiParameter = parseAbiParameter('address from')\n * //    ^? const abiParameter: { type: \"address\"; name: \"from\"; }\n *\n * @example\n * const abiParameter = parseAbiParameter([\n *   //  ^? const abiParameter: { type: \"tuple\"; components: [{ type: \"string\"; name:...\n *   'Baz bar',\n *   'struct Baz { string name; }',\n * ])\n */\nexport function parseAbiParameter(param) {\n  let abiParameter;\n  if (typeof param === 'string') abiParameter = parseAbiParameter_(param, {\n    modifiers\n  });else {\n    const structs = parseStructs(param);\n    const length = param.length;\n    for (let i = 0; i < length; i++) {\n      const signature = param[i];\n      if (isStructSignature(signature)) continue;\n      abiParameter = parseAbiParameter_(signature, {\n        modifiers,\n        structs\n      });\n      break;\n    }\n  }\n  if (!abiParameter) throw new InvalidAbiParameterError({\n    param\n  });\n  return abiParameter;\n}","map":{"version":3,"names":["InvalidAbiParameterError","isStructSignature","modifiers","parseStructs","parseAbiParameter","parseAbiParameter_","param","abiParameter","structs","length","i","signature"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\abitype\\src\\human-readable\\parseAbiParameter.ts"],"sourcesContent":["import type { AbiParameter } from '../abi.js'\nimport type { Narrow } from '../narrow.js'\nimport type { Error, Filter } from '../types.js'\nimport { InvalidAbiParameterError } from './errors/abiParameter.js'\nimport { isStructSignature, modifiers } from './runtime/signatures.js'\nimport { parseStructs } from './runtime/structs.js'\nimport { parseAbiParameter as parseAbiParameter_ } from './runtime/utils.js'\nimport type { IsStructSignature, Modifier } from './types/signatures.js'\nimport type { ParseStructs } from './types/structs.js'\nimport type { ParseAbiParameter as ParseAbiParameter_ } from './types/utils.js'\n\n/**\n * Parses human-readable ABI parameter into {@link AbiParameter}\n *\n * @param param - Human-readable ABI parameter\n * @returns Parsed {@link AbiParameter}\n *\n * @example\n * type Result = ParseAbiParameter<'address from'>\n * //   ^? type Result = { type: \"address\"; name: \"from\"; }\n *\n * @example\n * type Result = ParseAbiParameter<\n *   // ^? type Result = { type: \"tuple\"; components: [{ type: \"string\"; name:...\n *   ['Baz bar', 'struct Baz { string name; }']\n * >\n */\nexport type ParseAbiParameter<\n  param extends string | readonly string[] | readonly unknown[],\n> =\n  | (param extends string\n      ? param extends ''\n        ? never\n        : string extends param\n          ? AbiParameter\n          : ParseAbiParameter_<param, { modifier: Modifier }>\n      : never)\n  | (param extends readonly string[]\n      ? string[] extends param\n        ? AbiParameter // Return generic AbiParameter item since type was no inferrable\n        : ParseStructs<param> extends infer structs\n          ? {\n              [key in keyof param]: param[key] extends string\n                ? IsStructSignature<param[key]> extends true\n                  ? never\n                  : ParseAbiParameter_<\n                      param[key],\n                      { modifier: Modifier; structs: structs }\n                    >\n                : never\n            } extends infer mapped extends readonly unknown[]\n            ? Filter<mapped, never>[0] extends infer result\n              ? result extends undefined\n                ? never\n                : result\n              : never\n            : never\n          : never\n      : never)\n\n/**\n * Parses human-readable ABI parameter into {@link AbiParameter}\n *\n * @param param - Human-readable ABI parameter\n * @returns Parsed {@link AbiParameter}\n *\n * @example\n * const abiParameter = parseAbiParameter('address from')\n * //    ^? const abiParameter: { type: \"address\"; name: \"from\"; }\n *\n * @example\n * const abiParameter = parseAbiParameter([\n *   //  ^? const abiParameter: { type: \"tuple\"; components: [{ type: \"string\"; name:...\n *   'Baz bar',\n *   'struct Baz { string name; }',\n * ])\n */\nexport function parseAbiParameter<\n  param extends string | readonly string[] | readonly unknown[],\n>(\n  param: Narrow<param> &\n    (\n      | (param extends string\n          ? param extends ''\n            ? Error<'Empty string is not allowed.'>\n            : unknown\n          : never)\n      | (param extends readonly string[]\n          ? param extends readonly [] // empty array\n            ? Error<'At least one parameter required.'>\n            : string[] extends param\n              ? unknown\n              : unknown // TODO: Validate param string\n          : never)\n    ),\n): ParseAbiParameter<param> {\n  let abiParameter: AbiParameter | undefined\n  if (typeof param === 'string')\n    abiParameter = parseAbiParameter_(param, {\n      modifiers,\n    }) as ParseAbiParameter<param>\n  else {\n    const structs = parseStructs(param as readonly string[])\n    const length = param.length as number\n    for (let i = 0; i < length; i++) {\n      const signature = (param as readonly string[])[i]!\n      if (isStructSignature(signature)) continue\n      abiParameter = parseAbiParameter_(signature, { modifiers, structs })\n      break\n    }\n  }\n\n  if (!abiParameter) throw new InvalidAbiParameterError({ param })\n\n  return abiParameter as ParseAbiParameter<param>\n}\n"],"mappings":"AAGA,SAASA,wBAAwB,QAAQ,0BAA0B;AACnE,SAASC,iBAAiB,EAAEC,SAAS,QAAQ,yBAAyB;AACtE,SAASC,YAAY,QAAQ,sBAAsB;AACnD,SAASC,iBAAiB,IAAIC,kBAAkB,QAAQ,oBAAoB;AAsD5E;;;;;;;;;;;;;;;;;AAiBA,OAAM,SAAUD,iBAAiBA,CAG/BE,KAcG;EAEH,IAAIC,YAAsC;EAC1C,IAAI,OAAOD,KAAK,KAAK,QAAQ,EAC3BC,YAAY,GAAGF,kBAAkB,CAACC,KAAK,EAAE;IACvCJ;GACD,CAA6B,MAC3B;IACH,MAAMM,OAAO,GAAGL,YAAY,CAACG,KAA0B,CAAC;IACxD,MAAMG,MAAM,GAAGH,KAAK,CAACG,MAAgB;IACrC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,MAAM,EAAEC,CAAC,EAAE,EAAE;MAC/B,MAAMC,SAAS,GAAIL,KAA2B,CAACI,CAAC,CAAE;MAClD,IAAIT,iBAAiB,CAACU,SAAS,CAAC,EAAE;MAClCJ,YAAY,GAAGF,kBAAkB,CAACM,SAAS,EAAE;QAAET,SAAS;QAAEM;MAAO,CAAE,CAAC;MACpE;IACF;EACF;EAEA,IAAI,CAACD,YAAY,EAAE,MAAM,IAAIP,wBAAwB,CAAC;IAAEM;EAAK,CAAE,CAAC;EAEhE,OAAOC,YAAwC;AACjD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}