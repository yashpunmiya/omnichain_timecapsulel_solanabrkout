{"ast":null,"code":"import { createDefaultAddressSelector, createDefaultAuthorizationResultCache, createDefaultWalletNotFoundHandler, SolanaMobileWalletAdapter, SolanaMobileWalletAdapterWalletName } from '@solana-mobile/wallet-adapter-mobile';\nimport { useStandardWalletAdapters } from '@solana/wallet-standard-wallet-adapter-react';\nimport React, { useCallback, useEffect, useMemo, useRef } from 'react';\nimport getEnvironment, { Environment } from './getEnvironment.js';\nimport getInferredClusterFromEndpoint from './getInferredClusterFromEndpoint.js';\nimport { useConnection } from './useConnection.js';\nimport { useLocalStorage } from './useLocalStorage.js';\nimport { WalletProviderBase } from './WalletProviderBase.js';\nlet _userAgent;\nfunction getUserAgent() {\n  if (_userAgent === undefined) {\n    _userAgent = globalThis.navigator?.userAgent ?? null;\n  }\n  return _userAgent;\n}\nfunction getIsMobile(adapters) {\n  const userAgentString = getUserAgent();\n  return getEnvironment({\n    adapters,\n    userAgentString\n  }) === Environment.MOBILE_WEB;\n}\nfunction getUriForAppIdentity() {\n  const location = globalThis.location;\n  if (!location) return;\n  return `${location.protocol}//${location.host}`;\n}\nexport function WalletProvider({\n  children,\n  wallets: adapters,\n  autoConnect,\n  localStorageKey = 'walletName',\n  onError\n}) {\n  const {\n    connection\n  } = useConnection();\n  const adaptersWithStandardAdapters = useStandardWalletAdapters(adapters);\n  const mobileWalletAdapter = useMemo(() => {\n    if (!getIsMobile(adaptersWithStandardAdapters)) {\n      return null;\n    }\n    const existingMobileWalletAdapter = adaptersWithStandardAdapters.find(adapter => adapter.name === SolanaMobileWalletAdapterWalletName);\n    if (existingMobileWalletAdapter) {\n      return existingMobileWalletAdapter;\n    }\n    return new SolanaMobileWalletAdapter({\n      addressSelector: createDefaultAddressSelector(),\n      appIdentity: {\n        uri: getUriForAppIdentity()\n      },\n      authorizationResultCache: createDefaultAuthorizationResultCache(),\n      cluster: getInferredClusterFromEndpoint(connection?.rpcEndpoint),\n      onWalletNotFound: createDefaultWalletNotFoundHandler()\n    });\n  }, [adaptersWithStandardAdapters, connection?.rpcEndpoint]);\n  const adaptersWithMobileWalletAdapter = useMemo(() => {\n    if (mobileWalletAdapter == null || adaptersWithStandardAdapters.indexOf(mobileWalletAdapter) !== -1) {\n      return adaptersWithStandardAdapters;\n    }\n    return [mobileWalletAdapter, ...adaptersWithStandardAdapters];\n  }, [adaptersWithStandardAdapters, mobileWalletAdapter]);\n  const [walletName, setWalletName] = useLocalStorage(localStorageKey, null);\n  const adapter = useMemo(() => adaptersWithMobileWalletAdapter.find(a => a.name === walletName) ?? null, [adaptersWithMobileWalletAdapter, walletName]);\n  const changeWallet = useCallback(nextWalletName => {\n    if (walletName === nextWalletName) return;\n    if (adapter &&\n    // Selecting a wallet other than the mobile wallet adapter is not\n    // sufficient reason to call `disconnect` on the mobile wallet adapter.\n    // Calling `disconnect` on the mobile wallet adapter causes the entire\n    // authorization store to be wiped.\n    adapter.name !== SolanaMobileWalletAdapterWalletName) {\n      adapter.disconnect();\n    }\n    setWalletName(nextWalletName);\n  }, [adapter, setWalletName, walletName]);\n  useEffect(() => {\n    if (!adapter) return;\n    function handleDisconnect() {\n      if (isUnloadingRef.current) return;\n      setWalletName(null);\n    }\n    adapter.on('disconnect', handleDisconnect);\n    return () => {\n      adapter.off('disconnect', handleDisconnect);\n    };\n  }, [adapter, adaptersWithStandardAdapters, setWalletName, walletName]);\n  const hasUserSelectedAWallet = useRef(false);\n  const handleAutoConnectRequest = useMemo(() => {\n    if (!autoConnect || !adapter) return;\n    return async () => {\n      // If autoConnect is true or returns true, use the default autoConnect behavior.\n      if (autoConnect === true || (await autoConnect(adapter))) {\n        if (hasUserSelectedAWallet.current) {\n          await adapter.connect();\n        } else {\n          await adapter.autoConnect();\n        }\n      }\n    };\n  }, [autoConnect, adapter]);\n  const isUnloadingRef = useRef(false);\n  useEffect(() => {\n    if (walletName === SolanaMobileWalletAdapterWalletName && getIsMobile(adaptersWithStandardAdapters)) {\n      isUnloadingRef.current = false;\n      return;\n    }\n    function handleBeforeUnload() {\n      isUnloadingRef.current = true;\n    }\n    /**\n     * Some wallets fire disconnection events when the window unloads. Since there's no way to\n     * distinguish between a disconnection event received because a user initiated it, and one\n     * that was received because they've closed the window, we have to track window unload\n     * events themselves. Downstream components use this information to decide whether to act\n     * upon or drop wallet events and errors.\n     */\n    window.addEventListener('beforeunload', handleBeforeUnload);\n    return () => {\n      window.removeEventListener('beforeunload', handleBeforeUnload);\n    };\n  }, [adaptersWithStandardAdapters, walletName]);\n  const handleConnectError = useCallback(() => {\n    if (adapter) {\n      // If any error happens while connecting, unset the adapter.\n      changeWallet(null);\n    }\n  }, [adapter, changeWallet]);\n  const selectWallet = useCallback(walletName => {\n    hasUserSelectedAWallet.current = true;\n    changeWallet(walletName);\n  }, [changeWallet]);\n  return React.createElement(WalletProviderBase, {\n    wallets: adaptersWithMobileWalletAdapter,\n    adapter: adapter,\n    isUnloadingRef: isUnloadingRef,\n    onAutoConnectRequest: handleAutoConnectRequest,\n    onConnectError: handleConnectError,\n    onError: onError,\n    onSelectWallet: selectWallet\n  }, children);\n}\n//# sourceMappingURL=WalletProvider.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}