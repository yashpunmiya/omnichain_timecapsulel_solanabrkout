{"ast":null,"code":"import { parseAccount } from '../../accounts/utils/parseAccount.js';\nimport { decodeFunctionResult } from '../../utils/abi/decodeFunctionResult.js';\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js';\nimport { getContractError } from '../../utils/errors/getContractError.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { call } from './call.js';\n/**\n * Simulates/validates a contract interaction. This is useful for retrieving **return data** and **revert reasons** of contract write functions.\n *\n * - Docs: https://viem.sh/docs/contract/simulateContract\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_writing-to-contracts\n *\n * This function does not require gas to execute and _**does not**_ change the state of the blockchain. It is almost identical to [`readContract`](https://viem.sh/docs/contract/readContract), but also supports contract write functions.\n *\n * Internally, uses a [Public Client](https://viem.sh/docs/clients/public) to call the [`call` action](https://viem.sh/docs/actions/public/call) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).\n *\n * @param client - Client to use\n * @param parameters - {@link SimulateContractParameters}\n * @returns The simulation result and write request. {@link SimulateContractReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { simulateContract } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const result = await simulateContract(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function mint(uint32) view returns (uint32)']),\n *   functionName: 'mint',\n *   args: ['69420'],\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * })\n */\nexport async function simulateContract(client, parameters) {\n  const {\n    abi,\n    address,\n    args,\n    dataSuffix,\n    functionName,\n    ...callRequest\n  } = parameters;\n  const account = callRequest.account ? parseAccount(callRequest.account) : client.account;\n  const calldata = encodeFunctionData({\n    abi,\n    args,\n    functionName\n  });\n  try {\n    const {\n      data\n    } = await getAction(client, call, 'call')({\n      batch: false,\n      data: `${calldata}${dataSuffix ? dataSuffix.replace('0x', '') : ''}`,\n      to: address,\n      ...callRequest,\n      account\n    });\n    const result = decodeFunctionResult({\n      abi,\n      args,\n      functionName,\n      data: data || '0x'\n    });\n    const minimizedAbi = abi.filter(abiItem => 'name' in abiItem && abiItem.name === parameters.functionName);\n    return {\n      result,\n      request: {\n        abi: minimizedAbi,\n        address,\n        args,\n        dataSuffix,\n        functionName,\n        ...callRequest,\n        account\n      }\n    };\n  } catch (error) {\n    throw getContractError(error, {\n      abi,\n      address,\n      args,\n      docsPath: '/docs/contract/simulateContract',\n      functionName,\n      sender: account?.address\n    });\n  }\n}","map":{"version":3,"names":["parseAccount","decodeFunctionResult","encodeFunctionData","getContractError","getAction","call","simulateContract","client","parameters","abi","address","args","dataSuffix","functionName","callRequest","account","calldata","data","batch","replace","to","result","minimizedAbi","filter","abiItem","name","request","error","docsPath","sender"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\utils\\node_modules\\viem\\actions\\public\\simulateContract.ts"],"sourcesContent":["import type { Abi, AbiFunction, AbiStateMutability, Address } from 'abitype'\n\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account, ParseAccount } from '../../types/account.js'\nimport type { Chain, DeriveChain } from '../../types/chain.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n  ContractFunctionParameters,\n  ContractFunctionReturnType,\n  ExtractAbiFunctionForArgs,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type {\n  IsNarrowable,\n  NoInfer,\n  Prettify,\n  UnionEvaluate,\n  UnionOmit,\n} from '../../types/utils.js'\nimport {\n  type DecodeFunctionResultErrorType,\n  decodeFunctionResult,\n} from '../../utils/abi/decodeFunctionResult.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport {\n  type GetContractErrorReturnType,\n  getContractError,\n} from '../../utils/errors/getContractError.js'\nimport type { WriteContractParameters } from '../wallet/writeContract.js'\n\nimport type { TransactionRequest } from '../../types/transaction.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { type CallErrorType, type CallParameters, call } from './call.js'\n\nexport type GetMutabilityAwareValue<\n  abi extends Abi | readonly unknown[],\n  mutability extends AbiStateMutability = AbiStateMutability,\n  functionName extends ContractFunctionName<\n    abi,\n    mutability\n  > = ContractFunctionName<abi, mutability>,\n  valueType = TransactionRequest['value'],\n  args extends ContractFunctionArgs<\n    abi,\n    mutability,\n    functionName\n  > = ContractFunctionArgs<abi, mutability, functionName>,\n  abiFunction extends AbiFunction = abi extends Abi\n    ? ExtractAbiFunctionForArgs<abi, mutability, functionName, args>\n    : AbiFunction,\n  _Narrowable extends boolean = IsNarrowable<abi, Abi>,\n> = _Narrowable extends true\n  ? abiFunction['stateMutability'] extends 'payable'\n    ? { value?: NoInfer<valueType> | undefined }\n    : abiFunction['payable'] extends true\n      ? { value?: NoInfer<valueType> | undefined }\n      : { value?: undefined }\n  : { value?: NoInfer<valueType> | undefined }\n\nexport type SimulateContractParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'nonpayable' | 'payable'\n  > = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,\n  chain extends Chain | undefined = Chain | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  accountOverride extends Account | Address | null | undefined = undefined,\n  ///\n  derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = {\n  account?: accountOverride | null | undefined\n  chain?: chainOverride | undefined\n  /** Data to append to the end of the calldata. Useful for adding a [\"domain\" tag](https://opensea.notion.site/opensea/Seaport-Order-Attributions-ec2d69bf455041a5baa490941aad307f). */\n  dataSuffix?: Hex | undefined\n} & ContractFunctionParameters<\n  abi,\n  'nonpayable' | 'payable',\n  functionName,\n  args\n> &\n  UnionOmit<\n    CallParameters<derivedChain>,\n    | 'account'\n    | 'batch'\n    | 'code'\n    | 'to'\n    | 'data'\n    | 'factory'\n    | 'factoryData'\n    | 'value'\n  > &\n  GetMutabilityAwareValue<\n    abi,\n    'nonpayable' | 'payable',\n    functionName,\n    CallParameters<derivedChain> extends CallParameters\n      ? CallParameters<derivedChain>['value']\n      : CallParameters['value'],\n    args\n  >\n\nexport type SimulateContractReturnType<\n  out abi extends Abi | readonly unknown[] = Abi,\n  in out functionName extends ContractFunctionName<\n    abi,\n    'nonpayable' | 'payable'\n  > = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  in out args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,\n  /** @ts-expect-error cast variance */\n  out chain extends Chain | undefined = Chain | undefined,\n  out account extends Account | undefined = Account | undefined,\n  out chainOverride extends Chain | undefined = Chain | undefined,\n  out accountOverride extends Account | Address | null | undefined =\n    | Account\n    | Address\n    | null\n    | undefined,\n  ///\n  in out minimizedAbi extends Abi = readonly [\n    ExtractAbiFunctionForArgs<\n      abi extends Abi ? abi : Abi,\n      'nonpayable' | 'payable',\n      functionName,\n      args\n    >,\n  ],\n  out resolvedAccount extends\n    | Account\n    | null\n    | undefined = accountOverride extends Account | Address | null\n    ? ParseAccount<accountOverride>\n    : account,\n> = {\n  result: ContractFunctionReturnType<\n    minimizedAbi,\n    'nonpayable' | 'payable',\n    functionName,\n    args\n  >\n  request: Prettify<\n    UnionEvaluate<\n      UnionOmit<\n        WriteContractParameters<\n          minimizedAbi,\n          functionName,\n          args,\n          chain,\n          undefined,\n          chainOverride\n        >,\n        'account' | 'abi' | 'args' | 'chain' | 'functionName'\n      >\n    > &\n      ContractFunctionParameters<\n        minimizedAbi,\n        'nonpayable' | 'payable',\n        functionName,\n        args\n      > & {\n        chain: DeriveChain<chain, chainOverride>\n      } & (resolvedAccount extends Account | null\n        ? { account: resolvedAccount }\n        : { account?: undefined })\n  >\n}\n\nexport type SimulateContractErrorType =\n  | ParseAccountErrorType\n  | EncodeFunctionDataErrorType\n  | GetContractErrorReturnType<CallErrorType | DecodeFunctionResultErrorType>\n  | ErrorType\n\n/**\n * Simulates/validates a contract interaction. This is useful for retrieving **return data** and **revert reasons** of contract write functions.\n *\n * - Docs: https://viem.sh/docs/contract/simulateContract\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_writing-to-contracts\n *\n * This function does not require gas to execute and _**does not**_ change the state of the blockchain. It is almost identical to [`readContract`](https://viem.sh/docs/contract/readContract), but also supports contract write functions.\n *\n * Internally, uses a [Public Client](https://viem.sh/docs/clients/public) to call the [`call` action](https://viem.sh/docs/actions/public/call) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).\n *\n * @param client - Client to use\n * @param parameters - {@link SimulateContractParameters}\n * @returns The simulation result and write request. {@link SimulateContractReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { simulateContract } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const result = await simulateContract(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function mint(uint32) view returns (uint32)']),\n *   functionName: 'mint',\n *   args: ['69420'],\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * })\n */\nexport async function simulateContract<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  const args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  chainOverride extends Chain | undefined = undefined,\n  accountOverride extends Account | Address | null | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: SimulateContractParameters<\n    abi,\n    functionName,\n    args,\n    chain,\n    chainOverride,\n    accountOverride\n  >,\n): Promise<\n  SimulateContractReturnType<\n    abi,\n    functionName,\n    args,\n    chain,\n    account,\n    chainOverride,\n    accountOverride\n  >\n> {\n  const { abi, address, args, dataSuffix, functionName, ...callRequest } =\n    parameters as SimulateContractParameters\n\n  const account = callRequest.account\n    ? parseAccount(callRequest.account)\n    : client.account\n  const calldata = encodeFunctionData({ abi, args, functionName })\n  try {\n    const { data } = await getAction(\n      client,\n      call,\n      'call',\n    )({\n      batch: false,\n      data: `${calldata}${dataSuffix ? dataSuffix.replace('0x', '') : ''}`,\n      to: address,\n      ...callRequest,\n      account,\n    })\n    const result = decodeFunctionResult({\n      abi,\n      args,\n      functionName,\n      data: data || '0x',\n    })\n    const minimizedAbi = abi.filter(\n      (abiItem) =>\n        'name' in abiItem && abiItem.name === parameters.functionName,\n    )\n    return {\n      result,\n      request: {\n        abi: minimizedAbi,\n        address,\n        args,\n        dataSuffix,\n        functionName,\n        ...callRequest,\n        account,\n      },\n    } as unknown as SimulateContractReturnType<\n      abi,\n      functionName,\n      args,\n      chain,\n      account,\n      chainOverride,\n      accountOverride\n    >\n  } catch (error) {\n    throw getContractError(error as BaseError, {\n      abi,\n      address,\n      args,\n      docsPath: '/docs/contract/simulateContract',\n      functionName,\n      sender: account?.address,\n    })\n  }\n}\n"],"mappings":"AAEA,SAEEA,YAAY,QACP,sCAAsC;AAsB7C,SAEEC,oBAAoB,QACf,yCAAyC;AAChD,SAEEC,kBAAkB,QACb,uCAAuC;AAC9C,SAEEC,gBAAgB,QACX,wCAAwC;AAI/C,SAASC,SAAS,QAAQ,0BAA0B;AACpD,SAAkDC,IAAI,QAAQ,WAAW;AAsJzE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BA,OAAO,eAAeC,gBAAgBA,CAapCC,MAAyC,EACzCC,UAOC;EAYD,MAAM;IAAEC,GAAG;IAAEC,OAAO;IAAEC,IAAI;IAAEC,UAAU;IAAEC,YAAY;IAAE,GAAGC;EAAW,CAAE,GACpEN,UAAwC;EAE1C,MAAMO,OAAO,GAAGD,WAAW,CAACC,OAAO,GAC/Bf,YAAY,CAACc,WAAW,CAACC,OAAO,CAAC,GACjCR,MAAM,CAACQ,OAAO;EAClB,MAAMC,QAAQ,GAAGd,kBAAkB,CAAC;IAAEO,GAAG;IAAEE,IAAI;IAAEE;EAAY,CAAE,CAAC;EAChE,IAAI;IACF,MAAM;MAAEI;IAAI,CAAE,GAAG,MAAMb,SAAS,CAC9BG,MAAM,EACNF,IAAI,EACJ,MAAM,CACP,CAAC;MACAa,KAAK,EAAE,KAAK;MACZD,IAAI,EAAE,GAAGD,QAAQ,GAAGJ,UAAU,GAAGA,UAAU,CAACO,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,GAAG,EAAE,EAAE;MACpEC,EAAE,EAAEV,OAAO;MACX,GAAGI,WAAW;MACdC;KACD,CAAC;IACF,MAAMM,MAAM,GAAGpB,oBAAoB,CAAC;MAClCQ,GAAG;MACHE,IAAI;MACJE,YAAY;MACZI,IAAI,EAAEA,IAAI,IAAI;KACf,CAAC;IACF,MAAMK,YAAY,GAAGb,GAAG,CAACc,MAAM,CAC5BC,OAAO,IACN,MAAM,IAAIA,OAAO,IAAIA,OAAO,CAACC,IAAI,KAAKjB,UAAU,CAACK,YAAY,CAChE;IACD,OAAO;MACLQ,MAAM;MACNK,OAAO,EAAE;QACPjB,GAAG,EAAEa,YAAY;QACjBZ,OAAO;QACPC,IAAI;QACJC,UAAU;QACVC,YAAY;QACZ,GAAGC,WAAW;QACdC;;KAUH;EACH,CAAC,CAAC,OAAOY,KAAK,EAAE;IACd,MAAMxB,gBAAgB,CAACwB,KAAkB,EAAE;MACzClB,GAAG;MACHC,OAAO;MACPC,IAAI;MACJiB,QAAQ,EAAE,iCAAiC;MAC3Cf,YAAY;MACZgB,MAAM,EAAEd,OAAO,EAAEL;KAClB,CAAC;EACJ;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}