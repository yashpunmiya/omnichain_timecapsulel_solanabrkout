{"ast":null,"code":"import { BaseError } from '../../errors/base.js';\nimport { observe } from '../../utils/observe.js';\nimport { poll } from '../../utils/poll.js';\nimport { withResolvers } from '../../utils/promise/withResolvers.js';\nimport { stringify } from '../../utils/stringify.js';\nimport { getCallsStatus } from './getCallsStatus.js';\n/**\n * Waits for the status & receipts of a call bundle that was sent via `sendCalls`.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/waitForCallsStatus\n * - JSON-RPC Methods: [`wallet_getCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)\n *\n * @param client - Client to use\n * @param parameters - {@link WaitForCallsStatusParameters}\n * @returns Status & receipts of the call bundle. {@link WaitForCallsStatusReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { waitForCallsStatus } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n *\n * const { receipts, status } = await waitForCallsStatus(client, { id: '0xdeadbeef' })\n */\nexport async function waitForCallsStatus(client, parameters) {\n  const {\n    id,\n    pollingInterval = client.pollingInterval,\n    status = ({\n      statusCode\n    }) => statusCode >= 200,\n    timeout = 60_000\n  } = parameters;\n  const observerId = stringify(['waitForCallsStatus', client.uid, id]);\n  const {\n    promise,\n    resolve,\n    reject\n  } = withResolvers();\n  let timer = undefined;\n  const unobserve = observe(observerId, {\n    resolve,\n    reject\n  }, emit => {\n    const unpoll = poll(async () => {\n      const done = fn => {\n        clearTimeout(timer);\n        unpoll();\n        fn();\n        unobserve();\n      };\n      try {\n        const result = await getCallsStatus(client, {\n          id\n        });\n        if (!status(result)) return;\n        done(() => emit.resolve(result));\n      } catch (error) {\n        done(() => emit.reject(error));\n      }\n    }, {\n      interval: pollingInterval,\n      emitOnBegin: true\n    });\n    return unpoll;\n  });\n  timer = timeout ? setTimeout(() => {\n    unobserve();\n    clearTimeout(timer);\n    reject(new WaitForCallsStatusTimeoutError({\n      id\n    }));\n  }, timeout) : undefined;\n  return await promise;\n}\nexport class WaitForCallsStatusTimeoutError extends BaseError {\n  constructor({\n    id\n  }) {\n    super(`Timed out while waiting for call bundle with id \"${id}\" to be confirmed.`, {\n      name: 'WaitForCallsStatusTimeoutError'\n    });\n  }\n}","map":{"version":3,"names":["BaseError","observe","poll","withResolvers","stringify","getCallsStatus","waitForCallsStatus","client","parameters","id","pollingInterval","status","statusCode","timeout","observerId","uid","promise","resolve","reject","timer","undefined","unobserve","emit","unpoll","done","fn","clearTimeout","result","error","interval","emitOnBegin","setTimeout","WaitForCallsStatusTimeoutError","constructor","name"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\viem\\actions\\wallet\\waitForCallsStatus.ts"],"sourcesContent":["import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport { type ObserveErrorType, observe } from '../../utils/observe.js'\nimport { type PollErrorType, poll } from '../../utils/poll.js'\nimport { withResolvers } from '../../utils/promise/withResolvers.js'\nimport { stringify } from '../../utils/stringify.js'\nimport {\n  type GetCallsStatusErrorType,\n  type GetCallsStatusReturnType,\n  getCallsStatus,\n} from './getCallsStatus.js'\n\nexport type WaitForCallsStatusParameters = {\n  /**\n   * The id of the call batch to wait for.\n   */\n  id: string\n  /**\n   * Polling frequency (in ms). Defaults to the client's pollingInterval config.\n   *\n   * @default client.pollingInterval\n   */\n  pollingInterval?: number | undefined\n  /**\n   * The status range to wait for.\n   *\n   * @default (status) => status >= 200\n   */\n  status?: ((parameters: GetCallsStatusReturnType) => boolean) | undefined\n  /**\n   * Optional timeout (in milliseconds) to wait before stopping polling.\n   *\n   * @default 60_000\n   */\n  timeout?: number | undefined\n}\n\nexport type WaitForCallsStatusReturnType = GetCallsStatusReturnType\n\nexport type WaitForCallsStatusErrorType =\n  | ObserveErrorType\n  | PollErrorType\n  | GetCallsStatusErrorType\n  | WaitForCallsStatusTimeoutError\n  | ErrorType\n\n/**\n * Waits for the status & receipts of a call bundle that was sent via `sendCalls`.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/waitForCallsStatus\n * - JSON-RPC Methods: [`wallet_getCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)\n *\n * @param client - Client to use\n * @param parameters - {@link WaitForCallsStatusParameters}\n * @returns Status & receipts of the call bundle. {@link WaitForCallsStatusReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { waitForCallsStatus } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n *\n * const { receipts, status } = await waitForCallsStatus(client, { id: '0xdeadbeef' })\n */\nexport async function waitForCallsStatus<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: WaitForCallsStatusParameters,\n): Promise<WaitForCallsStatusReturnType> {\n  const {\n    id,\n    pollingInterval = client.pollingInterval,\n    status = ({ statusCode }) => statusCode >= 200,\n    timeout = 60_000,\n  } = parameters\n  const observerId = stringify(['waitForCallsStatus', client.uid, id])\n\n  const { promise, resolve, reject } =\n    withResolvers<WaitForCallsStatusReturnType>()\n\n  let timer: Timer | undefined = undefined\n\n  const unobserve = observe(observerId, { resolve, reject }, (emit) => {\n    const unpoll = poll(\n      async () => {\n        const done = (fn: () => void) => {\n          clearTimeout(timer)\n          unpoll()\n          fn()\n          unobserve()\n        }\n\n        try {\n          const result = await getCallsStatus(client, { id })\n          if (!status(result)) return\n          done(() => emit.resolve(result))\n        } catch (error) {\n          done(() => emit.reject(error))\n        }\n      },\n      {\n        interval: pollingInterval,\n        emitOnBegin: true,\n      },\n    )\n\n    return unpoll\n  })\n\n  timer = timeout\n    ? setTimeout(() => {\n        unobserve()\n        clearTimeout(timer)\n        reject(new WaitForCallsStatusTimeoutError({ id }))\n      }, timeout)\n    : undefined\n\n  return await promise\n}\n\nexport type WaitForCallsStatusTimeoutErrorType =\n  WaitForCallsStatusTimeoutError & {\n    name: 'WaitForCallsStatusTimeoutError'\n  }\nexport class WaitForCallsStatusTimeoutError extends BaseError {\n  constructor({ id }: { id: string }) {\n    super(\n      `Timed out while waiting for call bundle with id \"${id}\" to be confirmed.`,\n      { name: 'WaitForCallsStatusTimeoutError' },\n    )\n  }\n}\n"],"mappings":"AAEA,SAASA,SAAS,QAAQ,sBAAsB;AAGhD,SAAgCC,OAAO,QAAQ,wBAAwB;AACvE,SAA6BC,IAAI,QAAQ,qBAAqB;AAC9D,SAASC,aAAa,QAAQ,sCAAsC;AACpE,SAASC,SAAS,QAAQ,0BAA0B;AACpD,SAGEC,cAAc,QACT,qBAAqB;AAoC5B;;;;;;;;;;;;;;;;;;;;;;AAsBA,OAAO,eAAeC,kBAAkBA,CACtCC,MAAgC,EAChCC,UAAwC;EAExC,MAAM;IACJC,EAAE;IACFC,eAAe,GAAGH,MAAM,CAACG,eAAe;IACxCC,MAAM,GAAGA,CAAC;MAAEC;IAAU,CAAE,KAAKA,UAAU,IAAI,GAAG;IAC9CC,OAAO,GAAG;EAAM,CACjB,GAAGL,UAAU;EACd,MAAMM,UAAU,GAAGV,SAAS,CAAC,CAAC,oBAAoB,EAAEG,MAAM,CAACQ,GAAG,EAAEN,EAAE,CAAC,CAAC;EAEpE,MAAM;IAAEO,OAAO;IAAEC,OAAO;IAAEC;EAAM,CAAE,GAChCf,aAAa,EAAgC;EAE/C,IAAIgB,KAAK,GAAsBC,SAAS;EAExC,MAAMC,SAAS,GAAGpB,OAAO,CAACa,UAAU,EAAE;IAAEG,OAAO;IAAEC;EAAM,CAAE,EAAGI,IAAI,IAAI;IAClE,MAAMC,MAAM,GAAGrB,IAAI,CACjB,YAAW;MACT,MAAMsB,IAAI,GAAIC,EAAc,IAAI;QAC9BC,YAAY,CAACP,KAAK,CAAC;QACnBI,MAAM,EAAE;QACRE,EAAE,EAAE;QACJJ,SAAS,EAAE;MACb,CAAC;MAED,IAAI;QACF,MAAMM,MAAM,GAAG,MAAMtB,cAAc,CAACE,MAAM,EAAE;UAAEE;QAAE,CAAE,CAAC;QACnD,IAAI,CAACE,MAAM,CAACgB,MAAM,CAAC,EAAE;QACrBH,IAAI,CAAC,MAAMF,IAAI,CAACL,OAAO,CAACU,MAAM,CAAC,CAAC;MAClC,CAAC,CAAC,OAAOC,KAAK,EAAE;QACdJ,IAAI,CAAC,MAAMF,IAAI,CAACJ,MAAM,CAACU,KAAK,CAAC,CAAC;MAChC;IACF,CAAC,EACD;MACEC,QAAQ,EAAEnB,eAAe;MACzBoB,WAAW,EAAE;KACd,CACF;IAED,OAAOP,MAAM;EACf,CAAC,CAAC;EAEFJ,KAAK,GAAGN,OAAO,GACXkB,UAAU,CAAC,MAAK;IACdV,SAAS,EAAE;IACXK,YAAY,CAACP,KAAK,CAAC;IACnBD,MAAM,CAAC,IAAIc,8BAA8B,CAAC;MAAEvB;IAAE,CAAE,CAAC,CAAC;EACpD,CAAC,EAAEI,OAAO,CAAC,GACXO,SAAS;EAEb,OAAO,MAAMJ,OAAO;AACtB;AAMA,OAAM,MAAOgB,8BAA+B,SAAQhC,SAAS;EAC3DiC,YAAY;IAAExB;EAAE,CAAkB;IAChC,KAAK,CACH,oDAAoDA,EAAE,oBAAoB,EAC1E;MAAEyB,IAAI,EAAE;IAAgC,CAAE,CAC3C;EACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}