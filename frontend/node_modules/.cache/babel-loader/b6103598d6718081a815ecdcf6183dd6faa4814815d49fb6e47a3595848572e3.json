{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport Transport from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/hid-framing\";\nimport { identifyUSBProductId, ledgerUSBVendorId } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport { TransportOpenUserCancelled, DisconnectedDeviceDuringOperation, DisconnectedDevice, TransportError } from \"@ledgerhq/errors\";\nconst ledgerDevices = [{\n  vendorId: ledgerUSBVendorId\n}];\nconst isSupported = () => Promise.resolve(!!(window.navigator && window.navigator.hid));\nconst getHID = () => {\n  // $FlowFixMe\n  const {\n    hid\n  } = navigator;\n  if (!hid) throw new TransportError(\"navigator.hid is not supported\", \"HIDNotSupported\");\n  return hid;\n};\nfunction requestLedgerDevices() {\n  return __awaiter(this, void 0, void 0, function* () {\n    const device = yield getHID().requestDevice({\n      filters: ledgerDevices\n    });\n    if (Array.isArray(device)) return device;\n    return [device];\n  });\n}\nfunction getLedgerDevices() {\n  return __awaiter(this, void 0, void 0, function* () {\n    const devices = yield getHID().getDevices();\n    return devices.filter(d => d.vendorId === ledgerUSBVendorId);\n  });\n}\nfunction getFirstLedgerDevice() {\n  return __awaiter(this, void 0, void 0, function* () {\n    const existingDevices = yield getLedgerDevices();\n    if (existingDevices.length > 0) return existingDevices[0];\n    const devices = yield requestLedgerDevices();\n    return devices[0];\n  });\n}\n/**\n * WebHID Transport implementation\n * @example\n * import TransportWebHID from \"@ledgerhq/hw-transport-webhid\";\n * ...\n * TransportWebHID.create().then(transport => ...)\n */\nclass TransportWebHID extends Transport {\n  constructor(device) {\n    super();\n    this.channel = Math.floor(Math.random() * 0xffff);\n    this.packetSize = 64;\n    this.inputs = [];\n    this.read = () => {\n      if (this.inputs.length) {\n        return Promise.resolve(this.inputs.shift());\n      }\n      return new Promise(success => {\n        this.inputCallback = success;\n      });\n    };\n    this.onInputReport = e => {\n      const buffer = Buffer.from(e.data.buffer);\n      if (this.inputCallback) {\n        this.inputCallback(buffer);\n        this.inputCallback = null;\n      } else {\n        this.inputs.push(buffer);\n      }\n    };\n    this._disconnectEmitted = false;\n    this._emitDisconnect = e => {\n      if (this._disconnectEmitted) return;\n      this._disconnectEmitted = true;\n      this.emit(\"disconnect\", e);\n    };\n    /**\n     * Exchange with the device using APDU protocol.\n     * @param apdu\n     * @returns a promise of apdu response\n     */\n    this.exchange = apdu => __awaiter(this, void 0, void 0, function* () {\n      const b = yield this.exchangeAtomicImpl(() => __awaiter(this, void 0, void 0, function* () {\n        const {\n          channel,\n          packetSize\n        } = this;\n        log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n        const framing = hidFraming(channel, packetSize);\n        // Write...\n        const blocks = framing.makeBlocks(apdu);\n        for (let i = 0; i < blocks.length; i++) {\n          yield this.device.sendReport(0, blocks[i]);\n        }\n        // Read...\n        let result;\n        let acc;\n        while (!(result = framing.getReducedResult(acc))) {\n          try {\n            const buffer = yield this.read();\n            acc = framing.reduceResponse(acc, buffer);\n          } catch (e) {\n            if (e instanceof TransportError && e.id === \"InvalidChannel\") {\n              // this can happen if the device is connected\n              // on a different channel (like another app)\n              // in this case we just filter out the event\n              continue;\n            }\n            throw e;\n          }\n        }\n        log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n        return result;\n      })).catch(e => {\n        if (e && e.message && e.message.includes(\"write\")) {\n          this._emitDisconnect(e);\n          throw new DisconnectedDeviceDuringOperation(e.message);\n        }\n        throw e;\n      });\n      return b;\n    });\n    this.device = device;\n    this.deviceModel = typeof device.productId === \"number\" ? identifyUSBProductId(device.productId) : undefined;\n    device.addEventListener(\"inputreport\", this.onInputReport);\n  }\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n  static request() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const [device] = yield requestLedgerDevices();\n      return TransportWebHID.open(device);\n    });\n  }\n  /**\n   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n   */\n  static openConnected() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const devices = yield getLedgerDevices();\n      if (devices.length === 0) return null;\n      return TransportWebHID.open(devices[0]);\n    });\n  }\n  /**\n   * Create a Ledger transport with a HIDDevice\n   */\n  static open(device) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield device.open();\n      const transport = new TransportWebHID(device);\n      const onDisconnect = e => {\n        if (device === e.device) {\n          getHID().removeEventListener(\"disconnect\", onDisconnect);\n          transport._emitDisconnect(new DisconnectedDevice());\n        }\n      };\n      getHID().addEventListener(\"disconnect\", onDisconnect);\n      return transport;\n    });\n  }\n  /**\n   * Release the transport device\n   */\n  close() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.exchangeBusyPromise;\n      this.device.removeEventListener(\"inputreport\", this.onInputReport);\n      yield this.device.close();\n    });\n  }\n  setScrambleKey() {}\n}\n/**\n * Check if WebUSB transport is supported.\n */\nTransportWebHID.isSupported = isSupported;\n/**\n * List the WebUSB devices that was previously authorized by the user.\n */\nTransportWebHID.list = getLedgerDevices;\n/**\n * Actively listen to WebUSB devices and emit ONE device\n * that was either accepted before, if not it will trigger the native permission UI.\n *\n * Important: it must be called in the context of a UI click!\n */\nTransportWebHID.listen = observer => {\n  let unsubscribed = false;\n  getFirstLedgerDevice().then(device => {\n    if (!device) {\n      observer.error(new TransportOpenUserCancelled(\"Access denied to use Ledger device\"));\n    } else if (!unsubscribed) {\n      const deviceModel = typeof device.productId === \"number\" ? identifyUSBProductId(device.productId) : undefined;\n      observer.next({\n        type: \"add\",\n        descriptor: device,\n        deviceModel\n      });\n      observer.complete();\n    }\n  }, error => {\n    observer.error(new TransportOpenUserCancelled(error.message));\n  });\n  function unsubscribe() {\n    unsubscribed = true;\n  }\n  return {\n    unsubscribe\n  };\n};\nexport default TransportWebHID;\n//# sourceMappingURL=TransportWebHID.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}