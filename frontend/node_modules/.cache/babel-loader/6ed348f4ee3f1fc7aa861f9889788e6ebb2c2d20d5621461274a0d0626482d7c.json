{"ast":null,"code":"import { getRandomBytesSync } from 'ethereum-cryptography/random.js';\n// eslint-disable-next-line no-restricted-imports\nimport { bytesToHex as _bytesToUnprefixedHex } from 'ethereum-cryptography/utils.js';\nimport { assertIsArray, assertIsBytes, assertIsHexString } from './helpers.js';\nimport { isHexString, padToEven, stripHexPrefix } from './internal.js';\nconst BIGINT_0 = BigInt(0);\n/**\n * @deprecated\n */\nexport const bytesToUnprefixedHex = _bytesToUnprefixedHex;\n// hexToBytes cache\nconst hexToBytesMapFirstKey = {};\nconst hexToBytesMapSecondKey = {};\nfor (let i = 0; i < 16; i++) {\n  const vSecondKey = i;\n  const vFirstKey = i * 16;\n  const key = i.toString(16).toLowerCase();\n  hexToBytesMapSecondKey[key] = vSecondKey;\n  hexToBytesMapSecondKey[key.toUpperCase()] = vSecondKey;\n  hexToBytesMapFirstKey[key] = vFirstKey;\n  hexToBytesMapFirstKey[key.toUpperCase()] = vFirstKey;\n}\n/**\n * NOTE: only use this function if the string is even, and only consists of hex characters\n * If this is not the case, this function could return weird results\n * @deprecated\n */\nfunction _unprefixedHexToBytes(hex) {\n  const byteLen = hex.length;\n  const bytes = new Uint8Array(byteLen / 2);\n  for (let i = 0; i < byteLen; i += 2) {\n    bytes[i / 2] = hexToBytesMapFirstKey[hex[i]] + hexToBytesMapSecondKey[hex[i + 1]];\n  }\n  return bytes;\n}\n/**\n * @deprecated\n */\nexport const unprefixedHexToBytes = inp => {\n  if (inp.slice(0, 2) === '0x') {\n    throw new Error('hex string is prefixed with 0x, should be unprefixed');\n  } else {\n    return _unprefixedHexToBytes(padToEven(inp));\n  }\n};\n/****************  Borrowed from @chainsafe/ssz */\n// Caching this info costs about ~1000 bytes and speeds up toHexString() by x6\nconst hexByByte = Array.from({\n  length: 256\n}, (v, i) => i.toString(16).padStart(2, '0'));\nexport const bytesToHex = bytes => {\n  let hex = `0x`;\n  if (bytes === undefined || bytes.length === 0) return hex;\n  for (const byte of bytes) {\n    hex = `${hex}${hexByByte[byte]}`;\n  }\n  return hex;\n};\n// BigInt cache for the numbers 0 - 256*256-1 (two-byte bytes)\nconst BIGINT_CACHE = [];\nfor (let i = 0; i <= 256 * 256 - 1; i++) {\n  BIGINT_CACHE[i] = BigInt(i);\n}\n/**\n * Converts a {@link Uint8Array} to a {@link bigint}\n * @param {Uint8Array} bytes the bytes to convert\n * @returns {bigint}\n */\nexport const bytesToBigInt = (bytes, littleEndian = false) => {\n  if (littleEndian) {\n    bytes.reverse();\n  }\n  const hex = bytesToHex(bytes);\n  if (hex === '0x') {\n    return BIGINT_0;\n  }\n  if (hex.length === 4) {\n    // If the byte length is 1 (this is faster than checking `bytes.length === 1`)\n    return BIGINT_CACHE[bytes[0]];\n  }\n  if (hex.length === 6) {\n    return BIGINT_CACHE[bytes[0] * 256 + bytes[1]];\n  }\n  return BigInt(hex);\n};\n/**\n * Converts a {@link Uint8Array} to a {@link number}.\n * @param {Uint8Array} bytes the bytes to convert\n * @return  {number}\n * @throws If the input number exceeds 53 bits.\n */\nexport const bytesToInt = bytes => {\n  const res = Number(bytesToBigInt(bytes));\n  if (!Number.isSafeInteger(res)) throw new Error('Number exceeds 53 bits');\n  return res;\n};\n// TODO: Restrict the input type to only PrefixedHexString\n/**\n * Converts a {@link PrefixedHexString} to a {@link Uint8Array}\n * @param {PrefixedHexString | string} hex The 0x-prefixed hex string to convert\n * @returns {Uint8Array} The converted bytes\n * @throws If the input is not a valid 0x-prefixed hex string\n */\nexport const hexToBytes = hex => {\n  if (typeof hex !== 'string') {\n    throw new Error(`hex argument type ${typeof hex} must be of type string`);\n  }\n  if (!/^0x[0-9a-fA-F]*$/.test(hex)) {\n    throw new Error(`Input must be a 0x-prefixed hexadecimal string, got ${hex}`);\n  }\n  const unprefixedHex = hex.slice(2);\n  return _unprefixedHexToBytes(unprefixedHex.length % 2 === 0 ? unprefixedHex : padToEven(unprefixedHex));\n};\n/******************************************/\n/**\n * Converts a {@link number} into a {@link PrefixedHexString}\n * @param {number} i\n * @return {PrefixedHexString}\n */\nexport const intToHex = i => {\n  if (!Number.isSafeInteger(i) || i < 0) {\n    throw new Error(`Received an invalid integer type: ${i}`);\n  }\n  return `0x${i.toString(16)}`;\n};\n/**\n * Converts an {@link number} to a {@link Uint8Array}\n * @param {Number} i\n * @return {Uint8Array}\n */\nexport const intToBytes = i => {\n  const hex = intToHex(i);\n  return hexToBytes(hex);\n};\n/**\n * Converts a {@link bigint} to a {@link Uint8Array}\n *  * @param {bigint} num the bigint to convert\n * @returns {Uint8Array}\n */\nexport const bigIntToBytes = (num, littleEndian = false) => {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  const bytes = toBytes(`0x${padToEven(num.toString(16))}`);\n  return littleEndian ? bytes.reverse() : bytes;\n};\n/**\n * Returns a Uint8Array filled with 0s.\n * @param {number} bytes the number of bytes of the Uint8Array\n * @return {Uint8Array}\n */\nexport const zeros = bytes => {\n  return new Uint8Array(bytes);\n};\n/**\n * Pads a `Uint8Array` with zeros till it has `length` bytes.\n * Truncates the beginning or end of input if its length exceeds `length`.\n * @param {Uint8Array} msg the value to pad\n * @param {number} length the number of bytes the output should be\n * @param {boolean} right whether to start padding form the left or right\n * @return {Uint8Array}\n */\nconst setLength = (msg, length, right) => {\n  if (right) {\n    if (msg.length < length) {\n      return new Uint8Array([...msg, ...zeros(length - msg.length)]);\n    }\n    return msg.subarray(0, length);\n  } else {\n    if (msg.length < length) {\n      return new Uint8Array([...zeros(length - msg.length), ...msg]);\n    }\n    return msg.subarray(-length);\n  }\n};\n/**\n * Left Pads a `Uint8Array` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @param {Uint8Array} msg the value to pad\n * @param {number} length the number of bytes the output should be\n * @return {Uint8Array}\n */\nexport const setLengthLeft = (msg, length) => {\n  assertIsBytes(msg);\n  return setLength(msg, length, false);\n};\n/**\n * Right Pads a `Uint8Array` with trailing zeros till it has `length` bytes.\n * it truncates the end if it exceeds.\n * @param {Uint8Array} msg the value to pad\n * @param {number} length the number of bytes the output should be\n * @return {Uint8Array}\n */\nexport const setLengthRight = (msg, length) => {\n  assertIsBytes(msg);\n  return setLength(msg, length, true);\n};\n/**\n * Trims leading zeros from a `Uint8Array`, `number[]` or `string`.\n * @param {Uint8Array|number[]|string} a\n * @return {Uint8Array|number[]|string}\n */\nconst stripZeros = a => {\n  let first = a[0];\n  while (a.length > 0 && first.toString() === '0') {\n    a = a.slice(1);\n    first = a[0];\n  }\n  return a;\n};\n/**\n * Trims leading zeros from a `Uint8Array`.\n * @param {Uint8Array} a\n * @return {Uint8Array}\n */\nexport const unpadBytes = a => {\n  assertIsBytes(a);\n  return stripZeros(a);\n};\n/**\n * Trims leading zeros from an `Array` (of numbers).\n * @param  {number[]} a\n * @return {number[]}\n */\nexport const unpadArray = a => {\n  assertIsArray(a);\n  return stripZeros(a);\n};\n// TODO: Restrict the input type to only PrefixedHexString\n/**\n * Trims leading zeros from a `PrefixedHexString`.\n * @param {PrefixedHexString | string} a\n * @return {PrefixedHexString}\n */\nexport const unpadHex = a => {\n  assertIsHexString(a);\n  return `0x${stripZeros(stripHexPrefix(a))}`;\n};\n/**\n * Attempts to turn a value into a `Uint8Array`.\n * Inputs supported: `Buffer`, `Uint8Array`, `String` (hex-prefixed), `Number`, null/undefined, `BigInt` and other objects\n * with a `toArray()` or `toBytes()` method.\n * @param {ToBytesInputTypes} v the value\n * @return {Uint8Array}\n */\nexport const toBytes = v => {\n  if (v === null || v === undefined) {\n    return new Uint8Array();\n  }\n  if (Array.isArray(v) || v instanceof Uint8Array) {\n    return Uint8Array.from(v);\n  }\n  if (typeof v === 'string') {\n    if (!isHexString(v)) {\n      throw new Error(`Cannot convert string to Uint8Array. toBytes only supports 0x-prefixed hex strings and this string was given: ${v}`);\n    }\n    return hexToBytes(v);\n  }\n  if (typeof v === 'number') {\n    return intToBytes(v);\n  }\n  if (typeof v === 'bigint') {\n    if (v < BIGINT_0) {\n      throw new Error(`Cannot convert negative bigint to Uint8Array. Given: ${v}`);\n    }\n    let n = v.toString(16);\n    if (n.length % 2) n = '0' + n;\n    return unprefixedHexToBytes(n);\n  }\n  if (v.toBytes !== undefined) {\n    // converts a `TransformableToBytes` object to a Uint8Array\n    return v.toBytes();\n  }\n  throw new Error('invalid type');\n};\n/**\n * Interprets a `Uint8Array` as a signed integer and returns a `BigInt`. Assumes 256-bit numbers.\n * @param {Uint8Array} num Signed integer value\n * @returns {bigint}\n */\nexport const fromSigned = num => {\n  return BigInt.asIntN(256, bytesToBigInt(num));\n};\n/**\n * Converts a `BigInt` to an unsigned integer and returns it as a `Uint8Array`. Assumes 256-bit numbers.\n * @param {bigint} num\n * @returns {Uint8Array}\n */\nexport const toUnsigned = num => {\n  return bigIntToBytes(BigInt.asUintN(256, num));\n};\n/**\n * Adds \"0x\" to a given `string` if it does not already start with \"0x\".\n * @param {string} str\n * @return {PrefixedHexString}\n */\nexport const addHexPrefix = str => {\n  if (typeof str !== 'string') {\n    return str;\n  }\n  return isHexString(str) ? str : `0x${str}`;\n};\n/**\n * Shortens a string  or Uint8Array's hex string representation to maxLength (default 50).\n *\n * Examples:\n *\n * Input:  '657468657265756d000000000000000000000000000000000000000000000000'\n * Output: '657468657265756d0000000000000000000000000000000000â€¦'\n * @param {Uint8Array | string} bytes\n * @param {number} maxLength\n * @return {string}\n */\nexport const short = (bytes, maxLength = 50) => {\n  const byteStr = bytes instanceof Uint8Array ? bytesToHex(bytes) : bytes;\n  const len = byteStr.slice(0, 2) === '0x' ? maxLength + 2 : maxLength;\n  if (byteStr.length <= len) {\n    return byteStr;\n  }\n  return byteStr.slice(0, len) + 'â€¦';\n};\n/**\n * Checks provided Uint8Array for leading zeroes and throws if found.\n *\n * Examples:\n *\n * Valid values: 0x1, 0x, 0x01, 0x1234\n * Invalid values: 0x0, 0x00, 0x001, 0x0001\n *\n * Note: This method is useful for validating that RLP encoded integers comply with the rule that all\n * integer values encoded to RLP must be in the most compact form and contain no leading zero bytes\n * @param values An object containing string keys and Uint8Array values\n * @throws if any provided value is found to have leading zero bytes\n */\nexport const validateNoLeadingZeroes = values => {\n  for (const [k, v] of Object.entries(values)) {\n    if (v !== undefined && v.length > 0 && v[0] === 0) {\n      throw new Error(`${k} cannot have leading zeroes, received: ${bytesToHex(v)}`);\n    }\n  }\n};\n/**\n * Converts a {@link bigint} to a `0x` prefixed hex string\n * @param {bigint} num the bigint to convert\n * @returns {PrefixedHexString}\n */\nexport const bigIntToHex = num => {\n  return `0x${num.toString(16)}`;\n};\n/**\n * Calculates max bigint from an array of bigints\n * @param args array of bigints\n */\nexport const bigIntMax = (...args) => args.reduce((m, e) => e > m ? e : m);\n/**\n * Calculates min BigInt from an array of BigInts\n * @param args array of bigints\n */\nexport const bigIntMin = (...args) => args.reduce((m, e) => e < m ? e : m);\n/**\n * Convert value from bigint to an unpadded Uint8Array\n * (useful for RLP transport)\n * @param {bigint} value the bigint to convert\n * @returns {Uint8Array}\n */\nexport const bigIntToUnpaddedBytes = value => {\n  return unpadBytes(bigIntToBytes(value));\n};\nexport const bigIntToAddressBytes = (value, strict = true) => {\n  const addressBytes = bigIntToBytes(value);\n  if (strict && addressBytes.length > 20) {\n    throw Error(`Invalid address bytes length=${addressBytes.length} strict=${strict}`);\n  }\n  // setLength already slices if more than requisite length\n  return setLengthLeft(addressBytes, 20);\n};\n/**\n * Convert value from number to an unpadded Uint8Array\n * (useful for RLP transport)\n * @param {number} value the bigint to convert\n * @returns {Uint8Array}\n */\nexport const intToUnpaddedBytes = value => {\n  return unpadBytes(intToBytes(value));\n};\n/**\n * Compares two Uint8Arrays and returns a number indicating their order in a sorted array.\n *\n * @param {Uint8Array} value1 - The first Uint8Array to compare.\n * @param {Uint8Array} value2 - The second Uint8Array to compare.\n * @returns {number} A positive number if value1 is larger than value2,\n *                   A negative number if value1 is smaller than value2,\n *                   or 0 if value1 and value2 are equal.\n */\nexport const compareBytes = (value1, value2) => {\n  const bigIntValue1 = bytesToBigInt(value1);\n  const bigIntValue2 = bytesToBigInt(value2);\n  return bigIntValue1 > bigIntValue2 ? 1 : bigIntValue1 < bigIntValue2 ? -1 : 0;\n};\n/**\n * Generates a Uint8Array of random bytes of specified length.\n *\n * @param {number} length - The length of the Uint8Array.\n * @returns {Uint8Array} A Uint8Array of random bytes of specified length.\n */\nexport const randomBytes = length => {\n  return getRandomBytesSync(length);\n};\n/**\n * This mirrors the functionality of the `ethereum-cryptography` export except\n * it skips the check to validate that every element of `arrays` is indead a `uint8Array`\n * Can give small performance gains on large arrays\n * @param {Uint8Array[]} arrays an array of Uint8Arrays\n * @returns {Uint8Array} one Uint8Array with all the elements of the original set\n * works like `Buffer.concat`\n */\nexport const concatBytes = (...arrays) => {\n  if (arrays.length === 1) return arrays[0];\n  const length = arrays.reduce((a, arr) => a + arr.length, 0);\n  const result = new Uint8Array(length);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const arr = arrays[i];\n    result.set(arr, pad);\n    pad += arr.length;\n  }\n  return result;\n};\n/**\n * @notice Convert a Uint8Array to a 32-bit integer\n * @param {Uint8Array} bytes The input Uint8Array from which to read the 32-bit integer.\n * @param {boolean} littleEndian True for little-endian, undefined or false for big-endian.\n * @return {number} The 32-bit integer read from the input Uint8Array.\n */\nexport function bytesToInt32(bytes, littleEndian = false) {\n  if (bytes.length < 4) {\n    bytes = setLength(bytes, 4, littleEndian);\n  }\n  const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n  return dataView.getUint32(0, littleEndian);\n}\n/**\n * @notice Convert a Uint8Array to a 64-bit bigint\n * @param {Uint8Array} bytes The input Uint8Array from which to read the 64-bit bigint.\n * @param {boolean} littleEndian True for little-endian, undefined or false for big-endian.\n * @return {bigint} The 64-bit bigint read from the input Uint8Array.\n */\nexport function bytesToBigInt64(bytes, littleEndian = false) {\n  if (bytes.length < 8) {\n    bytes = setLength(bytes, 8, littleEndian);\n  }\n  const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n  return dataView.getBigUint64(0, littleEndian);\n}\n/**\n * @notice Convert a 32-bit integer to a Uint8Array.\n * @param {number} value The 32-bit integer to convert.\n * @param {boolean} littleEndian True for little-endian, undefined or false for big-endian.\n * @return {Uint8Array} A Uint8Array of length 4 containing the integer.\n */\nexport function int32ToBytes(value, littleEndian = false) {\n  const buffer = new ArrayBuffer(4);\n  const dataView = new DataView(buffer);\n  dataView.setUint32(0, value, littleEndian);\n  return new Uint8Array(buffer);\n}\n/**\n * @notice Convert a 64-bit bigint to a Uint8Array.\n * @param {bigint} value The 64-bit bigint to convert.\n * @param {boolean} littleEndian True for little-endian, undefined or false for big-endian.\n * @return {Uint8Array} A Uint8Array of length 8 containing the bigint.\n */\nexport function bigInt64ToBytes(value, littleEndian = false) {\n  const buffer = new ArrayBuffer(8);\n  const dataView = new DataView(buffer);\n  dataView.setBigUint64(0, value, littleEndian);\n  return new Uint8Array(buffer);\n}\n// eslint-disable-next-line no-restricted-imports\nexport { bytesToUtf8, equalsBytes, utf8ToBytes } from 'ethereum-cryptography/utils.js';\n// TODO: Restrict the input type to only PrefixedHexString\nexport function hexToBigInt(input) {\n  return bytesToBigInt(hexToBytes(isHexString(input) ? input : `0x${input}`));\n}\n//# sourceMappingURL=bytes.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}