{"ast":null,"code":"import { pad } from '../../utils/data/pad.js';\nimport { toBytes } from '../../utils/encoding/toBytes.js';\nimport { sha256 } from '../../utils/hash/sha256.js';\nimport { maxBytecodeSize } from '../constants/number.js';\nimport { BytecodeLengthExceedsMaxSizeError, BytecodeLengthInWordsMustBeOddError, BytecodeLengthMustBeDivisibleBy32Error } from '../errors/bytecode.js';\nexport function hashBytecode(bytecode) {\n  const bytecodeBytes = toBytes(bytecode);\n  if (bytecodeBytes.length % 32 !== 0) throw new BytecodeLengthMustBeDivisibleBy32Error({\n    givenLength: bytecodeBytes.length\n  });\n  if (bytecodeBytes.length > maxBytecodeSize) throw new BytecodeLengthExceedsMaxSizeError({\n    givenLength: bytecodeBytes.length,\n    maxBytecodeSize\n  });\n  const hashStr = sha256(bytecodeBytes);\n  const hash = toBytes(hashStr);\n  // Note that the length of the bytecode\n  // should be provided in 32-byte words.\n  const bytecodeLengthInWords = bytecodeBytes.length / 32;\n  if (bytecodeLengthInWords % 2 === 0) {\n    throw new BytecodeLengthInWordsMustBeOddError({\n      givenLengthInWords: bytecodeLengthInWords\n    });\n  }\n  const bytecodeLength = toBytes(bytecodeLengthInWords);\n  // The bytecode should always take the first 2 bytes of the bytecode hash,\n  // so we pad it from the left in case the length is smaller than 2 bytes.\n  const bytecodeLengthPadded = pad(bytecodeLength, {\n    size: 2\n  });\n  const codeHashVersion = new Uint8Array([1, 0]);\n  hash.set(codeHashVersion, 0);\n  hash.set(bytecodeLengthPadded, 2);\n  return hash;\n}\n//# sourceMappingURL=hashBytecode.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}