{"ast":null,"code":"import * as BlockOverrides from 'ox/BlockOverrides';\nimport { parseAccount } from '../../accounts/utils/parseAccount.js';\nimport { AbiDecodingZeroDataError } from '../../errors/abi.js';\nimport { RawContractError } from '../../errors/contract.js';\nimport { UnknownNodeError } from '../../errors/node.js';\nimport { decodeFunctionResult } from '../../utils/abi/decodeFunctionResult.js';\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js';\nimport { numberToHex } from '../../utils/encoding/toHex.js';\nimport { getContractError } from '../../utils/errors/getContractError.js';\nimport { getNodeError } from '../../utils/errors/getNodeError.js';\nimport { formatBlock } from '../../utils/formatters/block.js';\nimport { formatLog } from '../../utils/formatters/log.js';\nimport { formatTransactionRequest } from '../../utils/formatters/transactionRequest.js';\nimport { serializeStateOverride } from '../../utils/stateOverride.js';\nimport { assertRequest } from '../../utils/transaction/assertRequest.js';\n/**\n * Simulates a set of calls on block(s) with optional block and state overrides.\n *\n * @example\n * ```ts\n * import { createClient, http, parseEther } from 'viem'\n * import { simulate } from 'viem/actions'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const result = await simulate(client, {\n *   blocks: [{\n *     blockOverrides: {\n *       number: 69420n,\n *     },\n *     calls: [{\n *       {\n *         account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',\n *         data: '0xdeadbeef',\n *         to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *       },\n *       {\n *         account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',\n *         to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *         value: parseEther('1'),\n *       },\n *     }],\n *     stateOverrides: [{\n *       address: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',\n *       balance: parseEther('10'),\n *     }],\n *   }]\n * })\n * ```\n *\n * @param client - Client to use.\n * @param parameters - {@link SimulateBlocksParameters}\n * @returns Simulated blocks. {@link SimulateBlocksReturnType}\n */\nexport async function simulateBlocks(client, parameters) {\n  const {\n    blockNumber,\n    blockTag = 'latest',\n    blocks,\n    returnFullTransactions,\n    traceTransfers,\n    validation\n  } = parameters;\n  try {\n    const blockStateCalls = [];\n    for (const block of blocks) {\n      const blockOverrides = block.blockOverrides ? BlockOverrides.toRpc(block.blockOverrides) : undefined;\n      const calls = block.calls.map(call_ => {\n        const call = call_;\n        const account = call.account ? parseAccount(call.account) : undefined;\n        const request = {\n          ...call,\n          data: call.abi ? encodeFunctionData(call) : call.data,\n          from: call.from ?? account?.address\n        };\n        assertRequest(request);\n        return formatTransactionRequest(request);\n      });\n      const stateOverrides = block.stateOverrides ? serializeStateOverride(block.stateOverrides) : undefined;\n      blockStateCalls.push({\n        blockOverrides,\n        calls,\n        stateOverrides\n      });\n    }\n    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;\n    const block = blockNumberHex || blockTag;\n    const result = await client.request({\n      method: 'eth_simulateV1',\n      params: [{\n        blockStateCalls,\n        returnFullTransactions,\n        traceTransfers,\n        validation\n      }, block]\n    });\n    return result.map((block, i) => ({\n      ...formatBlock(block),\n      calls: block.calls.map((call, j) => {\n        const {\n          abi,\n          args,\n          functionName,\n          to\n        } = blocks[i].calls[j];\n        const data = call.error?.data ?? call.returnData;\n        const gasUsed = BigInt(call.gasUsed);\n        const logs = call.logs?.map(log => formatLog(log));\n        const status = call.status === '0x1' ? 'success' : 'failure';\n        const result = abi && status === 'success' ? decodeFunctionResult({\n          abi,\n          data,\n          functionName\n        }) : null;\n        const error = (() => {\n          if (status === 'success') return undefined;\n          let error = undefined;\n          if (call.error?.data === '0x') error = new AbiDecodingZeroDataError();else if (call.error) error = new RawContractError(call.error);\n          if (!error) return undefined;\n          return getContractError(error, {\n            abi: abi ?? [],\n            address: to,\n            args,\n            functionName: functionName ?? '<unknown>'\n          });\n        })();\n        return {\n          data,\n          gasUsed,\n          logs,\n          status,\n          ...(status === 'success' ? {\n            result\n          } : {\n            error\n          })\n        };\n      })\n    }));\n  } catch (e) {\n    const cause = e;\n    const error = getNodeError(cause, {});\n    if (error instanceof UnknownNodeError) throw cause;\n    throw error;\n  }\n}\n//# sourceMappingURL=simulateBlocks.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}