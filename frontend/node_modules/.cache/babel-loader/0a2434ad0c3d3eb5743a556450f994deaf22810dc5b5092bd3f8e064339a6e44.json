{"ast":null,"code":"import * as BlockOverrides from 'ox/BlockOverrides';\nimport { parseAccount } from '../../accounts/utils/parseAccount.js';\nimport { AbiDecodingZeroDataError } from '../../errors/abi.js';\nimport { RawContractError } from '../../errors/contract.js';\nimport { UnknownNodeError } from '../../errors/node.js';\nimport { decodeFunctionResult } from '../../utils/abi/decodeFunctionResult.js';\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js';\nimport { numberToHex } from '../../utils/encoding/toHex.js';\nimport { getContractError } from '../../utils/errors/getContractError.js';\nimport { getNodeError } from '../../utils/errors/getNodeError.js';\nimport { formatBlock } from '../../utils/formatters/block.js';\nimport { formatLog } from '../../utils/formatters/log.js';\nimport { formatTransactionRequest } from '../../utils/formatters/transactionRequest.js';\nimport { serializeStateOverride } from '../../utils/stateOverride.js';\nimport { assertRequest } from '../../utils/transaction/assertRequest.js';\n/**\n * Simulates a set of calls on block(s) with optional block and state overrides.\n *\n * @example\n * ```ts\n * import { createClient, http, parseEther } from 'viem'\n * import { simulate } from 'viem/actions'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const result = await simulate(client, {\n *   blocks: [{\n *     blockOverrides: {\n *       number: 69420n,\n *     },\n *     calls: [{\n *       {\n *         account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',\n *         data: '0xdeadbeef',\n *         to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *       },\n *       {\n *         account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',\n *         to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *         value: parseEther('1'),\n *       },\n *     }],\n *     stateOverrides: [{\n *       address: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',\n *       balance: parseEther('10'),\n *     }],\n *   }]\n * })\n * ```\n *\n * @param client - Client to use.\n * @param parameters - {@link SimulateBlocksParameters}\n * @returns Simulated blocks. {@link SimulateBlocksReturnType}\n */\nexport async function simulateBlocks(client, parameters) {\n  const {\n    blockNumber,\n    blockTag = 'latest',\n    blocks,\n    returnFullTransactions,\n    traceTransfers,\n    validation\n  } = parameters;\n  try {\n    const blockStateCalls = [];\n    for (const block of blocks) {\n      const blockOverrides = block.blockOverrides ? BlockOverrides.toRpc(block.blockOverrides) : undefined;\n      const calls = block.calls.map(call_ => {\n        const call = call_;\n        const account = call.account ? parseAccount(call.account) : undefined;\n        const request = {\n          ...call,\n          data: call.abi ? encodeFunctionData(call) : call.data,\n          from: call.from ?? account?.address\n        };\n        assertRequest(request);\n        return formatTransactionRequest(request);\n      });\n      const stateOverrides = block.stateOverrides ? serializeStateOverride(block.stateOverrides) : undefined;\n      blockStateCalls.push({\n        blockOverrides,\n        calls,\n        stateOverrides\n      });\n    }\n    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;\n    const block = blockNumberHex || blockTag;\n    const result = await client.request({\n      method: 'eth_simulateV1',\n      params: [{\n        blockStateCalls,\n        returnFullTransactions,\n        traceTransfers,\n        validation\n      }, block]\n    });\n    return result.map((block, i) => ({\n      ...formatBlock(block),\n      calls: block.calls.map((call, j) => {\n        const {\n          abi,\n          args,\n          functionName,\n          to\n        } = blocks[i].calls[j];\n        const data = call.error?.data ?? call.returnData;\n        const gasUsed = BigInt(call.gasUsed);\n        const logs = call.logs?.map(log => formatLog(log));\n        const status = call.status === '0x1' ? 'success' : 'failure';\n        const result = abi && status === 'success' ? decodeFunctionResult({\n          abi,\n          data,\n          functionName\n        }) : null;\n        const error = (() => {\n          if (status === 'success') return undefined;\n          let error = undefined;\n          if (call.error?.data === '0x') error = new AbiDecodingZeroDataError();else if (call.error) error = new RawContractError(call.error);\n          if (!error) return undefined;\n          return getContractError(error, {\n            abi: abi ?? [],\n            address: to,\n            args,\n            functionName: functionName ?? '<unknown>'\n          });\n        })();\n        return {\n          data,\n          gasUsed,\n          logs,\n          status,\n          ...(status === 'success' ? {\n            result\n          } : {\n            error\n          })\n        };\n      })\n    }));\n  } catch (e) {\n    const cause = e;\n    const error = getNodeError(cause, {});\n    if (error instanceof UnknownNodeError) throw cause;\n    throw error;\n  }\n}","map":{"version":3,"names":["BlockOverrides","parseAccount","AbiDecodingZeroDataError","RawContractError","UnknownNodeError","decodeFunctionResult","encodeFunctionData","numberToHex","getContractError","getNodeError","formatBlock","formatLog","formatTransactionRequest","serializeStateOverride","assertRequest","simulateBlocks","client","parameters","blockNumber","blockTag","blocks","returnFullTransactions","traceTransfers","validation","blockStateCalls","block","blockOverrides","toRpc","undefined","calls","map","call_","call","account","request","data","abi","from","address","stateOverrides","push","blockNumberHex","result","method","params","i","j","args","functionName","to","error","returnData","gasUsed","BigInt","logs","log","status","e","cause"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@reown\\appkit-controllers\\node_modules\\@walletconnect\\utils\\node_modules\\viem\\actions\\public\\simulateBlocks.ts"],"sourcesContent":["import type { Abi, AbiStateMutability, Address, Narrow } from 'abitype'\nimport * as BlockOverrides from 'ox/BlockOverrides'\n\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { AbiDecodingZeroDataError } from '../../errors/abi.js'\nimport type { BaseError } from '../../errors/base.js'\nimport { RawContractError } from '../../errors/contract.js'\nimport { UnknownNodeError } from '../../errors/node.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Block, BlockTag } from '../../types/block.js'\nimport type { Call, Calls } from '../../types/calls.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Log } from '../../types/log.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { MulticallResults } from '../../types/multicall.js'\nimport type { StateOverride } from '../../types/stateOverride.js'\nimport type { TransactionRequest } from '../../types/transaction.js'\nimport type { ExactPartial, UnionOmit } from '../../types/utils.js'\nimport {\n  type DecodeFunctionResultErrorType,\n  decodeFunctionResult,\n} from '../../utils/abi/decodeFunctionResult.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\nimport { getContractError } from '../../utils/errors/getContractError.js'\nimport {\n  type GetNodeErrorReturnType,\n  getNodeError,\n} from '../../utils/errors/getNodeError.js'\nimport {\n  type FormatBlockErrorType,\n  formatBlock,\n} from '../../utils/formatters/block.js'\nimport { formatLog } from '../../utils/formatters/log.js'\nimport {\n  type FormatTransactionRequestErrorType,\n  formatTransactionRequest,\n} from '../../utils/formatters/transactionRequest.js'\nimport {\n  type SerializeStateOverrideErrorType,\n  serializeStateOverride,\n} from '../../utils/stateOverride.js'\nimport {\n  type AssertRequestErrorType,\n  assertRequest,\n} from '../../utils/transaction/assertRequest.js'\n\ntype CallExtraProperties = ExactPartial<\n  UnionOmit<\n    TransactionRequest,\n    'blobs' | 'data' | 'kzg' | 'to' | 'sidecars' | 'value'\n  >\n> & {\n  /** Account attached to the call (msg.sender). */\n  account?: Account | Address | undefined\n}\n\nexport type SimulateBlocksParameters<\n  calls extends readonly unknown[] = readonly unknown[],\n> = {\n  /** Blocks to simulate. */\n  blocks: readonly {\n    /** Block overrides. */\n    blockOverrides?: BlockOverrides.BlockOverrides | undefined\n    /** Calls to execute. */\n    calls: Calls<Narrow<calls>, CallExtraProperties>\n    /** State overrides. */\n    stateOverrides?: StateOverride | undefined\n  }[]\n  /** Whether to return the full transactions. */\n  returnFullTransactions?: boolean | undefined\n  /** Whether to trace transfers. */\n  traceTransfers?: boolean | undefined\n  /** Whether to enable validation mode. */\n  validation?: boolean | undefined\n} & (\n  | {\n      /** The balance of the account at a block number. */\n      blockNumber?: bigint | undefined\n      blockTag?: undefined\n    }\n  | {\n      blockNumber?: undefined\n      /**\n       * The balance of the account at a block tag.\n       * @default 'latest'\n       */\n      blockTag?: BlockTag | undefined\n    }\n)\n\nexport type SimulateBlocksReturnType<\n  calls extends readonly unknown[] = readonly unknown[],\n> = readonly (Block & {\n  calls: MulticallResults<\n    Narrow<calls>,\n    true,\n    {\n      extraProperties: {\n        data: Hex\n        gasUsed: bigint\n        logs?: Log[] | undefined\n      }\n      error: Error\n      mutability: AbiStateMutability\n    }\n  >\n})[]\n\nexport type SimulateBlocksErrorType =\n  | AssertRequestErrorType\n  | DecodeFunctionResultErrorType\n  | EncodeFunctionDataErrorType\n  | FormatBlockErrorType\n  | FormatTransactionRequestErrorType\n  | GetNodeErrorReturnType\n  | ParseAccountErrorType\n  | SerializeStateOverrideErrorType\n  | NumberToHexErrorType\n  | ErrorType\n\n/**\n * Simulates a set of calls on block(s) with optional block and state overrides.\n *\n * @example\n * ```ts\n * import { createClient, http, parseEther } from 'viem'\n * import { simulate } from 'viem/actions'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const result = await simulate(client, {\n *   blocks: [{\n *     blockOverrides: {\n *       number: 69420n,\n *     },\n *     calls: [{\n *       {\n *         account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',\n *         data: '0xdeadbeef',\n *         to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *       },\n *       {\n *         account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',\n *         to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *         value: parseEther('1'),\n *       },\n *     }],\n *     stateOverrides: [{\n *       address: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',\n *       balance: parseEther('10'),\n *     }],\n *   }]\n * })\n * ```\n *\n * @param client - Client to use.\n * @param parameters - {@link SimulateBlocksParameters}\n * @returns Simulated blocks. {@link SimulateBlocksReturnType}\n */\nexport async function simulateBlocks<\n  chain extends Chain | undefined,\n  const calls extends readonly unknown[],\n>(\n  client: Client<Transport, chain>,\n  parameters: SimulateBlocksParameters<calls>,\n): Promise<SimulateBlocksReturnType<calls>> {\n  const {\n    blockNumber,\n    blockTag = 'latest',\n    blocks,\n    returnFullTransactions,\n    traceTransfers,\n    validation,\n  } = parameters\n\n  try {\n    const blockStateCalls = []\n    for (const block of blocks) {\n      const blockOverrides = block.blockOverrides\n        ? BlockOverrides.toRpc(block.blockOverrides)\n        : undefined\n      const calls = block.calls.map((call_) => {\n        const call = call_ as Call<unknown, CallExtraProperties>\n        const account = call.account ? parseAccount(call.account) : undefined\n        const request = {\n          ...call,\n          data: call.abi ? encodeFunctionData(call) : call.data,\n          from: call.from ?? account?.address,\n        } as const\n        assertRequest(request)\n        return formatTransactionRequest(request)\n      })\n      const stateOverrides = block.stateOverrides\n        ? serializeStateOverride(block.stateOverrides)\n        : undefined\n\n      blockStateCalls.push({\n        blockOverrides,\n        calls,\n        stateOverrides,\n      })\n    }\n\n    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined\n    const block = blockNumberHex || blockTag\n\n    const result = await client.request({\n      method: 'eth_simulateV1',\n      params: [\n        { blockStateCalls, returnFullTransactions, traceTransfers, validation },\n        block,\n      ],\n    })\n\n    return result.map((block, i) => ({\n      ...formatBlock(block),\n      calls: block.calls.map((call, j) => {\n        const { abi, args, functionName, to } = blocks[i].calls[j] as Call<\n          unknown,\n          CallExtraProperties\n        >\n\n        const data = call.error?.data ?? call.returnData\n        const gasUsed = BigInt(call.gasUsed)\n        const logs = call.logs?.map((log) => formatLog(log))\n        const status = call.status === '0x1' ? 'success' : 'failure'\n\n        const result =\n          abi && status === 'success'\n            ? decodeFunctionResult({\n                abi,\n                data,\n                functionName,\n              })\n            : null\n\n        const error = (() => {\n          if (status === 'success') return undefined\n\n          let error = undefined\n          if (call.error?.data === '0x') error = new AbiDecodingZeroDataError()\n          else if (call.error) error = new RawContractError(call.error)\n\n          if (!error) return undefined\n          return getContractError(error, {\n            abi: (abi ?? []) as Abi,\n            address: to,\n            args,\n            functionName: functionName ?? '<unknown>',\n          })\n        })()\n\n        return {\n          data,\n          gasUsed,\n          logs,\n          status,\n          ...(status === 'success'\n            ? {\n                result,\n              }\n            : {\n                error,\n              }),\n        }\n      }),\n    })) as unknown as SimulateBlocksReturnType<calls>\n  } catch (e) {\n    const cause = e as BaseError\n    const error = getNodeError(cause, {})\n    if (error instanceof UnknownNodeError) throw cause\n    throw error\n  }\n}\n"],"mappings":"AACA,OAAO,KAAKA,cAAc,MAAM,mBAAmB;AAEnD,SAEEC,YAAY,QACP,sCAAsC;AAG7C,SAASC,wBAAwB,QAAQ,qBAAqB;AAE9D,SAASC,gBAAgB,QAAQ,0BAA0B;AAC3D,SAASC,gBAAgB,QAAQ,sBAAsB;AAYvD,SAEEC,oBAAoB,QACf,yCAAyC;AAChD,SAEEC,kBAAkB,QACb,uCAAuC;AAC9C,SAEEC,WAAW,QACN,+BAA+B;AACtC,SAASC,gBAAgB,QAAQ,wCAAwC;AACzE,SAEEC,YAAY,QACP,oCAAoC;AAC3C,SAEEC,WAAW,QACN,iCAAiC;AACxC,SAASC,SAAS,QAAQ,+BAA+B;AACzD,SAEEC,wBAAwB,QACnB,8CAA8C;AACrD,SAEEC,sBAAsB,QACjB,8BAA8B;AACrC,SAEEC,aAAa,QACR,0CAA0C;AA4EjD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2CA,OAAO,eAAeC,cAAcA,CAIlCC,MAAgC,EAChCC,UAA2C;EAE3C,MAAM;IACJC,WAAW;IACXC,QAAQ,GAAG,QAAQ;IACnBC,MAAM;IACNC,sBAAsB;IACtBC,cAAc;IACdC;EAAU,CACX,GAAGN,UAAU;EAEd,IAAI;IACF,MAAMO,eAAe,GAAG,EAAE;IAC1B,KAAK,MAAMC,KAAK,IAAIL,MAAM,EAAE;MAC1B,MAAMM,cAAc,GAAGD,KAAK,CAACC,cAAc,GACvC1B,cAAc,CAAC2B,KAAK,CAACF,KAAK,CAACC,cAAc,CAAC,GAC1CE,SAAS;MACb,MAAMC,KAAK,GAAGJ,KAAK,CAACI,KAAK,CAACC,GAAG,CAAEC,KAAK,IAAI;QACtC,MAAMC,IAAI,GAAGD,KAA2C;QACxD,MAAME,OAAO,GAAGD,IAAI,CAACC,OAAO,GAAGhC,YAAY,CAAC+B,IAAI,CAACC,OAAO,CAAC,GAAGL,SAAS;QACrE,MAAMM,OAAO,GAAG;UACd,GAAGF,IAAI;UACPG,IAAI,EAAEH,IAAI,CAACI,GAAG,GAAG9B,kBAAkB,CAAC0B,IAAI,CAAC,GAAGA,IAAI,CAACG,IAAI;UACrDE,IAAI,EAAEL,IAAI,CAACK,IAAI,IAAIJ,OAAO,EAAEK;SACpB;QACVxB,aAAa,CAACoB,OAAO,CAAC;QACtB,OAAOtB,wBAAwB,CAACsB,OAAO,CAAC;MAC1C,CAAC,CAAC;MACF,MAAMK,cAAc,GAAGd,KAAK,CAACc,cAAc,GACvC1B,sBAAsB,CAACY,KAAK,CAACc,cAAc,CAAC,GAC5CX,SAAS;MAEbJ,eAAe,CAACgB,IAAI,CAAC;QACnBd,cAAc;QACdG,KAAK;QACLU;OACD,CAAC;IACJ;IAEA,MAAME,cAAc,GAAGvB,WAAW,GAAGX,WAAW,CAACW,WAAW,CAAC,GAAGU,SAAS;IACzE,MAAMH,KAAK,GAAGgB,cAAc,IAAItB,QAAQ;IAExC,MAAMuB,MAAM,GAAG,MAAM1B,MAAM,CAACkB,OAAO,CAAC;MAClCS,MAAM,EAAE,gBAAgB;MACxBC,MAAM,EAAE,CACN;QAAEpB,eAAe;QAAEH,sBAAsB;QAAEC,cAAc;QAAEC;MAAU,CAAE,EACvEE,KAAK;KAER,CAAC;IAEF,OAAOiB,MAAM,CAACZ,GAAG,CAAC,CAACL,KAAK,EAAEoB,CAAC,MAAM;MAC/B,GAAGnC,WAAW,CAACe,KAAK,CAAC;MACrBI,KAAK,EAAEJ,KAAK,CAACI,KAAK,CAACC,GAAG,CAAC,CAACE,IAAI,EAAEc,CAAC,KAAI;QACjC,MAAM;UAAEV,GAAG;UAAEW,IAAI;UAAEC,YAAY;UAAEC;QAAE,CAAE,GAAG7B,MAAM,CAACyB,CAAC,CAAC,CAAChB,KAAK,CAACiB,CAAC,CAGxD;QAED,MAAMX,IAAI,GAAGH,IAAI,CAACkB,KAAK,EAAEf,IAAI,IAAIH,IAAI,CAACmB,UAAU;QAChD,MAAMC,OAAO,GAAGC,MAAM,CAACrB,IAAI,CAACoB,OAAO,CAAC;QACpC,MAAME,IAAI,GAAGtB,IAAI,CAACsB,IAAI,EAAExB,GAAG,CAAEyB,GAAG,IAAK5C,SAAS,CAAC4C,GAAG,CAAC,CAAC;QACpD,MAAMC,MAAM,GAAGxB,IAAI,CAACwB,MAAM,KAAK,KAAK,GAAG,SAAS,GAAG,SAAS;QAE5D,MAAMd,MAAM,GACVN,GAAG,IAAIoB,MAAM,KAAK,SAAS,GACvBnD,oBAAoB,CAAC;UACnB+B,GAAG;UACHD,IAAI;UACJa;SACD,CAAC,GACF,IAAI;QAEV,MAAME,KAAK,GAAG,CAAC,MAAK;UAClB,IAAIM,MAAM,KAAK,SAAS,EAAE,OAAO5B,SAAS;UAE1C,IAAIsB,KAAK,GAAGtB,SAAS;UACrB,IAAII,IAAI,CAACkB,KAAK,EAAEf,IAAI,KAAK,IAAI,EAAEe,KAAK,GAAG,IAAIhD,wBAAwB,EAAE,MAChE,IAAI8B,IAAI,CAACkB,KAAK,EAAEA,KAAK,GAAG,IAAI/C,gBAAgB,CAAC6B,IAAI,CAACkB,KAAK,CAAC;UAE7D,IAAI,CAACA,KAAK,EAAE,OAAOtB,SAAS;UAC5B,OAAOpB,gBAAgB,CAAC0C,KAAK,EAAE;YAC7Bd,GAAG,EAAGA,GAAG,IAAI,EAAU;YACvBE,OAAO,EAAEW,EAAE;YACXF,IAAI;YACJC,YAAY,EAAEA,YAAY,IAAI;WAC/B,CAAC;QACJ,CAAC,EAAC,CAAE;QAEJ,OAAO;UACLb,IAAI;UACJiB,OAAO;UACPE,IAAI;UACJE,MAAM;UACN,IAAIA,MAAM,KAAK,SAAS,GACpB;YACEd;WACD,GACD;YACEQ;WACD;SACN;MACH,CAAC;KACF,CAAC,CAA+C;EACnD,CAAC,CAAC,OAAOO,CAAC,EAAE;IACV,MAAMC,KAAK,GAAGD,CAAc;IAC5B,MAAMP,KAAK,GAAGzC,YAAY,CAACiD,KAAK,EAAE,EAAE,CAAC;IACrC,IAAIR,KAAK,YAAY9C,gBAAgB,EAAE,MAAMsD,KAAK;IAClD,MAAMR,KAAK;EACb;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}