{"ast":null,"code":"import h, { levels as s } from \"pino\";\nimport { default as U } from \"pino\";\nimport { safeJsonStringify as u } from \"@walletconnect/safe-json\";\nconst c = {\n    level: \"info\"\n  },\n  n = \"custom_context\",\n  l = 1e3 * 1024;\nclass O {\n  constructor(e) {\n    this.nodeValue = e, this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length, this.next = null;\n  }\n  get value() {\n    return this.nodeValue;\n  }\n  get size() {\n    return this.sizeInBytes;\n  }\n}\nclass d {\n  constructor(e) {\n    this.head = null, this.tail = null, this.lengthInNodes = 0, this.maxSizeInBytes = e, this.sizeInBytes = 0;\n  }\n  append(e) {\n    const t = new O(e);\n    if (t.size > this.maxSizeInBytes) throw new Error(`[LinkedList] Value too big to insert into list: ${e} with size ${t.size}`);\n    for (; this.size + t.size > this.maxSizeInBytes;) this.shift();\n    this.head ? (this.tail && (this.tail.next = t), this.tail = t) : (this.head = t, this.tail = t), this.lengthInNodes++, this.sizeInBytes += t.size;\n  }\n  shift() {\n    if (!this.head) return;\n    const e = this.head;\n    this.head = this.head.next, this.head || (this.tail = null), this.lengthInNodes--, this.sizeInBytes -= e.size;\n  }\n  toArray() {\n    const e = [];\n    let t = this.head;\n    for (; t !== null;) e.push(t.value), t = t.next;\n    return e;\n  }\n  get length() {\n    return this.lengthInNodes;\n  }\n  get size() {\n    return this.sizeInBytes;\n  }\n  toOrderedArray() {\n    return Array.from(this);\n  }\n  [Symbol.iterator]() {\n    let e = this.head;\n    return {\n      next: () => {\n        if (!e) return {\n          done: !0,\n          value: null\n        };\n        const t = e.value;\n        return e = e.next, {\n          done: !1,\n          value: t\n        };\n      }\n    };\n  }\n}\nclass L {\n  constructor(e, t = l) {\n    this.level = e ?? \"error\", this.levelValue = s.values[this.level], this.MAX_LOG_SIZE_IN_BYTES = t, this.logs = new d(this.MAX_LOG_SIZE_IN_BYTES);\n  }\n  forwardToConsole(e, t) {\n    t === s.values.error ? console.error(e) : t === s.values.warn ? console.warn(e) : t === s.values.debug ? console.debug(e) : t === s.values.trace ? console.trace(e) : console.log(e);\n  }\n  appendToLogs(e) {\n    this.logs.append(u({\n      timestamp: new Date().toISOString(),\n      log: e\n    }));\n    const t = typeof e == \"string\" ? JSON.parse(e).level : e.level;\n    t >= this.levelValue && this.forwardToConsole(e, t);\n  }\n  getLogs() {\n    return this.logs;\n  }\n  clearLogs() {\n    this.logs = new d(this.MAX_LOG_SIZE_IN_BYTES);\n  }\n  getLogArray() {\n    return Array.from(this.logs);\n  }\n  logsToBlob(e) {\n    const t = this.getLogArray();\n    return t.push(u({\n      extraMetadata: e\n    })), new Blob(t, {\n      type: \"application/json\"\n    });\n  }\n}\nclass m {\n  constructor(e, t = l) {\n    this.baseChunkLogger = new L(e, t);\n  }\n  write(e) {\n    this.baseChunkLogger.appendToLogs(e);\n  }\n  getLogs() {\n    return this.baseChunkLogger.getLogs();\n  }\n  clearLogs() {\n    this.baseChunkLogger.clearLogs();\n  }\n  getLogArray() {\n    return this.baseChunkLogger.getLogArray();\n  }\n  logsToBlob(e) {\n    return this.baseChunkLogger.logsToBlob(e);\n  }\n  downloadLogsBlobInBrowser(e) {\n    const t = URL.createObjectURL(this.logsToBlob(e)),\n      o = document.createElement(\"a\");\n    o.href = t, o.download = `walletconnect-logs-${new Date().toISOString()}.txt`, document.body.appendChild(o), o.click(), document.body.removeChild(o), URL.revokeObjectURL(t);\n  }\n}\nclass B {\n  constructor(e, t = l) {\n    this.baseChunkLogger = new L(e, t);\n  }\n  write(e) {\n    this.baseChunkLogger.appendToLogs(e);\n  }\n  getLogs() {\n    return this.baseChunkLogger.getLogs();\n  }\n  clearLogs() {\n    this.baseChunkLogger.clearLogs();\n  }\n  getLogArray() {\n    return this.baseChunkLogger.getLogArray();\n  }\n  logsToBlob(e) {\n    return this.baseChunkLogger.logsToBlob(e);\n  }\n}\nvar x = Object.defineProperty,\n  S = Object.defineProperties,\n  _ = Object.getOwnPropertyDescriptors,\n  p = Object.getOwnPropertySymbols,\n  T = Object.prototype.hasOwnProperty,\n  z = Object.prototype.propertyIsEnumerable,\n  f = (r, e, t) => e in r ? x(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  i = (r, e) => {\n    for (var t in e || (e = {})) T.call(e, t) && f(r, t, e[t]);\n    if (p) for (var t of p(e)) z.call(e, t) && f(r, t, e[t]);\n    return r;\n  },\n  g = (r, e) => S(r, _(e));\nfunction k(r) {\n  return g(i({}, r), {\n    level: r?.level || c.level\n  });\n}\nfunction v(r, e = n) {\n  return r[e] || \"\";\n}\nfunction b(r, e, t = n) {\n  return r[t] = e, r;\n}\nfunction y(r, e = n) {\n  let t = \"\";\n  return typeof r.bindings > \"u\" ? t = v(r, e) : t = r.bindings().context || \"\", t;\n}\nfunction w(r, e, t = n) {\n  const o = y(r, t);\n  return o.trim() ? `${o}/${e}` : e;\n}\nfunction E(r, e, t = n) {\n  const o = w(r, e, t),\n    a = r.child({\n      context: o\n    });\n  return b(a, o, t);\n}\nfunction C(r) {\n  var e, t;\n  const o = new m((e = r.opts) == null ? void 0 : e.level, r.maxSizeInBytes);\n  return {\n    logger: h(g(i({}, r.opts), {\n      level: \"trace\",\n      browser: g(i({}, (t = r.opts) == null ? void 0 : t.browser), {\n        write: a => o.write(a)\n      })\n    })),\n    chunkLoggerController: o\n  };\n}\nfunction I(r) {\n  var e;\n  const t = new B((e = r.opts) == null ? void 0 : e.level, r.maxSizeInBytes);\n  return {\n    logger: h(g(i({}, r.opts), {\n      level: \"trace\"\n    }), t),\n    chunkLoggerController: t\n  };\n}\nfunction A(r) {\n  return typeof r.loggerOverride < \"u\" && typeof r.loggerOverride != \"string\" ? {\n    logger: r.loggerOverride,\n    chunkLoggerController: null\n  } : typeof window < \"u\" ? C(r) : I(r);\n}\nexport { l as MAX_LOG_SIZE_IN_BYTES_DEFAULT, n as PINO_CUSTOM_CONTEXT_KEY, c as PINO_LOGGER_DEFAULTS, w as formatChildLoggerContext, E as generateChildLogger, C as generateClientLogger, A as generatePlatformLogger, I as generateServerLogger, v as getBrowserLoggerContext, k as getDefaultLoggerOptions, y as getLoggerContext, U as pino, b as setBrowserLoggerContext };","map":{"version":3,"names":[],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\logger\\src\\constants.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\logger\\src\\linkedList.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\logger\\src\\baseChunkLogger.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\logger\\src\\clientChunkLogger.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\logger\\src\\serverChunkLogger.ts","C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@walletconnect\\logger\\src\\utils.ts"],"sourcesContent":["export const PINO_LOGGER_DEFAULTS = {\n  level: \"info\",\n};\n\nexport const PINO_CUSTOM_CONTEXT_KEY = \"custom_context\";\n\nexport const MAX_LOG_SIZE_IN_BYTES_DEFAULT = 1000 * 1024; // 1MB\n","class LogListNode {\n  private nodeValue: string;\n  private sizeInBytes: number;\n  public next: LogListNode | null;\n\n  constructor(value: string) {\n    this.nodeValue = value;\n    this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length;\n    this.next = null;\n  }\n\n  public get value() {\n    return this.nodeValue;\n  }\n\n  public get size() {\n    return this.sizeInBytes;\n  }\n}\n\nexport default class LogLinkedList {\n  private lengthInNodes: number;\n  private sizeInBytes: number;\n  private head: LogListNode | null;\n  private tail: LogListNode | null;\n  private maxSizeInBytes: number;\n\n  constructor(maxSizeInBytes: number) {\n    this.head = null;\n    this.tail = null;\n    this.lengthInNodes = 0;\n    this.maxSizeInBytes = maxSizeInBytes;\n    this.sizeInBytes = 0;\n  }\n\n  public append(value: string): void {\n    const newNode = new LogListNode(value);\n\n    if (newNode.size > this.maxSizeInBytes) {\n      throw new Error(\n        `[LinkedList] Value too big to insert into list: ${value} with size ${newNode.size}`,\n      );\n    }\n\n    while (this.size + newNode.size > this.maxSizeInBytes) {\n      this.shift();\n    }\n\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n    } else {\n      if (this.tail) {\n        this.tail.next = newNode;\n      }\n      this.tail = newNode;\n    }\n    this.lengthInNodes++;\n    this.sizeInBytes += newNode.size;\n  }\n\n  public shift(): void {\n    if (!this.head) {\n      return;\n    }\n\n    const removedNode = this.head;\n    this.head = this.head.next;\n\n    if (!this.head) {\n      this.tail = null;\n    }\n\n    this.lengthInNodes--;\n    this.sizeInBytes -= removedNode.size;\n  }\n\n  public toArray(): string[] {\n    const array: string[] = [];\n    let currentNode = this.head;\n    while (currentNode !== null) {\n      array.push(currentNode.value);\n      currentNode = currentNode.next;\n    }\n    return array;\n  }\n\n  public get length() {\n    return this.lengthInNodes;\n  }\n\n  public get size() {\n    return this.sizeInBytes;\n  }\n\n  public toOrderedArray() {\n    return Array.from(this);\n  }\n\n  [Symbol.iterator](): Iterator<string> {\n    let node = this.head;\n\n    const next = (): IteratorResult<string> => {\n      if (!node) {\n        return { done: true, value: null };\n      }\n\n      const value = node.value;\n      node = node.next;\n\n      return { done: false, value };\n    };\n\n    return { next };\n  }\n}\n","import { MAX_LOG_SIZE_IN_BYTES_DEFAULT } from \"./constants\";\nimport type { LoggerOptions } from \"pino\";\nimport { levels } from \"pino\";\nimport LinkedList from \"./linkedList\";\nimport { safeJsonStringify } from \"@walletconnect/safe-json\";\n\nexport default class BaseChunkLogger {\n  private logs: LinkedList;\n  private level: LoggerOptions[\"level\"];\n  private levelValue: number;\n\n  private MAX_LOG_SIZE_IN_BYTES: number;\n\n  public constructor(\n    level: LoggerOptions[\"level\"],\n    MAX_LOG_SIZE_IN_BYTES: number = MAX_LOG_SIZE_IN_BYTES_DEFAULT,\n  ) {\n    this.level = level ?? \"error\";\n    this.levelValue = levels.values[this.level];\n\n    this.MAX_LOG_SIZE_IN_BYTES = MAX_LOG_SIZE_IN_BYTES;\n    this.logs = new LinkedList(this.MAX_LOG_SIZE_IN_BYTES);\n  }\n\n  public forwardToConsole(chunk: any, level: number) {\n    if (level === levels.values.error) {\n      // eslint-disable-next-line no-console\n      console.error(chunk);\n    } else if (level === levels.values.warn) {\n      // eslint-disable-next-line no-console\n      console.warn(chunk);\n    } else if (level === levels.values.debug) {\n      // eslint-disable-next-line no-console\n      console.debug(chunk);\n    } else if (level === levels.values.trace) {\n      // eslint-disable-next-line no-console\n      console.trace(chunk);\n    } else {\n      // eslint-disable-next-line no-console\n      console.log(chunk);\n    }\n  }\n\n  public appendToLogs(chunk: any) {\n    this.logs.append(\n      safeJsonStringify({\n        timestamp: new Date().toISOString(),\n        log: chunk,\n      }),\n    );\n\n    // Based on https://github.com/pinojs/pino/blob/master/lib/constants.js\n    const level = typeof chunk === \"string\" ? JSON.parse(chunk).level : chunk.level;\n    if (level >= this.levelValue) {\n      this.forwardToConsole(chunk, level);\n    }\n  }\n\n  public getLogs() {\n    return this.logs;\n  }\n\n  public clearLogs() {\n    this.logs = new LinkedList(this.MAX_LOG_SIZE_IN_BYTES);\n  }\n\n  public getLogArray() {\n    return Array.from(this.logs);\n  }\n\n  public logsToBlob(extraMetadata: Record<string, string>) {\n    const logArray = this.getLogArray();\n    logArray.push(safeJsonStringify({ extraMetadata }));\n    const blob = new Blob(logArray, { type: \"application/json\" });\n    return blob;\n  }\n}\n","import { MAX_LOG_SIZE_IN_BYTES_DEFAULT } from \"./constants\";\nimport type { LoggerOptions } from \"pino\";\nimport BaseChunkLogger from \"./baseChunkLogger\";\n\nexport default class ClientChunkLogger {\n  private baseChunkLogger: BaseChunkLogger;\n\n  public constructor(\n    level: LoggerOptions[\"level\"],\n    MAX_LOG_SIZE_IN_BYTES: number = MAX_LOG_SIZE_IN_BYTES_DEFAULT,\n  ) {\n    this.baseChunkLogger = new BaseChunkLogger(level, MAX_LOG_SIZE_IN_BYTES);\n  }\n\n  public write(chunk: any): void {\n    this.baseChunkLogger.appendToLogs(chunk);\n  }\n\n  public getLogs() {\n    return this.baseChunkLogger.getLogs();\n  }\n\n  public clearLogs() {\n    this.baseChunkLogger.clearLogs();\n  }\n\n  public getLogArray() {\n    return this.baseChunkLogger.getLogArray();\n  }\n\n  public logsToBlob(extraMetadata: Record<string, string>) {\n    return this.baseChunkLogger.logsToBlob(extraMetadata);\n  }\n\n  public downloadLogsBlobInBrowser(extraMetadata: Record<string, string>) {\n    const url = URL.createObjectURL(this.logsToBlob(extraMetadata));\n    const anchor = document.createElement(\"a\");\n    anchor.href = url;\n    anchor.download = `walletconnect-logs-${new Date().toISOString()}.txt`;\n    document.body.appendChild(anchor);\n    anchor.click();\n    document.body.removeChild(anchor);\n    URL.revokeObjectURL(url);\n  }\n}\n","import { MAX_LOG_SIZE_IN_BYTES_DEFAULT } from \"./constants\";\nimport type { DestinationStream, LoggerOptions } from \"pino\";\nimport BaseChunkLogger from \"./baseChunkLogger\";\n\nexport default class ServerChunkLogger implements DestinationStream {\n  private baseChunkLogger: BaseChunkLogger;\n\n  public constructor(\n    level: LoggerOptions[\"level\"],\n    MAX_LOG_SIZE_IN_BYTES: number = MAX_LOG_SIZE_IN_BYTES_DEFAULT,\n  ) {\n    this.baseChunkLogger = new BaseChunkLogger(level, MAX_LOG_SIZE_IN_BYTES);\n  }\n\n  public write(chunk: any): void {\n    this.baseChunkLogger.appendToLogs(chunk);\n  }\n\n  public getLogs() {\n    return this.baseChunkLogger.getLogs();\n  }\n\n  public clearLogs() {\n    this.baseChunkLogger.clearLogs();\n  }\n\n  public getLogArray() {\n    return this.baseChunkLogger.getLogArray();\n  }\n\n  public logsToBlob(extraMetadata: Record<string, string>) {\n    return this.baseChunkLogger.logsToBlob(extraMetadata);\n  }\n}\n","import pino, { Logger, LoggerOptions } from \"pino\";\nimport { PINO_CUSTOM_CONTEXT_KEY, PINO_LOGGER_DEFAULTS } from \"./constants\";\nimport ClientChunkLogger from \"./clientChunkLogger\";\nimport ServerChunkLogger from \"./serverChunkLogger\";\nimport BaseChunkLogger from \"./baseChunkLogger\";\n\nexport interface ChunkLoggerController {\n  logsToBlob: BaseChunkLogger[\"logsToBlob\"];\n  getLogArray: () => string[];\n  clearLogs: () => void;\n  downloadLogsBlobInBrowser?: ClientChunkLogger[\"downloadLogsBlobInBrowser\"];\n}\n\nexport function getDefaultLoggerOptions(opts?: LoggerOptions): LoggerOptions {\n  return {\n    ...opts,\n    level: opts?.level || PINO_LOGGER_DEFAULTS.level,\n  };\n}\n\nexport function getBrowserLoggerContext(\n  logger: Logger,\n  customContextKey: string = PINO_CUSTOM_CONTEXT_KEY,\n): string {\n  return (logger as any)[customContextKey] || \"\";\n}\n\nexport function setBrowserLoggerContext(\n  logger: Logger,\n  context: string,\n  customContextKey: string = PINO_CUSTOM_CONTEXT_KEY,\n): Logger {\n  (logger as any)[customContextKey] = context;\n  return logger;\n}\n\nexport function getLoggerContext(\n  logger: Logger,\n  customContextKey: string = PINO_CUSTOM_CONTEXT_KEY,\n): string {\n  let context = \"\";\n  // logger.bindings is undefined in browser\n  if (typeof logger.bindings === \"undefined\") {\n    context = getBrowserLoggerContext(logger, customContextKey);\n  } else {\n    context = logger.bindings().context || \"\";\n  }\n  return context;\n}\n\nexport function formatChildLoggerContext(\n  logger: Logger,\n  childContext: string,\n  customContextKey: string = PINO_CUSTOM_CONTEXT_KEY,\n): string {\n  const parentContext = getLoggerContext(logger, customContextKey);\n  const context = parentContext.trim() ? `${parentContext}/${childContext}` : childContext;\n  return context;\n}\n\nexport function generateChildLogger(\n  logger: Logger,\n  childContext: string,\n  customContextKey: string = PINO_CUSTOM_CONTEXT_KEY,\n): Logger {\n  const context = formatChildLoggerContext(logger, childContext, customContextKey);\n  const child = logger.child({ context });\n  return setBrowserLoggerContext(child, context, customContextKey);\n}\n\nexport function generateClientLogger(params: { opts?: LoggerOptions; maxSizeInBytes?: number }): {\n  logger: Logger<any>;\n  chunkLoggerController: ClientChunkLogger;\n} {\n  const clientLogger = new ClientChunkLogger(params.opts?.level, params.maxSizeInBytes);\n  const logger = pino({\n    ...params.opts,\n    level: \"trace\",\n    browser: {\n      ...params.opts?.browser,\n      write: (obj) => clientLogger.write(obj),\n    },\n  });\n\n  return { logger, chunkLoggerController: clientLogger };\n}\n\nexport function generateServerLogger(params: { maxSizeInBytes?: number; opts?: LoggerOptions }): {\n  logger: Logger<any>;\n  chunkLoggerController: ServerChunkLogger;\n} {\n  const serverLogger = new ServerChunkLogger(params.opts?.level, params.maxSizeInBytes);\n  const logger = pino(\n    {\n      ...params.opts,\n      level: \"trace\",\n    },\n    serverLogger,\n  );\n\n  return { logger, chunkLoggerController: serverLogger };\n}\n\nexport function generatePlatformLogger(params: {\n  maxSizeInBytes?: number;\n  opts?: LoggerOptions;\n  loggerOverride?: string | Logger<any>;\n}): {\n  logger: Logger<any>;\n  chunkLoggerController: ChunkLoggerController | null;\n} {\n  if (typeof params.loggerOverride !== \"undefined\" && typeof params.loggerOverride !== \"string\") {\n    return {\n      logger: params.loggerOverride,\n      chunkLoggerController: null,\n    };\n  }\n\n  if (typeof window !== \"undefined\") {\n    return generateClientLogger(params);\n  } else {\n    return generateServerLogger(params);\n  }\n}\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}