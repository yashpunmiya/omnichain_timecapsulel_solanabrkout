{"ast":null,"code":"import { InvalidAbiParametersError } from './errors/abiParameter.js';\nimport { isStructSignature, modifiers } from './runtime/signatures.js';\nimport { parseStructs } from './runtime/structs.js';\nimport { splitParameters } from './runtime/utils.js';\nimport { parseAbiParameter as parseAbiParameter_ } from './runtime/utils.js';\n/**\n * Parses human-readable ABI parameters into {@link AbiParameter}s\n *\n * @param params - Human-readable ABI parameters\n * @returns Parsed {@link AbiParameter}s\n *\n * @example\n * const abiParameters = parseAbiParameters('address from, address to, uint256 amount')\n * //    ^? const abiParameters: [{ type: \"address\"; name: \"from\"; }, { type: \"address\";...\n *\n * @example\n * const abiParameters = parseAbiParameters([\n *   //  ^? const abiParameters: [{ type: \"tuple\"; components: [{ type: \"string\"; name:...\n *   'Baz bar',\n *   'struct Baz { string name; }',\n * ])\n */\nexport function parseAbiParameters(params) {\n  const abiParameters = [];\n  if (typeof params === 'string') {\n    const parameters = splitParameters(params);\n    const length = parameters.length;\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(parseAbiParameter_(parameters[i], {\n        modifiers\n      }));\n    }\n  } else {\n    const structs = parseStructs(params);\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      const signature = params[i];\n      if (isStructSignature(signature)) continue;\n      const parameters = splitParameters(signature);\n      const length = parameters.length;\n      for (let k = 0; k < length; k++) {\n        abiParameters.push(parseAbiParameter_(parameters[k], {\n          modifiers,\n          structs\n        }));\n      }\n    }\n  }\n  if (abiParameters.length === 0) throw new InvalidAbiParametersError({\n    params\n  });\n  return abiParameters;\n}\n//# sourceMappingURL=parseAbiParameters.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}