{"ast":null,"code":"import { WalletNotConnectedError, WalletNotReadyError, WalletReadyState } from '@solana/wallet-adapter-base';\nimport React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { WalletNotSelectedError } from './errors.js';\nimport { WalletContext } from './useWallet.js';\nexport function WalletProviderBase({\n  children,\n  wallets: adapters,\n  adapter,\n  isUnloadingRef,\n  onAutoConnectRequest,\n  onConnectError,\n  onError,\n  onSelectWallet\n}) {\n  const isConnectingRef = useRef(false);\n  const [connecting, setConnecting] = useState(false);\n  const isDisconnectingRef = useRef(false);\n  const [disconnecting, setDisconnecting] = useState(false);\n  const [publicKey, setPublicKey] = useState(() => adapter?.publicKey ?? null);\n  const [connected, setConnected] = useState(() => adapter?.connected ?? false);\n  /**\n   * Store the error handlers as refs so that a change in the\n   * custom error handler does not recompute other dependencies.\n   */\n  const onErrorRef = useRef(onError);\n  useEffect(() => {\n    onErrorRef.current = onError;\n    return () => {\n      onErrorRef.current = undefined;\n    };\n  }, [onError]);\n  const handleErrorRef = useRef((error, adapter) => {\n    if (!isUnloadingRef.current) {\n      if (onErrorRef.current) {\n        onErrorRef.current(error, adapter);\n      } else {\n        console.error(error, adapter);\n        if (error instanceof WalletNotReadyError && typeof window !== 'undefined' && adapter) {\n          window.open(adapter.url, '_blank');\n        }\n      }\n    }\n    return error;\n  });\n  // Wrap adapters to conform to the `Wallet` interface\n  const [wallets, setWallets] = useState(() => adapters.map(adapter => ({\n    adapter,\n    readyState: adapter.readyState\n  })).filter(({\n    readyState\n  }) => readyState !== WalletReadyState.Unsupported));\n  // When the adapters change, start to listen for changes to their `readyState`\n  useEffect(() => {\n    // When the adapters change, wrap them to conform to the `Wallet` interface\n    setWallets(wallets => adapters.map((adapter, index) => {\n      const wallet = wallets[index];\n      // If the wallet hasn't changed, return the same instance\n      return wallet && wallet.adapter === adapter && wallet.readyState === adapter.readyState ? wallet : {\n        adapter: adapter,\n        readyState: adapter.readyState\n      };\n    }).filter(({\n      readyState\n    }) => readyState !== WalletReadyState.Unsupported));\n    function handleReadyStateChange(readyState) {\n      setWallets(prevWallets => {\n        const index = prevWallets.findIndex(({\n          adapter\n        }) => adapter === this);\n        if (index === -1) return prevWallets;\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const {\n          adapter\n        } = prevWallets[index];\n        return [...prevWallets.slice(0, index), {\n          adapter,\n          readyState\n        }, ...prevWallets.slice(index + 1)].filter(({\n          readyState\n        }) => readyState !== WalletReadyState.Unsupported);\n      });\n    }\n    adapters.forEach(adapter => adapter.on('readyStateChange', handleReadyStateChange, adapter));\n    return () => {\n      adapters.forEach(adapter => adapter.off('readyStateChange', handleReadyStateChange, adapter));\n    };\n  }, [adapter, adapters]);\n  const wallet = useMemo(() => wallets.find(wallet => wallet.adapter === adapter) ?? null, [adapter, wallets]);\n  // Setup and teardown event listeners when the adapter changes\n  useEffect(() => {\n    if (!adapter) return;\n    const handleConnect = publicKey => {\n      setPublicKey(publicKey);\n      isConnectingRef.current = false;\n      setConnecting(false);\n      setConnected(true);\n      isDisconnectingRef.current = false;\n      setDisconnecting(false);\n    };\n    const handleDisconnect = () => {\n      if (isUnloadingRef.current) return;\n      setPublicKey(null);\n      isConnectingRef.current = false;\n      setConnecting(false);\n      setConnected(false);\n      isDisconnectingRef.current = false;\n      setDisconnecting(false);\n    };\n    const handleError = error => {\n      handleErrorRef.current(error, adapter);\n    };\n    adapter.on('connect', handleConnect);\n    adapter.on('disconnect', handleDisconnect);\n    adapter.on('error', handleError);\n    return () => {\n      adapter.off('connect', handleConnect);\n      adapter.off('disconnect', handleDisconnect);\n      adapter.off('error', handleError);\n      handleDisconnect();\n    };\n  }, [adapter, isUnloadingRef]);\n  // When the adapter changes, clear the `autoConnect` tracking flag\n  const didAttemptAutoConnectRef = useRef(false);\n  useEffect(() => {\n    return () => {\n      didAttemptAutoConnectRef.current = false;\n    };\n  }, [adapter]);\n  // If auto-connect is enabled, request to connect when the adapter changes and is ready\n  useEffect(() => {\n    if (didAttemptAutoConnectRef.current || isConnectingRef.current || connected || !onAutoConnectRequest || !(wallet?.readyState === WalletReadyState.Installed || wallet?.readyState === WalletReadyState.Loadable)) return;\n    isConnectingRef.current = true;\n    setConnecting(true);\n    didAttemptAutoConnectRef.current = true;\n    (async function () {\n      try {\n        await onAutoConnectRequest();\n      } catch {\n        onConnectError();\n        // Drop the error. It will be caught by `handleError` anyway.\n      } finally {\n        setConnecting(false);\n        isConnectingRef.current = false;\n      }\n    })();\n  }, [connected, onAutoConnectRequest, onConnectError, wallet]);\n  // Send a transaction using the provided connection\n  const sendTransaction = useCallback(async (transaction, connection, options) => {\n    if (!adapter) throw handleErrorRef.current(new WalletNotSelectedError());\n    if (!connected) throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n    return await adapter.sendTransaction(transaction, connection, options);\n  }, [adapter, connected]);\n  // Sign a transaction if the wallet supports it\n  const signTransaction = useMemo(() => adapter && 'signTransaction' in adapter ? async transaction => {\n    if (!connected) throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n    return await adapter.signTransaction(transaction);\n  } : undefined, [adapter, connected]);\n  // Sign multiple transactions if the wallet supports it\n  const signAllTransactions = useMemo(() => adapter && 'signAllTransactions' in adapter ? async transactions => {\n    if (!connected) throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n    return await adapter.signAllTransactions(transactions);\n  } : undefined, [adapter, connected]);\n  // Sign an arbitrary message if the wallet supports it\n  const signMessage = useMemo(() => adapter && 'signMessage' in adapter ? async message => {\n    if (!connected) throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n    return await adapter.signMessage(message);\n  } : undefined, [adapter, connected]);\n  // Sign in if the wallet supports it\n  const signIn = useMemo(() => adapter && 'signIn' in adapter ? async input => {\n    return await adapter.signIn(input);\n  } : undefined, [adapter]);\n  const handleConnect = useCallback(async () => {\n    if (isConnectingRef.current || isDisconnectingRef.current || wallet?.adapter.connected) return;\n    if (!wallet) throw handleErrorRef.current(new WalletNotSelectedError());\n    const {\n      adapter,\n      readyState\n    } = wallet;\n    if (!(readyState === WalletReadyState.Installed || readyState === WalletReadyState.Loadable)) throw handleErrorRef.current(new WalletNotReadyError(), adapter);\n    isConnectingRef.current = true;\n    setConnecting(true);\n    try {\n      await adapter.connect();\n    } catch (e) {\n      onConnectError();\n      throw e;\n    } finally {\n      setConnecting(false);\n      isConnectingRef.current = false;\n    }\n  }, [onConnectError, wallet]);\n  const handleDisconnect = useCallback(async () => {\n    if (isDisconnectingRef.current) return;\n    if (!adapter) return;\n    isDisconnectingRef.current = true;\n    setDisconnecting(true);\n    try {\n      await adapter.disconnect();\n    } finally {\n      setDisconnecting(false);\n      isDisconnectingRef.current = false;\n    }\n  }, [adapter]);\n  return React.createElement(WalletContext.Provider, {\n    value: {\n      autoConnect: !!onAutoConnectRequest,\n      wallets,\n      wallet,\n      publicKey,\n      connected,\n      connecting,\n      disconnecting,\n      select: onSelectWallet,\n      connect: handleConnect,\n      disconnect: handleDisconnect,\n      sendTransaction,\n      signTransaction,\n      signAllTransactions,\n      signMessage,\n      signIn\n    }\n  }, children);\n}\n//# sourceMappingURL=WalletProviderBase.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}