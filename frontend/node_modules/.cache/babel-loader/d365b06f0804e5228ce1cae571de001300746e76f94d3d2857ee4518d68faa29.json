{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.QRHardwareCall = exports.QRHardwareCallVersion = exports.QRHardwareCallType = void 0;\nconst RegistryType_1 = require(\"../RegistryType\");\nconst RegistryItem_1 = require(\"../RegistryItem\");\nconst lib_1 = require(\"../lib\");\nconst KeyDerivation_1 = require(\"./KeyDerivation\");\nvar Keys;\n(function (Keys) {\n  Keys[Keys[\"type\"] = 1] = \"type\";\n  Keys[Keys[\"params\"] = 2] = \"params\";\n  Keys[Keys[\"origin\"] = 3] = \"origin\";\n  Keys[Keys[\"version\"] = 4] = \"version\";\n})(Keys || (Keys = {}));\nvar QRHardwareCallType;\n(function (QRHardwareCallType) {\n  QRHardwareCallType[QRHardwareCallType[\"KeyDerivation\"] = 0] = \"KeyDerivation\";\n})(QRHardwareCallType = exports.QRHardwareCallType || (exports.QRHardwareCallType = {}));\nvar QRHardwareCallVersion;\n(function (QRHardwareCallVersion) {\n  QRHardwareCallVersion[QRHardwareCallVersion[\"V0\"] = 0] = \"V0\";\n  QRHardwareCallVersion[QRHardwareCallVersion[\"V1\"] = 1] = \"V1\";\n})(QRHardwareCallVersion = exports.QRHardwareCallVersion || (exports.QRHardwareCallVersion = {}));\nclass QRHardwareCall extends RegistryItem_1.RegistryItem {\n  constructor(type, params, origin, version) {\n    super();\n    this.type = type;\n    this.params = params;\n    this.origin = origin;\n    this.version = version;\n    this.getRegistryType = () => RegistryType_1.RegistryTypes.QR_HARDWARE_CALL;\n    this.getType = () => this.type;\n    this.getParams = () => this.params;\n    this.getOrigin = () => this.origin;\n    this.getVersion = () => this.version;\n    this.toDataItem = () => {\n      const map = {};\n      map[Keys.type] = this.type;\n      const param = this.params.toDataItem();\n      param.setTag(this.params.getRegistryType().getTag());\n      map[Keys.params] = param;\n      if (this.origin) {\n        map[Keys.origin] = this.origin;\n      }\n      if (this.version) {\n        map[Keys.version] = this.version;\n      }\n      return new lib_1.DataItem(map);\n    };\n  }\n}\nexports.QRHardwareCall = QRHardwareCall;\nQRHardwareCall.fromDataItem = dataItem => {\n  const map = dataItem.getData();\n  const type = map[Keys.type] || QRHardwareCallType.KeyDerivation;\n  let params;\n  switch (type) {\n    case QRHardwareCallType.KeyDerivation:\n      params = KeyDerivation_1.KeyDerivation.fromDataItem(map[Keys.params]);\n  }\n  const origin = map[Keys.origin];\n  const version = map[Keys.version];\n  return new QRHardwareCall(type, params, origin, version);\n};\nQRHardwareCall.fromCBOR = _cborPayload => {\n  const dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);\n  return QRHardwareCall.fromDataItem(dataItem);\n};","map":{"version":3,"names":["RegistryType_1","require","RegistryItem_1","lib_1","KeyDerivation_1","Keys","QRHardwareCallType","exports","QRHardwareCallVersion","QRHardwareCall","RegistryItem","constructor","type","params","origin","version","getRegistryType","RegistryTypes","QR_HARDWARE_CALL","getType","getParams","getOrigin","getVersion","toDataItem","map","param","setTag","getTag","DataItem","fromDataItem","dataItem","getData","KeyDerivation","fromCBOR","_cborPayload","decodeToDataItem"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@keystonehq\\bc-ur-registry-sol\\node_modules\\@keystonehq\\bc-ur-registry\\src\\extended\\QRHardwareCall.ts"],"sourcesContent":["import { RegistryTypes } from '../RegistryType';\nimport { RegistryItem } from '../RegistryItem';\nimport { decodeToDataItem, DataItem } from '../lib';\nimport { DataItemMap } from '../types';\nimport { KeyDerivation } from './KeyDerivation';\n\nenum Keys {\n  type = 1,\n  params,\n  origin,\n  version,\n}\n\nexport enum QRHardwareCallType {\n  KeyDerivation,\n}\n\nexport enum QRHardwareCallVersion {\n  V0 = 0,\n  V1,\n}\n\ntype QRHardwareCallParams = KeyDerivation;\n\nexport class QRHardwareCall extends RegistryItem {\n  getRegistryType = () => RegistryTypes.QR_HARDWARE_CALL;\n\n  constructor(\n    private type: QRHardwareCallType,\n    private params: QRHardwareCallParams,\n    private origin?: string,\n    private version?: QRHardwareCallVersion,\n  ) {\n    super();\n  }\n\n  public getType = (): number => this.type;\n  public getParams = (): QRHardwareCallParams => this.params;\n  public getOrigin = (): string | undefined => this.origin;\n  public getVersion = (): QRHardwareCallVersion | undefined => this.version;\n\n  public toDataItem = (): DataItem => {\n    const map: DataItemMap = {};\n    map[Keys.type] = this.type;\n\n    const param = this.params.toDataItem();\n    param.setTag(this.params.getRegistryType().getTag());\n    map[Keys.params] = param;\n\n    if (this.origin) {\n      map[Keys.origin] = this.origin;\n    }\n\n    if (this.version) {\n      map[Keys.version] = this.version;\n    }\n    return new DataItem(map);\n  };\n\n  public static fromDataItem = (dataItem: DataItem): QRHardwareCall => {\n    const map = dataItem.getData();\n    const type = map[Keys.type] || QRHardwareCallType.KeyDerivation;\n    let params;\n\n    switch (type) {\n      case QRHardwareCallType.KeyDerivation:\n        params = KeyDerivation.fromDataItem(map[Keys.params]);\n    }\n    const origin = map[Keys.origin];\n    const version = map[Keys.version];\n    return new QRHardwareCall(type, params, origin, version);\n  };\n\n  public static fromCBOR = (_cborPayload: Buffer): QRHardwareCall => {\n    const dataItem = decodeToDataItem(_cborPayload);\n    return QRHardwareCall.fromDataItem(dataItem);\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}