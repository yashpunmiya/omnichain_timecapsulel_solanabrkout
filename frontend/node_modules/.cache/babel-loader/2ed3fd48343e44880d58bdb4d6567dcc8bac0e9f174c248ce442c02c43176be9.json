{"ast":null,"code":"import * as Errors from '../Errors.js';\nconst staticCursor = /*#__PURE__*/{\n  bytes: new Uint8Array(),\n  dataView: new DataView(new ArrayBuffer(0)),\n  position: 0,\n  positionReadCount: new Map(),\n  recursiveReadCount: 0,\n  recursiveReadLimit: Number.POSITIVE_INFINITY,\n  assertReadLimit() {\n    if (this.recursiveReadCount >= this.recursiveReadLimit) throw new RecursiveReadLimitExceededError({\n      count: this.recursiveReadCount + 1,\n      limit: this.recursiveReadLimit\n    });\n  },\n  assertPosition(position) {\n    if (position < 0 || position > this.bytes.length - 1) throw new PositionOutOfBoundsError({\n      length: this.bytes.length,\n      position\n    });\n  },\n  decrementPosition(offset) {\n    if (offset < 0) throw new NegativeOffsetError({\n      offset\n    });\n    const position = this.position - offset;\n    this.assertPosition(position);\n    this.position = position;\n  },\n  getReadCount(position) {\n    return this.positionReadCount.get(position || this.position) || 0;\n  },\n  incrementPosition(offset) {\n    if (offset < 0) throw new NegativeOffsetError({\n      offset\n    });\n    const position = this.position + offset;\n    this.assertPosition(position);\n    this.position = position;\n  },\n  inspectByte(position_) {\n    const position = position_ ?? this.position;\n    this.assertPosition(position);\n    return this.bytes[position];\n  },\n  inspectBytes(length, position_) {\n    const position = position_ ?? this.position;\n    this.assertPosition(position + length - 1);\n    return this.bytes.subarray(position, position + length);\n  },\n  inspectUint8(position_) {\n    const position = position_ ?? this.position;\n    this.assertPosition(position);\n    return this.bytes[position];\n  },\n  inspectUint16(position_) {\n    const position = position_ ?? this.position;\n    this.assertPosition(position + 1);\n    return this.dataView.getUint16(position);\n  },\n  inspectUint24(position_) {\n    const position = position_ ?? this.position;\n    this.assertPosition(position + 2);\n    return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);\n  },\n  inspectUint32(position_) {\n    const position = position_ ?? this.position;\n    this.assertPosition(position + 3);\n    return this.dataView.getUint32(position);\n  },\n  pushByte(byte) {\n    this.assertPosition(this.position);\n    this.bytes[this.position] = byte;\n    this.position++;\n  },\n  pushBytes(bytes) {\n    this.assertPosition(this.position + bytes.length - 1);\n    this.bytes.set(bytes, this.position);\n    this.position += bytes.length;\n  },\n  pushUint8(value) {\n    this.assertPosition(this.position);\n    this.bytes[this.position] = value;\n    this.position++;\n  },\n  pushUint16(value) {\n    this.assertPosition(this.position + 1);\n    this.dataView.setUint16(this.position, value);\n    this.position += 2;\n  },\n  pushUint24(value) {\n    this.assertPosition(this.position + 2);\n    this.dataView.setUint16(this.position, value >> 8);\n    this.dataView.setUint8(this.position + 2, value & ~4294967040);\n    this.position += 3;\n  },\n  pushUint32(value) {\n    this.assertPosition(this.position + 3);\n    this.dataView.setUint32(this.position, value);\n    this.position += 4;\n  },\n  readByte() {\n    this.assertReadLimit();\n    this._touch();\n    const value = this.inspectByte();\n    this.position++;\n    return value;\n  },\n  readBytes(length, size) {\n    this.assertReadLimit();\n    this._touch();\n    const value = this.inspectBytes(length);\n    this.position += size ?? length;\n    return value;\n  },\n  readUint8() {\n    this.assertReadLimit();\n    this._touch();\n    const value = this.inspectUint8();\n    this.position += 1;\n    return value;\n  },\n  readUint16() {\n    this.assertReadLimit();\n    this._touch();\n    const value = this.inspectUint16();\n    this.position += 2;\n    return value;\n  },\n  readUint24() {\n    this.assertReadLimit();\n    this._touch();\n    const value = this.inspectUint24();\n    this.position += 3;\n    return value;\n  },\n  readUint32() {\n    this.assertReadLimit();\n    this._touch();\n    const value = this.inspectUint32();\n    this.position += 4;\n    return value;\n  },\n  get remaining() {\n    return this.bytes.length - this.position;\n  },\n  setPosition(position) {\n    const oldPosition = this.position;\n    this.assertPosition(position);\n    this.position = position;\n    return () => this.position = oldPosition;\n  },\n  _touch() {\n    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY) return;\n    const count = this.getReadCount();\n    this.positionReadCount.set(this.position, count + 1);\n    if (count > 0) this.recursiveReadCount++;\n  }\n};\n/** @internal */\nexport function create(bytes, {\n  recursiveReadLimit = 8_192\n} = {}) {\n  const cursor = Object.create(staticCursor);\n  cursor.bytes = bytes;\n  cursor.dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n  cursor.positionReadCount = new Map();\n  cursor.recursiveReadLimit = recursiveReadLimit;\n  return cursor;\n}\n/** @internal */\nexport class NegativeOffsetError extends Errors.BaseError {\n  constructor({\n    offset\n  }) {\n    super(`Offset \\`${offset}\\` cannot be negative.`);\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Cursor.NegativeOffsetError'\n    });\n  }\n}\n/** @internal */\nexport class PositionOutOfBoundsError extends Errors.BaseError {\n  constructor({\n    length,\n    position\n  }) {\n    super(`Position \\`${position}\\` is out of bounds (\\`0 < position < ${length}\\`).`);\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Cursor.PositionOutOfBoundsError'\n    });\n  }\n}\n/** @internal */\nexport class RecursiveReadLimitExceededError extends Errors.BaseError {\n  constructor({\n    count,\n    limit\n  }) {\n    super(`Recursive read limit of \\`${limit}\\` exceeded (recursive read count: \\`${count}\\`).`);\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Cursor.RecursiveReadLimitExceededError'\n    });\n  }\n}\n//# sourceMappingURL=cursor.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}