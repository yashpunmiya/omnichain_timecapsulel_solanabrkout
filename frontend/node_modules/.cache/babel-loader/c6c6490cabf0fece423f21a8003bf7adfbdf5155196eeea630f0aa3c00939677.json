{"ast":null,"code":"import { BlockNotFoundError } from '../../errors/block.js';\nimport { TransactionNotFoundError, TransactionReceiptNotFoundError, WaitForTransactionReceiptTimeoutError } from '../../errors/transaction.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { observe } from '../../utils/observe.js';\nimport { withResolvers } from '../../utils/promise/withResolvers.js';\nimport { withRetry } from '../../utils/promise/withRetry.js';\nimport { stringify } from '../../utils/stringify.js';\nimport { getBlock } from './getBlock.js';\nimport { getTransaction } from './getTransaction.js';\nimport { getTransactionReceipt } from './getTransactionReceipt.js';\nimport { watchBlockNumber } from './watchBlockNumber.js';\n/**\n * Waits for the [Transaction](https://viem.sh/docs/glossary/terms#transaction) to be included on a [Block](https://viem.sh/docs/glossary/terms#block) (one confirmation), and then returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms#transaction-receipt).\n *\n * - Docs: https://viem.sh/docs/actions/public/waitForTransactionReceipt\n * - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_sending-transactions\n * - JSON-RPC Methods:\n *   - Polls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) on each block until it has been processed.\n *   - If a Transaction has been replaced:\n *     - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) and extracts the transactions\n *     - Checks if one of the Transactions is a replacement\n *     - If so, calls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt).\n *\n * The `waitForTransactionReceipt` action additionally supports Replacement detection (e.g. sped up Transactions).\n *\n * Transactions can be replaced when a user modifies their transaction in their wallet (to speed up or cancel). Transactions are replaced when they are sent from the same nonce.\n *\n * There are 3 types of Transaction Replacement reasons:\n *\n * - `repriced`: The gas price has been modified (e.g. different `maxFeePerGas`)\n * - `cancelled`: The Transaction has been cancelled (e.g. `value === 0n`)\n * - `replaced`: The Transaction has been replaced (e.g. different `value` or `data`)\n *\n * @param client - Client to use\n * @param parameters - {@link WaitForTransactionReceiptParameters}\n * @returns The transaction receipt. {@link WaitForTransactionReceiptReturnType}\n *\n * @example\n * import { createPublicClient, waitForTransactionReceipt, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const transactionReceipt = await waitForTransactionReceipt(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport async function waitForTransactionReceipt(client, {\n  confirmations = 1,\n  hash,\n  onReplaced,\n  pollingInterval = client.pollingInterval,\n  retryCount = 6,\n  retryDelay = ({\n    count\n  }) => ~~(1 << count) * 200,\n  // exponential backoff\n  timeout = 180_000\n}) {\n  const observerId = stringify(['waitForTransactionReceipt', client.uid, hash]);\n  let transaction;\n  let replacedTransaction;\n  let receipt;\n  let retrying = false;\n  const {\n    promise,\n    resolve,\n    reject\n  } = withResolvers();\n  const timer = timeout ? setTimeout(() => reject(new WaitForTransactionReceiptTimeoutError({\n    hash\n  })), timeout) : undefined;\n  const _unobserve = observe(observerId, {\n    onReplaced,\n    resolve,\n    reject\n  }, emit => {\n    const _unwatch = getAction(client, watchBlockNumber, 'watchBlockNumber')({\n      emitMissed: true,\n      emitOnBegin: true,\n      poll: true,\n      pollingInterval,\n      async onBlockNumber(blockNumber_) {\n        const done = fn => {\n          clearTimeout(timer);\n          _unwatch();\n          fn();\n          _unobserve();\n        };\n        let blockNumber = blockNumber_;\n        if (retrying) return;\n        try {\n          // If we already have a valid receipt, let's check if we have enough\n          // confirmations. If we do, then we can resolve.\n          if (receipt) {\n            if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations)) return;\n            done(() => emit.resolve(receipt));\n            return;\n          }\n          // Get the transaction to check if it's been replaced.\n          // We need to retry as some RPC Providers may be slow to sync\n          // up mined transactions.\n          if (!transaction) {\n            retrying = true;\n            await withRetry(async () => {\n              transaction = await getAction(client, getTransaction, 'getTransaction')({\n                hash\n              });\n              if (transaction.blockNumber) blockNumber = transaction.blockNumber;\n            }, {\n              delay: retryDelay,\n              retryCount\n            });\n            retrying = false;\n          }\n          // Get the receipt to check if it's been processed.\n          receipt = await getAction(client, getTransactionReceipt, 'getTransactionReceipt')({\n            hash\n          });\n          // Check if we have enough confirmations. If not, continue polling.\n          if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations)) return;\n          done(() => emit.resolve(receipt));\n        } catch (err) {\n          // If the receipt is not found, the transaction will be pending.\n          // We need to check if it has potentially been replaced.\n          if (err instanceof TransactionNotFoundError || err instanceof TransactionReceiptNotFoundError) {\n            if (!transaction) {\n              retrying = false;\n              return;\n            }\n            try {\n              replacedTransaction = transaction;\n              // Let's retrieve the transactions from the current block.\n              // We need to retry as some RPC Providers may be slow to sync\n              // up mined blocks.\n              retrying = true;\n              const block = await withRetry(() => getAction(client, getBlock, 'getBlock')({\n                blockNumber,\n                includeTransactions: true\n              }), {\n                delay: retryDelay,\n                retryCount,\n                shouldRetry: ({\n                  error\n                }) => error instanceof BlockNotFoundError\n              });\n              retrying = false;\n              const replacementTransaction = block.transactions.find(({\n                from,\n                nonce\n              }) => from === replacedTransaction.from && nonce === replacedTransaction.nonce);\n              // If we couldn't find a replacement transaction, continue polling.\n              if (!replacementTransaction) return;\n              // If we found a replacement transaction, return it's receipt.\n              receipt = await getAction(client, getTransactionReceipt, 'getTransactionReceipt')({\n                hash: replacementTransaction.hash\n              });\n              // Check if we have enough confirmations. If not, continue polling.\n              if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations)) return;\n              let reason = 'replaced';\n              if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value && replacementTransaction.input === replacedTransaction.input) {\n                reason = 'repriced';\n              } else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) {\n                reason = 'cancelled';\n              }\n              done(() => {\n                emit.onReplaced?.({\n                  reason,\n                  replacedTransaction: replacedTransaction,\n                  transaction: replacementTransaction,\n                  transactionReceipt: receipt\n                });\n                emit.resolve(receipt);\n              });\n            } catch (err_) {\n              done(() => emit.reject(err_));\n            }\n          } else {\n            done(() => emit.reject(err));\n          }\n        }\n      }\n    });\n  });\n  return promise;\n}","map":{"version":3,"names":["BlockNotFoundError","TransactionNotFoundError","TransactionReceiptNotFoundError","WaitForTransactionReceiptTimeoutError","getAction","observe","withResolvers","withRetry","stringify","getBlock","getTransaction","getTransactionReceipt","watchBlockNumber","waitForTransactionReceipt","client","confirmations","hash","onReplaced","pollingInterval","retryCount","retryDelay","count","timeout","observerId","uid","transaction","replacedTransaction","receipt","retrying","promise","resolve","reject","timer","setTimeout","undefined","_unobserve","emit","_unwatch","emitMissed","emitOnBegin","poll","onBlockNumber","blockNumber_","done","fn","clearTimeout","blockNumber","delay","err","block","includeTransactions","shouldRetry","error","replacementTransaction","transactions","find","from","nonce","reason","to","value","input","transactionReceipt","err_"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@reown\\appkit-controllers\\node_modules\\@walletconnect\\utils\\node_modules\\viem\\actions\\public\\waitForTransactionReceipt.ts"],"sourcesContent":["import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { BlockNotFoundError } from '../../errors/block.js'\nimport {\n  TransactionNotFoundError,\n  TransactionReceiptNotFoundError,\n  WaitForTransactionReceiptTimeoutError,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { Transaction } from '../../types/transaction.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { type ObserveErrorType, observe } from '../../utils/observe.js'\nimport { withResolvers } from '../../utils/promise/withResolvers.js'\nimport {\n  type WithRetryParameters,\n  withRetry,\n} from '../../utils/promise/withRetry.js'\nimport { stringify } from '../../utils/stringify.js'\n\nimport { type GetBlockErrorType, getBlock } from './getBlock.js'\nimport {\n  type GetTransactionErrorType,\n  type GetTransactionReturnType,\n  getTransaction,\n} from './getTransaction.js'\nimport {\n  type GetTransactionReceiptErrorType,\n  type GetTransactionReceiptReturnType,\n  getTransactionReceipt,\n} from './getTransactionReceipt.js'\nimport {\n  type WatchBlockNumberErrorType,\n  watchBlockNumber,\n} from './watchBlockNumber.js'\n\nexport type ReplacementReason = 'cancelled' | 'replaced' | 'repriced'\nexport type ReplacementReturnType<\n  chain extends Chain | undefined = Chain | undefined,\n> = {\n  reason: ReplacementReason\n  replacedTransaction: Transaction\n  transaction: Transaction\n  transactionReceipt: GetTransactionReceiptReturnType<chain>\n}\n\nexport type WaitForTransactionReceiptReturnType<\n  chain extends Chain | undefined = Chain | undefined,\n> = GetTransactionReceiptReturnType<chain>\n\nexport type WaitForTransactionReceiptParameters<\n  chain extends Chain | undefined = Chain | undefined,\n> = {\n  /**\n   * The number of confirmations (blocks that have passed) to wait before resolving.\n   * @default 1\n   */\n  confirmations?: number | undefined\n  /** The hash of the transaction. */\n  hash: Hash\n  /** Optional callback to emit if the transaction has been replaced. */\n  onReplaced?: ((response: ReplacementReturnType<chain>) => void) | undefined\n  /**\n   * Polling frequency (in ms). Defaults to the client's pollingInterval config.\n   * @default client.pollingInterval\n   */\n  pollingInterval?: number | undefined\n  /**\n   * Number of times to retry if the transaction or block is not found.\n   * @default 6 (exponential backoff)\n   */\n  retryCount?: WithRetryParameters['retryCount'] | undefined\n  /**\n   * Time to wait (in ms) between retries.\n   * @default `({ count }) => ~~(1 << count) * 200` (exponential backoff)\n   */\n  retryDelay?: WithRetryParameters['delay'] | undefined\n  /**\n   * Optional timeout (in milliseconds) to wait before stopping polling.\n   * @default 180_000\n   */\n  timeout?: number | undefined\n}\n\nexport type WaitForTransactionReceiptErrorType =\n  | ObserveErrorType\n  | GetBlockErrorType\n  | GetTransactionErrorType\n  | GetTransactionReceiptErrorType\n  | WatchBlockNumberErrorType\n  | ErrorType\n\n/**\n * Waits for the [Transaction](https://viem.sh/docs/glossary/terms#transaction) to be included on a [Block](https://viem.sh/docs/glossary/terms#block) (one confirmation), and then returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms#transaction-receipt).\n *\n * - Docs: https://viem.sh/docs/actions/public/waitForTransactionReceipt\n * - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_sending-transactions\n * - JSON-RPC Methods:\n *   - Polls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) on each block until it has been processed.\n *   - If a Transaction has been replaced:\n *     - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) and extracts the transactions\n *     - Checks if one of the Transactions is a replacement\n *     - If so, calls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt).\n *\n * The `waitForTransactionReceipt` action additionally supports Replacement detection (e.g. sped up Transactions).\n *\n * Transactions can be replaced when a user modifies their transaction in their wallet (to speed up or cancel). Transactions are replaced when they are sent from the same nonce.\n *\n * There are 3 types of Transaction Replacement reasons:\n *\n * - `repriced`: The gas price has been modified (e.g. different `maxFeePerGas`)\n * - `cancelled`: The Transaction has been cancelled (e.g. `value === 0n`)\n * - `replaced`: The Transaction has been replaced (e.g. different `value` or `data`)\n *\n * @param client - Client to use\n * @param parameters - {@link WaitForTransactionReceiptParameters}\n * @returns The transaction receipt. {@link WaitForTransactionReceiptReturnType}\n *\n * @example\n * import { createPublicClient, waitForTransactionReceipt, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const transactionReceipt = await waitForTransactionReceipt(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport async function waitForTransactionReceipt<\n  chain extends Chain | undefined,\n>(\n  client: Client<Transport, chain>,\n  {\n    confirmations = 1,\n    hash,\n    onReplaced,\n    pollingInterval = client.pollingInterval,\n    retryCount = 6,\n    retryDelay = ({ count }) => ~~(1 << count) * 200, // exponential backoff\n    timeout = 180_000,\n  }: WaitForTransactionReceiptParameters<chain>,\n): Promise<WaitForTransactionReceiptReturnType<chain>> {\n  const observerId = stringify(['waitForTransactionReceipt', client.uid, hash])\n\n  let transaction: GetTransactionReturnType<chain> | undefined\n  let replacedTransaction: GetTransactionReturnType<chain> | undefined\n  let receipt: GetTransactionReceiptReturnType<chain>\n  let retrying = false\n\n  const { promise, resolve, reject } =\n    withResolvers<WaitForTransactionReceiptReturnType<chain>>()\n\n  const timer = timeout\n    ? setTimeout(\n        () => reject(new WaitForTransactionReceiptTimeoutError({ hash })),\n        timeout,\n      )\n    : undefined\n\n  const _unobserve = observe(\n    observerId,\n    { onReplaced, resolve, reject },\n    (emit) => {\n      const _unwatch = getAction(\n        client,\n        watchBlockNumber,\n        'watchBlockNumber',\n      )({\n        emitMissed: true,\n        emitOnBegin: true,\n        poll: true,\n        pollingInterval,\n        async onBlockNumber(blockNumber_) {\n          const done = (fn: () => void) => {\n            clearTimeout(timer)\n            _unwatch()\n            fn()\n            _unobserve()\n          }\n\n          let blockNumber = blockNumber_\n\n          if (retrying) return\n\n          try {\n            // If we already have a valid receipt, let's check if we have enough\n            // confirmations. If we do, then we can resolve.\n            if (receipt) {\n              if (\n                confirmations > 1 &&\n                (!receipt.blockNumber ||\n                  blockNumber - receipt.blockNumber + 1n < confirmations)\n              )\n                return\n\n              done(() => emit.resolve(receipt))\n              return\n            }\n\n            // Get the transaction to check if it's been replaced.\n            // We need to retry as some RPC Providers may be slow to sync\n            // up mined transactions.\n            if (!transaction) {\n              retrying = true\n              await withRetry(\n                async () => {\n                  transaction = (await getAction(\n                    client,\n                    getTransaction,\n                    'getTransaction',\n                  )({ hash })) as GetTransactionReturnType<chain>\n                  if (transaction.blockNumber)\n                    blockNumber = transaction.blockNumber\n                },\n                {\n                  delay: retryDelay,\n                  retryCount,\n                },\n              )\n              retrying = false\n            }\n\n            // Get the receipt to check if it's been processed.\n            receipt = await getAction(\n              client,\n              getTransactionReceipt,\n              'getTransactionReceipt',\n            )({ hash })\n\n            // Check if we have enough confirmations. If not, continue polling.\n            if (\n              confirmations > 1 &&\n              (!receipt.blockNumber ||\n                blockNumber - receipt.blockNumber + 1n < confirmations)\n            )\n              return\n\n            done(() => emit.resolve(receipt))\n          } catch (err) {\n            // If the receipt is not found, the transaction will be pending.\n            // We need to check if it has potentially been replaced.\n            if (\n              err instanceof TransactionNotFoundError ||\n              err instanceof TransactionReceiptNotFoundError\n            ) {\n              if (!transaction) {\n                retrying = false\n                return\n              }\n\n              try {\n                replacedTransaction = transaction\n\n                // Let's retrieve the transactions from the current block.\n                // We need to retry as some RPC Providers may be slow to sync\n                // up mined blocks.\n                retrying = true\n                const block = await withRetry(\n                  () =>\n                    getAction(\n                      client,\n                      getBlock,\n                      'getBlock',\n                    )({\n                      blockNumber,\n                      includeTransactions: true,\n                    }),\n                  {\n                    delay: retryDelay,\n                    retryCount,\n                    shouldRetry: ({ error }) =>\n                      error instanceof BlockNotFoundError,\n                  },\n                )\n                retrying = false\n\n                const replacementTransaction = (\n                  block.transactions as {} as Transaction[]\n                ).find(\n                  ({ from, nonce }) =>\n                    from === replacedTransaction!.from &&\n                    nonce === replacedTransaction!.nonce,\n                )\n\n                // If we couldn't find a replacement transaction, continue polling.\n                if (!replacementTransaction) return\n\n                // If we found a replacement transaction, return it's receipt.\n                receipt = await getAction(\n                  client,\n                  getTransactionReceipt,\n                  'getTransactionReceipt',\n                )({\n                  hash: replacementTransaction.hash,\n                })\n\n                // Check if we have enough confirmations. If not, continue polling.\n                if (\n                  confirmations > 1 &&\n                  (!receipt.blockNumber ||\n                    blockNumber - receipt.blockNumber + 1n < confirmations)\n                )\n                  return\n\n                let reason: ReplacementReason = 'replaced'\n                if (\n                  replacementTransaction.to === replacedTransaction.to &&\n                  replacementTransaction.value === replacedTransaction.value &&\n                  replacementTransaction.input === replacedTransaction.input\n                ) {\n                  reason = 'repriced'\n                } else if (\n                  replacementTransaction.from === replacementTransaction.to &&\n                  replacementTransaction.value === 0n\n                ) {\n                  reason = 'cancelled'\n                }\n\n                done(() => {\n                  emit.onReplaced?.({\n                    reason,\n                    replacedTransaction: replacedTransaction! as any,\n                    transaction: replacementTransaction,\n                    transactionReceipt: receipt,\n                  })\n                  emit.resolve(receipt)\n                })\n              } catch (err_) {\n                done(() => emit.reject(err_))\n              }\n            } else {\n              done(() => emit.reject(err))\n            }\n          }\n        },\n      })\n    },\n  )\n\n  return promise\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}