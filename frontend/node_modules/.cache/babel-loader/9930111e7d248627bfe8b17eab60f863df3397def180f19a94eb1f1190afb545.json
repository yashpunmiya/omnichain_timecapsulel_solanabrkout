{"ast":null,"code":"import * as Bytes from './Bytes.js';\nimport * as Caches from './Caches.js';\nimport * as Errors from './Errors.js';\nimport * as Hash from './Hash.js';\nimport * as PublicKey from './PublicKey.js';\nconst addressRegex = /*#__PURE__*//^0x[a-fA-F0-9]{40}$/;\n/**\n * Asserts that the given value is a valid {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.assert('0xA0Cf798816D4b9b9866b5330EEa46a18382f251e')\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.assert('0xdeadbeef')\n * // @error: InvalidAddressError: Address \"0xdeadbeef\" is invalid.\n * ```\n *\n * @param value - Value to assert if it is a valid address.\n * @param options - Assertion options.\n */\nexport function assert(value, options = {}) {\n  const {\n    strict = true\n  } = options;\n  if (!addressRegex.test(value)) throw new InvalidAddressError({\n    address: value,\n    cause: new InvalidInputError()\n  });\n  if (strict) {\n    if (value.toLowerCase() === value) return;\n    if (checksum(value) !== value) throw new InvalidAddressError({\n      address: value,\n      cause: new InvalidChecksumError()\n    });\n  }\n}\n/**\n * Computes the checksum address for the given {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.checksum('0xa0cf798816d4b9b9866b5330eea46a18382f251e')\n * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * ```\n *\n * @param address - The address to compute the checksum for.\n * @returns The checksummed address.\n */\nexport function checksum(address) {\n  if (Caches.checksum.has(address)) return Caches.checksum.get(address);\n  assert(address, {\n    strict: false\n  });\n  const hexAddress = address.substring(2).toLowerCase();\n  const hash = Hash.keccak256(Bytes.fromString(hexAddress), {\n    as: 'Bytes'\n  });\n  const characters = hexAddress.split('');\n  for (let i = 0; i < 40; i += 2) {\n    if (hash[i >> 1] >> 4 >= 8 && characters[i]) {\n      characters[i] = characters[i].toUpperCase();\n    }\n    if ((hash[i >> 1] & 0x0f) >= 8 && characters[i + 1]) {\n      characters[i + 1] = characters[i + 1].toUpperCase();\n    }\n  }\n  const result = `0x${characters.join('')}`;\n  Caches.checksum.set(address, result);\n  return result;\n}\n/**\n * Converts a stringified address to a typed (checksummed) {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0xa0cf798816d4b9b9866b5330eea46a18382f251e')\n * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0xa0cf798816d4b9b9866b5330eea46a18382f251e', {\n *   checksum: false\n * })\n * // @log: '0xa0cf798816d4b9b9866b5330eea46a18382f251e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('hello')\n * // @error: InvalidAddressError: Address \"0xa\" is invalid.\n * ```\n *\n * @param address - An address string to convert to a typed Address.\n * @param options - Conversion options.\n * @returns The typed Address.\n */\nexport function from(address, options = {}) {\n  const {\n    checksum: checksumVal = false\n  } = options;\n  assert(address);\n  if (checksumVal) return checksum(address);\n  return address;\n}\n/**\n * Converts an ECDSA public key to an {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address, PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from(\n *   '0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5',\n * )\n * const address = Address.fromPublicKey(publicKey)\n * // @log: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'\n * ```\n *\n * @param publicKey - The ECDSA public key to convert to an {@link ox#Address.Address}.\n * @param options - Conversion options.\n * @returns The {@link ox#Address.Address} corresponding to the public key.\n */\nexport function fromPublicKey(publicKey, options = {}) {\n  const address = Hash.keccak256(`0x${PublicKey.toHex(publicKey).slice(4)}`).substring(26);\n  return from(`0x${address}`, options);\n}\n/**\n * Checks if two {@link ox#Address.Address} are equal.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.isEqual(\n *   '0xa0cf798816d4b9b9866b5330eea46a18382f251e',\n *   '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * )\n * // @log: true\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.isEqual(\n *   '0xa0cf798816d4b9b9866b5330eea46a18382f251e',\n *   '0xA0Cf798816D4b9b9866b5330EEa46a18382f251f'\n * )\n * // @log: false\n * ```\n *\n * @param addressA - The first address to compare.\n * @param addressB - The second address to compare.\n * @returns Whether the addresses are equal.\n */\nexport function isEqual(addressA, addressB) {\n  assert(addressA, {\n    strict: false\n  });\n  assert(addressB, {\n    strict: false\n  });\n  return addressA.toLowerCase() === addressB.toLowerCase();\n}\n/**\n * Checks if the given address is a valid {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.validate('0xA0Cf798816D4b9b9866b5330EEa46a18382f251e')\n * // @log: true\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.validate('0xdeadbeef')\n * // @log: false\n * ```\n *\n * @param address - Value to check if it is a valid address.\n * @param options - Check options.\n * @returns Whether the address is a valid address.\n */\nexport function validate(address, options = {}) {\n  const {\n    strict = true\n  } = options ?? {};\n  try {\n    assert(address, {\n      strict\n    });\n    return true;\n  } catch {\n    return false;\n  }\n}\n/**\n * Thrown when an address is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0x123')\n * // @error: Address.InvalidAddressError: Address `0x123` is invalid.\n * ```\n */\nexport class InvalidAddressError extends Errors.BaseError {\n  constructor({\n    address,\n    cause\n  }) {\n    super(`Address \"${address}\" is invalid.`, {\n      cause\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Address.InvalidAddressError'\n    });\n  }\n}\n/** Thrown when an address is not a 20 byte (40 hexadecimal character) value. */\nexport class InvalidInputError extends Errors.BaseError {\n  constructor() {\n    super('Address is not a 20 byte (40 hexadecimal character) value.');\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Address.InvalidInputError'\n    });\n  }\n}\n/** Thrown when an address does not match its checksum counterpart. */\nexport class InvalidChecksumError extends Errors.BaseError {\n  constructor() {\n    super('Address does not match its checksum counterpart.');\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Address.InvalidChecksumError'\n    });\n  }\n}\n//# sourceMappingURL=Address.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}