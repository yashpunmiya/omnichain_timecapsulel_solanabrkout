{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TrezorConnect = exports.CoreInIframe = void 0;\nconst tslib_1 = require(\"tslib\");\nconst events_1 = tslib_1.__importDefault(require(\"events\"));\nconst ERRORS = tslib_1.__importStar(require(\"@trezor/connect/lib/constants/errors\"));\nconst config_1 = require(\"@trezor/connect/lib/data/config\");\nconst events_2 = require(\"@trezor/connect/lib/events\");\nconst factory_1 = require(\"@trezor/connect/lib/factory\");\nconst debug_1 = require(\"@trezor/connect/lib/utils/debug\");\nconst createDeferredManager_1 = require(\"@trezor/utils/lib/createDeferredManager\");\nconst connectSettings_1 = require(\"../connectSettings\");\nconst iframe = tslib_1.__importStar(require(\"../iframe\"));\nconst popup = tslib_1.__importStar(require(\"../popup\"));\nconst button_1 = tslib_1.__importDefault(require(\"../webusb/button\"));\nclass CoreInIframe {\n  eventEmitter = new events_1.default();\n  _settings;\n  _log;\n  _popupManager;\n  _messagePromises;\n  boundHandleMessage = this.handleMessage.bind(this);\n  boundDispose = this.dispose.bind(this);\n  constructor() {\n    this._settings = (0, connectSettings_1.parseConnectSettings)();\n    this._log = (0, debug_1.initLog)('@trezor/connect-web');\n    this._messagePromises = (0, createDeferredManager_1.createDeferredManager)({\n      initialId: 1\n    });\n  }\n  initPopupManager() {\n    const pm = new popup.PopupManager(this._settings, {\n      logger: this._log\n    });\n    pm.on(events_2.POPUP.CLOSED, error => {\n      iframe.postMessage({\n        type: events_2.POPUP.CLOSED,\n        payload: error ? {\n          error\n        } : null\n      });\n    });\n    return pm;\n  }\n  manifest(data) {\n    this._settings = (0, connectSettings_1.parseConnectSettings)({\n      ...this._settings,\n      manifest: data\n    });\n  }\n  dispose() {\n    this.eventEmitter.removeAllListeners();\n    iframe.dispose();\n    this._settings = (0, connectSettings_1.parseConnectSettings)();\n    if (this._popupManager) {\n      this._popupManager.close();\n    }\n    window.removeEventListener('message', this.boundHandleMessage);\n    window.removeEventListener('unload', this.boundDispose);\n    return Promise.resolve(undefined);\n  }\n  cancel(error) {\n    if (this._popupManager) {\n      this._popupManager.emit(events_2.POPUP.CLOSED, error);\n    }\n  }\n  handleMessage(messageEvent) {\n    if (messageEvent.origin !== iframe.origin) return;\n    const message = (0, events_2.parseMessage)(messageEvent.data);\n    this._log.log('handleMessage', message);\n    switch (message.event) {\n      case events_2.RESPONSE_EVENT:\n        {\n          const {\n            id = 0,\n            success,\n            payload,\n            device\n          } = message;\n          const resolved = this._messagePromises.resolve(id, {\n            id,\n            success,\n            payload,\n            device\n          });\n          if (!resolved) this._log.warn(`Unknown message id ${id}`);\n          break;\n        }\n      case events_2.DEVICE_EVENT:\n        this.eventEmitter.emit(message.event, message);\n        this.eventEmitter.emit(message.type, message.payload);\n        break;\n      case events_2.TRANSPORT_EVENT:\n        this.eventEmitter.emit(message.event, message);\n        this.eventEmitter.emit(message.type, message.payload);\n        break;\n      case events_2.BLOCKCHAIN_EVENT:\n        this.eventEmitter.emit(message.event, message);\n        this.eventEmitter.emit(message.type, message.payload);\n        break;\n      case events_2.UI_EVENT:\n        if (message.type === events_2.IFRAME.BOOTSTRAP) {\n          iframe.clearTimeout();\n          break;\n        }\n        if (message.type === events_2.IFRAME.LOADED) {\n          iframe.initPromise.resolve();\n        }\n        if (message.type === events_2.IFRAME.ERROR) {\n          iframe.initPromise.reject(message.payload.error);\n        }\n        this.eventEmitter.emit(message.event, message);\n        this.eventEmitter.emit(message.type, message.payload);\n        break;\n      default:\n        this._log.log('Undefined message', messageEvent.data);\n    }\n  }\n  async init(settings) {\n    if (iframe.instance) {\n      throw ERRORS.TypedError('Init_AlreadyInitialized');\n    }\n    this._settings = (0, connectSettings_1.parseConnectSettings)({\n      ...this._settings,\n      ...settings\n    });\n    if (!this._settings.manifest) {\n      throw ERRORS.TypedError('Init_ManifestMissing');\n    }\n    if (!this._settings.transports?.length) {\n      this._settings.transports = ['BridgeTransport', 'WebUsbTransport'];\n    }\n    if (!this._settings.coreMode) {\n      this._settings.coreMode = 'auto';\n    }\n    if (this._settings.lazyLoad) {\n      this._settings.lazyLoad = false;\n      return;\n    }\n    if (!this._popupManager) {\n      this._popupManager = this.initPopupManager();\n    }\n    this._log.enabled = !!this._settings.debug;\n    window.addEventListener('message', this.boundHandleMessage);\n    window.addEventListener('unload', this.boundDispose);\n    await iframe.init(this._settings);\n    if (this._settings.coreMode === 'auto') {\n      const {\n        promiseId,\n        promise\n      } = this._messagePromises.create();\n      this._log.debug('coreMode = auto, Checking bridge availability');\n      iframe.postMessage({\n        id: promiseId,\n        type: events_2.TRANSPORT.GET_INFO\n      });\n      const response = await promise;\n      this._log.debug('Bridge availability response', response);\n      if (response.payload === undefined && navigator.usb && this._settings.transports?.includes('WebUsbTransport')) {\n        throw ERRORS.TypedError('Transport_Missing');\n      }\n    }\n    if (this._settings.sharedLogger !== false) {\n      iframe.initIframeLogger();\n    }\n  }\n  setTransports() {\n    throw new Error('Unsupported right now');\n  }\n  async call(params) {\n    if (!iframe.instance && !iframe.timeout) {\n      this._settings = (0, connectSettings_1.parseConnectSettings)(this._settings);\n      if (!this._settings.manifest) {\n        return (0, events_2.createErrorMessage)(ERRORS.TypedError('Init_ManifestMissing'));\n      }\n      if (!this._popupManager) {\n        this._popupManager = this.initPopupManager();\n      }\n      try {\n        await this.init(this._settings);\n      } catch (error) {\n        if (this._popupManager) {\n          this._popupManager.clear();\n        }\n        return (0, events_2.createErrorMessage)(error);\n      }\n    }\n    if (iframe.timeout) {\n      await iframe.initPromise.promise;\n    }\n    if (iframe.error) {\n      return (0, events_2.createErrorMessage)(iframe.error);\n    }\n    if (this._settings.popup && this._popupManager) {\n      this._popupManager.request();\n    }\n    try {\n      const {\n        promiseId,\n        promise\n      } = this._messagePromises.create();\n      iframe.postMessage({\n        id: promiseId,\n        type: events_2.IFRAME.CALL,\n        payload: params\n      });\n      const response = await promise;\n      if (response) {\n        if (!response.success && response.payload.code !== 'Device_CallInProgress' && this._popupManager) {\n          this._popupManager.unlock();\n        }\n        return response;\n      }\n      if (this._popupManager) {\n        this._popupManager.unlock();\n      }\n      return (0, events_2.createErrorMessage)(ERRORS.TypedError('Method_NoResponse'));\n    } catch (error) {\n      this._log.error('__call error', error);\n      if (this._popupManager) {\n        this._popupManager.clear(false);\n      }\n      return (0, events_2.createErrorMessage)(error);\n    }\n  }\n  uiResponse(response) {\n    if (!iframe.instance) {\n      throw ERRORS.TypedError('Init_NotInitialized');\n    }\n    iframe.postMessage(response);\n  }\n  renderWebUSBButton(className) {\n    (0, button_1.default)(className, this._settings.webusbSrc);\n  }\n  async requestLogin(params) {\n    if (typeof params.callback === 'function') {\n      const {\n        callback\n      } = params;\n      const loginChallengeListener = async event => {\n        const {\n          data\n        } = event;\n        if (data && data.type === events_2.UI.LOGIN_CHALLENGE_REQUEST) {\n          try {\n            const payload = await callback();\n            iframe.postMessage({\n              type: events_2.UI.LOGIN_CHALLENGE_RESPONSE,\n              payload\n            });\n          } catch (error) {\n            iframe.postMessage({\n              type: events_2.UI.LOGIN_CHALLENGE_RESPONSE,\n              payload: error.message\n            });\n          }\n        }\n      };\n      window.addEventListener('message', loginChallengeListener, false);\n      const response = await this.call({\n        method: 'requestLogin',\n        ...params,\n        asyncChallenge: true,\n        callback: null\n      });\n      window.removeEventListener('message', loginChallengeListener);\n      return response;\n    }\n    return this.call({\n      method: 'requestLogin',\n      ...params\n    });\n  }\n  disableWebUSB() {\n    if (!iframe.instance) {\n      throw ERRORS.TypedError('Init_NotInitialized');\n    }\n    iframe.postMessage({\n      type: events_2.TRANSPORT.DISABLE_WEBUSB\n    });\n  }\n  async requestWebUSBDevice() {\n    try {\n      await window.navigator.usb.requestDevice({\n        filters: config_1.config.webusb\n      });\n      iframe.postMessage({\n        type: events_2.TRANSPORT.REQUEST_DEVICE\n      });\n    } catch {}\n  }\n}\nexports.CoreInIframe = CoreInIframe;\nconst impl = new CoreInIframe();\nexports.TrezorConnect = (0, factory_1.factory)({\n  eventEmitter: impl.eventEmitter,\n  init: impl.init.bind(impl),\n  call: impl.call.bind(impl),\n  setTransports: impl.setTransports.bind(impl),\n  manifest: impl.manifest.bind(impl),\n  requestLogin: impl.requestLogin.bind(impl),\n  uiResponse: impl.uiResponse.bind(impl),\n  cancel: impl.cancel.bind(impl),\n  dispose: impl.dispose.bind(impl)\n}, {\n  renderWebUSBButton: impl.renderWebUSBButton.bind(impl),\n  disableWebUSB: impl.disableWebUSB.bind(impl),\n  requestWebUSBDevice: impl.requestWebUSBDevice.bind(impl)\n});\n//# sourceMappingURL=core-in-iframe.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}