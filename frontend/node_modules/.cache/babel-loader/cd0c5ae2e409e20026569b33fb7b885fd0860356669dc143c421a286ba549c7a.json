{"ast":null,"code":"/** @internal */\nexport const promiseCache = /*#__PURE__*/new Map();\n/** @internal */\nexport const responseCache = /*#__PURE__*/new Map();\nexport function getCache(cacheKey) {\n  const buildCache = (cacheKey, cache) => ({\n    clear: () => cache.delete(cacheKey),\n    get: () => cache.get(cacheKey),\n    set: data => cache.set(cacheKey, data)\n  });\n  const promise = buildCache(cacheKey, promiseCache);\n  const response = buildCache(cacheKey, responseCache);\n  return {\n    clear: () => {\n      promise.clear();\n      response.clear();\n    },\n    promise,\n    response\n  };\n}\n/**\n * @description Returns the result of a given promise, and caches the result for\n * subsequent invocations against a provided cache key.\n */\nexport async function withCache(fn, {\n  cacheKey,\n  cacheTime = Number.POSITIVE_INFINITY\n}) {\n  const cache = getCache(cacheKey);\n  // If a response exists in the cache, and it's not expired, return it\n  // and do not invoke the promise.\n  // If the max age is 0, the cache is disabled.\n  const response = cache.response.get();\n  if (response && cacheTime > 0) {\n    const age = new Date().getTime() - response.created.getTime();\n    if (age < cacheTime) return response.data;\n  }\n  let promise = cache.promise.get();\n  if (!promise) {\n    promise = fn();\n    // Store the promise in the cache so that subsequent invocations\n    // will wait for the same promise to resolve (deduping).\n    cache.promise.set(promise);\n  }\n  try {\n    const data = await promise;\n    // Store the response in the cache so that subsequent invocations\n    // will return the same response.\n    cache.response.set({\n      created: new Date(),\n      data\n    });\n    return data;\n  } finally {\n    // Clear the promise cache so that subsequent invocations will\n    // invoke the promise again.\n    cache.promise.clear();\n  }\n}\n//# sourceMappingURL=withCache.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}