{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FountainDecoderPart = void 0;\nconst utils_1 = require(\"./utils\");\nconst fountainUtils_1 = require(\"./fountainUtils\");\nconst errors_1 = require(\"./errors\");\nclass FountainDecoderPart {\n  constructor(_indexes, _fragment) {\n    this._indexes = _indexes;\n    this._fragment = _fragment;\n  }\n  get indexes() {\n    return this._indexes;\n  }\n  get fragment() {\n    return this._fragment;\n  }\n  static fromEncoderPart(encoderPart) {\n    const indexes = fountainUtils_1.chooseFragments(encoderPart.seqNum, encoderPart.seqLength, encoderPart.checksum);\n    const fragment = encoderPart.fragment;\n    return new FountainDecoderPart(indexes, fragment);\n  }\n  isSimple() {\n    return this.indexes.length === 1;\n  }\n}\nexports.FountainDecoderPart = FountainDecoderPart;\nclass FountainDecoder {\n  constructor() {\n    this.result = undefined;\n    this.expectedMessageLength = 0;\n    this.expectedChecksum = 0;\n    this.expectedFragmentLength = 0;\n    this.processedPartsCount = 0;\n    this.expectedPartIndexes = [];\n    this.lastPartIndexes = [];\n    this.queuedParts = [];\n    this.receivedPartIndexes = [];\n    this.mixedParts = [];\n    this.simpleParts = [];\n  }\n  validatePart(part) {\n    // If this is the first part we've seen\n    if (this.expectedPartIndexes.length === 0) {\n      // Record the things that all the other parts we see will have to match to be valid.\n      [...new Array(part.seqLength)].forEach((_, index) => this.expectedPartIndexes.push(index));\n      this.expectedMessageLength = part.messageLength;\n      this.expectedChecksum = part.checksum;\n      this.expectedFragmentLength = part.fragment.length;\n    } else {\n      // If this part's values don't match the first part's values, throw away the part\n      if (this.expectedPartIndexes.length !== part.seqLength) {\n        return false;\n      }\n      if (this.expectedMessageLength !== part.messageLength) {\n        return false;\n      }\n      if (this.expectedChecksum !== part.checksum) {\n        return false;\n      }\n      if (this.expectedFragmentLength !== part.fragment.length) {\n        return false;\n      }\n    }\n    // This part should be processed\n    return true;\n  }\n  reducePartByPart(a, b) {\n    // If the fragments mixed into `b` are a strict (proper) subset of those in `a`...\n    if (utils_1.arrayContains(a.indexes, b.indexes)) {\n      const newIndexes = utils_1.setDifference(a.indexes, b.indexes);\n      const newFragment = utils_1.bufferXOR(a.fragment, b.fragment);\n      return new FountainDecoderPart(newIndexes, newFragment);\n    } else {\n      // `a` is not reducable by `b`, so return a\n      return a;\n    }\n  }\n  reduceMixedBy(part) {\n    const newMixed = [];\n    this.mixedParts.map(({\n      value: mixedPart\n    }) => this.reducePartByPart(mixedPart, part)).forEach(reducedPart => {\n      if (reducedPart.isSimple()) {\n        this.queuedParts.push(reducedPart);\n      } else {\n        newMixed.push({\n          key: reducedPart.indexes,\n          value: reducedPart\n        });\n      }\n    });\n    this.mixedParts = newMixed;\n  }\n  processSimplePart(part) {\n    // Don't process duplicate parts\n    const fragmentIndex = part.indexes[0];\n    if (this.receivedPartIndexes.includes(fragmentIndex)) {\n      return;\n    }\n    this.simpleParts.push({\n      key: part.indexes,\n      value: part\n    });\n    this.receivedPartIndexes.push(fragmentIndex);\n    // If we've received all the parts\n    if (utils_1.arraysEqual(this.receivedPartIndexes, this.expectedPartIndexes)) {\n      // Reassemble the message from its fragments\n      const sortedParts = this.simpleParts.map(({\n        value\n      }) => value).sort((a, b) => a.indexes[0] - b.indexes[0]);\n      const message = FountainDecoder.joinFragments(sortedParts.map(part => part.fragment), this.expectedMessageLength);\n      const checksum = utils_1.getCRC(message);\n      if (checksum === this.expectedChecksum) {\n        this.result = message;\n      } else {\n        this.error = new errors_1.InvalidChecksumError();\n      }\n    } else {\n      this.reduceMixedBy(part);\n    }\n  }\n  processMixedPart(part) {\n    // Don't process duplicate parts\n    if (this.mixedParts.some(({\n      key: indexes\n    }) => utils_1.arraysEqual(indexes, part.indexes))) {\n      return;\n    }\n    // Reduce this part by all the others\n    let p2 = this.simpleParts.reduce((acc, {\n      value: p\n    }) => this.reducePartByPart(acc, p), part);\n    p2 = this.mixedParts.reduce((acc, {\n      value: p\n    }) => this.reducePartByPart(acc, p), p2);\n    // If the part is now simple\n    if (p2.isSimple()) {\n      // Add it to the queue\n      this.queuedParts.push(p2);\n    } else {\n      this.reduceMixedBy(p2);\n      this.mixedParts.push({\n        key: p2.indexes,\n        value: p2\n      });\n    }\n  }\n  processQueuedItem() {\n    if (this.queuedParts.length === 0) {\n      return;\n    }\n    const part = this.queuedParts.shift();\n    if (part.isSimple()) {\n      this.processSimplePart(part);\n    } else {\n      this.processMixedPart(part);\n    }\n  }\n  receivePart(encoderPart) {\n    if (this.isComplete()) {\n      return false;\n    }\n    if (!this.validatePart(encoderPart)) {\n      return false;\n    }\n    const decoderPart = FountainDecoderPart.fromEncoderPart(encoderPart);\n    this.lastPartIndexes = decoderPart.indexes;\n    this.queuedParts.push(decoderPart);\n    while (!this.isComplete() && this.queuedParts.length > 0) {\n      this.processQueuedItem();\n    }\n    ;\n    this.processedPartsCount += 1;\n    return true;\n  }\n  isComplete() {\n    return Boolean(this.result !== undefined && this.result.length > 0);\n  }\n  isSuccess() {\n    return Boolean(this.error === undefined && this.isComplete());\n  }\n  resultMessage() {\n    return this.isSuccess() ? this.result : Buffer.from([]);\n  }\n  isFailure() {\n    return this.error !== undefined;\n  }\n  resultError() {\n    return this.error ? this.error.message : '';\n  }\n  expectedPartCount() {\n    return this.expectedPartIndexes.length;\n  }\n  getExpectedPartIndexes() {\n    return [...this.expectedPartIndexes];\n  }\n  getReceivedPartIndexes() {\n    return [...this.receivedPartIndexes];\n  }\n  getLastPartIndexes() {\n    return [...this.lastPartIndexes];\n  }\n  estimatedPercentComplete() {\n    if (this.isComplete()) {\n      return 1;\n    }\n    const expectedPartCount = this.expectedPartCount();\n    if (expectedPartCount === 0) {\n      return 0;\n    }\n    // We multiply the expectedPartCount by `1.75` as a way to compensate for the facet\n    // that `this.processedPartsCount` also tracks the duplicate parts that have been\n    // processeed.\n    return Math.min(0.99, this.processedPartsCount / (expectedPartCount * 1.75));\n  }\n  getProgress() {\n    if (this.isComplete()) {\n      return 1;\n    }\n    const expectedPartCount = this.expectedPartCount();\n    if (expectedPartCount === 0) {\n      return 0;\n    }\n    return this.receivedPartIndexes.length / expectedPartCount;\n  }\n}\nexports.default = FountainDecoder;\nFountainDecoder.joinFragments = (fragments, messageLength) => {\n  return Buffer.concat(fragments).slice(0, messageLength);\n};","map":{"version":3,"names":["utils_1","require","fountainUtils_1","errors_1","FountainDecoderPart","constructor","_indexes","_fragment","indexes","fragment","fromEncoderPart","encoderPart","chooseFragments","seqNum","seqLength","checksum","isSimple","length","exports","FountainDecoder","result","undefined","expectedMessageLength","expectedChecksum","expectedFragmentLength","processedPartsCount","expectedPartIndexes","lastPartIndexes","queuedParts","receivedPartIndexes","mixedParts","simpleParts","validatePart","part","Array","forEach","_","index","push","messageLength","reducePartByPart","a","b","arrayContains","newIndexes","setDifference","newFragment","bufferXOR","reduceMixedBy","newMixed","map","value","mixedPart","reducedPart","key","processSimplePart","fragmentIndex","includes","arraysEqual","sortedParts","sort","message","joinFragments","getCRC","error","InvalidChecksumError","processMixedPart","some","p2","reduce","acc","p","processQueuedItem","shift","receivePart","isComplete","decoderPart","Boolean","isSuccess","resultMessage","Buffer","from","isFailure","resultError","expectedPartCount","getExpectedPartIndexes","getReceivedPartIndexes","getLastPartIndexes","estimatedPercentComplete","Math","min","getProgress","default","fragments","concat","slice"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@ngraveio\\bc-ur\\src\\fountainDecoder.ts"],"sourcesContent":["import { arrayContains, arraysEqual, bufferXOR, getCRC, setDifference, split } from \"./utils\";\nimport { chooseFragments } from \"./fountainUtils\";\nimport { FountainEncoderPart } from \"./fountainEncoder\";\nimport { InvalidChecksumError } from \"./errors\";\n\nexport class FountainDecoderPart {\n  constructor(\n    private _indexes: number[],\n    private _fragment: Buffer\n  ) { }\n\n  get indexes() { return this._indexes; }\n  get fragment() { return this._fragment; }\n\n  public static fromEncoderPart(encoderPart: FountainEncoderPart) {\n    const indexes = chooseFragments(encoderPart.seqNum, encoderPart.seqLength, encoderPart.checksum);\n    const fragment = encoderPart.fragment;\n\n    return new FountainDecoderPart(indexes, fragment);\n  }\n\n  public isSimple() {\n    return this.indexes.length === 1;\n  }\n}\n\ntype PartIndexes = number[];\ninterface PartDict {\n  key: PartIndexes;\n  value: FountainDecoderPart;\n}\n\nexport default class FountainDecoder {\n  private error: Error | undefined;\n  private result: Buffer | undefined = undefined;\n  private expectedMessageLength: number = 0;\n  private expectedChecksum: number = 0;\n  private expectedFragmentLength: number = 0;\n  private processedPartsCount: number = 0;\n  private expectedPartIndexes: PartIndexes = [];\n  private lastPartIndexes: PartIndexes = [];\n  private queuedParts: FountainDecoderPart[] = [];\n  private receivedPartIndexes: PartIndexes = [];\n  private mixedParts: PartDict[] = [];\n  private simpleParts: PartDict[] = [];\n\n\n  private validatePart(part: FountainEncoderPart) {\n    // If this is the first part we've seen\n    if (this.expectedPartIndexes.length === 0) {\n      // Record the things that all the other parts we see will have to match to be valid.\n      [...new Array(part.seqLength)]\n        .forEach((_, index) => this.expectedPartIndexes.push(index));\n\n      this.expectedMessageLength = part.messageLength;\n      this.expectedChecksum = part.checksum;\n      this.expectedFragmentLength = part.fragment.length;\n    }\n    else {\n      // If this part's values don't match the first part's values, throw away the part\n      if (this.expectedPartIndexes.length !== part.seqLength) {\n        return false;\n      }\n      if (this.expectedMessageLength !== part.messageLength) {\n        return false;\n      }\n      if (this.expectedChecksum !== part.checksum) {\n        return false;\n      }\n      if (this.expectedFragmentLength !== part.fragment.length) {\n        return false;\n      }\n    }\n\n    // This part should be processed\n    return true;\n  }\n\n  private reducePartByPart(a: FountainDecoderPart, b: FountainDecoderPart): FountainDecoderPart {\n    // If the fragments mixed into `b` are a strict (proper) subset of those in `a`...\n    if (arrayContains(a.indexes, b.indexes)) {\n      const newIndexes = setDifference(a.indexes, b.indexes);\n      const newFragment = bufferXOR(a.fragment, b.fragment);\n\n      return new FountainDecoderPart(newIndexes, newFragment);\n    } else {\n      // `a` is not reducable by `b`, so return a\n      return a;\n    }\n  }\n\n  private reduceMixedBy(part: FountainDecoderPart): void {\n    const newMixed: PartDict[] = [];\n\n    this.mixedParts\n      .map(({ value: mixedPart }) => this.reducePartByPart(mixedPart, part))\n      .forEach(reducedPart => {\n        if (reducedPart.isSimple()) {\n          this.queuedParts.push(reducedPart)\n        } else {\n          newMixed.push({ key: reducedPart.indexes, value: reducedPart })\n        }\n      })\n\n    this.mixedParts = newMixed;\n  }\n\n  private processSimplePart(part: FountainDecoderPart): void {\n    // Don't process duplicate parts\n    const fragmentIndex = part.indexes[0]\n\n    if (this.receivedPartIndexes.includes(fragmentIndex)) {\n      return;\n    }\n\n    this.simpleParts.push({ key: part.indexes, value: part });\n    this.receivedPartIndexes.push(fragmentIndex);\n\n    // If we've received all the parts\n    if (arraysEqual(this.receivedPartIndexes, this.expectedPartIndexes)) {\n      // Reassemble the message from its fragments\n      const sortedParts = this.simpleParts\n        .map(({ value }) => value)\n        .sort((a, b) => (a.indexes[0] - b.indexes[0]))\n      const message = FountainDecoder.joinFragments(sortedParts.map(part => part.fragment), this.expectedMessageLength)\n      const checksum = getCRC(message);\n\n      if (checksum === this.expectedChecksum) {\n        this.result = message;\n      } else {\n        this.error = new InvalidChecksumError();\n      }\n    }\n    else {\n      this.reduceMixedBy(part);\n    }\n  }\n\n  private processMixedPart(part: FountainDecoderPart): void {\n    // Don't process duplicate parts\n    if (this.mixedParts.some(({ key: indexes }) => arraysEqual(indexes, part.indexes))) {\n      return;\n    }\n\n    // Reduce this part by all the others\n    let p2 = this.simpleParts.reduce((acc, { value: p }) => this.reducePartByPart(acc, p), part)\n    p2 = this.mixedParts.reduce((acc, { value: p }) => this.reducePartByPart(acc, p), p2)\n\n    // If the part is now simple\n    if (p2.isSimple()) {\n      // Add it to the queue\n      this.queuedParts.push(p2);\n    } else {\n      this.reduceMixedBy(p2);\n\n      this.mixedParts.push({ key: p2.indexes, value: p2 });\n    }\n  }\n\n  private processQueuedItem(): void {\n    if (this.queuedParts.length === 0) {\n      return;\n    }\n\n    const part = this.queuedParts.shift()!;\n\n    if (part.isSimple()) {\n      this.processSimplePart(part);\n    } else {\n      this.processMixedPart(part);\n    }\n  }\n\n  public static joinFragments = (fragments: Buffer[], messageLength: number) => {\n    return Buffer.concat(fragments).slice(0, messageLength)\n  }\n\n  public receivePart(encoderPart: FountainEncoderPart): boolean {\n    if (this.isComplete()) {\n      return false;\n    }\n\n    if (!this.validatePart(encoderPart)) {\n      return false;\n    }\n\n    const decoderPart = FountainDecoderPart.fromEncoderPart(encoderPart);\n\n    this.lastPartIndexes = decoderPart.indexes;\n    this.queuedParts.push(decoderPart);\n\n    while (!this.isComplete() && this.queuedParts.length > 0) {\n      this.processQueuedItem();\n    };\n\n    this.processedPartsCount += 1;\n\n    return true;\n  }\n\n  public isComplete() {\n    return Boolean(this.result !== undefined && this.result.length > 0);\n  }\n\n  public isSuccess() {\n    return Boolean(this.error === undefined && this.isComplete());\n  }\n\n  public resultMessage(): Buffer {\n    return this.isSuccess() ? this.result! : Buffer.from([]);\n  }\n\n  public isFailure() {\n    return this.error !== undefined;\n  }\n\n  public resultError() {\n    return this.error ? this.error.message : '';\n  }\n\n  public expectedPartCount(): number {\n    return this.expectedPartIndexes.length;\n  }\n\n  public getExpectedPartIndexes(): PartIndexes {\n    return [...this.expectedPartIndexes]\n  }\n\n  public getReceivedPartIndexes(): PartIndexes {\n    return [...this.receivedPartIndexes]\n  }\n\n  public getLastPartIndexes(): PartIndexes {\n    return [...this.lastPartIndexes]\n  }\n\n  public estimatedPercentComplete(): number {\n    if (this.isComplete()) {\n      return 1;\n    }\n\n    const expectedPartCount = this.expectedPartCount();\n\n    if (expectedPartCount === 0) {\n      return 0;\n    }\n\n    // We multiply the expectedPartCount by `1.75` as a way to compensate for the facet\n    // that `this.processedPartsCount` also tracks the duplicate parts that have been\n    // processeed.\n    return Math.min(0.99, this.processedPartsCount / (expectedPartCount * 1.75));\n  }\n\n  public getProgress(): number {\n    if (this.isComplete()) {\n      return 1;\n    }\n\n    const expectedPartCount = this.expectedPartCount();\n\n    if (expectedPartCount === 0) {\n      return 0;\n    }\n\n    return this.receivedPartIndexes.length / expectedPartCount;\n  }\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}