{"ast":null,"code":"import { generateAddress, generateAddress2, isValidAddress, privateToAddress, pubToAddress } from './account.js';\nimport { bigIntToBytes, bytesToBigInt, bytesToHex, equalsBytes, hexToBytes, zeros } from './bytes.js';\nimport { BIGINT_0 } from './constants.js';\n/**\n * Handling and generating Ethereum addresses\n */\nexport class Address {\n  constructor(bytes) {\n    if (bytes.length !== 20) {\n      throw new Error('Invalid address length');\n    }\n    this.bytes = bytes;\n  }\n  /**\n   * Returns the zero address.\n   */\n  static zero() {\n    return new Address(zeros(20));\n  }\n  /**\n   * Returns an Address object from a hex-encoded string.\n   * @param str - Hex-encoded address\n   */\n  static fromString(str) {\n    if (!isValidAddress(str)) {\n      throw new Error(`Invalid address input=${str}`);\n    }\n    return new Address(hexToBytes(str));\n  }\n  /**\n   * Returns an address for a given public key.\n   * @param pubKey The two points of an uncompressed key\n   */\n  static fromPublicKey(pubKey) {\n    if (!(pubKey instanceof Uint8Array)) {\n      throw new Error('Public key should be Uint8Array');\n    }\n    const bytes = pubToAddress(pubKey);\n    return new Address(bytes);\n  }\n  /**\n   * Returns an address for a given private key.\n   * @param privateKey A private key must be 256 bits wide\n   */\n  static fromPrivateKey(privateKey) {\n    if (!(privateKey instanceof Uint8Array)) {\n      throw new Error('Private key should be Uint8Array');\n    }\n    const bytes = privateToAddress(privateKey);\n    return new Address(bytes);\n  }\n  /**\n   * Generates an address for a newly created contract.\n   * @param from The address which is creating this new address\n   * @param nonce The nonce of the from account\n   */\n  static generate(from, nonce) {\n    if (typeof nonce !== 'bigint') {\n      throw new Error('Expected nonce to be a bigint');\n    }\n    return new Address(generateAddress(from.bytes, bigIntToBytes(nonce)));\n  }\n  /**\n   * Generates an address for a contract created using CREATE2.\n   * @param from The address which is creating this new address\n   * @param salt A salt\n   * @param initCode The init code of the contract being created\n   */\n  static generate2(from, salt, initCode) {\n    if (!(salt instanceof Uint8Array)) {\n      throw new Error('Expected salt to be a Uint8Array');\n    }\n    if (!(initCode instanceof Uint8Array)) {\n      throw new Error('Expected initCode to be a Uint8Array');\n    }\n    return new Address(generateAddress2(from.bytes, salt, initCode));\n  }\n  /**\n   * Is address equal to another.\n   */\n  equals(address) {\n    return equalsBytes(this.bytes, address.bytes);\n  }\n  /**\n   * Is address zero.\n   */\n  isZero() {\n    return this.equals(Address.zero());\n  }\n  /**\n   * True if address is in the address range defined\n   * by EIP-1352\n   */\n  isPrecompileOrSystemAddress() {\n    const address = bytesToBigInt(this.bytes);\n    const rangeMin = BIGINT_0;\n    const rangeMax = BigInt('0xffff');\n    return address >= rangeMin && address <= rangeMax;\n  }\n  /**\n   * Returns hex encoding of address.\n   */\n  toString() {\n    return bytesToHex(this.bytes);\n  }\n  /**\n   * Returns a new Uint8Array representation of address.\n   */\n  toBytes() {\n    return new Uint8Array(this.bytes);\n  }\n}","map":{"version":3,"names":["generateAddress","generateAddress2","isValidAddress","privateToAddress","pubToAddress","bigIntToBytes","bytesToBigInt","bytesToHex","equalsBytes","hexToBytes","zeros","BIGINT_0","Address","constructor","bytes","length","Error","zero","fromString","str","fromPublicKey","pubKey","Uint8Array","fromPrivateKey","privateKey","generate","from","nonce","generate2","salt","initCode","equals","address","isZero","isPrecompileOrSystemAddress","rangeMin","rangeMax","BigInt","toString","toBytes"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@ethereumjs\\util\\src\\address.ts"],"sourcesContent":["import {\n  generateAddress,\n  generateAddress2,\n  isValidAddress,\n  privateToAddress,\n  pubToAddress,\n} from './account.js'\nimport {\n  bigIntToBytes,\n  bytesToBigInt,\n  bytesToHex,\n  equalsBytes,\n  hexToBytes,\n  zeros,\n} from './bytes.js'\nimport { BIGINT_0 } from './constants.js'\n\nimport type { PrefixedHexString } from './types.js'\n\n/**\n * Handling and generating Ethereum addresses\n */\nexport class Address {\n  public readonly bytes: Uint8Array\n\n  constructor(bytes: Uint8Array) {\n    if (bytes.length !== 20) {\n      throw new Error('Invalid address length')\n    }\n    this.bytes = bytes\n  }\n\n  /**\n   * Returns the zero address.\n   */\n  static zero(): Address {\n    return new Address(zeros(20))\n  }\n\n  /**\n   * Returns an Address object from a hex-encoded string.\n   * @param str - Hex-encoded address\n   */\n  static fromString(str: string): Address {\n    if (!isValidAddress(str)) {\n      throw new Error(`Invalid address input=${str}`)\n    }\n    return new Address(hexToBytes(str))\n  }\n\n  /**\n   * Returns an address for a given public key.\n   * @param pubKey The two points of an uncompressed key\n   */\n  static fromPublicKey(pubKey: Uint8Array): Address {\n    if (!(pubKey instanceof Uint8Array)) {\n      throw new Error('Public key should be Uint8Array')\n    }\n    const bytes = pubToAddress(pubKey)\n    return new Address(bytes)\n  }\n\n  /**\n   * Returns an address for a given private key.\n   * @param privateKey A private key must be 256 bits wide\n   */\n  static fromPrivateKey(privateKey: Uint8Array): Address {\n    if (!(privateKey instanceof Uint8Array)) {\n      throw new Error('Private key should be Uint8Array')\n    }\n    const bytes = privateToAddress(privateKey)\n    return new Address(bytes)\n  }\n\n  /**\n   * Generates an address for a newly created contract.\n   * @param from The address which is creating this new address\n   * @param nonce The nonce of the from account\n   */\n  static generate(from: Address, nonce: bigint): Address {\n    if (typeof nonce !== 'bigint') {\n      throw new Error('Expected nonce to be a bigint')\n    }\n    return new Address(generateAddress(from.bytes, bigIntToBytes(nonce)))\n  }\n\n  /**\n   * Generates an address for a contract created using CREATE2.\n   * @param from The address which is creating this new address\n   * @param salt A salt\n   * @param initCode The init code of the contract being created\n   */\n  static generate2(from: Address, salt: Uint8Array, initCode: Uint8Array): Address {\n    if (!(salt instanceof Uint8Array)) {\n      throw new Error('Expected salt to be a Uint8Array')\n    }\n    if (!(initCode instanceof Uint8Array)) {\n      throw new Error('Expected initCode to be a Uint8Array')\n    }\n    return new Address(generateAddress2(from.bytes, salt, initCode))\n  }\n\n  /**\n   * Is address equal to another.\n   */\n  equals(address: Address): boolean {\n    return equalsBytes(this.bytes, address.bytes)\n  }\n\n  /**\n   * Is address zero.\n   */\n  isZero(): boolean {\n    return this.equals(Address.zero())\n  }\n\n  /**\n   * True if address is in the address range defined\n   * by EIP-1352\n   */\n  isPrecompileOrSystemAddress(): boolean {\n    const address = bytesToBigInt(this.bytes)\n    const rangeMin = BIGINT_0\n    const rangeMax = BigInt('0xffff')\n    return address >= rangeMin && address <= rangeMax\n  }\n\n  /**\n   * Returns hex encoding of address.\n   */\n  toString(): PrefixedHexString {\n    return bytesToHex(this.bytes)\n  }\n\n  /**\n   * Returns a new Uint8Array representation of address.\n   */\n  toBytes(): Uint8Array {\n    return new Uint8Array(this.bytes)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}