{"ast":null,"code":"/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */;\n'use strict';\nconst bufferModule = require('buffer');\nconst {\n  isReadable,\n  isWritable,\n  isIterable,\n  isNodeStream,\n  isReadableNodeStream,\n  isWritableNodeStream,\n  isDuplexNodeStream,\n  isReadableStream,\n  isWritableStream\n} = require('./utils');\nconst eos = require('./end-of-stream');\nconst {\n  AbortError,\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_RETURN_VALUE\n  }\n} = require('../../ours/errors');\nconst {\n  destroyer\n} = require('./destroy');\nconst Duplex = require('./duplex');\nconst Readable = require('./readable');\nconst Writable = require('./writable');\nconst {\n  createDeferredPromise\n} = require('../../ours/util');\nconst from = require('./from');\nconst Blob = globalThis.Blob || bufferModule.Blob;\nconst isBlob = typeof Blob !== 'undefined' ? function isBlob(b) {\n  return b instanceof Blob;\n} : function isBlob(b) {\n  return false;\n};\nconst AbortController = globalThis.AbortController || require('abort-controller').AbortController;\nconst {\n  FunctionPrototypeCall\n} = require('../../ours/primordials');\n\n// This is needed for pre node 17.\nclass Duplexify extends Duplex {\n  constructor(options) {\n    super(options);\n\n    // https://github.com/nodejs/node/pull/34385\n\n    if ((options === null || options === undefined ? undefined : options.readable) === false) {\n      this._readableState.readable = false;\n      this._readableState.ended = true;\n      this._readableState.endEmitted = true;\n    }\n    if ((options === null || options === undefined ? undefined : options.writable) === false) {\n      this._writableState.writable = false;\n      this._writableState.ending = true;\n      this._writableState.ended = true;\n      this._writableState.finished = true;\n    }\n  }\n}\nmodule.exports = function duplexify(body, name) {\n  if (isDuplexNodeStream(body)) {\n    return body;\n  }\n  if (isReadableNodeStream(body)) {\n    return _duplexify({\n      readable: body\n    });\n  }\n  if (isWritableNodeStream(body)) {\n    return _duplexify({\n      writable: body\n    });\n  }\n  if (isNodeStream(body)) {\n    return _duplexify({\n      writable: false,\n      readable: false\n    });\n  }\n  if (isReadableStream(body)) {\n    return _duplexify({\n      readable: Readable.fromWeb(body)\n    });\n  }\n  if (isWritableStream(body)) {\n    return _duplexify({\n      writable: Writable.fromWeb(body)\n    });\n  }\n  if (typeof body === 'function') {\n    const {\n      value,\n      write,\n      final,\n      destroy\n    } = fromAsyncGen(body);\n    if (isIterable(value)) {\n      return from(Duplexify, value, {\n        // TODO (ronag): highWaterMark?\n        objectMode: true,\n        write,\n        final,\n        destroy\n      });\n    }\n    const then = value === null || value === undefined ? undefined : value.then;\n    if (typeof then === 'function') {\n      let d;\n      const promise = FunctionPrototypeCall(then, value, val => {\n        if (val != null) {\n          throw new ERR_INVALID_RETURN_VALUE('nully', 'body', val);\n        }\n      }, err => {\n        destroyer(d, err);\n      });\n      return d = new Duplexify({\n        // TODO (ronag): highWaterMark?\n        objectMode: true,\n        readable: false,\n        write,\n        final(cb) {\n          final(async () => {\n            try {\n              await promise;\n              process.nextTick(cb, null);\n            } catch (err) {\n              process.nextTick(cb, err);\n            }\n          });\n        },\n        destroy\n      });\n    }\n    throw new ERR_INVALID_RETURN_VALUE('Iterable, AsyncIterable or AsyncFunction', name, value);\n  }\n  if (isBlob(body)) {\n    return duplexify(body.arrayBuffer());\n  }\n  if (isIterable(body)) {\n    return from(Duplexify, body, {\n      // TODO (ronag): highWaterMark?\n      objectMode: true,\n      writable: false\n    });\n  }\n  if (isReadableStream(body === null || body === undefined ? undefined : body.readable) && isWritableStream(body === null || body === undefined ? undefined : body.writable)) {\n    return Duplexify.fromWeb(body);\n  }\n  if (typeof (body === null || body === undefined ? undefined : body.writable) === 'object' || typeof (body === null || body === undefined ? undefined : body.readable) === 'object') {\n    const readable = body !== null && body !== undefined && body.readable ? isReadableNodeStream(body === null || body === undefined ? undefined : body.readable) ? body === null || body === undefined ? undefined : body.readable : duplexify(body.readable) : undefined;\n    const writable = body !== null && body !== undefined && body.writable ? isWritableNodeStream(body === null || body === undefined ? undefined : body.writable) ? body === null || body === undefined ? undefined : body.writable : duplexify(body.writable) : undefined;\n    return _duplexify({\n      readable,\n      writable\n    });\n  }\n  const then = body === null || body === undefined ? undefined : body.then;\n  if (typeof then === 'function') {\n    let d;\n    FunctionPrototypeCall(then, body, val => {\n      if (val != null) {\n        d.push(val);\n      }\n      d.push(null);\n    }, err => {\n      destroyer(d, err);\n    });\n    return d = new Duplexify({\n      objectMode: true,\n      writable: false,\n      read() {}\n    });\n  }\n  throw new ERR_INVALID_ARG_TYPE(name, ['Blob', 'ReadableStream', 'WritableStream', 'Stream', 'Iterable', 'AsyncIterable', 'Function', '{ readable, writable } pair', 'Promise'], body);\n};\nfunction fromAsyncGen(fn) {\n  let {\n    promise,\n    resolve\n  } = createDeferredPromise();\n  const ac = new AbortController();\n  const signal = ac.signal;\n  const value = fn(async function* () {\n    while (true) {\n      const _promise = promise;\n      promise = null;\n      const {\n        chunk,\n        done,\n        cb\n      } = await _promise;\n      process.nextTick(cb);\n      if (done) return;\n      if (signal.aborted) throw new AbortError(undefined, {\n        cause: signal.reason\n      });\n      ({\n        promise,\n        resolve\n      } = createDeferredPromise());\n      yield chunk;\n    }\n  }(), {\n    signal\n  });\n  return {\n    value,\n    write(chunk, encoding, cb) {\n      const _resolve = resolve;\n      resolve = null;\n      _resolve({\n        chunk,\n        done: false,\n        cb\n      });\n    },\n    final(cb) {\n      const _resolve = resolve;\n      resolve = null;\n      _resolve({\n        done: true,\n        cb\n      });\n    },\n    destroy(err, cb) {\n      ac.abort();\n      cb(err);\n    }\n  };\n}\nfunction _duplexify(pair) {\n  const r = pair.readable && typeof pair.readable.read !== 'function' ? Readable.wrap(pair.readable) : pair.readable;\n  const w = pair.writable;\n  let readable = !!isReadable(r);\n  let writable = !!isWritable(w);\n  let ondrain;\n  let onfinish;\n  let onreadable;\n  let onclose;\n  let d;\n  function onfinished(err) {\n    const cb = onclose;\n    onclose = null;\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      d.destroy(err);\n    }\n  }\n\n  // TODO(ronag): Avoid double buffering.\n  // Implement Writable/Readable/Duplex traits.\n  // See, https://github.com/nodejs/node/pull/33515.\n  d = new Duplexify({\n    // TODO (ronag): highWaterMark?\n    readableObjectMode: !!(r !== null && r !== undefined && r.readableObjectMode),\n    writableObjectMode: !!(w !== null && w !== undefined && w.writableObjectMode),\n    readable,\n    writable\n  });\n  if (writable) {\n    eos(w, err => {\n      writable = false;\n      if (err) {\n        destroyer(r, err);\n      }\n      onfinished(err);\n    });\n    d._write = function (chunk, encoding, callback) {\n      if (w.write(chunk, encoding)) {\n        callback();\n      } else {\n        ondrain = callback;\n      }\n    };\n    d._final = function (callback) {\n      w.end();\n      onfinish = callback;\n    };\n    w.on('drain', function () {\n      if (ondrain) {\n        const cb = ondrain;\n        ondrain = null;\n        cb();\n      }\n    });\n    w.on('finish', function () {\n      if (onfinish) {\n        const cb = onfinish;\n        onfinish = null;\n        cb();\n      }\n    });\n  }\n  if (readable) {\n    eos(r, err => {\n      readable = false;\n      if (err) {\n        destroyer(r, err);\n      }\n      onfinished(err);\n    });\n    r.on('readable', function () {\n      if (onreadable) {\n        const cb = onreadable;\n        onreadable = null;\n        cb();\n      }\n    });\n    r.on('end', function () {\n      d.push(null);\n    });\n    d._read = function () {\n      while (true) {\n        const buf = r.read();\n        if (buf === null) {\n          onreadable = d._read;\n          return;\n        }\n        if (!d.push(buf)) {\n          return;\n        }\n      }\n    };\n  }\n  d._destroy = function (err, callback) {\n    if (!err && onclose !== null) {\n      err = new AbortError();\n    }\n    onreadable = null;\n    ondrain = null;\n    onfinish = null;\n    if (onclose === null) {\n      callback(err);\n    } else {\n      onclose = callback;\n      destroyer(w, err);\n      destroyer(r, err);\n    }\n  };\n  return d;\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}