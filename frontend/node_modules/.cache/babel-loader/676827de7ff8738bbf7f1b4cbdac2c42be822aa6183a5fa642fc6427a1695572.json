{"ast":null,"code":"import { getAction } from '../utils/getAction.js';\nimport { createContractEventFilter } from './public/createContractEventFilter.js';\nimport { estimateContractGas } from './public/estimateContractGas.js';\nimport { getContractEvents } from './public/getContractEvents.js';\nimport { readContract } from './public/readContract.js';\nimport { simulateContract } from './public/simulateContract.js';\nimport { watchContractEvent } from './public/watchContractEvent.js';\nimport { writeContract } from './wallet/writeContract.js';\n/**\n * Gets type-safe interface for performing contract-related actions with a specific `abi` and `address`.\n *\n * - Docs https://viem.sh/docs/contract/getContract\n *\n * Using Contract Instances can make it easier to work with contracts if you don't want to pass the `abi` and `address` properties every time you perform contract actions, e.g. [`readContract`](https://viem.sh/docs/contract/readContract), [`writeContract`](https://viem.sh/docs/contract/writeContract), [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas), etc.\n *\n * @example\n * import { createPublicClient, getContract, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const publicClient = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const contract = getContract({\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi([\n *     'function balanceOf(address owner) view returns (uint256)',\n *     'function ownerOf(uint256 tokenId) view returns (address)',\n *     'function totalSupply() view returns (uint256)',\n *   ]),\n *   client: publicClient,\n * })\n */\nexport function getContract({\n  abi,\n  address,\n  client: client_\n}) {\n  const client = client_;\n  const [publicClient, walletClient] = (() => {\n    if (!client) return [undefined, undefined];\n    if ('public' in client && 'wallet' in client) return [client.public, client.wallet];\n    if ('public' in client) return [client.public, undefined];\n    if ('wallet' in client) return [undefined, client.wallet];\n    return [client, client];\n  })();\n  const hasPublicClient = publicClient !== undefined && publicClient !== null;\n  const hasWalletClient = walletClient !== undefined && walletClient !== null;\n  const contract = {};\n  let hasReadFunction = false;\n  let hasWriteFunction = false;\n  let hasEvent = false;\n  for (const item of abi) {\n    if (item.type === 'function') {\n      if (item.stateMutability === 'view' || item.stateMutability === 'pure') hasReadFunction = true;else hasWriteFunction = true;\n    } else if (item.type === 'event') hasEvent = true;\n    // Exit early if all flags are `true`\n    if (hasReadFunction && hasWriteFunction && hasEvent) break;\n  }\n  if (hasPublicClient) {\n    if (hasReadFunction) contract.read = new Proxy({}, {\n      get(_, functionName) {\n        return (...parameters) => {\n          const {\n            args,\n            options\n          } = getFunctionParameters(parameters);\n          return getAction(publicClient, readContract, 'readContract')({\n            abi,\n            address,\n            functionName,\n            args,\n            ...options\n          });\n        };\n      }\n    });\n    if (hasWriteFunction) contract.simulate = new Proxy({}, {\n      get(_, functionName) {\n        return (...parameters) => {\n          const {\n            args,\n            options\n          } = getFunctionParameters(parameters);\n          return getAction(publicClient, simulateContract, 'simulateContract')({\n            abi,\n            address,\n            functionName,\n            args,\n            ...options\n          });\n        };\n      }\n    });\n    if (hasEvent) {\n      contract.createEventFilter = new Proxy({}, {\n        get(_, eventName) {\n          return (...parameters) => {\n            const abiEvent = abi.find(x => x.type === 'event' && x.name === eventName);\n            const {\n              args,\n              options\n            } = getEventParameters(parameters, abiEvent);\n            return getAction(publicClient, createContractEventFilter, 'createContractEventFilter')({\n              abi,\n              address,\n              eventName,\n              args,\n              ...options\n            });\n          };\n        }\n      });\n      contract.getEvents = new Proxy({}, {\n        get(_, eventName) {\n          return (...parameters) => {\n            const abiEvent = abi.find(x => x.type === 'event' && x.name === eventName);\n            const {\n              args,\n              options\n            } = getEventParameters(parameters, abiEvent);\n            return getAction(publicClient, getContractEvents, 'getContractEvents')({\n              abi,\n              address,\n              eventName,\n              args,\n              ...options\n            });\n          };\n        }\n      });\n      contract.watchEvent = new Proxy({}, {\n        get(_, eventName) {\n          return (...parameters) => {\n            const abiEvent = abi.find(x => x.type === 'event' && x.name === eventName);\n            const {\n              args,\n              options\n            } = getEventParameters(parameters, abiEvent);\n            return getAction(publicClient, watchContractEvent, 'watchContractEvent')({\n              abi,\n              address,\n              eventName,\n              args,\n              ...options\n            });\n          };\n        }\n      });\n    }\n  }\n  if (hasWalletClient) {\n    if (hasWriteFunction) contract.write = new Proxy({}, {\n      get(_, functionName) {\n        return (...parameters) => {\n          const {\n            args,\n            options\n          } = getFunctionParameters(parameters);\n          return getAction(walletClient, writeContract, 'writeContract')({\n            abi,\n            address,\n            functionName,\n            args,\n            ...options\n          });\n        };\n      }\n    });\n  }\n  if (hasPublicClient || hasWalletClient) if (hasWriteFunction) contract.estimateGas = new Proxy({}, {\n    get(_, functionName) {\n      return (...parameters) => {\n        const {\n          args,\n          options\n        } = getFunctionParameters(parameters);\n        const client = publicClient ?? walletClient;\n        return getAction(client, estimateContractGas, 'estimateContractGas')({\n          abi,\n          address,\n          functionName,\n          args,\n          ...options,\n          account: options.account ?? walletClient.account\n        });\n      };\n    }\n  });\n  contract.address = address;\n  contract.abi = abi;\n  return contract;\n}\n/**\n * @internal exporting for testing only\n */\nexport function getFunctionParameters(values) {\n  const hasArgs = values.length && Array.isArray(values[0]);\n  const args = hasArgs ? values[0] : [];\n  const options = (hasArgs ? values[1] : values[0]) ?? {};\n  return {\n    args,\n    options\n  };\n}\n/**\n * @internal exporting for testing only\n */\nexport function getEventParameters(values, abiEvent) {\n  let hasArgs = false;\n  // If first item is array, must be `args`\n  if (Array.isArray(values[0])) hasArgs = true;\n  // Check if first item is `args` or `options`\n  else if (values.length === 1) {\n    // if event has indexed inputs, must have `args`\n    hasArgs = abiEvent.inputs.some(x => x.indexed);\n    // If there are two items in array, must have `args`\n  } else if (values.length === 2) {\n    hasArgs = true;\n  }\n  const args = hasArgs ? values[0] : undefined;\n  const options = (hasArgs ? values[1] : values[0]) ?? {};\n  return {\n    args,\n    options\n  };\n}\n//# sourceMappingURL=getContract.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}