{"ast":null,"code":"import { proxy, subscribe as sub } from 'valtio/vanilla';\nimport { proxyMap, subscribeKey as subKey } from 'valtio/vanilla/utils';\nimport { ConstantsUtil as CommonConstantsUtil, NetworkUtil } from '@reown/appkit-common';\nimport { getChainsToDisconnect } from '../utils/ChainControllerUtil.js';\nimport { ConstantsUtil } from '../utils/ConstantsUtil.js';\nimport { CoreHelperUtil } from '../utils/CoreHelperUtil.js';\nimport { StorageUtil } from '../utils/StorageUtil.js';\nimport { AccountController } from './AccountController.js';\nimport { ConnectionController } from './ConnectionController.js';\nimport { ConnectorController } from './ConnectorController.js';\nimport { EventsController } from './EventsController.js';\nimport { ModalController } from './ModalController.js';\nimport { OptionsController } from './OptionsController.js';\nimport { PublicStateController } from './PublicStateController.js';\nimport { RouterController } from './RouterController.js';\nimport { SendController } from './SendController.js';\n// -- Constants ----------------------------------------- //\nconst accountState = {\n  currentTab: 0,\n  tokenBalance: [],\n  smartAccountDeployed: false,\n  addressLabels: new Map(),\n  allAccounts: [],\n  user: undefined\n};\nconst networkState = {\n  caipNetwork: undefined,\n  supportsAllNetworks: true,\n  smartAccountEnabledNetworks: []\n};\n// -- State --------------------------------------------- //\nconst state = proxy({\n  chains: proxyMap(),\n  activeCaipAddress: undefined,\n  activeChain: undefined,\n  activeCaipNetwork: undefined,\n  noAdapters: false,\n  universalAdapter: {\n    networkControllerClient: undefined,\n    connectionControllerClient: undefined\n  },\n  isSwitchingNamespace: false\n});\n// -- Controller ---------------------------------------- //\nexport const ChainController = {\n  state,\n  subscribe(callback) {\n    return sub(state, () => {\n      callback(state);\n    });\n  },\n  subscribeKey(key, callback) {\n    return subKey(state, key, callback);\n  },\n  subscribeChainProp(property, callback, chain) {\n    let prev = undefined;\n    return sub(state.chains, () => {\n      const activeChain = chain || state.activeChain;\n      if (activeChain) {\n        const nextValue = state.chains.get(activeChain)?.[property];\n        if (prev !== nextValue) {\n          prev = nextValue;\n          callback(nextValue);\n        }\n      }\n    });\n  },\n  initialize(adapters, caipNetworks, clients) {\n    const {\n      chainId: activeChainId,\n      namespace: activeNamespace\n    } = StorageUtil.getActiveNetworkProps();\n    const activeCaipNetwork = caipNetworks?.find(network => network.id.toString() === activeChainId?.toString());\n    const defaultAdapter = adapters.find(adapter => adapter?.namespace === activeNamespace);\n    const adapterToActivate = defaultAdapter || adapters?.[0];\n    const namespaces = new Set([...(caipNetworks?.map(network => network.chainNamespace) ?? [])]);\n    if (adapters?.length === 0 || !adapterToActivate) {\n      state.noAdapters = true;\n    }\n    if (!state.noAdapters) {\n      state.activeChain = adapterToActivate?.namespace;\n      state.activeCaipNetwork = activeCaipNetwork;\n      this.setChainNetworkData(adapterToActivate?.namespace, {\n        caipNetwork: activeCaipNetwork\n      });\n      if (state.activeChain) {\n        PublicStateController.set({\n          activeChain: adapterToActivate?.namespace\n        });\n      }\n    }\n    namespaces.forEach(namespace => {\n      const namespaceNetworks = caipNetworks?.filter(network => network.chainNamespace === namespace);\n      ChainController.state.chains.set(namespace, {\n        namespace,\n        networkState: proxy({\n          ...networkState,\n          caipNetwork: namespaceNetworks?.[0]\n        }),\n        accountState: proxy(accountState),\n        caipNetworks: namespaceNetworks ?? [],\n        ...clients\n      });\n      this.setRequestedCaipNetworks(namespaceNetworks ?? [], namespace);\n    });\n  },\n  removeAdapter(namespace) {\n    if (state.activeChain === namespace) {\n      const nextAdapter = Array.from(state.chains.entries()).find(([chainNamespace]) => chainNamespace !== namespace);\n      if (nextAdapter) {\n        const caipNetwork = nextAdapter[1]?.caipNetworks?.[0];\n        if (caipNetwork) {\n          this.setActiveCaipNetwork(caipNetwork);\n        }\n      }\n    }\n    state.chains.delete(namespace);\n  },\n  addAdapter(adapter, {\n    networkControllerClient,\n    connectionControllerClient\n  }, caipNetworks) {\n    state.chains.set(adapter.namespace, {\n      namespace: adapter.namespace,\n      networkState: {\n        ...networkState,\n        caipNetwork: caipNetworks[0]\n      },\n      accountState,\n      caipNetworks,\n      connectionControllerClient,\n      networkControllerClient\n    });\n    this.setRequestedCaipNetworks(caipNetworks?.filter(caipNetwork => caipNetwork.chainNamespace === adapter.namespace) ?? [], adapter.namespace);\n  },\n  addNetwork(network) {\n    const chainAdapter = state.chains.get(network.chainNamespace);\n    if (chainAdapter) {\n      const newNetworks = [...(chainAdapter.caipNetworks || [])];\n      if (!chainAdapter.caipNetworks?.find(caipNetwork => caipNetwork.id === network.id)) {\n        newNetworks.push(network);\n      }\n      state.chains.set(network.chainNamespace, {\n        ...chainAdapter,\n        caipNetworks: newNetworks\n      });\n      this.setRequestedCaipNetworks(newNetworks, network.chainNamespace);\n    }\n  },\n  removeNetwork(namespace, networkId) {\n    const chainAdapter = state.chains.get(namespace);\n    if (chainAdapter) {\n      // Check if network being removed is active network\n      const isActiveNetwork = state.activeCaipNetwork?.id === networkId;\n      // Filter out the network being removed\n      const newCaipNetworksOfAdapter = [...(chainAdapter.caipNetworks?.filter(network => network.id !== networkId) || [])];\n      // If active network was removed and there are other networks available, switch to first one\n      if (isActiveNetwork && chainAdapter?.caipNetworks?.[0]) {\n        this.setActiveCaipNetwork(chainAdapter.caipNetworks[0]);\n      }\n      state.chains.set(namespace, {\n        ...chainAdapter,\n        caipNetworks: newCaipNetworksOfAdapter\n      });\n      this.setRequestedCaipNetworks(newCaipNetworksOfAdapter || [], namespace);\n    }\n  },\n  setAdapterNetworkState(chain, props) {\n    const chainAdapter = state.chains.get(chain);\n    if (chainAdapter) {\n      chainAdapter.networkState = {\n        ...(chainAdapter.networkState || networkState),\n        ...props\n      };\n      state.chains.set(chain, chainAdapter);\n    }\n  },\n  setChainAccountData(chain, accountProps, _unknown = true) {\n    if (!chain) {\n      throw new Error('Chain is required to update chain account data');\n    }\n    const chainAdapter = state.chains.get(chain);\n    if (chainAdapter) {\n      const newAccountState = {\n        ...(chainAdapter.accountState || accountState),\n        ...accountProps\n      };\n      state.chains.set(chain, {\n        ...chainAdapter,\n        accountState: newAccountState\n      });\n      if (state.chains.size === 1 || state.activeChain === chain) {\n        if (accountProps.caipAddress) {\n          state.activeCaipAddress = accountProps.caipAddress;\n        }\n        AccountController.replaceState(newAccountState);\n      }\n    }\n  },\n  setChainNetworkData(chain, networkProps) {\n    if (!chain) {\n      return;\n    }\n    const chainAdapter = state.chains.get(chain);\n    if (chainAdapter) {\n      const newNetworkState = {\n        ...(chainAdapter.networkState || networkState),\n        ...networkProps\n      };\n      state.chains.set(chain, {\n        ...chainAdapter,\n        networkState: newNetworkState\n      });\n    }\n  },\n  // eslint-disable-next-line max-params\n  setAccountProp(prop, value, chain, replaceState = true) {\n    this.setChainAccountData(chain, {\n      [prop]: value\n    }, replaceState);\n    if (prop === 'status' && value === 'disconnected' && chain) {\n      ConnectorController.removeConnectorId(chain);\n    }\n  },\n  setActiveNamespace(chain) {\n    state.activeChain = chain;\n    const newAdapter = chain ? state.chains.get(chain) : undefined;\n    const caipNetwork = newAdapter?.networkState?.caipNetwork;\n    if (caipNetwork?.id && chain) {\n      state.activeCaipAddress = newAdapter?.accountState?.caipAddress;\n      state.activeCaipNetwork = caipNetwork;\n      this.setChainNetworkData(chain, {\n        caipNetwork\n      });\n      StorageUtil.setActiveCaipNetworkId(caipNetwork?.caipNetworkId);\n      PublicStateController.set({\n        activeChain: chain,\n        selectedNetworkId: caipNetwork?.caipNetworkId\n      });\n    }\n  },\n  setActiveCaipNetwork(caipNetwork) {\n    if (!caipNetwork) {\n      return;\n    }\n    if (state.activeChain !== caipNetwork.chainNamespace) {\n      this.setIsSwitchingNamespace(true);\n    }\n    const newAdapter = state.chains.get(caipNetwork.chainNamespace);\n    state.activeChain = caipNetwork.chainNamespace;\n    state.activeCaipNetwork = caipNetwork;\n    this.setChainNetworkData(caipNetwork.chainNamespace, {\n      caipNetwork\n    });\n    if (newAdapter?.accountState?.address) {\n      state.activeCaipAddress = `${caipNetwork.chainNamespace}:${caipNetwork.id}:${newAdapter?.accountState?.address}`;\n    } else {\n      state.activeCaipAddress = undefined;\n    }\n    // Update the chain's account state with the new caip address value\n    this.setAccountProp('caipAddress', state.activeCaipAddress, caipNetwork.chainNamespace);\n    if (newAdapter) {\n      AccountController.replaceState(newAdapter.accountState);\n    }\n    // Reset send state when switching networks\n    SendController.resetSend();\n    PublicStateController.set({\n      activeChain: state.activeChain,\n      selectedNetworkId: state.activeCaipNetwork?.caipNetworkId\n    });\n    StorageUtil.setActiveCaipNetworkId(caipNetwork.caipNetworkId);\n    const isSupported = this.checkIfSupportedNetwork(caipNetwork.chainNamespace);\n    if (!isSupported && OptionsController.state.enableNetworkSwitch && !OptionsController.state.allowUnsupportedChain && !ConnectionController.state.wcBasic) {\n      this.showUnsupportedChainUI();\n    }\n  },\n  addCaipNetwork(caipNetwork) {\n    if (!caipNetwork) {\n      return;\n    }\n    const chain = state.chains.get(caipNetwork.chainNamespace);\n    if (chain) {\n      chain?.caipNetworks?.push(caipNetwork);\n    }\n  },\n  async switchActiveNamespace(namespace) {\n    if (!namespace) {\n      return;\n    }\n    const isDifferentChain = namespace !== ChainController.state.activeChain;\n    const caipNetworkOfNamespace = ChainController.getNetworkData(namespace)?.caipNetwork;\n    const firstNetworkWithChain = ChainController.getCaipNetworkByNamespace(namespace, caipNetworkOfNamespace?.id);\n    if (isDifferentChain && firstNetworkWithChain) {\n      await ChainController.switchActiveNetwork(firstNetworkWithChain);\n    }\n  },\n  async switchActiveNetwork(network) {\n    const activeAdapter = ChainController.state.chains.get(ChainController.state.activeChain);\n    const unsupportedNetwork = !activeAdapter?.caipNetworks?.some(caipNetwork => caipNetwork.id === state.activeCaipNetwork?.id);\n    if (unsupportedNetwork) {\n      RouterController.goBack();\n    }\n    const networkControllerClient = this.getNetworkControllerClient(network.chainNamespace);\n    if (networkControllerClient) {\n      await networkControllerClient.switchCaipNetwork(network);\n      EventsController.sendEvent({\n        type: 'track',\n        event: 'SWITCH_NETWORK',\n        properties: {\n          network: network.caipNetworkId\n        }\n      });\n    }\n  },\n  getNetworkControllerClient(chainNamespace) {\n    const chain = chainNamespace || state.activeChain;\n    const chainAdapter = state.chains.get(chain);\n    if (!chainAdapter) {\n      throw new Error('Chain adapter not found');\n    }\n    if (!chainAdapter.networkControllerClient) {\n      throw new Error('NetworkController client not set');\n    }\n    return chainAdapter.networkControllerClient;\n  },\n  getConnectionControllerClient(_chain) {\n    const chain = _chain || state.activeChain;\n    if (!chain) {\n      throw new Error('Chain is required to get connection controller client');\n    }\n    const chainAdapter = state.chains.get(chain);\n    if (!chainAdapter?.connectionControllerClient) {\n      throw new Error('ConnectionController client not set');\n    }\n    return chainAdapter.connectionControllerClient;\n  },\n  getAccountProp(key, _chain) {\n    let chain = state.activeChain;\n    if (_chain) {\n      chain = _chain;\n    }\n    if (!chain) {\n      return undefined;\n    }\n    const chainAccountState = state.chains.get(chain)?.accountState;\n    if (!chainAccountState) {\n      return undefined;\n    }\n    return chainAccountState[key];\n  },\n  getNetworkProp(key, namespace) {\n    const chainNetworkState = state.chains.get(namespace)?.networkState;\n    if (!chainNetworkState) {\n      return undefined;\n    }\n    return chainNetworkState[key];\n  },\n  getRequestedCaipNetworks(chainToFilter) {\n    const adapter = state.chains.get(chainToFilter);\n    const {\n      approvedCaipNetworkIds = [],\n      requestedCaipNetworks = []\n    } = adapter?.networkState || {};\n    const sortedNetworks = CoreHelperUtil.sortRequestedNetworks(approvedCaipNetworkIds, requestedCaipNetworks);\n    return sortedNetworks;\n  },\n  getAllRequestedCaipNetworks() {\n    const requestedCaipNetworks = [];\n    state.chains.forEach(chainAdapter => {\n      const caipNetworks = this.getRequestedCaipNetworks(chainAdapter.namespace);\n      requestedCaipNetworks.push(...caipNetworks);\n    });\n    return requestedCaipNetworks;\n  },\n  setRequestedCaipNetworks(requestedCaipNetworks, chain) {\n    this.setAdapterNetworkState(chain, {\n      requestedCaipNetworks\n    });\n  },\n  getAllApprovedCaipNetworkIds() {\n    const approvedCaipNetworkIds = [];\n    state.chains.forEach(chainAdapter => {\n      const approvedIds = this.getApprovedCaipNetworkIds(chainAdapter.namespace);\n      approvedCaipNetworkIds.push(...approvedIds);\n    });\n    return approvedCaipNetworkIds;\n  },\n  getActiveCaipNetwork() {\n    return state.activeCaipNetwork;\n  },\n  getActiveCaipAddress() {\n    return state.activeCaipAddress;\n  },\n  getApprovedCaipNetworkIds(namespace) {\n    const adapter = state.chains.get(namespace);\n    const approvedCaipNetworkIds = adapter?.networkState?.approvedCaipNetworkIds || [];\n    return approvedCaipNetworkIds;\n  },\n  async setApprovedCaipNetworksData(namespace) {\n    const networkControllerClient = this.getNetworkControllerClient();\n    const data = await networkControllerClient?.getApprovedCaipNetworksData();\n    this.setAdapterNetworkState(namespace, {\n      approvedCaipNetworkIds: data?.approvedCaipNetworkIds,\n      supportsAllNetworks: data?.supportsAllNetworks\n    });\n  },\n  checkIfSupportedNetwork(namespace, caipNetwork) {\n    const activeCaipNetwork = caipNetwork || state.activeCaipNetwork;\n    const requestedCaipNetworks = this.getRequestedCaipNetworks(namespace);\n    if (!requestedCaipNetworks.length) {\n      return true;\n    }\n    return requestedCaipNetworks?.some(network => network.id === activeCaipNetwork?.id);\n  },\n  checkIfSupportedChainId(chainId) {\n    if (!state.activeChain) {\n      return true;\n    }\n    const requestedCaipNetworks = this.getRequestedCaipNetworks(state.activeChain);\n    return requestedCaipNetworks?.some(network => network.id === chainId);\n  },\n  // Smart Account Network Handlers\n  setSmartAccountEnabledNetworks(smartAccountEnabledNetworks, chain) {\n    this.setAdapterNetworkState(chain, {\n      smartAccountEnabledNetworks\n    });\n  },\n  checkIfSmartAccountEnabled() {\n    const networkId = NetworkUtil.caipNetworkIdToNumber(state.activeCaipNetwork?.caipNetworkId);\n    const activeChain = state.activeChain;\n    if (!activeChain || !networkId) {\n      return false;\n    }\n    const smartAccountEnabledNetworks = this.getNetworkProp('smartAccountEnabledNetworks', activeChain);\n    return Boolean(smartAccountEnabledNetworks?.includes(Number(networkId)));\n  },\n  getActiveNetworkTokenAddress() {\n    const namespace = state.activeCaipNetwork?.chainNamespace || 'eip155';\n    const chainId = state.activeCaipNetwork?.id || 1;\n    const address = ConstantsUtil.NATIVE_TOKEN_ADDRESS[namespace];\n    return `${namespace}:${chainId}:${address}`;\n  },\n  showUnsupportedChainUI() {\n    ModalController.open({\n      view: 'UnsupportedChain'\n    });\n  },\n  checkIfNamesSupported() {\n    const activeCaipNetwork = state.activeCaipNetwork;\n    return Boolean(activeCaipNetwork?.chainNamespace && ConstantsUtil.NAMES_SUPPORTED_CHAIN_NAMESPACES.includes(activeCaipNetwork.chainNamespace));\n  },\n  resetNetwork(namespace) {\n    this.setAdapterNetworkState(namespace, {\n      approvedCaipNetworkIds: undefined,\n      supportsAllNetworks: true,\n      smartAccountEnabledNetworks: []\n    });\n  },\n  resetAccount(chain) {\n    const chainToWrite = chain;\n    if (!chainToWrite) {\n      throw new Error('Chain is required to set account prop');\n    }\n    state.activeCaipAddress = undefined;\n    this.setChainAccountData(chainToWrite, {\n      smartAccountDeployed: false,\n      currentTab: 0,\n      caipAddress: undefined,\n      address: undefined,\n      balance: undefined,\n      balanceSymbol: undefined,\n      profileName: undefined,\n      profileImage: undefined,\n      addressExplorerUrl: undefined,\n      tokenBalance: [],\n      connectedWalletInfo: undefined,\n      preferredAccountType: undefined,\n      socialProvider: undefined,\n      socialWindow: undefined,\n      farcasterUrl: undefined,\n      allAccounts: [],\n      user: undefined,\n      status: 'disconnected'\n    });\n    ConnectorController.removeConnectorId(chainToWrite);\n  },\n  async disconnect(namespace) {\n    const chainsToDisconnect = getChainsToDisconnect(namespace);\n    try {\n      // Reset send state when disconnecting\n      SendController.resetSend();\n      const disconnectResults = await Promise.allSettled(chainsToDisconnect.map(async ([ns, adapter]) => {\n        try {\n          const {\n            caipAddress\n          } = this.getAccountData(ns) || {};\n          if (caipAddress && adapter.connectionControllerClient?.disconnect) {\n            await adapter.connectionControllerClient.disconnect(ns);\n          }\n          this.resetAccount(ns);\n          this.resetNetwork(ns);\n        } catch (error) {\n          throw new Error(`Failed to disconnect chain ${ns}: ${error.message}`);\n        }\n      }));\n      ConnectionController.resetWcConnection();\n      const failures = disconnectResults.filter(result => result.status === 'rejected');\n      if (failures.length > 0) {\n        throw new Error(failures.map(f => f.reason.message).join(', '));\n      }\n      StorageUtil.deleteConnectedSocialProvider();\n      if (namespace) {\n        ConnectorController.removeConnectorId(namespace);\n      } else {\n        ConnectorController.resetConnectorIds();\n      }\n      EventsController.sendEvent({\n        type: 'track',\n        event: 'DISCONNECT_SUCCESS',\n        properties: {\n          namespace: namespace || 'all'\n        }\n      });\n    } catch (error) {\n      // eslint-disable-next-line no-console\n      console.error(error.message || 'Failed to disconnect chains');\n      EventsController.sendEvent({\n        type: 'track',\n        event: 'DISCONNECT_ERROR',\n        properties: {\n          message: error.message || 'Failed to disconnect chains'\n        }\n      });\n    }\n  },\n  setIsSwitchingNamespace(isSwitchingNamespace) {\n    state.isSwitchingNamespace = isSwitchingNamespace;\n  },\n  getFirstCaipNetworkSupportsAuthConnector() {\n    const availableChains = [];\n    let firstCaipNetwork = undefined;\n    state.chains.forEach(chain => {\n      if (CommonConstantsUtil.AUTH_CONNECTOR_SUPPORTED_CHAINS.find(ns => ns === chain.namespace)) {\n        if (chain.namespace) {\n          availableChains.push(chain.namespace);\n        }\n      }\n    });\n    if (availableChains.length > 0) {\n      const firstAvailableChain = availableChains[0];\n      firstCaipNetwork = firstAvailableChain ? state.chains.get(firstAvailableChain)?.caipNetworks?.[0] : undefined;\n      return firstCaipNetwork;\n    }\n    return undefined;\n  },\n  getAccountData(chainNamespace) {\n    if (!chainNamespace) {\n      return AccountController.state;\n    }\n    return ChainController.state.chains.get(chainNamespace)?.accountState;\n  },\n  getNetworkData(chainNamespace) {\n    const namespace = chainNamespace || state.activeChain;\n    if (!namespace) {\n      return undefined;\n    }\n    return ChainController.state.chains.get(namespace)?.networkState;\n  },\n  getCaipNetworkByNamespace(chainNamespace, chainId) {\n    if (!chainNamespace) {\n      return undefined;\n    }\n    const chain = ChainController.state.chains.get(chainNamespace);\n    const byChainId = chain?.caipNetworks?.find(network => network.id === chainId);\n    if (byChainId) {\n      return byChainId;\n    }\n    return chain?.networkState?.caipNetwork || chain?.caipNetworks?.[0];\n  },\n  /**\n   * Get the requested CaipNetwork IDs for a given namespace. If namespace is not provided, all requested CaipNetwork IDs will be returned\n   * @param namespace - The namespace to get the requested CaipNetwork IDs for\n   * @returns The requested CaipNetwork IDs\n   */\n  getRequestedCaipNetworkIds() {\n    const namespace = ConnectorController.state.filterByNamespace;\n    const chains = namespace ? [state.chains.get(namespace)] : Array.from(state.chains.values());\n    return chains.flatMap(chain => chain?.caipNetworks || []).map(caipNetwork => caipNetwork.caipNetworkId);\n  }\n};\n//# sourceMappingURL=ChainController.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}