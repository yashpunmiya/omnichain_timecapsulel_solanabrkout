{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IntersectEvaluated = IntersectEvaluated;\nconst index_1 = require(\"../symbols/index\");\nconst type_1 = require(\"../create/type\");\nconst index_2 = require(\"../discard/index\");\nconst index_3 = require(\"../never/index\");\nconst index_4 = require(\"../optional/index\");\nconst intersect_create_1 = require(\"./intersect-create\");\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nconst kind_1 = require(\"../guard/kind\");\n// prettier-ignore\nfunction IsIntersectOptional(T) {\n  return T.every(L => (0, kind_1.IsOptional)(L));\n}\n// prettier-ignore\nfunction RemoveOptionalFromType(T) {\n  return (0, index_2.Discard)(T, [index_1.OptionalKind]);\n}\n// prettier-ignore\nfunction RemoveOptionalFromRest(T) {\n  return T.map(L => (0, kind_1.IsOptional)(L) ? RemoveOptionalFromType(L) : L);\n}\n// prettier-ignore\nfunction ResolveIntersect(T, options) {\n  return IsIntersectOptional(T) ? (0, index_4.Optional)((0, intersect_create_1.IntersectCreate)(RemoveOptionalFromRest(T), options)) : (0, intersect_create_1.IntersectCreate)(RemoveOptionalFromRest(T), options);\n}\n/** `[Json]` Creates an evaluated Intersect type */\nfunction IntersectEvaluated(T, options = {}) {\n  if (T.length === 0) return (0, index_3.Never)(options);\n  if (T.length === 1) return (0, type_1.CreateType)(T[0], options);\n  if (T.some(schema => (0, kind_1.IsTransform)(schema))) throw new Error('Cannot intersect transform types');\n  return ResolveIntersect(T, options);\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}