{"ast":null,"code":"import { SolanaSignAndSendTransaction, SolanaSignTransaction, SolanaSignMessage, SolanaSignIn } from '@solana/wallet-standard-features';\nimport { VersionedTransaction, PublicKey } from '@solana/web3.js';\nimport QRCode from 'qrcode';\nimport { StandardConnect, StandardDisconnect, StandardEvents } from '@wallet-standard/features';\nimport { SOLANA_MAINNET_CHAIN } from '@solana/wallet-standard-chains';\nimport { transact, startRemoteScenario } from '@solana-mobile/mobile-wallet-adapter-protocol-web3js';\nimport base58 from 'bs58';\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\nfunction __classPrivateFieldGet$1(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\nfunction __classPrivateFieldSet$1(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n}\nvar _EmbeddedModal_instances, _EmbeddedModal_root, _EmbeddedModal_eventListeners, _EmbeddedModal_listenersAttached, _EmbeddedModal_injectHTML, _EmbeddedModal_attachEventListeners, _EmbeddedModal_removeEventListeners, _EmbeddedModal_handleKeyDown;\nconst modalHtml = `\n<div class=\"mobile-wallet-adapter-embedded-modal-container\" role=\"dialog\" aria-modal=\"true\" aria-labelledby=\"modal-title\">\n    <div data-modal-close style=\"position: absolute; width: 100%; height: 100%;\"></div>\n\t<div class=\"mobile-wallet-adapter-embedded-modal-card\">\n\t\t<div>\n\t\t\t<button data-modal-close class=\"mobile-wallet-adapter-embedded-modal-close\">\n\t\t\t\t<svg width=\"14\" height=\"14\">\n\t\t\t\t\t<path d=\"M 6.7125,8.3036995 1.9082,13.108199 c -0.2113,0.2112 -0.4765,0.3168 -0.7957,0.3168 -0.3192,0 -0.5844,-0.1056 -0.7958,-0.3168 C 0.1056,12.896899 0,12.631699 0,12.312499 c 0,-0.3192 0.1056,-0.5844 0.3167,-0.7958 L 5.1212,6.7124995 0.3167,1.9082 C 0.1056,1.6969 0,1.4317 0,1.1125 0,0.7933 0.1056,0.5281 0.3167,0.3167 0.5281,0.1056 0.7933,0 1.1125,0 1.4317,0 1.6969,0.1056 1.9082,0.3167 L 6.7125,5.1212 11.5167,0.3167 C 11.7281,0.1056 11.9933,0 12.3125,0 c 0.3192,0 0.5844,0.1056 0.7957,0.3167 0.2112,0.2114 0.3168,0.4766 0.3168,0.7958 0,0.3192 -0.1056,0.5844 -0.3168,0.7957 L 8.3037001,6.7124995 13.1082,11.516699 c 0.2112,0.2114 0.3168,0.4766 0.3168,0.7958 0,0.3192 -0.1056,0.5844 -0.3168,0.7957 -0.2113,0.2112 -0.4765,0.3168 -0.7957,0.3168 -0.3192,0 -0.5844,-0.1056 -0.7958,-0.3168 z\" />\n\t\t\t\t</svg>\n\t\t\t</button>\n\t\t</div>\n\t\t<div class=\"mobile-wallet-adapter-embedded-modal-content\"></div>\n\t</div>\n</div>\n`;\nconst css$2 = `\n.mobile-wallet-adapter-embedded-modal-container {\n    display: flex; /* Use flexbox to center content */\n    justify-content: center; /* Center horizontally */\n    align-items: center; /* Center vertically */\n    position: fixed; /* Stay in place */\n    z-index: 1; /* Sit on top */\n    left: 0;\n    top: 0;\n    width: 100%; /* Full width */\n    height: 100%; /* Full height */\n    background-color: rgba(0,0,0,0.4); /* Black w/ opacity */\n    overflow-y: auto; /* enable scrolling */\n}\n\n.mobile-wallet-adapter-embedded-modal-card {\n    display: flex;\n    flex-direction: column;\n    margin: auto 20px;\n    max-width: 780px;\n    padding: 20px;\n    border-radius: 24px;\n    background: #ffffff;\n    font-family: \"Inter Tight\", \"PT Sans\", Calibri, sans-serif;\n    transform: translateY(-200%);\n    animation: slide-in 0.5s forwards;\n}\n\n@keyframes slide-in {\n    100% { transform: translateY(0%); }\n}\n\n.mobile-wallet-adapter-embedded-modal-close {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    width: 32px;\n    height: 32px;\n    cursor: pointer;\n    background: #e4e9e9;\n    border: none;\n    border-radius: 50%;\n}\n\n.mobile-wallet-adapter-embedded-modal-close:focus-visible {\n    outline-color: red;\n}\n\n.mobile-wallet-adapter-embedded-modal-close svg {\n    fill: #546266;\n    transition: fill 200ms ease 0s;\n}\n\n.mobile-wallet-adapter-embedded-modal-close:hover svg {\n    fill: #fff;\n}\n`;\nconst fonts = `\n<link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\n<link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\n<link href=\"https://fonts.googleapis.com/css2?family=Inter+Tight:ital,wght@0,100..900;1,100..900&display=swap\" rel=\"stylesheet\">\n`;\nclass EmbeddedModal {\n  constructor() {\n    _EmbeddedModal_instances.add(this);\n    _EmbeddedModal_root.set(this, null);\n    _EmbeddedModal_eventListeners.set(this, {});\n    _EmbeddedModal_listenersAttached.set(this, false);\n    this.dom = null;\n    this.open = () => {\n      console.debug('Modal open');\n      __classPrivateFieldGet$1(this, _EmbeddedModal_instances, \"m\", _EmbeddedModal_attachEventListeners).call(this);\n      if (__classPrivateFieldGet$1(this, _EmbeddedModal_root, \"f\")) {\n        __classPrivateFieldGet$1(this, _EmbeddedModal_root, \"f\").style.display = 'flex';\n      }\n    };\n    this.close = (event = undefined) => {\n      var _a;\n      console.debug('Modal close');\n      __classPrivateFieldGet$1(this, _EmbeddedModal_instances, \"m\", _EmbeddedModal_removeEventListeners).call(this);\n      if (__classPrivateFieldGet$1(this, _EmbeddedModal_root, \"f\")) {\n        __classPrivateFieldGet$1(this, _EmbeddedModal_root, \"f\").style.display = 'none';\n      }\n      (_a = __classPrivateFieldGet$1(this, _EmbeddedModal_eventListeners, \"f\")['close']) === null || _a === void 0 ? void 0 : _a.forEach(listener => listener(event));\n    };\n    _EmbeddedModal_handleKeyDown.set(this, event => {\n      if (event.key === 'Escape') this.close(event);\n    });\n    // Bind methods to ensure `this` context is correct\n    this.init = this.init.bind(this);\n    __classPrivateFieldSet$1(this, _EmbeddedModal_root, document.getElementById('mobile-wallet-adapter-embedded-root-ui'), \"f\");\n  }\n  init() {\n    return __awaiter(this, void 0, void 0, function* () {\n      console.log('Injecting modal');\n      __classPrivateFieldGet$1(this, _EmbeddedModal_instances, \"m\", _EmbeddedModal_injectHTML).call(this);\n    });\n  }\n  addEventListener(event, listener) {\n    var _a;\n    ((_a = __classPrivateFieldGet$1(this, _EmbeddedModal_eventListeners, \"f\")[event]) === null || _a === void 0 ? void 0 : _a.push(listener)) || (__classPrivateFieldGet$1(this, _EmbeddedModal_eventListeners, \"f\")[event] = [listener]);\n    return () => this.removeEventListener(event, listener);\n  }\n  removeEventListener(event, listener) {\n    var _a;\n    __classPrivateFieldGet$1(this, _EmbeddedModal_eventListeners, \"f\")[event] = (_a = __classPrivateFieldGet$1(this, _EmbeddedModal_eventListeners, \"f\")[event]) === null || _a === void 0 ? void 0 : _a.filter(existingListener => listener !== existingListener);\n  }\n}\n_EmbeddedModal_root = new WeakMap(), _EmbeddedModal_eventListeners = new WeakMap(), _EmbeddedModal_listenersAttached = new WeakMap(), _EmbeddedModal_handleKeyDown = new WeakMap(), _EmbeddedModal_instances = new WeakSet(), _EmbeddedModal_injectHTML = function _EmbeddedModal_injectHTML() {\n  // Check if the HTML has already been injected\n  if (document.getElementById('mobile-wallet-adapter-embedded-root-ui')) {\n    if (!__classPrivateFieldGet$1(this, _EmbeddedModal_root, \"f\")) __classPrivateFieldSet$1(this, _EmbeddedModal_root, document.getElementById('mobile-wallet-adapter-embedded-root-ui'), \"f\");\n    return;\n  }\n  // Create a container for the modal\n  __classPrivateFieldSet$1(this, _EmbeddedModal_root, document.createElement('div'), \"f\");\n  __classPrivateFieldGet$1(this, _EmbeddedModal_root, \"f\").id = 'mobile-wallet-adapter-embedded-root-ui';\n  __classPrivateFieldGet$1(this, _EmbeddedModal_root, \"f\").innerHTML = modalHtml;\n  __classPrivateFieldGet$1(this, _EmbeddedModal_root, \"f\").style.display = 'none';\n  // Add modal content\n  const content = __classPrivateFieldGet$1(this, _EmbeddedModal_root, \"f\").querySelector('.mobile-wallet-adapter-embedded-modal-content');\n  if (content) content.innerHTML = this.contentHtml;\n  // Apply styles\n  const styles = document.createElement('style');\n  styles.id = 'mobile-wallet-adapter-embedded-modal-styles';\n  styles.textContent = css$2 + this.contentStyles;\n  // Create a shadow DOM to encapsulate the modal\n  const host = document.createElement('div');\n  host.innerHTML = fonts;\n  this.dom = host.attachShadow({\n    mode: 'closed'\n  });\n  this.dom.appendChild(styles);\n  this.dom.appendChild(__classPrivateFieldGet$1(this, _EmbeddedModal_root, \"f\"));\n  // Append the shadow DOM host to the body\n  document.body.appendChild(host);\n}, _EmbeddedModal_attachEventListeners = function _EmbeddedModal_attachEventListeners() {\n  if (!__classPrivateFieldGet$1(this, _EmbeddedModal_root, \"f\") || __classPrivateFieldGet$1(this, _EmbeddedModal_listenersAttached, \"f\")) return;\n  const closers = [...__classPrivateFieldGet$1(this, _EmbeddedModal_root, \"f\").querySelectorAll('[data-modal-close]')];\n  closers.forEach(closer => closer === null || closer === void 0 ? void 0 : closer.addEventListener('click', this.close));\n  window.addEventListener('load', this.close);\n  document.addEventListener('keydown', __classPrivateFieldGet$1(this, _EmbeddedModal_handleKeyDown, \"f\"));\n  __classPrivateFieldSet$1(this, _EmbeddedModal_listenersAttached, true, \"f\");\n}, _EmbeddedModal_removeEventListeners = function _EmbeddedModal_removeEventListeners() {\n  if (!__classPrivateFieldGet$1(this, _EmbeddedModal_listenersAttached, \"f\")) return;\n  window.removeEventListener('load', this.close);\n  document.removeEventListener('keydown', __classPrivateFieldGet$1(this, _EmbeddedModal_handleKeyDown, \"f\"));\n  if (!__classPrivateFieldGet$1(this, _EmbeddedModal_root, \"f\")) return;\n  const closers = [...__classPrivateFieldGet$1(this, _EmbeddedModal_root, \"f\").querySelectorAll('[data-modal-close]')];\n  closers.forEach(closer => closer === null || closer === void 0 ? void 0 : closer.removeEventListener('click', this.close));\n  __classPrivateFieldSet$1(this, _EmbeddedModal_listenersAttached, false, \"f\");\n};\nclass RemoteConnectionModal extends EmbeddedModal {\n  constructor() {\n    super(...arguments);\n    this.contentStyles = css$1;\n    this.contentHtml = QRCodeHtml;\n  }\n  initWithQR(qrCode) {\n    const _super = Object.create(null, {\n      init: {\n        get: () => super.init\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      _super.init.call(this);\n      this.populateQRCode(qrCode);\n    });\n  }\n  populateQRCode(qrUrl) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const qrcodeContainer = (_a = this.dom) === null || _a === void 0 ? void 0 : _a.getElementById('mobile-wallet-adapter-embedded-modal-qr-code-container');\n      if (qrcodeContainer) {\n        const qrCodeElement = yield QRCode.toCanvas(qrUrl, {\n          width: 200,\n          margin: 0\n        });\n        if (qrcodeContainer.firstElementChild !== null) {\n          qrcodeContainer.replaceChild(qrCodeElement, qrcodeContainer.firstElementChild);\n        } else qrcodeContainer.appendChild(qrCodeElement);\n      } else {\n        console.error('QRCode Container not found');\n      }\n    });\n  }\n}\nconst QRCodeHtml = `\n<div class=\"mobile-wallet-adapter-embedded-modal-qr-content\">\n    <div>\n        <svg class=\"mobile-wallet-adapter-embedded-modal-icon\" width=\"100%\" height=\"100%\">\n            <circle r=\"52\" cx=\"53\" cy=\"53\" fill=\"#99b3be\" stroke=\"#000000\" stroke-width=\"2\"/>\n            <path d=\"m 53,82.7305 c -3.3116,0 -6.1361,-1.169 -8.4735,-3.507 -2.338,-2.338 -3.507,-5.1625 -3.507,-8.4735 0,-3.3116 1.169,-6.1364 3.507,-8.4744 2.3374,-2.338 5.1619,-3.507 8.4735,-3.507 3.3116,0 6.1361,1.169 8.4735,3.507 2.338,2.338 3.507,5.1628 3.507,8.4744 0,3.311 -1.169,6.1355 -3.507,8.4735 -2.3374,2.338 -5.1619,3.507 -8.4735,3.507 z m 0.007,-5.25 c 1.8532,0 3.437,-0.6598 4.7512,-1.9793 1.3149,-1.3195 1.9723,-2.9058 1.9723,-4.7591 0,-1.8526 -0.6598,-3.4364 -1.9793,-4.7512 -1.3195,-1.3149 -2.9055,-1.9723 -4.7582,-1.9723 -1.8533,0 -3.437,0.6598 -4.7513,1.9793 -1.3148,1.3195 -1.9722,2.9058 -1.9722,4.7591 0,1.8527 0.6597,3.4364 1.9792,4.7512 1.3195,1.3149 2.9056,1.9723 4.7583,1.9723 z m -28,-33.5729 -3.85,-3.6347 c 4.1195,-4.025 8.8792,-7.1984 14.2791,-9.52 5.4005,-2.3223 11.2551,-3.4834 17.5639,-3.4834 6.3087,0 12.1634,1.1611 17.5639,3.4834 5.3999,2.3216 10.1596,5.495 14.2791,9.52 l -3.85,3.6347 C 77.2999,40.358 73.0684,37.5726 68.2985,35.5514 63.5292,33.5301 58.4296,32.5195 53,32.5195 c -5.4297,0 -10.5292,1.0106 -15.2985,3.0319 -4.7699,2.0212 -9.0014,4.8066 -12.6945,8.3562 z m 44.625,10.8771 c -2.2709,-2.1046 -4.7962,-3.7167 -7.5758,-4.8361 -2.7795,-1.12 -5.7983,-1.68 -9.0562,-1.68 -3.2579,0 -6.2621,0.56 -9.0125,1.68 -2.7504,1.1194 -5.2903,2.7315 -7.6195,4.8361 L 32.5189,51.15 c 2.8355,-2.6028 5.9777,-4.6086 9.4263,-6.0174 3.4481,-1.4087 7.133,-2.1131 11.0548,-2.1131 3.9217,0 7.5979,0.7044 11.0285,2.1131 3.43,1.4088 6.5631,3.4146 9.3992,6.0174 z\"/>\n        </svg>\n        <div class=\"mobile-wallet-adapter-embedded-modal-title\">Remote Mobile Wallet Adapter</div>\n    </div>\n    <div>\n        <div>\n            <h4 class=\"mobile-wallet-adapter-embedded-modal-qr-label\">\n                Open your wallet and scan this code\n            </h4>\n        </div>\n        <div id=\"mobile-wallet-adapter-embedded-modal-qr-code-container\" class=\"mobile-wallet-adapter-embedded-modal-qr-code-container\"></div>\n    </div>\n</div>\n<div class=\"mobile-wallet-adapter-embedded-modal-divider\"><hr></div>\n<div class=\"mobile-wallet-adapter-embedded-modal-footer\">\n    <div class=\"mobile-wallet-adapter-embedded-modal-subtitle\">\n        Follow the instructions on your device. When you're finished, this screen will update.\n    </div>\n    <div class=\"mobile-wallet-adapter-embedded-modal-progress-badge\">\n        <div>\n            <div class=\"spinner\">\n                <div class=\"leftWrapper\">\n                    <div class=\"left\">\n                        <div class=\"circle\"></div>\n                    </div>\n                </div>\n                <div class=\"rightWrapper\">\n                    <div class=\"right\">\n                        <div class=\"circle\"></div>\n                    </div>\n                </div>\n            </div>\n        </div>\n        <div>Waiting for scan</div>\n    </div>\n</div>\n`;\nconst css$1 = `\n.mobile-wallet-adapter-embedded-modal-qr-content {\n    display: flex; \n    margin-top: 10px;\n    padding: 10px;\n}\n\n.mobile-wallet-adapter-embedded-modal-qr-content > div:first-child {\n    display: flex;\n    flex-direction: column;\n    flex: 2;\n    margin-top: auto;\n    margin-right: 30px;\n}\n\n.mobile-wallet-adapter-embedded-modal-qr-content > div:nth-child(2) {\n    display: flex;\n    flex-direction: column;\n    flex: 1;\n    margin-left: auto;\n}\n\n.mobile-wallet-adapter-embedded-modal-footer {\n    display: flex;\n    padding: 10px;\n}\n\n.mobile-wallet-adapter-embedded-modal-icon {}\n\n.mobile-wallet-adapter-embedded-modal-title {\n    color: #000000;\n    font-size: 2.5em;\n    font-weight: 600;\n}\n\n.mobile-wallet-adapter-embedded-modal-qr-label {\n    text-align: right;\n    color: #000000;\n}\n\n.mobile-wallet-adapter-embedded-modal-qr-code-container {\n    margin-left: auto;\n}\n\n.mobile-wallet-adapter-embedded-modal-divider {\n    margin-top: 20px;\n    padding-left: 10px;\n    padding-right: 10px;\n}\n\n.mobile-wallet-adapter-embedded-modal-divider hr {\n    border-top: 1px solid #D9DEDE;\n}\n\n.mobile-wallet-adapter-embedded-modal-subtitle {\n    margin: auto;\n    margin-right: 60px;\n    padding: 20px;\n    color: #6E8286;\n}\n\n.mobile-wallet-adapter-embedded-modal-progress-badge {\n    display: flex;\n    background: #F7F8F8;\n    height: 56px;\n    min-width: 200px;\n    margin: auto;\n    padding-left: 20px;\n    padding-right: 20px;\n    border-radius: 18px;\n    color: #A8B6B8;\n    align-items: center;\n}\n\n.mobile-wallet-adapter-embedded-modal-progress-badge > div:first-child {\n    margin-left: auto;\n    margin-right: 20px;\n}\n\n.mobile-wallet-adapter-embedded-modal-progress-badge > div:nth-child(2) {\n    margin-right: auto;\n}\n\n/* Smaller screens */\n@media all and (max-width: 600px) {\n    .mobile-wallet-adapter-embedded-modal-card {\n        text-align: center;\n    }\n    .mobile-wallet-adapter-embedded-modal-qr-content {\n        flex-direction: column;\n    }\n    .mobile-wallet-adapter-embedded-modal-qr-content > div:first-child {\n        margin: auto;\n    }\n    .mobile-wallet-adapter-embedded-modal-qr-content > div:nth-child(2) {\n        margin: auto;\n        flex: 2 auto;\n    }\n    .mobile-wallet-adapter-embedded-modal-footer {\n        flex-direction: column;\n    }\n    .mobile-wallet-adapter-embedded-modal-icon {\n        display: none;\n    }\n    .mobile-wallet-adapter-embedded-modal-title {\n        font-size: 1.5em;\n    }\n    .mobile-wallet-adapter-embedded-modal-subtitle {\n        margin-right: unset;\n    }\n    .mobile-wallet-adapter-embedded-modal-qr-label {\n        text-align: center;\n    }\n    .mobile-wallet-adapter-embedded-modal-qr-code-container {\n        margin: auto;\n    }\n}\n\n/* Spinner */\n@keyframes spinLeft {\n    0% {\n        transform: rotate(20deg);\n    }\n    50% {\n        transform: rotate(160deg);\n    }\n    100% {\n        transform: rotate(20deg);\n    }\n}\n@keyframes spinRight {\n    0% {\n        transform: rotate(160deg);\n    }\n    50% {\n        transform: rotate(20deg);\n    }\n    100% {\n        transform: rotate(160deg);\n    }\n}\n@keyframes spin {\n    0% {\n        transform: rotate(0deg);\n    }\n    100% {\n        transform: rotate(2520deg);\n    }\n}\n\n.spinner {\n    position: relative;\n    width: 1.5em;\n    height: 1.5em;\n    margin: auto;\n    animation: spin 10s linear infinite;\n}\n.spinner::before {\n    content: \"\";\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n}\n.right, .rightWrapper, .left, .leftWrapper {\n    position: absolute;\n    top: 0;\n    overflow: hidden;\n    width: .75em;\n    height: 1.5em;\n}\n.left, .leftWrapper {\n    left: 0;\n}\n.right {\n    left: -12px;\n}\n.rightWrapper {\n    right: 0;\n}\n.circle {\n    border: .125em solid #A8B6B8;\n    width: 1.25em; /* 1.5em - 2*0.125em border */\n    height: 1.25em; /* 1.5em - 2*0.125em border */\n    border-radius: 0.75em; /* 0.5*1.5em spinner size 8 */\n}\n.left {\n    transform-origin: 100% 50%;\n    animation: spinLeft 2.5s cubic-bezier(.2,0,.8,1) infinite;\n}\n.right {\n    transform-origin: 100% 50%;\n    animation: spinRight 2.5s cubic-bezier(.2,0,.8,1) infinite;\n}\n`;\nconst icon = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik03IDIuNUgxN0MxNy44Mjg0IDIuNSAxOC41IDMuMTcxNTcgMTguNSA0VjIwQzE4LjUgMjAuODI4NCAxNy44Mjg0IDIxLjUgMTcgMjEuNUg3QzYuMTcxNTcgMjEuNSA1LjUgMjAuODI4NCA1LjUgMjBWNEM1LjUgMy4xNzE1NyA2LjE3MTU3IDIuNSA3IDIuNVpNMyA0QzMgMS43OTA4NiA0Ljc5MDg2IDAgNyAwSDE3QzE5LjIwOTEgMCAyMSAxLjc5MDg2IDIxIDRWMjBDMjEgMjIuMjA5MSAxOS4yMDkxIDI0IDE3IDI0SDdDNC43OTA4NiAyNCAzIDIyLjIwOTEgMyAyMFY0Wk0xMSA0LjYxNTM4QzEwLjQ0NzcgNC42MTUzOCAxMCA1LjA2MzEgMTAgNS42MTUzOFY2LjM4NDYyQzEwIDYuOTM2OSAxMC40NDc3IDcuMzg0NjIgMTEgNy4zODQ2MkgxM0MxMy41NTIzIDcuMzg0NjIgMTQgNi45MzY5IDE0IDYuMzg0NjJWNS42MTUzOEMxNCA1LjA2MzEgMTMuNTUyMyA0LjYxNTM4IDEzIDQuNjE1MzhIMTFaIiBmaWxsPSIjRENCOEZGIi8+Cjwvc3ZnPgo=';\nfunction isVersionedTransaction(transaction) {\n  return 'version' in transaction;\n}\nfunction fromUint8Array(byteArray) {\n  return window.btoa(String.fromCharCode.call(null, ...byteArray));\n}\nfunction toUint8Array(base64EncodedByteArray) {\n  return new Uint8Array(window.atob(base64EncodedByteArray).split('').map(c => c.charCodeAt(0)));\n}\nvar _LocalSolanaMobileWalletAdapterWallet_instances, _LocalSolanaMobileWalletAdapterWallet_listeners, _LocalSolanaMobileWalletAdapterWallet_version, _LocalSolanaMobileWalletAdapterWallet_name, _LocalSolanaMobileWalletAdapterWallet_url, _LocalSolanaMobileWalletAdapterWallet_icon, _LocalSolanaMobileWalletAdapterWallet_appIdentity, _LocalSolanaMobileWalletAdapterWallet_authorization, _LocalSolanaMobileWalletAdapterWallet_authorizationCache, _LocalSolanaMobileWalletAdapterWallet_connecting, _LocalSolanaMobileWalletAdapterWallet_connectionGeneration, _LocalSolanaMobileWalletAdapterWallet_chains, _LocalSolanaMobileWalletAdapterWallet_chainSelector, _LocalSolanaMobileWalletAdapterWallet_optionalFeatures, _LocalSolanaMobileWalletAdapterWallet_onWalletNotFound, _LocalSolanaMobileWalletAdapterWallet_on, _LocalSolanaMobileWalletAdapterWallet_emit, _LocalSolanaMobileWalletAdapterWallet_off, _LocalSolanaMobileWalletAdapterWallet_connect, _LocalSolanaMobileWalletAdapterWallet_performAuthorization, _LocalSolanaMobileWalletAdapterWallet_handleAuthorizationResult, _LocalSolanaMobileWalletAdapterWallet_handleWalletCapabilitiesResult, _LocalSolanaMobileWalletAdapterWallet_performReauthorization, _LocalSolanaMobileWalletAdapterWallet_disconnect, _LocalSolanaMobileWalletAdapterWallet_transact, _LocalSolanaMobileWalletAdapterWallet_assertIsAuthorized, _LocalSolanaMobileWalletAdapterWallet_accountsToWalletStandardAccounts, _LocalSolanaMobileWalletAdapterWallet_performSignTransactions, _LocalSolanaMobileWalletAdapterWallet_performSignAndSendTransaction, _LocalSolanaMobileWalletAdapterWallet_signAndSendTransaction, _LocalSolanaMobileWalletAdapterWallet_signTransaction, _LocalSolanaMobileWalletAdapterWallet_signMessage, _LocalSolanaMobileWalletAdapterWallet_signIn, _LocalSolanaMobileWalletAdapterWallet_performSignIn, _RemoteSolanaMobileWalletAdapterWallet_instances, _RemoteSolanaMobileWalletAdapterWallet_listeners, _RemoteSolanaMobileWalletAdapterWallet_version, _RemoteSolanaMobileWalletAdapterWallet_name, _RemoteSolanaMobileWalletAdapterWallet_url, _RemoteSolanaMobileWalletAdapterWallet_icon, _RemoteSolanaMobileWalletAdapterWallet_appIdentity, _RemoteSolanaMobileWalletAdapterWallet_authorization, _RemoteSolanaMobileWalletAdapterWallet_authorizationCache, _RemoteSolanaMobileWalletAdapterWallet_connecting, _RemoteSolanaMobileWalletAdapterWallet_connectionGeneration, _RemoteSolanaMobileWalletAdapterWallet_chains, _RemoteSolanaMobileWalletAdapterWallet_chainSelector, _RemoteSolanaMobileWalletAdapterWallet_optionalFeatures, _RemoteSolanaMobileWalletAdapterWallet_onWalletNotFound, _RemoteSolanaMobileWalletAdapterWallet_hostAuthority, _RemoteSolanaMobileWalletAdapterWallet_session, _RemoteSolanaMobileWalletAdapterWallet_on, _RemoteSolanaMobileWalletAdapterWallet_emit, _RemoteSolanaMobileWalletAdapterWallet_off, _RemoteSolanaMobileWalletAdapterWallet_connect, _RemoteSolanaMobileWalletAdapterWallet_performAuthorization, _RemoteSolanaMobileWalletAdapterWallet_handleAuthorizationResult, _RemoteSolanaMobileWalletAdapterWallet_handleWalletCapabilitiesResult, _RemoteSolanaMobileWalletAdapterWallet_performReauthorization, _RemoteSolanaMobileWalletAdapterWallet_disconnect, _RemoteSolanaMobileWalletAdapterWallet_transact, _RemoteSolanaMobileWalletAdapterWallet_assertIsAuthorized, _RemoteSolanaMobileWalletAdapterWallet_accountsToWalletStandardAccounts, _RemoteSolanaMobileWalletAdapterWallet_performSignTransactions, _RemoteSolanaMobileWalletAdapterWallet_performSignAndSendTransaction, _RemoteSolanaMobileWalletAdapterWallet_signAndSendTransaction, _RemoteSolanaMobileWalletAdapterWallet_signTransaction, _RemoteSolanaMobileWalletAdapterWallet_signMessage, _RemoteSolanaMobileWalletAdapterWallet_signIn, _RemoteSolanaMobileWalletAdapterWallet_performSignIn;\nconst SolanaMobileWalletAdapterWalletName = 'Mobile Wallet Adapter';\nconst SIGNATURE_LENGTH_IN_BYTES = 64;\nconst DEFAULT_FEATURES = [SolanaSignAndSendTransaction, SolanaSignTransaction, SolanaSignMessage, SolanaSignIn];\nclass LocalSolanaMobileWalletAdapterWallet {\n  constructor(config) {\n    _LocalSolanaMobileWalletAdapterWallet_instances.add(this);\n    _LocalSolanaMobileWalletAdapterWallet_listeners.set(this, {});\n    _LocalSolanaMobileWalletAdapterWallet_version.set(this, '1.0.0'); // wallet-standard version\n    _LocalSolanaMobileWalletAdapterWallet_name.set(this, SolanaMobileWalletAdapterWalletName);\n    _LocalSolanaMobileWalletAdapterWallet_url.set(this, 'https://solanamobile.com/wallets');\n    _LocalSolanaMobileWalletAdapterWallet_icon.set(this, icon);\n    _LocalSolanaMobileWalletAdapterWallet_appIdentity.set(this, void 0);\n    _LocalSolanaMobileWalletAdapterWallet_authorization.set(this, void 0);\n    _LocalSolanaMobileWalletAdapterWallet_authorizationCache.set(this, void 0);\n    _LocalSolanaMobileWalletAdapterWallet_connecting.set(this, false);\n    /**\n     * Every time the connection is recycled in some way (eg. `disconnect()` is called)\n     * increment this and use it to make sure that `transact` calls from the previous\n     * 'generation' don't continue to do work and throw exceptions.\n     */\n    _LocalSolanaMobileWalletAdapterWallet_connectionGeneration.set(this, 0);\n    _LocalSolanaMobileWalletAdapterWallet_chains.set(this, []);\n    _LocalSolanaMobileWalletAdapterWallet_chainSelector.set(this, void 0);\n    _LocalSolanaMobileWalletAdapterWallet_optionalFeatures.set(this, void 0);\n    _LocalSolanaMobileWalletAdapterWallet_onWalletNotFound.set(this, void 0);\n    _LocalSolanaMobileWalletAdapterWallet_on.set(this, (event, listener) => {\n      var _a;\n      ((_a = __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_listeners, \"f\")[event]) === null || _a === void 0 ? void 0 : _a.push(listener)) || (__classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_listeners, \"f\")[event] = [listener]);\n      return () => __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_instances, \"m\", _LocalSolanaMobileWalletAdapterWallet_off).call(this, event, listener);\n    });\n    _LocalSolanaMobileWalletAdapterWallet_connect.set(this, ({\n      silent\n    } = {}) => __awaiter(this, void 0, void 0, function* () {\n      if (__classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_connecting, \"f\") || this.connected) {\n        return {\n          accounts: this.accounts\n        };\n      }\n      __classPrivateFieldSet$1(this, _LocalSolanaMobileWalletAdapterWallet_connecting, true, \"f\");\n      try {\n        if (silent) {\n          const cachedAuthorization = yield __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorizationCache, \"f\").get();\n          if (cachedAuthorization) {\n            yield __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_handleAuthorizationResult, \"f\").call(this, cachedAuthorization);\n          } else {\n            return {\n              accounts: this.accounts\n            };\n          }\n        } else {\n          yield __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_performAuthorization, \"f\").call(this);\n        }\n      } catch (e) {\n        throw new Error(e instanceof Error && e.message || 'Unknown error');\n      } finally {\n        __classPrivateFieldSet$1(this, _LocalSolanaMobileWalletAdapterWallet_connecting, false, \"f\");\n      }\n      return {\n        accounts: this.accounts\n      };\n    }));\n    _LocalSolanaMobileWalletAdapterWallet_performAuthorization.set(this, signInPayload => __awaiter(this, void 0, void 0, function* () {\n      try {\n        const cachedAuthorizationResult = yield __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorizationCache, \"f\").get();\n        if (cachedAuthorizationResult) {\n          // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n          __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_handleAuthorizationResult, \"f\").call(this, cachedAuthorizationResult);\n          return cachedAuthorizationResult;\n        }\n        const selectedChain = yield __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_chainSelector, \"f\").select(__classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_chains, \"f\"));\n        return yield __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_transact, \"f\").call(this, wallet => __awaiter(this, void 0, void 0, function* () {\n          const [capabilities, mwaAuthorizationResult] = yield Promise.all([wallet.getCapabilities(), wallet.authorize({\n            chain: selectedChain,\n            identity: __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_appIdentity, \"f\"),\n            sign_in_payload: signInPayload\n          })]);\n          const accounts = __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_accountsToWalletStandardAccounts, \"f\").call(this, mwaAuthorizationResult.accounts);\n          const authorization = Object.assign(Object.assign({}, mwaAuthorizationResult), {\n            accounts,\n            chain: selectedChain\n          });\n          // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n          Promise.all([__classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_handleWalletCapabilitiesResult, \"f\").call(this, capabilities), __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorizationCache, \"f\").set(authorization), __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_handleAuthorizationResult, \"f\").call(this, authorization)]);\n          return authorization;\n        }));\n      } catch (e) {\n        throw new Error(e instanceof Error && e.message || 'Unknown error');\n      }\n    }));\n    _LocalSolanaMobileWalletAdapterWallet_handleAuthorizationResult.set(this, authorization => __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      const didPublicKeysChange =\n      // Case 1: We started from having no authorization.\n      __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorization, \"f\") == null ||\n      // Case 2: The number of authorized accounts changed.\n      ((_a = __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorization, \"f\")) === null || _a === void 0 ? void 0 : _a.accounts.length) !== authorization.accounts.length ||\n      // Case 3: The new list of addresses isn't exactly the same as the old list, in the same order.\n      __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorization, \"f\").accounts.some((account, ii) => account.address !== authorization.accounts[ii].address);\n      __classPrivateFieldSet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorization, authorization, \"f\");\n      if (didPublicKeysChange) {\n        __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_instances, \"m\", _LocalSolanaMobileWalletAdapterWallet_emit).call(this, 'change', {\n          accounts: this.accounts\n        });\n      }\n    }));\n    _LocalSolanaMobileWalletAdapterWallet_handleWalletCapabilitiesResult.set(this, capabilities => __awaiter(this, void 0, void 0, function* () {\n      // TODO: investigate why using SolanaSignTransactions constant breaks treeshaking\n      const supportsSignTransaction = capabilities.features.includes('solana:signTransactions'); //SolanaSignTransactions);\n      const supportsSignAndSendTransaction = capabilities.supports_sign_and_send_transactions;\n      const didCapabilitiesChange = SolanaSignAndSendTransaction in this.features !== supportsSignAndSendTransaction || SolanaSignTransaction in this.features !== supportsSignTransaction;\n      __classPrivateFieldSet$1(this, _LocalSolanaMobileWalletAdapterWallet_optionalFeatures, Object.assign(Object.assign({}, (supportsSignAndSendTransaction || !supportsSignAndSendTransaction && !supportsSignTransaction) && {\n        [SolanaSignAndSendTransaction]: {\n          version: '1.0.0',\n          supportedTransactionVersions: ['legacy', 0],\n          signAndSendTransaction: __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_signAndSendTransaction, \"f\")\n        }\n      }), supportsSignTransaction && {\n        [SolanaSignTransaction]: {\n          version: '1.0.0',\n          supportedTransactionVersions: ['legacy', 0],\n          signTransaction: __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_signTransaction, \"f\")\n        }\n      }), \"f\");\n      if (didCapabilitiesChange) {\n        __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_instances, \"m\", _LocalSolanaMobileWalletAdapterWallet_emit).call(this, 'change', {\n          features: this.features\n        });\n      }\n    }));\n    _LocalSolanaMobileWalletAdapterWallet_performReauthorization.set(this, (wallet, authToken, chain) => __awaiter(this, void 0, void 0, function* () {\n      try {\n        const mwaAuthorizationResult = yield wallet.authorize({\n          auth_token: authToken,\n          identity: __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_appIdentity, \"f\"),\n          chain: chain\n        });\n        const accounts = __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_accountsToWalletStandardAccounts, \"f\").call(this, mwaAuthorizationResult.accounts);\n        const authorization = Object.assign(Object.assign({}, mwaAuthorizationResult), {\n          accounts: accounts,\n          chain: chain\n        });\n        // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n        Promise.all([__classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorizationCache, \"f\").set(authorization), __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_handleAuthorizationResult, \"f\").call(this, authorization)]);\n      } catch (e) {\n        __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_disconnect, \"f\").call(this);\n        throw new Error(e instanceof Error && e.message || 'Unknown error');\n      }\n    }));\n    _LocalSolanaMobileWalletAdapterWallet_disconnect.set(this, () => __awaiter(this, void 0, void 0, function* () {\n      var _b;\n      __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorizationCache, \"f\").clear(); // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n      __classPrivateFieldSet$1(this, _LocalSolanaMobileWalletAdapterWallet_connecting, false, \"f\");\n      __classPrivateFieldSet$1(this, _LocalSolanaMobileWalletAdapterWallet_connectionGeneration, (_b = __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_connectionGeneration, \"f\"), _b++, _b), \"f\");\n      __classPrivateFieldSet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorization, undefined, \"f\");\n      __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_instances, \"m\", _LocalSolanaMobileWalletAdapterWallet_emit).call(this, 'change', {\n        accounts: this.accounts\n      });\n    }));\n    _LocalSolanaMobileWalletAdapterWallet_transact.set(this, callback => __awaiter(this, void 0, void 0, function* () {\n      var _c;\n      const walletUriBase = (_c = __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorization, \"f\")) === null || _c === void 0 ? void 0 : _c.wallet_uri_base;\n      const config = walletUriBase ? {\n        baseUri: walletUriBase\n      } : undefined;\n      const currentConnectionGeneration = __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_connectionGeneration, \"f\");\n      try {\n        return yield transact(callback, config);\n      } catch (e) {\n        if (__classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_connectionGeneration, \"f\") !== currentConnectionGeneration) {\n          yield new Promise(() => {}); // Never resolve.\n        }\n        if (e instanceof Error && e.name === 'SolanaMobileWalletAdapterError' && e.code === 'ERROR_WALLET_NOT_FOUND') {\n          yield __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_onWalletNotFound, \"f\").call(this, this);\n        }\n        throw e;\n      }\n    }));\n    _LocalSolanaMobileWalletAdapterWallet_assertIsAuthorized.set(this, () => {\n      if (!__classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorization, \"f\")) throw new Error('Wallet not connected');\n      return {\n        authToken: __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorization, \"f\").auth_token,\n        chain: __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorization, \"f\").chain\n      };\n    });\n    _LocalSolanaMobileWalletAdapterWallet_accountsToWalletStandardAccounts.set(this, accounts => {\n      return accounts.map(account => {\n        var _a, _b;\n        const publicKey = toUint8Array(account.address);\n        return {\n          address: base58.encode(publicKey),\n          publicKey,\n          label: account.label,\n          icon: account.icon,\n          chains: (_a = account.chains) !== null && _a !== void 0 ? _a : __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_chains, \"f\"),\n          // TODO: get supported features from getCapabilities API \n          features: (_b = account.features) !== null && _b !== void 0 ? _b : DEFAULT_FEATURES\n        };\n      });\n    });\n    _LocalSolanaMobileWalletAdapterWallet_performSignTransactions.set(this, transactions => __awaiter(this, void 0, void 0, function* () {\n      const {\n        authToken,\n        chain\n      } = __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_assertIsAuthorized, \"f\").call(this);\n      try {\n        return yield __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_transact, \"f\").call(this, wallet => __awaiter(this, void 0, void 0, function* () {\n          yield __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_performReauthorization, \"f\").call(this, wallet, authToken, chain);\n          const signedTransactions = yield wallet.signTransactions({\n            transactions\n          });\n          return signedTransactions;\n        }));\n      } catch (e) {\n        throw new Error(e instanceof Error && e.message || 'Unknown error');\n      }\n    }));\n    _LocalSolanaMobileWalletAdapterWallet_performSignAndSendTransaction.set(this, (transaction, options) => __awaiter(this, void 0, void 0, function* () {\n      const {\n        authToken,\n        chain\n      } = __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_assertIsAuthorized, \"f\").call(this);\n      try {\n        return yield __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_transact, \"f\").call(this, wallet => __awaiter(this, void 0, void 0, function* () {\n          const [capabilities, _1] = yield Promise.all([wallet.getCapabilities(), __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_performReauthorization, \"f\").call(this, wallet, authToken, chain)]);\n          if (capabilities.supports_sign_and_send_transactions) {\n            const signatures = yield wallet.signAndSendTransactions(Object.assign(Object.assign({}, options), {\n              transactions: [transaction]\n            }));\n            return signatures[0];\n          } else {\n            throw new Error('connected wallet does not support signAndSendTransaction');\n          }\n        }));\n      } catch (e) {\n        throw new Error(e instanceof Error && e.message || 'Unknown error');\n      }\n    }));\n    _LocalSolanaMobileWalletAdapterWallet_signAndSendTransaction.set(this, (...inputs) => __awaiter(this, void 0, void 0, function* () {\n      const outputs = [];\n      for (const input of inputs) {\n        const transaction = VersionedTransaction.deserialize(input.transaction);\n        const signature = yield __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_performSignAndSendTransaction, \"f\").call(this, transaction, input.options);\n        outputs.push({\n          signature: base58.decode(signature)\n        });\n      }\n      return outputs;\n    }));\n    _LocalSolanaMobileWalletAdapterWallet_signTransaction.set(this, (...inputs) => __awaiter(this, void 0, void 0, function* () {\n      const transactions = inputs.map(({\n        transaction\n      }) => VersionedTransaction.deserialize(transaction));\n      const signedTransactions = yield __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_performSignTransactions, \"f\").call(this, transactions);\n      return signedTransactions.map(signedTransaction => {\n        const serializedTransaction = isVersionedTransaction(signedTransaction) ? signedTransaction.serialize() : new Uint8Array(signedTransaction.serialize({\n          requireAllSignatures: false,\n          verifySignatures: false\n        }));\n        return {\n          signedTransaction: serializedTransaction\n        };\n      });\n    }));\n    _LocalSolanaMobileWalletAdapterWallet_signMessage.set(this, (...inputs) => __awaiter(this, void 0, void 0, function* () {\n      const {\n        authToken,\n        chain\n      } = __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_assertIsAuthorized, \"f\").call(this);\n      const addresses = inputs.map(({\n        account\n      }) => fromUint8Array(account.publicKey));\n      const messages = inputs.map(({\n        message\n      }) => message);\n      try {\n        return yield __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_transact, \"f\").call(this, wallet => __awaiter(this, void 0, void 0, function* () {\n          yield __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_performReauthorization, \"f\").call(this, wallet, authToken, chain);\n          const signedMessages = yield wallet.signMessages({\n            addresses: addresses,\n            payloads: messages\n          });\n          return signedMessages.map(signedMessage => {\n            return {\n              signedMessage: signedMessage,\n              signature: signedMessage.slice(-SIGNATURE_LENGTH_IN_BYTES)\n            };\n          });\n        }));\n      } catch (e) {\n        throw new Error(e instanceof Error && e.message || 'Unknown error');\n      }\n    }));\n    _LocalSolanaMobileWalletAdapterWallet_signIn.set(this, (...inputs) => __awaiter(this, void 0, void 0, function* () {\n      const outputs = [];\n      if (inputs.length > 1) {\n        for (const input of inputs) {\n          outputs.push(yield __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_performSignIn, \"f\").call(this, input));\n        }\n      } else {\n        return [yield __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_performSignIn, \"f\").call(this, inputs[0])];\n      }\n      return outputs;\n    }));\n    _LocalSolanaMobileWalletAdapterWallet_performSignIn.set(this, input => __awaiter(this, void 0, void 0, function* () {\n      var _d, _e;\n      __classPrivateFieldSet$1(this, _LocalSolanaMobileWalletAdapterWallet_connecting, true, \"f\");\n      try {\n        const authorizationResult = yield __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_performAuthorization, \"f\").call(this, Object.assign(Object.assign({}, input), {\n          domain: (_d = input === null || input === void 0 ? void 0 : input.domain) !== null && _d !== void 0 ? _d : window.location.host\n        }));\n        if (!authorizationResult.sign_in_result) {\n          throw new Error(\"Sign in failed, no sign in result returned by wallet\");\n        }\n        const signedInAddress = authorizationResult.sign_in_result.address;\n        const signedInAccount = Object.assign(Object.assign({}, (_e = authorizationResult.accounts.find(acc => acc.address == signedInAddress)) !== null && _e !== void 0 ? _e : {\n          address: signedInAddress\n        }), {\n          publicKey: toUint8Array(signedInAddress)\n        });\n        return {\n          account: signedInAccount,\n          signedMessage: toUint8Array(authorizationResult.sign_in_result.signed_message),\n          signature: toUint8Array(authorizationResult.sign_in_result.signature)\n        };\n      } catch (e) {\n        throw new Error(e instanceof Error && e.message || 'Unknown error');\n      } finally {\n        __classPrivateFieldSet$1(this, _LocalSolanaMobileWalletAdapterWallet_connecting, false, \"f\");\n      }\n    }));\n    __classPrivateFieldSet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorizationCache, config.authorizationCache, \"f\");\n    __classPrivateFieldSet$1(this, _LocalSolanaMobileWalletAdapterWallet_appIdentity, config.appIdentity, \"f\");\n    __classPrivateFieldSet$1(this, _LocalSolanaMobileWalletAdapterWallet_chains, config.chains, \"f\");\n    __classPrivateFieldSet$1(this, _LocalSolanaMobileWalletAdapterWallet_chainSelector, config.chainSelector, \"f\");\n    __classPrivateFieldSet$1(this, _LocalSolanaMobileWalletAdapterWallet_onWalletNotFound, config.onWalletNotFound, \"f\");\n    __classPrivateFieldSet$1(this, _LocalSolanaMobileWalletAdapterWallet_optionalFeatures, {\n      // We are forced to provide either SolanaSignAndSendTransaction or SolanaSignTransaction\n      // because the wallet-adapter compatible wallet-standard wallet requires at least one of them.\n      // MWA 2.0+ wallets must implement signAndSend and pre 2.0 wallets have always provided it so \n      // this is a safe assumption. We later update the features after we get the wallets capabilities. \n      [SolanaSignAndSendTransaction]: {\n        version: '1.0.0',\n        supportedTransactionVersions: ['legacy', 0],\n        signAndSendTransaction: __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_signAndSendTransaction, \"f\")\n      }\n    }, \"f\");\n  }\n  get version() {\n    return __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_version, \"f\");\n  }\n  get name() {\n    return __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_name, \"f\");\n  }\n  get url() {\n    return __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_url, \"f\");\n  }\n  get icon() {\n    return __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_icon, \"f\");\n  }\n  get chains() {\n    return __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_chains, \"f\");\n  }\n  get features() {\n    return Object.assign({\n      [StandardConnect]: {\n        version: '1.0.0',\n        connect: __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_connect, \"f\")\n      },\n      [StandardDisconnect]: {\n        version: '1.0.0',\n        disconnect: __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_disconnect, \"f\")\n      },\n      [StandardEvents]: {\n        version: '1.0.0',\n        on: __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_on, \"f\")\n      },\n      [SolanaSignMessage]: {\n        version: '1.0.0',\n        signMessage: __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_signMessage, \"f\")\n      },\n      [SolanaSignIn]: {\n        version: '1.0.0',\n        signIn: __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_signIn, \"f\")\n      }\n    }, __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_optionalFeatures, \"f\"));\n  }\n  get accounts() {\n    var _a, _b;\n    return (_b = (_a = __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorization, \"f\")) === null || _a === void 0 ? void 0 : _a.accounts) !== null && _b !== void 0 ? _b : [];\n  }\n  get connected() {\n    return !!__classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorization, \"f\");\n  }\n  get isAuthorized() {\n    return !!__classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorization, \"f\");\n  }\n  get currentAuthorization() {\n    return __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorization, \"f\");\n  }\n  get cachedAuthorizationResult() {\n    return __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorizationCache, \"f\").get();\n  }\n}\n_LocalSolanaMobileWalletAdapterWallet_listeners = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_version = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_name = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_url = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_icon = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_appIdentity = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_authorization = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_authorizationCache = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_connecting = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_connectionGeneration = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_chains = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_chainSelector = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_optionalFeatures = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_onWalletNotFound = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_on = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_connect = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_performAuthorization = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_handleAuthorizationResult = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_handleWalletCapabilitiesResult = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_performReauthorization = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_disconnect = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_transact = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_assertIsAuthorized = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_accountsToWalletStandardAccounts = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_performSignTransactions = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_performSignAndSendTransaction = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_signAndSendTransaction = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_signTransaction = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_signMessage = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_signIn = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_performSignIn = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_instances = new WeakSet(), _LocalSolanaMobileWalletAdapterWallet_emit = function _LocalSolanaMobileWalletAdapterWallet_emit(event, ...args) {\n  var _a;\n  // eslint-disable-next-line prefer-spread\n  (_a = __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_listeners, \"f\")[event]) === null || _a === void 0 ? void 0 : _a.forEach(listener => listener.apply(null, args));\n}, _LocalSolanaMobileWalletAdapterWallet_off = function _LocalSolanaMobileWalletAdapterWallet_off(event, listener) {\n  var _a;\n  __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_listeners, \"f\")[event] = (_a = __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_listeners, \"f\")[event]) === null || _a === void 0 ? void 0 : _a.filter(existingListener => listener !== existingListener);\n};\nclass RemoteSolanaMobileWalletAdapterWallet {\n  constructor(config) {\n    _RemoteSolanaMobileWalletAdapterWallet_instances.add(this);\n    _RemoteSolanaMobileWalletAdapterWallet_listeners.set(this, {});\n    _RemoteSolanaMobileWalletAdapterWallet_version.set(this, '1.0.0'); // wallet-standard version\n    _RemoteSolanaMobileWalletAdapterWallet_name.set(this, SolanaMobileWalletAdapterWalletName);\n    _RemoteSolanaMobileWalletAdapterWallet_url.set(this, 'https://solanamobile.com/wallets');\n    _RemoteSolanaMobileWalletAdapterWallet_icon.set(this, icon);\n    _RemoteSolanaMobileWalletAdapterWallet_appIdentity.set(this, void 0);\n    _RemoteSolanaMobileWalletAdapterWallet_authorization.set(this, void 0);\n    _RemoteSolanaMobileWalletAdapterWallet_authorizationCache.set(this, void 0);\n    _RemoteSolanaMobileWalletAdapterWallet_connecting.set(this, false);\n    /**\n     * Every time the connection is recycled in some way (eg. `disconnect()` is called)\n     * increment this and use it to make sure that `transact` calls from the previous\n     * 'generation' don't continue to do work and throw exceptions.\n     */\n    _RemoteSolanaMobileWalletAdapterWallet_connectionGeneration.set(this, 0);\n    _RemoteSolanaMobileWalletAdapterWallet_chains.set(this, []);\n    _RemoteSolanaMobileWalletAdapterWallet_chainSelector.set(this, void 0);\n    _RemoteSolanaMobileWalletAdapterWallet_optionalFeatures.set(this, void 0);\n    _RemoteSolanaMobileWalletAdapterWallet_onWalletNotFound.set(this, void 0);\n    _RemoteSolanaMobileWalletAdapterWallet_hostAuthority.set(this, void 0);\n    _RemoteSolanaMobileWalletAdapterWallet_session.set(this, void 0);\n    _RemoteSolanaMobileWalletAdapterWallet_on.set(this, (event, listener) => {\n      var _a;\n      ((_a = __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_listeners, \"f\")[event]) === null || _a === void 0 ? void 0 : _a.push(listener)) || (__classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_listeners, \"f\")[event] = [listener]);\n      return () => __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_instances, \"m\", _RemoteSolanaMobileWalletAdapterWallet_off).call(this, event, listener);\n    });\n    _RemoteSolanaMobileWalletAdapterWallet_connect.set(this, ({\n      silent\n    } = {}) => __awaiter(this, void 0, void 0, function* () {\n      if (__classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_connecting, \"f\") || this.connected) {\n        return {\n          accounts: this.accounts\n        };\n      }\n      __classPrivateFieldSet$1(this, _RemoteSolanaMobileWalletAdapterWallet_connecting, true, \"f\");\n      try {\n        yield __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_performAuthorization, \"f\").call(this);\n      } catch (e) {\n        throw new Error(e instanceof Error && e.message || 'Unknown error');\n      } finally {\n        __classPrivateFieldSet$1(this, _RemoteSolanaMobileWalletAdapterWallet_connecting, false, \"f\");\n      }\n      return {\n        accounts: this.accounts\n      };\n    }));\n    _RemoteSolanaMobileWalletAdapterWallet_performAuthorization.set(this, signInPayload => __awaiter(this, void 0, void 0, function* () {\n      try {\n        const cachedAuthorizationResult = yield __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorizationCache, \"f\").get();\n        if (cachedAuthorizationResult) {\n          // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n          __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_handleAuthorizationResult, \"f\").call(this, cachedAuthorizationResult);\n          return cachedAuthorizationResult;\n        }\n        if (__classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_session, \"f\")) __classPrivateFieldSet$1(this, _RemoteSolanaMobileWalletAdapterWallet_session, undefined, \"f\");\n        const selectedChain = yield __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_chainSelector, \"f\").select(__classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_chains, \"f\"));\n        return yield __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_transact, \"f\").call(this, wallet => __awaiter(this, void 0, void 0, function* () {\n          const [capabilities, mwaAuthorizationResult] = yield Promise.all([wallet.getCapabilities(), wallet.authorize({\n            chain: selectedChain,\n            identity: __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_appIdentity, \"f\"),\n            sign_in_payload: signInPayload\n          })]);\n          const accounts = __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_accountsToWalletStandardAccounts, \"f\").call(this, mwaAuthorizationResult.accounts);\n          const authorizationResult = Object.assign(Object.assign({}, mwaAuthorizationResult), {\n            accounts,\n            chain: selectedChain\n          });\n          // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n          Promise.all([__classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_handleWalletCapabilitiesResult, \"f\").call(this, capabilities), __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorizationCache, \"f\").set(authorizationResult), __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_handleAuthorizationResult, \"f\").call(this, authorizationResult)]);\n          return authorizationResult;\n        }));\n      } catch (e) {\n        throw new Error(e instanceof Error && e.message || 'Unknown error');\n      }\n    }));\n    _RemoteSolanaMobileWalletAdapterWallet_handleAuthorizationResult.set(this, authorization => __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      const didPublicKeysChange =\n      // Case 1: We started from having no authorization.\n      __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorization, \"f\") == null ||\n      // Case 2: The number of authorized accounts changed.\n      ((_a = __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorization, \"f\")) === null || _a === void 0 ? void 0 : _a.accounts.length) !== authorization.accounts.length ||\n      // Case 3: The new list of addresses isn't exactly the same as the old list, in the same order.\n      __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorization, \"f\").accounts.some((account, ii) => account.address !== authorization.accounts[ii].address);\n      __classPrivateFieldSet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorization, authorization, \"f\");\n      if (didPublicKeysChange) {\n        __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_instances, \"m\", _RemoteSolanaMobileWalletAdapterWallet_emit).call(this, 'change', {\n          accounts: this.accounts\n        });\n      }\n    }));\n    _RemoteSolanaMobileWalletAdapterWallet_handleWalletCapabilitiesResult.set(this, capabilities => __awaiter(this, void 0, void 0, function* () {\n      // TODO: investigate why using SolanaSignTransactions constant breaks treeshaking\n      const supportsSignTransaction = capabilities.features.includes('solana:signTransactions'); //SolanaSignTransactions);\n      const supportsSignAndSendTransaction = capabilities.supports_sign_and_send_transactions || capabilities.features.includes('solana:signAndSendTransaction');\n      const didCapabilitiesChange = SolanaSignAndSendTransaction in this.features !== supportsSignAndSendTransaction || SolanaSignTransaction in this.features !== supportsSignTransaction;\n      __classPrivateFieldSet$1(this, _RemoteSolanaMobileWalletAdapterWallet_optionalFeatures, Object.assign(Object.assign({}, supportsSignAndSendTransaction && {\n        [SolanaSignAndSendTransaction]: {\n          version: '1.0.0',\n          supportedTransactionVersions: capabilities.supported_transaction_versions,\n          signAndSendTransaction: __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_signAndSendTransaction, \"f\")\n        }\n      }), supportsSignTransaction && {\n        [SolanaSignTransaction]: {\n          version: '1.0.0',\n          supportedTransactionVersions: capabilities.supported_transaction_versions,\n          signTransaction: __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_signTransaction, \"f\")\n        }\n      }), \"f\");\n      if (didCapabilitiesChange) {\n        __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_instances, \"m\", _RemoteSolanaMobileWalletAdapterWallet_emit).call(this, 'change', {\n          features: this.features\n        });\n      }\n    }));\n    _RemoteSolanaMobileWalletAdapterWallet_performReauthorization.set(this, (wallet, authToken, chain) => __awaiter(this, void 0, void 0, function* () {\n      try {\n        const mwaAuthorizationResult = yield wallet.authorize({\n          auth_token: authToken,\n          identity: __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_appIdentity, \"f\")\n        });\n        const accounts = __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_accountsToWalletStandardAccounts, \"f\").call(this, mwaAuthorizationResult.accounts);\n        const authorization = Object.assign(Object.assign({}, mwaAuthorizationResult), {\n          accounts: accounts,\n          chain: chain\n        });\n        // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n        Promise.all([__classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorizationCache, \"f\").set(authorization), __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_handleAuthorizationResult, \"f\").call(this, authorization)]);\n      } catch (e) {\n        __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_disconnect, \"f\").call(this);\n        throw new Error(e instanceof Error && e.message || 'Unknown error');\n      }\n    }));\n    _RemoteSolanaMobileWalletAdapterWallet_disconnect.set(this, () => __awaiter(this, void 0, void 0, function* () {\n      var _b;\n      var _c;\n      (_b = __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_session, \"f\")) === null || _b === void 0 ? void 0 : _b.close();\n      __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorizationCache, \"f\").clear(); // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n      __classPrivateFieldSet$1(this, _RemoteSolanaMobileWalletAdapterWallet_connecting, false, \"f\");\n      __classPrivateFieldSet$1(this, _RemoteSolanaMobileWalletAdapterWallet_connectionGeneration, (_c = __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_connectionGeneration, \"f\"), _c++, _c), \"f\");\n      __classPrivateFieldSet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorization, undefined, \"f\");\n      __classPrivateFieldSet$1(this, _RemoteSolanaMobileWalletAdapterWallet_session, undefined, \"f\");\n      __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_instances, \"m\", _RemoteSolanaMobileWalletAdapterWallet_emit).call(this, 'change', {\n        accounts: this.accounts\n      });\n    }));\n    _RemoteSolanaMobileWalletAdapterWallet_transact.set(this, callback => __awaiter(this, void 0, void 0, function* () {\n      var _d;\n      const walletUriBase = (_d = __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorization, \"f\")) === null || _d === void 0 ? void 0 : _d.wallet_uri_base;\n      const baseConfig = walletUriBase ? {\n        baseUri: walletUriBase\n      } : undefined;\n      const remoteConfig = Object.assign(Object.assign({}, baseConfig), {\n        remoteHostAuthority: __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_hostAuthority, \"f\")\n      });\n      const currentConnectionGeneration = __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_connectionGeneration, \"f\");\n      const modal = new RemoteConnectionModal();\n      if (__classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_session, \"f\")) {\n        return callback(__classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_session, \"f\").wallet);\n      }\n      try {\n        const {\n          associationUrl,\n          close,\n          wallet\n        } = yield startRemoteScenario(remoteConfig);\n        const removeCloseListener = modal.addEventListener('close', event => {\n          if (event) close();\n        });\n        modal.initWithQR(associationUrl.toString());\n        modal.open();\n        __classPrivateFieldSet$1(this, _RemoteSolanaMobileWalletAdapterWallet_session, {\n          close,\n          wallet: yield wallet\n        }, \"f\");\n        removeCloseListener();\n        modal.close();\n        return yield callback(__classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_session, \"f\").wallet);\n      } catch (e) {\n        modal.close();\n        if (__classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_connectionGeneration, \"f\") !== currentConnectionGeneration) {\n          yield new Promise(() => {}); // Never resolve.\n        }\n        if (e instanceof Error && e.name === 'SolanaMobileWalletAdapterError' && e.code === 'ERROR_WALLET_NOT_FOUND') {\n          yield __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_onWalletNotFound, \"f\").call(this, this);\n        }\n        throw e;\n      }\n    }));\n    _RemoteSolanaMobileWalletAdapterWallet_assertIsAuthorized.set(this, () => {\n      if (!__classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorization, \"f\")) throw new Error('Wallet not connected');\n      return {\n        authToken: __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorization, \"f\").auth_token,\n        chain: __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorization, \"f\").chain\n      };\n    });\n    _RemoteSolanaMobileWalletAdapterWallet_accountsToWalletStandardAccounts.set(this, accounts => {\n      return accounts.map(account => {\n        var _a, _b;\n        const publicKey = toUint8Array(account.address);\n        return {\n          address: base58.encode(publicKey),\n          publicKey,\n          label: account.label,\n          icon: account.icon,\n          chains: (_a = account.chains) !== null && _a !== void 0 ? _a : __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_chains, \"f\"),\n          // TODO: get supported features from getCapabilities API \n          features: (_b = account.features) !== null && _b !== void 0 ? _b : DEFAULT_FEATURES\n        };\n      });\n    });\n    _RemoteSolanaMobileWalletAdapterWallet_performSignTransactions.set(this, transactions => __awaiter(this, void 0, void 0, function* () {\n      const {\n        authToken,\n        chain\n      } = __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_assertIsAuthorized, \"f\").call(this);\n      try {\n        return yield __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_transact, \"f\").call(this, wallet => __awaiter(this, void 0, void 0, function* () {\n          yield __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_performReauthorization, \"f\").call(this, wallet, authToken, chain);\n          const signedTransactions = yield wallet.signTransactions({\n            transactions\n          });\n          return signedTransactions;\n        }));\n      } catch (e) {\n        throw new Error(e instanceof Error && e.message || 'Unknown error');\n      }\n    }));\n    _RemoteSolanaMobileWalletAdapterWallet_performSignAndSendTransaction.set(this, (transaction, options) => __awaiter(this, void 0, void 0, function* () {\n      const {\n        authToken,\n        chain\n      } = __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_assertIsAuthorized, \"f\").call(this);\n      try {\n        return yield __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_transact, \"f\").call(this, wallet => __awaiter(this, void 0, void 0, function* () {\n          const [capabilities, _1] = yield Promise.all([wallet.getCapabilities(), __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_performReauthorization, \"f\").call(this, wallet, authToken, chain)]);\n          if (capabilities.supports_sign_and_send_transactions) {\n            const signatures = yield wallet.signAndSendTransactions(Object.assign(Object.assign({}, options), {\n              transactions: [transaction]\n            }));\n            return signatures[0];\n          } else {\n            throw new Error('connected wallet does not support signAndSendTransaction');\n          }\n        }));\n      } catch (e) {\n        throw new Error(e instanceof Error && e.message || 'Unknown error');\n      }\n    }));\n    _RemoteSolanaMobileWalletAdapterWallet_signAndSendTransaction.set(this, (...inputs) => __awaiter(this, void 0, void 0, function* () {\n      const outputs = [];\n      for (const input of inputs) {\n        const transaction = VersionedTransaction.deserialize(input.transaction);\n        const signature = yield __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_performSignAndSendTransaction, \"f\").call(this, transaction, input.options);\n        outputs.push({\n          signature: base58.decode(signature)\n        });\n      }\n      return outputs;\n    }));\n    _RemoteSolanaMobileWalletAdapterWallet_signTransaction.set(this, (...inputs) => __awaiter(this, void 0, void 0, function* () {\n      const transactions = inputs.map(({\n        transaction\n      }) => VersionedTransaction.deserialize(transaction));\n      const signedTransactions = yield __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_performSignTransactions, \"f\").call(this, transactions);\n      return signedTransactions.map(signedTransaction => {\n        const serializedTransaction = isVersionedTransaction(signedTransaction) ? signedTransaction.serialize() : new Uint8Array(signedTransaction.serialize({\n          requireAllSignatures: false,\n          verifySignatures: false\n        }));\n        return {\n          signedTransaction: serializedTransaction\n        };\n      });\n    }));\n    _RemoteSolanaMobileWalletAdapterWallet_signMessage.set(this, (...inputs) => __awaiter(this, void 0, void 0, function* () {\n      const {\n        authToken,\n        chain\n      } = __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_assertIsAuthorized, \"f\").call(this);\n      const addresses = inputs.map(({\n        account\n      }) => fromUint8Array(account.publicKey));\n      const messages = inputs.map(({\n        message\n      }) => message);\n      try {\n        return yield __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_transact, \"f\").call(this, wallet => __awaiter(this, void 0, void 0, function* () {\n          yield __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_performReauthorization, \"f\").call(this, wallet, authToken, chain);\n          const signedMessages = yield wallet.signMessages({\n            addresses: addresses,\n            payloads: messages\n          });\n          return signedMessages.map(signedMessage => {\n            return {\n              signedMessage: signedMessage,\n              signature: signedMessage.slice(-SIGNATURE_LENGTH_IN_BYTES)\n            };\n          });\n        }));\n      } catch (e) {\n        throw new Error(e instanceof Error && e.message || 'Unknown error');\n      }\n    }));\n    _RemoteSolanaMobileWalletAdapterWallet_signIn.set(this, (...inputs) => __awaiter(this, void 0, void 0, function* () {\n      const outputs = [];\n      if (inputs.length > 1) {\n        for (const input of inputs) {\n          outputs.push(yield __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_performSignIn, \"f\").call(this, input));\n        }\n      } else {\n        return [yield __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_performSignIn, \"f\").call(this, inputs[0])];\n      }\n      return outputs;\n    }));\n    _RemoteSolanaMobileWalletAdapterWallet_performSignIn.set(this, input => __awaiter(this, void 0, void 0, function* () {\n      var _e, _f;\n      __classPrivateFieldSet$1(this, _RemoteSolanaMobileWalletAdapterWallet_connecting, true, \"f\");\n      try {\n        const authorizationResult = yield __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_performAuthorization, \"f\").call(this, Object.assign(Object.assign({}, input), {\n          domain: (_e = input === null || input === void 0 ? void 0 : input.domain) !== null && _e !== void 0 ? _e : window.location.host\n        }));\n        if (!authorizationResult.sign_in_result) {\n          throw new Error(\"Sign in failed, no sign in result returned by wallet\");\n        }\n        const signedInAddress = authorizationResult.sign_in_result.address;\n        const signedInAccount = Object.assign(Object.assign({}, (_f = authorizationResult.accounts.find(acc => acc.address == signedInAddress)) !== null && _f !== void 0 ? _f : {\n          address: signedInAddress\n        }), {\n          publicKey: toUint8Array(signedInAddress)\n        });\n        return {\n          account: signedInAccount,\n          signedMessage: toUint8Array(authorizationResult.sign_in_result.signed_message),\n          signature: toUint8Array(authorizationResult.sign_in_result.signature)\n        };\n      } catch (e) {\n        throw new Error(e instanceof Error && e.message || 'Unknown error');\n      } finally {\n        __classPrivateFieldSet$1(this, _RemoteSolanaMobileWalletAdapterWallet_connecting, false, \"f\");\n      }\n    }));\n    __classPrivateFieldSet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorizationCache, config.authorizationCache, \"f\");\n    __classPrivateFieldSet$1(this, _RemoteSolanaMobileWalletAdapterWallet_appIdentity, config.appIdentity, \"f\");\n    __classPrivateFieldSet$1(this, _RemoteSolanaMobileWalletAdapterWallet_chains, config.chains, \"f\");\n    __classPrivateFieldSet$1(this, _RemoteSolanaMobileWalletAdapterWallet_chainSelector, config.chainSelector, \"f\");\n    __classPrivateFieldSet$1(this, _RemoteSolanaMobileWalletAdapterWallet_hostAuthority, config.remoteHostAuthority, \"f\");\n    __classPrivateFieldSet$1(this, _RemoteSolanaMobileWalletAdapterWallet_onWalletNotFound, config.onWalletNotFound, \"f\");\n    __classPrivateFieldSet$1(this, _RemoteSolanaMobileWalletAdapterWallet_optionalFeatures, {\n      // We are forced to provide either SolanaSignAndSendTransaction or SolanaSignTransaction\n      // because the wallet-adapter compatible wallet-standard wallet requires at least one of them.\n      // MWA 2.0+ wallets must implement signAndSend and pre 2.0 wallets have always provided it so \n      // this is a safe assumption. We later update the features after we get the wallets capabilities. \n      [SolanaSignAndSendTransaction]: {\n        version: '1.0.0',\n        supportedTransactionVersions: ['legacy', 0],\n        signAndSendTransaction: __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_signAndSendTransaction, \"f\")\n      }\n    }, \"f\");\n  }\n  get version() {\n    return __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_version, \"f\");\n  }\n  get name() {\n    return __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_name, \"f\");\n  }\n  get url() {\n    return __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_url, \"f\");\n  }\n  get icon() {\n    return __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_icon, \"f\");\n  }\n  get chains() {\n    return __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_chains, \"f\");\n  }\n  get features() {\n    return Object.assign({\n      [StandardConnect]: {\n        version: '1.0.0',\n        connect: __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_connect, \"f\")\n      },\n      [StandardDisconnect]: {\n        version: '1.0.0',\n        disconnect: __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_disconnect, \"f\")\n      },\n      [StandardEvents]: {\n        version: '1.0.0',\n        on: __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_on, \"f\")\n      },\n      [SolanaSignMessage]: {\n        version: '1.0.0',\n        signMessage: __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_signMessage, \"f\")\n      },\n      [SolanaSignIn]: {\n        version: '1.0.0',\n        signIn: __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_signIn, \"f\")\n      }\n    }, __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_optionalFeatures, \"f\"));\n  }\n  get accounts() {\n    var _a, _b;\n    return (_b = (_a = __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorization, \"f\")) === null || _a === void 0 ? void 0 : _a.accounts) !== null && _b !== void 0 ? _b : [];\n  }\n  get connected() {\n    return !!__classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_session, \"f\") && !!__classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorization, \"f\");\n  }\n  get isAuthorized() {\n    return !!__classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorization, \"f\");\n  }\n  get currentAuthorization() {\n    return __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorization, \"f\");\n  }\n  get cachedAuthorizationResult() {\n    return __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorizationCache, \"f\").get();\n  }\n}\n_RemoteSolanaMobileWalletAdapterWallet_listeners = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_version = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_name = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_url = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_icon = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_appIdentity = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_authorization = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_authorizationCache = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_connecting = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_connectionGeneration = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_chains = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_chainSelector = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_optionalFeatures = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_onWalletNotFound = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_hostAuthority = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_session = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_on = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_connect = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_performAuthorization = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_handleAuthorizationResult = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_handleWalletCapabilitiesResult = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_performReauthorization = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_disconnect = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_transact = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_assertIsAuthorized = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_accountsToWalletStandardAccounts = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_performSignTransactions = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_performSignAndSendTransaction = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_signAndSendTransaction = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_signTransaction = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_signMessage = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_signIn = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_performSignIn = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_instances = new WeakSet(), _RemoteSolanaMobileWalletAdapterWallet_emit = function _RemoteSolanaMobileWalletAdapterWallet_emit(event, ...args) {\n  var _a;\n  // eslint-disable-next-line prefer-spread\n  (_a = __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_listeners, \"f\")[event]) === null || _a === void 0 ? void 0 : _a.forEach(listener => listener.apply(null, args));\n}, _RemoteSolanaMobileWalletAdapterWallet_off = function _RemoteSolanaMobileWalletAdapterWallet_off(event, listener) {\n  var _a;\n  __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_listeners, \"f\")[event] = (_a = __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_listeners, \"f\")[event]) === null || _a === void 0 ? void 0 : _a.filter(existingListener => listener !== existingListener);\n};\nvar __classPrivateFieldSet = undefined && undefined.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = undefined && undefined.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _RegisterWalletEvent_detail;\n/**\n * Register a {@link \"@wallet-standard/base\".Wallet} as a Standard Wallet with the app.\n *\n * This dispatches a {@link \"@wallet-standard/base\".WindowRegisterWalletEvent} to notify the app that the Wallet is\n * ready to be registered.\n *\n * This also adds a listener for {@link \"@wallet-standard/base\".WindowAppReadyEvent} to listen for a notification from\n * the app that the app is ready to register the Wallet.\n *\n * This combination of event dispatch and listener guarantees that the Wallet will be registered synchronously as soon\n * as the app is ready whether the Wallet loads before or after the app.\n *\n * @param wallet Wallet to register.\n *\n * @group Wallet\n */\nfunction registerWallet(wallet) {\n  const callback = ({\n    register\n  }) => register(wallet);\n  try {\n    window.dispatchEvent(new RegisterWalletEvent(callback));\n  } catch (error) {\n    console.error('wallet-standard:register-wallet event could not be dispatched\\n', error);\n  }\n  try {\n    window.addEventListener('wallet-standard:app-ready', ({\n      detail: api\n    }) => callback(api));\n  } catch (error) {\n    console.error('wallet-standard:app-ready event listener could not be added\\n', error);\n  }\n}\nclass RegisterWalletEvent extends Event {\n  constructor(callback) {\n    super('wallet-standard:register-wallet', {\n      bubbles: false,\n      cancelable: false,\n      composed: false\n    });\n    _RegisterWalletEvent_detail.set(this, void 0);\n    __classPrivateFieldSet(this, _RegisterWalletEvent_detail, callback, \"f\");\n  }\n  get detail() {\n    return __classPrivateFieldGet(this, _RegisterWalletEvent_detail, \"f\");\n  }\n  get type() {\n    return 'wallet-standard:register-wallet';\n  }\n  /** @deprecated */\n  preventDefault() {\n    throw new Error('preventDefault cannot be called');\n  }\n  /** @deprecated */\n  stopImmediatePropagation() {\n    throw new Error('stopImmediatePropagation cannot be called');\n  }\n  /** @deprecated */\n  stopPropagation() {\n    throw new Error('stopPropagation cannot be called');\n  }\n}\n_RegisterWalletEvent_detail = new WeakMap();\nundefined && undefined.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nundefined && undefined.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nfunction getIsLocalAssociationSupported() {\n  return typeof window !== 'undefined' && window.isSecureContext && typeof document !== 'undefined' && /android/i.test(navigator.userAgent);\n}\nfunction getIsRemoteAssociationSupported() {\n  return typeof window !== 'undefined' && window.isSecureContext && typeof document !== 'undefined' && !/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n}\nfunction registerMwa(config) {\n  if (getIsLocalAssociationSupported()) {\n    registerWallet(new LocalSolanaMobileWalletAdapterWallet(config));\n  } else if (getIsRemoteAssociationSupported() && config.remoteHostAuthority !== undefined) {\n    registerWallet(new RemoteSolanaMobileWalletAdapterWallet(Object.assign(Object.assign({}, config), {\n      remoteHostAuthority: config.remoteHostAuthority\n    })));\n  } else ;\n}\nconst WALLET_NOT_FOUND_ERROR_MESSAGE = 'To use mobile wallet adapter, you must have a compatible mobile wallet application installed on your device.';\nconst BROWSER_NOT_SUPPORTED_ERROR_MESSAGE = 'This browser appears to be incompatible with mobile wallet adapter. Open this page in a compatible mobile browser app and try again.';\nclass ErrorModal extends EmbeddedModal {\n  constructor() {\n    super(...arguments);\n    this.contentStyles = css;\n    this.contentHtml = ErrorDialogHtml;\n  }\n  initWithError(error) {\n    super.init();\n    this.populateError(error);\n  }\n  populateError(error) {\n    var _a, _b;\n    const errorMessageElement = (_a = this.dom) === null || _a === void 0 ? void 0 : _a.getElementById('mobile-wallet-adapter-error-message');\n    const actionBtn = (_b = this.dom) === null || _b === void 0 ? void 0 : _b.getElementById('mobile-wallet-adapter-error-action');\n    if (errorMessageElement) {\n      if (error.name === 'SolanaMobileWalletAdapterError') {\n        switch (error.code) {\n          case 'ERROR_WALLET_NOT_FOUND':\n            errorMessageElement.innerHTML = WALLET_NOT_FOUND_ERROR_MESSAGE;\n            if (actionBtn) actionBtn.addEventListener('click', () => {\n              window.location.href = 'https://solanamobile.com/wallets';\n            });\n            return;\n          case 'ERROR_BROWSER_NOT_SUPPORTED':\n            errorMessageElement.innerHTML = BROWSER_NOT_SUPPORTED_ERROR_MESSAGE;\n            if (actionBtn) actionBtn.style.display = 'none';\n            return;\n        }\n      }\n      errorMessageElement.innerHTML = `An unexpected error occurred: ${error.message}`;\n    } else {\n      console.log('Failed to locate error dialog element');\n    }\n  }\n}\nconst ErrorDialogHtml = `\n<svg class=\"mobile-wallet-adapter-embedded-modal-error-icon\" xmlns=\"http://www.w3.org/2000/svg\" height=\"50px\" viewBox=\"0 -960 960 960\" width=\"50px\" fill=\"#000000\"><path d=\"M 280,-80 Q 197,-80 138.5,-138.5 80,-197 80,-280 80,-363 138.5,-421.5 197,-480 280,-480 q 83,0 141.5,58.5 58.5,58.5 58.5,141.5 0,83 -58.5,141.5 Q 363,-80 280,-80 Z M 824,-120 568,-376 Q 556,-389 542.5,-402.5 529,-416 516,-428 q 38,-24 61,-64 23,-40 23,-88 0,-75 -52.5,-127.5 Q 495,-760 420,-760 345,-760 292.5,-707.5 240,-655 240,-580 q 0,6 0.5,11.5 0.5,5.5 1.5,11.5 -18,2 -39.5,8 -21.5,6 -38.5,14 -2,-11 -3,-22 -1,-11 -1,-23 0,-109 75.5,-184.5 Q 311,-840 420,-840 q 109,0 184.5,75.5 75.5,75.5 75.5,184.5 0,43 -13.5,81.5 Q 653,-460 629,-428 l 251,252 z m -615,-61 71,-71 70,71 29,-28 -71,-71 71,-71 -28,-28 -71,71 -71,-71 -28,28 71,71 -71,71 z\"/></svg>\n<div class=\"mobile-wallet-adapter-embedded-modal-title\">We can't find a wallet.</div>\n<div id=\"mobile-wallet-adapter-error-message\" class=\"mobile-wallet-adapter-embedded-modal-subtitle\"></div>\n<div>\n    <button data-error-action id=\"mobile-wallet-adapter-error-action\" class=\"mobile-wallet-adapter-embedded-modal-error-action\">\n        Find a wallet\n    </button>\n</div>\n`;\nconst css = `\n.mobile-wallet-adapter-embedded-modal-content {\n    text-align: center;\n}\n\n.mobile-wallet-adapter-embedded-modal-error-icon {\n    margin-top: 24px;\n}\n\n.mobile-wallet-adapter-embedded-modal-title {\n    margin: 18px 100px auto 100px;\n    color: #000000;\n    font-size: 2.75em;\n    font-weight: 600;\n}\n\n.mobile-wallet-adapter-embedded-modal-subtitle {\n    margin: 30px 60px 40px 60px;\n    color: #000000;\n    font-size: 1.25em;\n    font-weight: 400;\n}\n\n.mobile-wallet-adapter-embedded-modal-error-action {\n    display: block;\n    width: 100%;\n    height: 56px;\n    /*margin-top: 40px;*/\n    font-size: 1.25em;\n    /*line-height: 24px;*/\n    /*letter-spacing: -1%;*/\n    background: #000000;\n    color: #FFFFFF;\n    border-radius: 18px;\n}\n\n/* Smaller screens */\n@media all and (max-width: 600px) {\n    .mobile-wallet-adapter-embedded-modal-title {\n        font-size: 1.5em;\n        margin-right: 12px;\n        margin-left: 12px;\n    }\n    .mobile-wallet-adapter-embedded-modal-subtitle {\n        margin-right: 12px;\n        margin-left: 12px;\n    }\n}\n`;\nfunction defaultErrorModalWalletNotFoundHandler() {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (typeof window !== 'undefined') {\n      const userAgent = window.navigator.userAgent.toLowerCase();\n      const errorDialog = new ErrorModal();\n      if (userAgent.includes('wv')) {\n        // Android WebView\n        // MWA is not supported in this browser so we inform the user\n        // errorDialog.initWithError(\n        //     new SolanaMobileWalletAdapterError(\n        //         SolanaMobileWalletAdapterErrorCode.ERROR_BROWSER_NOT_SUPPORTED, \n        //         ''\n        //     )\n        // );\n        // TODO: investigate why instantiating a new SolanaMobileWalletAdapterError here breaks treeshaking \n        errorDialog.initWithError({\n          name: 'SolanaMobileWalletAdapterError',\n          code: 'ERROR_BROWSER_NOT_SUPPORTED',\n          message: ''\n        });\n      } else {\n        // Browser, user does not have a wallet installed.\n        // errorDialog.initWithError(\n        //     new SolanaMobileWalletAdapterError(\n        //         SolanaMobileWalletAdapterErrorCode.ERROR_WALLET_NOT_FOUND, \n        //         ''\n        //     )\n        // );\n        // TODO: investigate why instantiating a new SolanaMobileWalletAdapterError here breaks treeshaking \n        errorDialog.initWithError({\n          name: 'SolanaMobileWalletAdapterError',\n          code: 'ERROR_WALLET_NOT_FOUND',\n          message: ''\n        });\n      }\n      errorDialog.open();\n    }\n  });\n}\nfunction createDefaultWalletNotFoundHandler() {\n  return () => __awaiter(this, void 0, void 0, function* () {\n    defaultErrorModalWalletNotFoundHandler();\n  });\n}\nconst CACHE_KEY = 'SolanaMobileWalletAdapterDefaultAuthorizationCache';\nfunction createDefaultAuthorizationCache() {\n  let storage;\n  try {\n    storage = window.localStorage;\n    // eslint-disable-next-line no-empty\n  } catch (_a) {}\n  return {\n    clear() {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (!storage) {\n          return;\n        }\n        try {\n          storage.removeItem(CACHE_KEY);\n          // eslint-disable-next-line no-empty\n        } catch (_a) {}\n      });\n    },\n    get() {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (!storage) {\n          return;\n        }\n        try {\n          const parsed = JSON.parse(storage.getItem(CACHE_KEY));\n          if (parsed && parsed.accounts) {\n            const parsedAccounts = parsed.accounts.map(account => {\n              return Object.assign(Object.assign({}, account), {\n                publicKey: 'publicKey' in account ? new Uint8Array(Object.values(account.publicKey)) // Rebuild publicKey for WalletAccount\n                : new PublicKey(account.address).toBytes()\n              });\n            });\n            return Object.assign(Object.assign({}, parsed), {\n              accounts: parsedAccounts\n            });\n          } else return parsed || undefined;\n          // eslint-disable-next-line no-empty\n        } catch (_a) {}\n      });\n    },\n    set(authorizationResult) {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (!storage) {\n          return;\n        }\n        try {\n          storage.setItem(CACHE_KEY, JSON.stringify(authorizationResult));\n          // eslint-disable-next-line no-empty\n        } catch (_a) {}\n      });\n    }\n  };\n}\nfunction createDefaultChainSelector() {\n  return {\n    select(chains) {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (chains.length === 1) {\n          return chains[0];\n        } else if (chains.includes(SOLANA_MAINNET_CHAIN)) {\n          return SOLANA_MAINNET_CHAIN;\n        } else return chains[0];\n      });\n    }\n  };\n}\nexport { LocalSolanaMobileWalletAdapterWallet, RemoteSolanaMobileWalletAdapterWallet, SolanaMobileWalletAdapterWalletName, createDefaultAuthorizationCache, createDefaultChainSelector, createDefaultWalletNotFoundHandler, defaultErrorModalWalletNotFoundHandler, registerMwa };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}