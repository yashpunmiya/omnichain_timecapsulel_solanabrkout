{"ast":null,"code":"import { withResolvers } from './withResolvers.js';\nconst schedulerCache = /*#__PURE__*/new Map();\n/** @internal */\nexport function createBatchScheduler({\n  fn,\n  id,\n  shouldSplitBatch,\n  wait = 0,\n  sort\n}) {\n  const exec = async () => {\n    const scheduler = getScheduler();\n    flush();\n    const args = scheduler.map(({\n      args\n    }) => args);\n    if (args.length === 0) return;\n    fn(args).then(data => {\n      if (sort && Array.isArray(data)) data.sort(sort);\n      for (let i = 0; i < scheduler.length; i++) {\n        const {\n          resolve\n        } = scheduler[i];\n        resolve?.([data[i], data]);\n      }\n    }).catch(err => {\n      for (let i = 0; i < scheduler.length; i++) {\n        const {\n          reject\n        } = scheduler[i];\n        reject?.(err);\n      }\n    });\n  };\n  const flush = () => schedulerCache.delete(id);\n  const getBatchedArgs = () => getScheduler().map(({\n    args\n  }) => args);\n  const getScheduler = () => schedulerCache.get(id) || [];\n  const setScheduler = item => schedulerCache.set(id, [...getScheduler(), item]);\n  return {\n    flush,\n    async schedule(args) {\n      const {\n        promise,\n        resolve,\n        reject\n      } = withResolvers();\n      const split = shouldSplitBatch?.([...getBatchedArgs(), args]);\n      if (split) exec();\n      const hasActiveScheduler = getScheduler().length > 0;\n      if (hasActiveScheduler) {\n        setScheduler({\n          args,\n          resolve,\n          reject\n        });\n        return promise;\n      }\n      setScheduler({\n        args,\n        resolve,\n        reject\n      });\n      setTimeout(exec, wait);\n      return promise;\n    }\n  };\n}\n//# sourceMappingURL=createBatchScheduler.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}