{"ast":null,"code":"import { SolanaError, SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH, SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH, SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH, SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL } from '@solana/errors';\n\n// src/add-codec-sentinel.ts\n\n// src/bytes.ts\nvar mergeBytes = byteArrays => {\n  const nonEmptyByteArrays = byteArrays.filter(arr => arr.length);\n  if (nonEmptyByteArrays.length === 0) {\n    return byteArrays.length ? byteArrays[0] : new Uint8Array();\n  }\n  if (nonEmptyByteArrays.length === 1) {\n    return nonEmptyByteArrays[0];\n  }\n  const totalLength = nonEmptyByteArrays.reduce((total, arr) => total + arr.length, 0);\n  const result = new Uint8Array(totalLength);\n  let offset = 0;\n  nonEmptyByteArrays.forEach(arr => {\n    result.set(arr, offset);\n    offset += arr.length;\n  });\n  return result;\n};\nvar padBytes = (bytes, length) => {\n  if (bytes.length >= length) return bytes;\n  const paddedBytes = new Uint8Array(length).fill(0);\n  paddedBytes.set(bytes);\n  return paddedBytes;\n};\nvar fixBytes = (bytes, length) => padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\nfunction containsBytes(data, bytes, offset) {\n  const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);\n  if (slice.length !== bytes.length) return false;\n  return bytes.every((b, i) => b === slice[i]);\n}\nfunction getEncodedSize(value, encoder) {\n  return \"fixedSize\" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\nfunction createEncoder(encoder) {\n  return Object.freeze({\n    ...encoder,\n    encode: value => {\n      const bytes = new Uint8Array(getEncodedSize(value, encoder));\n      encoder.write(value, bytes, 0);\n      return bytes;\n    }\n  });\n}\nfunction createDecoder(decoder) {\n  return Object.freeze({\n    ...decoder,\n    decode: (bytes, offset = 0) => decoder.read(bytes, offset)[0]\n  });\n}\nfunction createCodec(codec) {\n  return Object.freeze({\n    ...codec,\n    decode: (bytes, offset = 0) => codec.read(bytes, offset)[0],\n    encode: value => {\n      const bytes = new Uint8Array(getEncodedSize(value, codec));\n      codec.write(value, bytes, 0);\n      return bytes;\n    }\n  });\n}\nfunction isFixedSize(codec) {\n  return \"fixedSize\" in codec && typeof codec.fixedSize === \"number\";\n}\nfunction assertIsFixedSize(codec) {\n  if (!isFixedSize(codec)) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n  }\n}\nfunction isVariableSize(codec) {\n  return !isFixedSize(codec);\n}\nfunction assertIsVariableSize(codec) {\n  if (!isVariableSize(codec)) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n  }\n}\nfunction combineCodec(encoder, decoder) {\n  if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n  }\n  if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n      decoderFixedSize: decoder.fixedSize,\n      encoderFixedSize: encoder.fixedSize\n    });\n  }\n  if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n      decoderMaxSize: decoder.maxSize,\n      encoderMaxSize: encoder.maxSize\n    });\n  }\n  return {\n    ...decoder,\n    ...encoder,\n    decode: decoder.decode,\n    encode: encoder.encode,\n    read: decoder.read,\n    write: encoder.write\n  };\n}\n\n// src/add-codec-sentinel.ts\nfunction addEncoderSentinel(encoder, sentinel) {\n  const write = (value, bytes, offset) => {\n    const encoderBytes = encoder.encode(value);\n    if (findSentinelIndex(encoderBytes, sentinel) >= 0) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {\n        encodedBytes: encoderBytes,\n        hexEncodedBytes: hexBytes(encoderBytes),\n        hexSentinel: hexBytes(sentinel),\n        sentinel\n      });\n    }\n    bytes.set(encoderBytes, offset);\n    offset += encoderBytes.length;\n    bytes.set(sentinel, offset);\n    offset += sentinel.length;\n    return offset;\n  };\n  if (isFixedSize(encoder)) {\n    return createEncoder({\n      ...encoder,\n      fixedSize: encoder.fixedSize + sentinel.length,\n      write\n    });\n  }\n  return createEncoder({\n    ...encoder,\n    ...(encoder.maxSize != null ? {\n      maxSize: encoder.maxSize + sentinel.length\n    } : {}),\n    getSizeFromValue: value => encoder.getSizeFromValue(value) + sentinel.length,\n    write\n  });\n}\nfunction addDecoderSentinel(decoder, sentinel) {\n  const read = (bytes, offset) => {\n    const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);\n    const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);\n    if (sentinelIndex === -1) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {\n        decodedBytes: candidateBytes,\n        hexDecodedBytes: hexBytes(candidateBytes),\n        hexSentinel: hexBytes(sentinel),\n        sentinel\n      });\n    }\n    const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);\n    return [decoder.decode(preSentinelBytes), offset + preSentinelBytes.length + sentinel.length];\n  };\n  if (isFixedSize(decoder)) {\n    return createDecoder({\n      ...decoder,\n      fixedSize: decoder.fixedSize + sentinel.length,\n      read\n    });\n  }\n  return createDecoder({\n    ...decoder,\n    ...(decoder.maxSize != null ? {\n      maxSize: decoder.maxSize + sentinel.length\n    } : {}),\n    read\n  });\n}\nfunction addCodecSentinel(codec, sentinel) {\n  return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));\n}\nfunction findSentinelIndex(bytes, sentinel) {\n  return bytes.findIndex((byte, index, arr) => {\n    if (sentinel.length === 1) return byte === sentinel[0];\n    return containsBytes(arr, sentinel, index);\n  });\n}\nfunction hexBytes(bytes) {\n  return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, \"0\"), \"\");\n}\nfunction assertByteArrayIsNotEmptyForCodec(codecDescription, bytes, offset = 0) {\n  if (bytes.length - offset <= 0) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n      codecDescription\n    });\n  }\n}\nfunction assertByteArrayHasEnoughBytesForCodec(codecDescription, expected, bytes, offset = 0) {\n  const bytesLength = bytes.length - offset;\n  if (bytesLength < expected) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n      bytesLength,\n      codecDescription,\n      expected\n    });\n  }\n}\nfunction assertByteArrayOffsetIsNotOutOfRange(codecDescription, offset, bytesLength) {\n  if (offset < 0 || offset > bytesLength) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {\n      bytesLength,\n      codecDescription,\n      offset\n    });\n  }\n}\n\n// src/add-codec-size-prefix.ts\nfunction addEncoderSizePrefix(encoder, prefix) {\n  const write = (value, bytes, offset) => {\n    const encoderBytes = encoder.encode(value);\n    offset = prefix.write(encoderBytes.length, bytes, offset);\n    bytes.set(encoderBytes, offset);\n    return offset + encoderBytes.length;\n  };\n  if (isFixedSize(prefix) && isFixedSize(encoder)) {\n    return createEncoder({\n      ...encoder,\n      fixedSize: prefix.fixedSize + encoder.fixedSize,\n      write\n    });\n  }\n  const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n  const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : encoder.maxSize ?? null;\n  const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;\n  return createEncoder({\n    ...encoder,\n    ...(maxSize !== null ? {\n      maxSize\n    } : {}),\n    getSizeFromValue: value => {\n      const encoderSize = getEncodedSize(value, encoder);\n      return getEncodedSize(encoderSize, prefix) + encoderSize;\n    },\n    write\n  });\n}\nfunction addDecoderSizePrefix(decoder, prefix) {\n  const read = (bytes, offset) => {\n    const [bigintSize, decoderOffset] = prefix.read(bytes, offset);\n    const size = Number(bigintSize);\n    offset = decoderOffset;\n    if (offset > 0 || bytes.length > size) {\n      bytes = bytes.slice(offset, offset + size);\n    }\n    assertByteArrayHasEnoughBytesForCodec(\"addDecoderSizePrefix\", size, bytes);\n    return [decoder.decode(bytes), offset + size];\n  };\n  if (isFixedSize(prefix) && isFixedSize(decoder)) {\n    return createDecoder({\n      ...decoder,\n      fixedSize: prefix.fixedSize + decoder.fixedSize,\n      read\n    });\n  }\n  const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n  const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : decoder.maxSize ?? null;\n  const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;\n  return createDecoder({\n    ...decoder,\n    ...(maxSize !== null ? {\n      maxSize\n    } : {}),\n    read\n  });\n}\nfunction addCodecSizePrefix(codec, prefix) {\n  return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));\n}\n\n// src/fix-codec-size.ts\nfunction fixEncoderSize(encoder, fixedBytes) {\n  return createEncoder({\n    fixedSize: fixedBytes,\n    write: (value, bytes, offset) => {\n      const variableByteArray = encoder.encode(value);\n      const fixedByteArray = variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n      bytes.set(fixedByteArray, offset);\n      return offset + fixedBytes;\n    }\n  });\n}\nfunction fixDecoderSize(decoder, fixedBytes) {\n  return createDecoder({\n    fixedSize: fixedBytes,\n    read: (bytes, offset) => {\n      assertByteArrayHasEnoughBytesForCodec(\"fixCodecSize\", fixedBytes, bytes, offset);\n      if (offset > 0 || bytes.length > fixedBytes) {\n        bytes = bytes.slice(offset, offset + fixedBytes);\n      }\n      if (isFixedSize(decoder)) {\n        bytes = fixBytes(bytes, decoder.fixedSize);\n      }\n      const [value] = decoder.read(bytes, 0);\n      return [value, offset + fixedBytes];\n    }\n  });\n}\nfunction fixCodecSize(codec, fixedBytes) {\n  return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));\n}\n\n// src/offset-codec.ts\nfunction offsetEncoder(encoder, config) {\n  return createEncoder({\n    ...encoder,\n    write: (value, bytes, preOffset) => {\n      const wrapBytes = offset => modulo(offset, bytes.length);\n      const newPreOffset = config.preOffset ? config.preOffset({\n        bytes,\n        preOffset,\n        wrapBytes\n      }) : preOffset;\n      assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPreOffset, bytes.length);\n      const postOffset = encoder.write(value, bytes, newPreOffset);\n      const newPostOffset = config.postOffset ? config.postOffset({\n        bytes,\n        newPreOffset,\n        postOffset,\n        preOffset,\n        wrapBytes\n      }) : postOffset;\n      assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPostOffset, bytes.length);\n      return newPostOffset;\n    }\n  });\n}\nfunction offsetDecoder(decoder, config) {\n  return createDecoder({\n    ...decoder,\n    read: (bytes, preOffset) => {\n      const wrapBytes = offset => modulo(offset, bytes.length);\n      const newPreOffset = config.preOffset ? config.preOffset({\n        bytes,\n        preOffset,\n        wrapBytes\n      }) : preOffset;\n      assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPreOffset, bytes.length);\n      const [value, postOffset] = decoder.read(bytes, newPreOffset);\n      const newPostOffset = config.postOffset ? config.postOffset({\n        bytes,\n        newPreOffset,\n        postOffset,\n        preOffset,\n        wrapBytes\n      }) : postOffset;\n      assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPostOffset, bytes.length);\n      return [value, newPostOffset];\n    }\n  });\n}\nfunction offsetCodec(codec, config) {\n  return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config));\n}\nfunction modulo(dividend, divisor) {\n  if (divisor === 0) return 0;\n  return (dividend % divisor + divisor) % divisor;\n}\nfunction resizeEncoder(encoder, resize) {\n  if (isFixedSize(encoder)) {\n    const fixedSize = resize(encoder.fixedSize);\n    if (fixedSize < 0) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n        bytesLength: fixedSize,\n        codecDescription: \"resizeEncoder\"\n      });\n    }\n    return createEncoder({\n      ...encoder,\n      fixedSize\n    });\n  }\n  return createEncoder({\n    ...encoder,\n    getSizeFromValue: value => {\n      const newSize = resize(encoder.getSizeFromValue(value));\n      if (newSize < 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n          bytesLength: newSize,\n          codecDescription: \"resizeEncoder\"\n        });\n      }\n      return newSize;\n    }\n  });\n}\nfunction resizeDecoder(decoder, resize) {\n  if (isFixedSize(decoder)) {\n    const fixedSize = resize(decoder.fixedSize);\n    if (fixedSize < 0) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n        bytesLength: fixedSize,\n        codecDescription: \"resizeDecoder\"\n      });\n    }\n    return createDecoder({\n      ...decoder,\n      fixedSize\n    });\n  }\n  return decoder;\n}\nfunction resizeCodec(codec, resize) {\n  return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize));\n}\n\n// src/pad-codec.ts\nfunction padLeftEncoder(encoder, offset) {\n  return offsetEncoder(resizeEncoder(encoder, size => size + offset), {\n    preOffset: ({\n      preOffset\n    }) => preOffset + offset\n  });\n}\nfunction padRightEncoder(encoder, offset) {\n  return offsetEncoder(resizeEncoder(encoder, size => size + offset), {\n    postOffset: ({\n      postOffset\n    }) => postOffset + offset\n  });\n}\nfunction padLeftDecoder(decoder, offset) {\n  return offsetDecoder(resizeDecoder(decoder, size => size + offset), {\n    preOffset: ({\n      preOffset\n    }) => preOffset + offset\n  });\n}\nfunction padRightDecoder(decoder, offset) {\n  return offsetDecoder(resizeDecoder(decoder, size => size + offset), {\n    postOffset: ({\n      postOffset\n    }) => postOffset + offset\n  });\n}\nfunction padLeftCodec(codec, offset) {\n  return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset));\n}\nfunction padRightCodec(codec, offset) {\n  return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset));\n}\n\n// src/reverse-codec.ts\nfunction copySourceToTargetInReverse(source, target_WILL_MUTATE, sourceOffset, sourceLength, targetOffset = 0) {\n  while (sourceOffset < --sourceLength) {\n    const leftValue = source[sourceOffset];\n    target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];\n    target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;\n    sourceOffset++;\n  }\n  if (sourceOffset === sourceLength) {\n    target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];\n  }\n}\nfunction reverseEncoder(encoder) {\n  assertIsFixedSize(encoder);\n  return createEncoder({\n    ...encoder,\n    write: (value, bytes, offset) => {\n      const newOffset = encoder.write(value, bytes, offset);\n      copySourceToTargetInReverse(bytes, bytes, offset, offset + encoder.fixedSize);\n      return newOffset;\n    }\n  });\n}\nfunction reverseDecoder(decoder) {\n  assertIsFixedSize(decoder);\n  return createDecoder({\n    ...decoder,\n    read: (bytes, offset) => {\n      const reversedBytes = bytes.slice();\n      copySourceToTargetInReverse(bytes, reversedBytes, offset, offset + decoder.fixedSize);\n      return decoder.read(reversedBytes, offset);\n    }\n  });\n}\nfunction reverseCodec(codec) {\n  return combineCodec(reverseEncoder(codec), reverseDecoder(codec));\n}\n\n// src/transform-codec.ts\nfunction transformEncoder(encoder, unmap) {\n  return createEncoder({\n    ...(isVariableSize(encoder) ? {\n      ...encoder,\n      getSizeFromValue: value => encoder.getSizeFromValue(unmap(value))\n    } : encoder),\n    write: (value, bytes, offset) => encoder.write(unmap(value), bytes, offset)\n  });\n}\nfunction transformDecoder(decoder, map) {\n  return createDecoder({\n    ...decoder,\n    read: (bytes, offset) => {\n      const [value, newOffset] = decoder.read(bytes, offset);\n      return [map(value, bytes, offset), newOffset];\n    }\n  });\n}\nfunction transformCodec(codec, unmap, map) {\n  return createCodec({\n    ...transformEncoder(codec, unmap),\n    read: map ? transformDecoder(codec, map).read : codec.read\n  });\n}\nexport { addCodecSentinel, addCodecSizePrefix, addDecoderSentinel, addDecoderSizePrefix, addEncoderSentinel, addEncoderSizePrefix, assertByteArrayHasEnoughBytesForCodec, assertByteArrayIsNotEmptyForCodec, assertByteArrayOffsetIsNotOutOfRange, assertIsFixedSize, assertIsVariableSize, combineCodec, containsBytes, createCodec, createDecoder, createEncoder, fixBytes, fixCodecSize, fixDecoderSize, fixEncoderSize, getEncodedSize, isFixedSize, isVariableSize, mergeBytes, offsetCodec, offsetDecoder, offsetEncoder, padBytes, padLeftCodec, padLeftDecoder, padLeftEncoder, padRightCodec, padRightDecoder, padRightEncoder, resizeCodec, resizeDecoder, resizeEncoder, reverseCodec, reverseDecoder, reverseEncoder, transformCodec, transformDecoder, transformEncoder };\n//# sourceMappingURL=index.browser.mjs.map\n//# sourceMappingURL=index.browser.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}