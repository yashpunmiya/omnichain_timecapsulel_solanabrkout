{"ast":null,"code":"import { AbiEncodingLengthMismatchError, BytesSizeMismatchError, UnsupportedPackedAbiType } from '../../errors/abi.js';\nimport { InvalidAddressError } from '../../errors/address.js';\nimport { isAddress } from '../address/isAddress.js';\nimport { concatHex } from '../data/concat.js';\nimport { pad } from '../data/pad.js';\nimport { boolToHex, numberToHex, stringToHex } from '../encoding/toHex.js';\nimport { arrayRegex, bytesRegex, integerRegex } from '../regex.js';\nexport function encodePacked(types, values) {\n  if (types.length !== values.length) throw new AbiEncodingLengthMismatchError({\n    expectedLength: types.length,\n    givenLength: values.length\n  });\n  const data = [];\n  for (let i = 0; i < types.length; i++) {\n    const type = types[i];\n    const value = values[i];\n    data.push(encode(type, value));\n  }\n  return concatHex(data);\n}\nfunction encode(type, value, isArray = false) {\n  if (type === 'address') {\n    const address = value;\n    if (!isAddress(address)) throw new InvalidAddressError({\n      address\n    });\n    return pad(address.toLowerCase(), {\n      size: isArray ? 32 : null\n    });\n  }\n  if (type === 'string') return stringToHex(value);\n  if (type === 'bytes') return value;\n  if (type === 'bool') return pad(boolToHex(value), {\n    size: isArray ? 32 : 1\n  });\n  const intMatch = type.match(integerRegex);\n  if (intMatch) {\n    const [_type, baseType, bits = '256'] = intMatch;\n    const size = Number.parseInt(bits) / 8;\n    return numberToHex(value, {\n      size: isArray ? 32 : size,\n      signed: baseType === 'int'\n    });\n  }\n  const bytesMatch = type.match(bytesRegex);\n  if (bytesMatch) {\n    const [_type, size] = bytesMatch;\n    if (Number.parseInt(size) !== (value.length - 2) / 2) throw new BytesSizeMismatchError({\n      expectedSize: Number.parseInt(size),\n      givenSize: (value.length - 2) / 2\n    });\n    return pad(value, {\n      dir: 'right',\n      size: isArray ? 32 : null\n    });\n  }\n  const arrayMatch = type.match(arrayRegex);\n  if (arrayMatch && Array.isArray(value)) {\n    const [_type, childType] = arrayMatch;\n    const data = [];\n    for (let i = 0; i < value.length; i++) {\n      data.push(encode(childType, value[i], true));\n    }\n    if (data.length === 0) return '0x';\n    return concatHex(data);\n  }\n  throw new UnsupportedPackedAbiType(type);\n}\n//# sourceMappingURL=encodePacked.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}