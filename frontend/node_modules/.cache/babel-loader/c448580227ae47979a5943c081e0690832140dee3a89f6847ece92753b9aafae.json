{"ast":null,"code":"'use strict';\n\nconst AbortController = globalThis.AbortController || require('abort-controller').AbortController;\nconst {\n  codes: {\n    ERR_INVALID_ARG_VALUE,\n    ERR_INVALID_ARG_TYPE,\n    ERR_MISSING_ARGS,\n    ERR_OUT_OF_RANGE\n  },\n  AbortError\n} = require('../../ours/errors');\nconst {\n  validateAbortSignal,\n  validateInteger,\n  validateObject\n} = require('../validators');\nconst kWeakHandler = require('../../ours/primordials').Symbol('kWeak');\nconst kResistStopPropagation = require('../../ours/primordials').Symbol('kResistStopPropagation');\nconst {\n  finished\n} = require('./end-of-stream');\nconst staticCompose = require('./compose');\nconst {\n  addAbortSignalNoValidate\n} = require('./add-abort-signal');\nconst {\n  isWritable,\n  isNodeStream\n} = require('./utils');\nconst {\n  deprecate\n} = require('../../ours/util');\nconst {\n  ArrayPrototypePush,\n  Boolean,\n  MathFloor,\n  Number,\n  NumberIsNaN,\n  Promise,\n  PromiseReject,\n  PromiseResolve,\n  PromisePrototypeThen,\n  Symbol\n} = require('../../ours/primordials');\nconst kEmpty = Symbol('kEmpty');\nconst kEof = Symbol('kEof');\nfunction compose(stream, options) {\n  if (options != null) {\n    validateObject(options, 'options');\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal');\n  }\n  if (isNodeStream(stream) && !isWritable(stream)) {\n    throw new ERR_INVALID_ARG_VALUE('stream', stream, 'must be writable');\n  }\n  const composedStream = staticCompose(this, stream);\n  if (options !== null && options !== undefined && options.signal) {\n    // Not validating as we already validated before\n    addAbortSignalNoValidate(options.signal, composedStream);\n  }\n  return composedStream;\n}\nfunction map(fn, options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn);\n  }\n  if (options != null) {\n    validateObject(options, 'options');\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal');\n  }\n  let concurrency = 1;\n  if ((options === null || options === undefined ? undefined : options.concurrency) != null) {\n    concurrency = MathFloor(options.concurrency);\n  }\n  let highWaterMark = concurrency - 1;\n  if ((options === null || options === undefined ? undefined : options.highWaterMark) != null) {\n    highWaterMark = MathFloor(options.highWaterMark);\n  }\n  validateInteger(concurrency, 'options.concurrency', 1);\n  validateInteger(highWaterMark, 'options.highWaterMark', 0);\n  highWaterMark += concurrency;\n  return async function* map() {\n    const signal = require('../../ours/util').AbortSignalAny([options === null || options === undefined ? undefined : options.signal].filter(Boolean));\n    const stream = this;\n    const queue = [];\n    const signalOpt = {\n      signal\n    };\n    let next;\n    let resume;\n    let done = false;\n    let cnt = 0;\n    function onCatch() {\n      done = true;\n      afterItemProcessed();\n    }\n    function afterItemProcessed() {\n      cnt -= 1;\n      maybeResume();\n    }\n    function maybeResume() {\n      if (resume && !done && cnt < concurrency && queue.length < highWaterMark) {\n        resume();\n        resume = null;\n      }\n    }\n    async function pump() {\n      try {\n        for await (let val of stream) {\n          if (done) {\n            return;\n          }\n          if (signal.aborted) {\n            throw new AbortError();\n          }\n          try {\n            val = fn(val, signalOpt);\n            if (val === kEmpty) {\n              continue;\n            }\n            val = PromiseResolve(val);\n          } catch (err) {\n            val = PromiseReject(err);\n          }\n          cnt += 1;\n          PromisePrototypeThen(val, afterItemProcessed, onCatch);\n          queue.push(val);\n          if (next) {\n            next();\n            next = null;\n          }\n          if (!done && (queue.length >= highWaterMark || cnt >= concurrency)) {\n            await new Promise(resolve => {\n              resume = resolve;\n            });\n          }\n        }\n        queue.push(kEof);\n      } catch (err) {\n        const val = PromiseReject(err);\n        PromisePrototypeThen(val, afterItemProcessed, onCatch);\n        queue.push(val);\n      } finally {\n        done = true;\n        if (next) {\n          next();\n          next = null;\n        }\n      }\n    }\n    pump();\n    try {\n      while (true) {\n        while (queue.length > 0) {\n          const val = await queue[0];\n          if (val === kEof) {\n            return;\n          }\n          if (signal.aborted) {\n            throw new AbortError();\n          }\n          if (val !== kEmpty) {\n            yield val;\n          }\n          queue.shift();\n          maybeResume();\n        }\n        await new Promise(resolve => {\n          next = resolve;\n        });\n      }\n    } finally {\n      done = true;\n      if (resume) {\n        resume();\n        resume = null;\n      }\n    }\n  }.call(this);\n}\nfunction asIndexedPairs(options = undefined) {\n  if (options != null) {\n    validateObject(options, 'options');\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal');\n  }\n  return async function* asIndexedPairs() {\n    let index = 0;\n    for await (const val of this) {\n      var _options$signal;\n      if (options !== null && options !== undefined && (_options$signal = options.signal) !== null && _options$signal !== undefined && _options$signal.aborted) {\n        throw new AbortError({\n          cause: options.signal.reason\n        });\n      }\n      yield [index++, val];\n    }\n  }.call(this);\n}\nasync function some(fn, options = undefined) {\n  for await (const unused of filter.call(this, fn, options)) {\n    return true;\n  }\n  return false;\n}\nasync function every(fn, options = undefined) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn);\n  }\n  // https://en.wikipedia.org/wiki/De_Morgan%27s_laws\n  return !(await some.call(this, async (...args) => {\n    return !(await fn(...args));\n  }, options));\n}\nasync function find(fn, options) {\n  for await (const result of filter.call(this, fn, options)) {\n    return result;\n  }\n  return undefined;\n}\nasync function forEach(fn, options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn);\n  }\n  async function forEachFn(value, options) {\n    await fn(value, options);\n    return kEmpty;\n  }\n  // eslint-disable-next-line no-unused-vars\n  for await (const unused of map.call(this, forEachFn, options));\n}\nfunction filter(fn, options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn);\n  }\n  async function filterFn(value, options) {\n    if (await fn(value, options)) {\n      return value;\n    }\n    return kEmpty;\n  }\n  return map.call(this, filterFn, options);\n}\n\n// Specific to provide better error to reduce since the argument is only\n// missing if the stream has no items in it - but the code is still appropriate\nclass ReduceAwareErrMissingArgs extends ERR_MISSING_ARGS {\n  constructor() {\n    super('reduce');\n    this.message = 'Reduce of an empty stream requires an initial value';\n  }\n}\nasync function reduce(reducer, initialValue, options) {\n  var _options$signal2;\n  if (typeof reducer !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('reducer', ['Function', 'AsyncFunction'], reducer);\n  }\n  if (options != null) {\n    validateObject(options, 'options');\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal');\n  }\n  let hasInitialValue = arguments.length > 1;\n  if (options !== null && options !== undefined && (_options$signal2 = options.signal) !== null && _options$signal2 !== undefined && _options$signal2.aborted) {\n    const err = new AbortError(undefined, {\n      cause: options.signal.reason\n    });\n    this.once('error', () => {}); // The error is already propagated\n    await finished(this.destroy(err));\n    throw err;\n  }\n  const ac = new AbortController();\n  const signal = ac.signal;\n  if (options !== null && options !== undefined && options.signal) {\n    const opts = {\n      once: true,\n      [kWeakHandler]: this,\n      [kResistStopPropagation]: true\n    };\n    options.signal.addEventListener('abort', () => ac.abort(), opts);\n  }\n  let gotAnyItemFromStream = false;\n  try {\n    for await (const value of this) {\n      var _options$signal3;\n      gotAnyItemFromStream = true;\n      if (options !== null && options !== undefined && (_options$signal3 = options.signal) !== null && _options$signal3 !== undefined && _options$signal3.aborted) {\n        throw new AbortError();\n      }\n      if (!hasInitialValue) {\n        initialValue = value;\n        hasInitialValue = true;\n      } else {\n        initialValue = await reducer(initialValue, value, {\n          signal\n        });\n      }\n    }\n    if (!gotAnyItemFromStream && !hasInitialValue) {\n      throw new ReduceAwareErrMissingArgs();\n    }\n  } finally {\n    ac.abort();\n  }\n  return initialValue;\n}\nasync function toArray(options) {\n  if (options != null) {\n    validateObject(options, 'options');\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal');\n  }\n  const result = [];\n  for await (const val of this) {\n    var _options$signal4;\n    if (options !== null && options !== undefined && (_options$signal4 = options.signal) !== null && _options$signal4 !== undefined && _options$signal4.aborted) {\n      throw new AbortError(undefined, {\n        cause: options.signal.reason\n      });\n    }\n    ArrayPrototypePush(result, val);\n  }\n  return result;\n}\nfunction flatMap(fn, options) {\n  const values = map.call(this, fn, options);\n  return async function* flatMap() {\n    for await (const val of values) {\n      yield* val;\n    }\n  }.call(this);\n}\nfunction toIntegerOrInfinity(number) {\n  // We coerce here to align with the spec\n  // https://github.com/tc39/proposal-iterator-helpers/issues/169\n  number = Number(number);\n  if (NumberIsNaN(number)) {\n    return 0;\n  }\n  if (number < 0) {\n    throw new ERR_OUT_OF_RANGE('number', '>= 0', number);\n  }\n  return number;\n}\nfunction drop(number, options = undefined) {\n  if (options != null) {\n    validateObject(options, 'options');\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal');\n  }\n  number = toIntegerOrInfinity(number);\n  return async function* drop() {\n    var _options$signal5;\n    if (options !== null && options !== undefined && (_options$signal5 = options.signal) !== null && _options$signal5 !== undefined && _options$signal5.aborted) {\n      throw new AbortError();\n    }\n    for await (const val of this) {\n      var _options$signal6;\n      if (options !== null && options !== undefined && (_options$signal6 = options.signal) !== null && _options$signal6 !== undefined && _options$signal6.aborted) {\n        throw new AbortError();\n      }\n      if (number-- <= 0) {\n        yield val;\n      }\n    }\n  }.call(this);\n}\nfunction take(number, options = undefined) {\n  if (options != null) {\n    validateObject(options, 'options');\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal');\n  }\n  number = toIntegerOrInfinity(number);\n  return async function* take() {\n    var _options$signal7;\n    if (options !== null && options !== undefined && (_options$signal7 = options.signal) !== null && _options$signal7 !== undefined && _options$signal7.aborted) {\n      throw new AbortError();\n    }\n    for await (const val of this) {\n      var _options$signal8;\n      if (options !== null && options !== undefined && (_options$signal8 = options.signal) !== null && _options$signal8 !== undefined && _options$signal8.aborted) {\n        throw new AbortError();\n      }\n      if (number-- > 0) {\n        yield val;\n      }\n\n      // Don't get another item from iterator in case we reached the end\n      if (number <= 0) {\n        return;\n      }\n    }\n  }.call(this);\n}\nmodule.exports.streamReturningOperators = {\n  asIndexedPairs: deprecate(asIndexedPairs, 'readable.asIndexedPairs will be removed in a future version.'),\n  drop,\n  filter,\n  flatMap,\n  map,\n  take,\n  compose\n};\nmodule.exports.promiseReturningOperators = {\n  every,\n  forEach,\n  reduce,\n  toArray,\n  some,\n  find\n};","map":{"version":3,"names":["AbortController","globalThis","require","codes","ERR_INVALID_ARG_VALUE","ERR_INVALID_ARG_TYPE","ERR_MISSING_ARGS","ERR_OUT_OF_RANGE","AbortError","validateAbortSignal","validateInteger","validateObject","kWeakHandler","Symbol","kResistStopPropagation","finished","staticCompose","addAbortSignalNoValidate","isWritable","isNodeStream","deprecate","ArrayPrototypePush","Boolean","MathFloor","Number","NumberIsNaN","Promise","PromiseReject","PromiseResolve","PromisePrototypeThen","kEmpty","kEof","compose","stream","options","undefined","signal","composedStream","map","fn","concurrency","highWaterMark","AbortSignalAny","filter","queue","signalOpt","next","resume","done","cnt","onCatch","afterItemProcessed","maybeResume","length","pump","val","aborted","err","push","resolve","shift","call","asIndexedPairs","index","_options$signal","cause","reason","some","unused","every","args","find","result","forEach","forEachFn","value","filterFn","ReduceAwareErrMissingArgs","constructor","message","reduce","reducer","initialValue","_options$signal2","hasInitialValue","arguments","once","destroy","ac","opts","addEventListener","abort","gotAnyItemFromStream","_options$signal3","toArray","_options$signal4","flatMap","values","toIntegerOrInfinity","number","drop","_options$signal5","_options$signal6","take","_options$signal7","_options$signal8","module","exports","streamReturningOperators","promiseReturningOperators"],"sources":["C:/Users/yyash/Coding/solana-brkout/frontend/node_modules/readable-stream/lib/internal/streams/operators.js"],"sourcesContent":["'use strict'\n\nconst AbortController = globalThis.AbortController || require('abort-controller').AbortController\nconst {\n  codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },\n  AbortError\n} = require('../../ours/errors')\nconst { validateAbortSignal, validateInteger, validateObject } = require('../validators')\nconst kWeakHandler = require('../../ours/primordials').Symbol('kWeak')\nconst kResistStopPropagation = require('../../ours/primordials').Symbol('kResistStopPropagation')\nconst { finished } = require('./end-of-stream')\nconst staticCompose = require('./compose')\nconst { addAbortSignalNoValidate } = require('./add-abort-signal')\nconst { isWritable, isNodeStream } = require('./utils')\nconst { deprecate } = require('../../ours/util')\nconst {\n  ArrayPrototypePush,\n  Boolean,\n  MathFloor,\n  Number,\n  NumberIsNaN,\n  Promise,\n  PromiseReject,\n  PromiseResolve,\n  PromisePrototypeThen,\n  Symbol\n} = require('../../ours/primordials')\nconst kEmpty = Symbol('kEmpty')\nconst kEof = Symbol('kEof')\nfunction compose(stream, options) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  if (isNodeStream(stream) && !isWritable(stream)) {\n    throw new ERR_INVALID_ARG_VALUE('stream', stream, 'must be writable')\n  }\n  const composedStream = staticCompose(this, stream)\n  if (options !== null && options !== undefined && options.signal) {\n    // Not validating as we already validated before\n    addAbortSignalNoValidate(options.signal, composedStream)\n  }\n  return composedStream\n}\nfunction map(fn, options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)\n  }\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  let concurrency = 1\n  if ((options === null || options === undefined ? undefined : options.concurrency) != null) {\n    concurrency = MathFloor(options.concurrency)\n  }\n  let highWaterMark = concurrency - 1\n  if ((options === null || options === undefined ? undefined : options.highWaterMark) != null) {\n    highWaterMark = MathFloor(options.highWaterMark)\n  }\n  validateInteger(concurrency, 'options.concurrency', 1)\n  validateInteger(highWaterMark, 'options.highWaterMark', 0)\n  highWaterMark += concurrency\n  return async function* map() {\n    const signal = require('../../ours/util').AbortSignalAny(\n      [options === null || options === undefined ? undefined : options.signal].filter(Boolean)\n    )\n    const stream = this\n    const queue = []\n    const signalOpt = {\n      signal\n    }\n    let next\n    let resume\n    let done = false\n    let cnt = 0\n    function onCatch() {\n      done = true\n      afterItemProcessed()\n    }\n    function afterItemProcessed() {\n      cnt -= 1\n      maybeResume()\n    }\n    function maybeResume() {\n      if (resume && !done && cnt < concurrency && queue.length < highWaterMark) {\n        resume()\n        resume = null\n      }\n    }\n    async function pump() {\n      try {\n        for await (let val of stream) {\n          if (done) {\n            return\n          }\n          if (signal.aborted) {\n            throw new AbortError()\n          }\n          try {\n            val = fn(val, signalOpt)\n            if (val === kEmpty) {\n              continue\n            }\n            val = PromiseResolve(val)\n          } catch (err) {\n            val = PromiseReject(err)\n          }\n          cnt += 1\n          PromisePrototypeThen(val, afterItemProcessed, onCatch)\n          queue.push(val)\n          if (next) {\n            next()\n            next = null\n          }\n          if (!done && (queue.length >= highWaterMark || cnt >= concurrency)) {\n            await new Promise((resolve) => {\n              resume = resolve\n            })\n          }\n        }\n        queue.push(kEof)\n      } catch (err) {\n        const val = PromiseReject(err)\n        PromisePrototypeThen(val, afterItemProcessed, onCatch)\n        queue.push(val)\n      } finally {\n        done = true\n        if (next) {\n          next()\n          next = null\n        }\n      }\n    }\n    pump()\n    try {\n      while (true) {\n        while (queue.length > 0) {\n          const val = await queue[0]\n          if (val === kEof) {\n            return\n          }\n          if (signal.aborted) {\n            throw new AbortError()\n          }\n          if (val !== kEmpty) {\n            yield val\n          }\n          queue.shift()\n          maybeResume()\n        }\n        await new Promise((resolve) => {\n          next = resolve\n        })\n      }\n    } finally {\n      done = true\n      if (resume) {\n        resume()\n        resume = null\n      }\n    }\n  }.call(this)\n}\nfunction asIndexedPairs(options = undefined) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  return async function* asIndexedPairs() {\n    let index = 0\n    for await (const val of this) {\n      var _options$signal\n      if (\n        options !== null &&\n        options !== undefined &&\n        (_options$signal = options.signal) !== null &&\n        _options$signal !== undefined &&\n        _options$signal.aborted\n      ) {\n        throw new AbortError({\n          cause: options.signal.reason\n        })\n      }\n      yield [index++, val]\n    }\n  }.call(this)\n}\nasync function some(fn, options = undefined) {\n  for await (const unused of filter.call(this, fn, options)) {\n    return true\n  }\n  return false\n}\nasync function every(fn, options = undefined) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)\n  }\n  // https://en.wikipedia.org/wiki/De_Morgan%27s_laws\n  return !(await some.call(\n    this,\n    async (...args) => {\n      return !(await fn(...args))\n    },\n    options\n  ))\n}\nasync function find(fn, options) {\n  for await (const result of filter.call(this, fn, options)) {\n    return result\n  }\n  return undefined\n}\nasync function forEach(fn, options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)\n  }\n  async function forEachFn(value, options) {\n    await fn(value, options)\n    return kEmpty\n  }\n  // eslint-disable-next-line no-unused-vars\n  for await (const unused of map.call(this, forEachFn, options));\n}\nfunction filter(fn, options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)\n  }\n  async function filterFn(value, options) {\n    if (await fn(value, options)) {\n      return value\n    }\n    return kEmpty\n  }\n  return map.call(this, filterFn, options)\n}\n\n// Specific to provide better error to reduce since the argument is only\n// missing if the stream has no items in it - but the code is still appropriate\nclass ReduceAwareErrMissingArgs extends ERR_MISSING_ARGS {\n  constructor() {\n    super('reduce')\n    this.message = 'Reduce of an empty stream requires an initial value'\n  }\n}\nasync function reduce(reducer, initialValue, options) {\n  var _options$signal2\n  if (typeof reducer !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('reducer', ['Function', 'AsyncFunction'], reducer)\n  }\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  let hasInitialValue = arguments.length > 1\n  if (\n    options !== null &&\n    options !== undefined &&\n    (_options$signal2 = options.signal) !== null &&\n    _options$signal2 !== undefined &&\n    _options$signal2.aborted\n  ) {\n    const err = new AbortError(undefined, {\n      cause: options.signal.reason\n    })\n    this.once('error', () => {}) // The error is already propagated\n    await finished(this.destroy(err))\n    throw err\n  }\n  const ac = new AbortController()\n  const signal = ac.signal\n  if (options !== null && options !== undefined && options.signal) {\n    const opts = {\n      once: true,\n      [kWeakHandler]: this,\n      [kResistStopPropagation]: true\n    }\n    options.signal.addEventListener('abort', () => ac.abort(), opts)\n  }\n  let gotAnyItemFromStream = false\n  try {\n    for await (const value of this) {\n      var _options$signal3\n      gotAnyItemFromStream = true\n      if (\n        options !== null &&\n        options !== undefined &&\n        (_options$signal3 = options.signal) !== null &&\n        _options$signal3 !== undefined &&\n        _options$signal3.aborted\n      ) {\n        throw new AbortError()\n      }\n      if (!hasInitialValue) {\n        initialValue = value\n        hasInitialValue = true\n      } else {\n        initialValue = await reducer(initialValue, value, {\n          signal\n        })\n      }\n    }\n    if (!gotAnyItemFromStream && !hasInitialValue) {\n      throw new ReduceAwareErrMissingArgs()\n    }\n  } finally {\n    ac.abort()\n  }\n  return initialValue\n}\nasync function toArray(options) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  const result = []\n  for await (const val of this) {\n    var _options$signal4\n    if (\n      options !== null &&\n      options !== undefined &&\n      (_options$signal4 = options.signal) !== null &&\n      _options$signal4 !== undefined &&\n      _options$signal4.aborted\n    ) {\n      throw new AbortError(undefined, {\n        cause: options.signal.reason\n      })\n    }\n    ArrayPrototypePush(result, val)\n  }\n  return result\n}\nfunction flatMap(fn, options) {\n  const values = map.call(this, fn, options)\n  return async function* flatMap() {\n    for await (const val of values) {\n      yield* val\n    }\n  }.call(this)\n}\nfunction toIntegerOrInfinity(number) {\n  // We coerce here to align with the spec\n  // https://github.com/tc39/proposal-iterator-helpers/issues/169\n  number = Number(number)\n  if (NumberIsNaN(number)) {\n    return 0\n  }\n  if (number < 0) {\n    throw new ERR_OUT_OF_RANGE('number', '>= 0', number)\n  }\n  return number\n}\nfunction drop(number, options = undefined) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  number = toIntegerOrInfinity(number)\n  return async function* drop() {\n    var _options$signal5\n    if (\n      options !== null &&\n      options !== undefined &&\n      (_options$signal5 = options.signal) !== null &&\n      _options$signal5 !== undefined &&\n      _options$signal5.aborted\n    ) {\n      throw new AbortError()\n    }\n    for await (const val of this) {\n      var _options$signal6\n      if (\n        options !== null &&\n        options !== undefined &&\n        (_options$signal6 = options.signal) !== null &&\n        _options$signal6 !== undefined &&\n        _options$signal6.aborted\n      ) {\n        throw new AbortError()\n      }\n      if (number-- <= 0) {\n        yield val\n      }\n    }\n  }.call(this)\n}\nfunction take(number, options = undefined) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  number = toIntegerOrInfinity(number)\n  return async function* take() {\n    var _options$signal7\n    if (\n      options !== null &&\n      options !== undefined &&\n      (_options$signal7 = options.signal) !== null &&\n      _options$signal7 !== undefined &&\n      _options$signal7.aborted\n    ) {\n      throw new AbortError()\n    }\n    for await (const val of this) {\n      var _options$signal8\n      if (\n        options !== null &&\n        options !== undefined &&\n        (_options$signal8 = options.signal) !== null &&\n        _options$signal8 !== undefined &&\n        _options$signal8.aborted\n      ) {\n        throw new AbortError()\n      }\n      if (number-- > 0) {\n        yield val\n      }\n\n      // Don't get another item from iterator in case we reached the end\n      if (number <= 0) {\n        return\n      }\n    }\n  }.call(this)\n}\nmodule.exports.streamReturningOperators = {\n  asIndexedPairs: deprecate(asIndexedPairs, 'readable.asIndexedPairs will be removed in a future version.'),\n  drop,\n  filter,\n  flatMap,\n  map,\n  take,\n  compose\n}\nmodule.exports.promiseReturningOperators = {\n  every,\n  forEach,\n  reduce,\n  toArray,\n  some,\n  find\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}