{"ast":null,"code":"'use strict';\n\nconst AbortController = globalThis.AbortController || require('abort-controller').AbortController;\nconst {\n  codes: {\n    ERR_INVALID_ARG_VALUE,\n    ERR_INVALID_ARG_TYPE,\n    ERR_MISSING_ARGS,\n    ERR_OUT_OF_RANGE\n  },\n  AbortError\n} = require('../../ours/errors');\nconst {\n  validateAbortSignal,\n  validateInteger,\n  validateObject\n} = require('../validators');\nconst kWeakHandler = require('../../ours/primordials').Symbol('kWeak');\nconst kResistStopPropagation = require('../../ours/primordials').Symbol('kResistStopPropagation');\nconst {\n  finished\n} = require('./end-of-stream');\nconst staticCompose = require('./compose');\nconst {\n  addAbortSignalNoValidate\n} = require('./add-abort-signal');\nconst {\n  isWritable,\n  isNodeStream\n} = require('./utils');\nconst {\n  deprecate\n} = require('../../ours/util');\nconst {\n  ArrayPrototypePush,\n  Boolean,\n  MathFloor,\n  Number,\n  NumberIsNaN,\n  Promise,\n  PromiseReject,\n  PromiseResolve,\n  PromisePrototypeThen,\n  Symbol\n} = require('../../ours/primordials');\nconst kEmpty = Symbol('kEmpty');\nconst kEof = Symbol('kEof');\nfunction compose(stream, options) {\n  if (options != null) {\n    validateObject(options, 'options');\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal');\n  }\n  if (isNodeStream(stream) && !isWritable(stream)) {\n    throw new ERR_INVALID_ARG_VALUE('stream', stream, 'must be writable');\n  }\n  const composedStream = staticCompose(this, stream);\n  if (options !== null && options !== undefined && options.signal) {\n    // Not validating as we already validated before\n    addAbortSignalNoValidate(options.signal, composedStream);\n  }\n  return composedStream;\n}\nfunction map(fn, options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn);\n  }\n  if (options != null) {\n    validateObject(options, 'options');\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal');\n  }\n  let concurrency = 1;\n  if ((options === null || options === undefined ? undefined : options.concurrency) != null) {\n    concurrency = MathFloor(options.concurrency);\n  }\n  let highWaterMark = concurrency - 1;\n  if ((options === null || options === undefined ? undefined : options.highWaterMark) != null) {\n    highWaterMark = MathFloor(options.highWaterMark);\n  }\n  validateInteger(concurrency, 'options.concurrency', 1);\n  validateInteger(highWaterMark, 'options.highWaterMark', 0);\n  highWaterMark += concurrency;\n  return async function* map() {\n    const signal = require('../../ours/util').AbortSignalAny([options === null || options === undefined ? undefined : options.signal].filter(Boolean));\n    const stream = this;\n    const queue = [];\n    const signalOpt = {\n      signal\n    };\n    let next;\n    let resume;\n    let done = false;\n    let cnt = 0;\n    function onCatch() {\n      done = true;\n      afterItemProcessed();\n    }\n    function afterItemProcessed() {\n      cnt -= 1;\n      maybeResume();\n    }\n    function maybeResume() {\n      if (resume && !done && cnt < concurrency && queue.length < highWaterMark) {\n        resume();\n        resume = null;\n      }\n    }\n    async function pump() {\n      try {\n        for await (let val of stream) {\n          if (done) {\n            return;\n          }\n          if (signal.aborted) {\n            throw new AbortError();\n          }\n          try {\n            val = fn(val, signalOpt);\n            if (val === kEmpty) {\n              continue;\n            }\n            val = PromiseResolve(val);\n          } catch (err) {\n            val = PromiseReject(err);\n          }\n          cnt += 1;\n          PromisePrototypeThen(val, afterItemProcessed, onCatch);\n          queue.push(val);\n          if (next) {\n            next();\n            next = null;\n          }\n          if (!done && (queue.length >= highWaterMark || cnt >= concurrency)) {\n            await new Promise(resolve => {\n              resume = resolve;\n            });\n          }\n        }\n        queue.push(kEof);\n      } catch (err) {\n        const val = PromiseReject(err);\n        PromisePrototypeThen(val, afterItemProcessed, onCatch);\n        queue.push(val);\n      } finally {\n        done = true;\n        if (next) {\n          next();\n          next = null;\n        }\n      }\n    }\n    pump();\n    try {\n      while (true) {\n        while (queue.length > 0) {\n          const val = await queue[0];\n          if (val === kEof) {\n            return;\n          }\n          if (signal.aborted) {\n            throw new AbortError();\n          }\n          if (val !== kEmpty) {\n            yield val;\n          }\n          queue.shift();\n          maybeResume();\n        }\n        await new Promise(resolve => {\n          next = resolve;\n        });\n      }\n    } finally {\n      done = true;\n      if (resume) {\n        resume();\n        resume = null;\n      }\n    }\n  }.call(this);\n}\nfunction asIndexedPairs(options = undefined) {\n  if (options != null) {\n    validateObject(options, 'options');\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal');\n  }\n  return async function* asIndexedPairs() {\n    let index = 0;\n    for await (const val of this) {\n      var _options$signal;\n      if (options !== null && options !== undefined && (_options$signal = options.signal) !== null && _options$signal !== undefined && _options$signal.aborted) {\n        throw new AbortError({\n          cause: options.signal.reason\n        });\n      }\n      yield [index++, val];\n    }\n  }.call(this);\n}\nasync function some(fn, options = undefined) {\n  for await (const unused of filter.call(this, fn, options)) {\n    return true;\n  }\n  return false;\n}\nasync function every(fn, options = undefined) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn);\n  }\n  // https://en.wikipedia.org/wiki/De_Morgan%27s_laws\n  return !(await some.call(this, async (...args) => {\n    return !(await fn(...args));\n  }, options));\n}\nasync function find(fn, options) {\n  for await (const result of filter.call(this, fn, options)) {\n    return result;\n  }\n  return undefined;\n}\nasync function forEach(fn, options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn);\n  }\n  async function forEachFn(value, options) {\n    await fn(value, options);\n    return kEmpty;\n  }\n  // eslint-disable-next-line no-unused-vars\n  for await (const unused of map.call(this, forEachFn, options));\n}\nfunction filter(fn, options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn);\n  }\n  async function filterFn(value, options) {\n    if (await fn(value, options)) {\n      return value;\n    }\n    return kEmpty;\n  }\n  return map.call(this, filterFn, options);\n}\n\n// Specific to provide better error to reduce since the argument is only\n// missing if the stream has no items in it - but the code is still appropriate\nclass ReduceAwareErrMissingArgs extends ERR_MISSING_ARGS {\n  constructor() {\n    super('reduce');\n    this.message = 'Reduce of an empty stream requires an initial value';\n  }\n}\nasync function reduce(reducer, initialValue, options) {\n  var _options$signal2;\n  if (typeof reducer !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('reducer', ['Function', 'AsyncFunction'], reducer);\n  }\n  if (options != null) {\n    validateObject(options, 'options');\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal');\n  }\n  let hasInitialValue = arguments.length > 1;\n  if (options !== null && options !== undefined && (_options$signal2 = options.signal) !== null && _options$signal2 !== undefined && _options$signal2.aborted) {\n    const err = new AbortError(undefined, {\n      cause: options.signal.reason\n    });\n    this.once('error', () => {}); // The error is already propagated\n    await finished(this.destroy(err));\n    throw err;\n  }\n  const ac = new AbortController();\n  const signal = ac.signal;\n  if (options !== null && options !== undefined && options.signal) {\n    const opts = {\n      once: true,\n      [kWeakHandler]: this,\n      [kResistStopPropagation]: true\n    };\n    options.signal.addEventListener('abort', () => ac.abort(), opts);\n  }\n  let gotAnyItemFromStream = false;\n  try {\n    for await (const value of this) {\n      var _options$signal3;\n      gotAnyItemFromStream = true;\n      if (options !== null && options !== undefined && (_options$signal3 = options.signal) !== null && _options$signal3 !== undefined && _options$signal3.aborted) {\n        throw new AbortError();\n      }\n      if (!hasInitialValue) {\n        initialValue = value;\n        hasInitialValue = true;\n      } else {\n        initialValue = await reducer(initialValue, value, {\n          signal\n        });\n      }\n    }\n    if (!gotAnyItemFromStream && !hasInitialValue) {\n      throw new ReduceAwareErrMissingArgs();\n    }\n  } finally {\n    ac.abort();\n  }\n  return initialValue;\n}\nasync function toArray(options) {\n  if (options != null) {\n    validateObject(options, 'options');\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal');\n  }\n  const result = [];\n  for await (const val of this) {\n    var _options$signal4;\n    if (options !== null && options !== undefined && (_options$signal4 = options.signal) !== null && _options$signal4 !== undefined && _options$signal4.aborted) {\n      throw new AbortError(undefined, {\n        cause: options.signal.reason\n      });\n    }\n    ArrayPrototypePush(result, val);\n  }\n  return result;\n}\nfunction flatMap(fn, options) {\n  const values = map.call(this, fn, options);\n  return async function* flatMap() {\n    for await (const val of values) {\n      yield* val;\n    }\n  }.call(this);\n}\nfunction toIntegerOrInfinity(number) {\n  // We coerce here to align with the spec\n  // https://github.com/tc39/proposal-iterator-helpers/issues/169\n  number = Number(number);\n  if (NumberIsNaN(number)) {\n    return 0;\n  }\n  if (number < 0) {\n    throw new ERR_OUT_OF_RANGE('number', '>= 0', number);\n  }\n  return number;\n}\nfunction drop(number, options = undefined) {\n  if (options != null) {\n    validateObject(options, 'options');\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal');\n  }\n  number = toIntegerOrInfinity(number);\n  return async function* drop() {\n    var _options$signal5;\n    if (options !== null && options !== undefined && (_options$signal5 = options.signal) !== null && _options$signal5 !== undefined && _options$signal5.aborted) {\n      throw new AbortError();\n    }\n    for await (const val of this) {\n      var _options$signal6;\n      if (options !== null && options !== undefined && (_options$signal6 = options.signal) !== null && _options$signal6 !== undefined && _options$signal6.aborted) {\n        throw new AbortError();\n      }\n      if (number-- <= 0) {\n        yield val;\n      }\n    }\n  }.call(this);\n}\nfunction take(number, options = undefined) {\n  if (options != null) {\n    validateObject(options, 'options');\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal');\n  }\n  number = toIntegerOrInfinity(number);\n  return async function* take() {\n    var _options$signal7;\n    if (options !== null && options !== undefined && (_options$signal7 = options.signal) !== null && _options$signal7 !== undefined && _options$signal7.aborted) {\n      throw new AbortError();\n    }\n    for await (const val of this) {\n      var _options$signal8;\n      if (options !== null && options !== undefined && (_options$signal8 = options.signal) !== null && _options$signal8 !== undefined && _options$signal8.aborted) {\n        throw new AbortError();\n      }\n      if (number-- > 0) {\n        yield val;\n      }\n\n      // Don't get another item from iterator in case we reached the end\n      if (number <= 0) {\n        return;\n      }\n    }\n  }.call(this);\n}\nmodule.exports.streamReturningOperators = {\n  asIndexedPairs: deprecate(asIndexedPairs, 'readable.asIndexedPairs will be removed in a future version.'),\n  drop,\n  filter,\n  flatMap,\n  map,\n  take,\n  compose\n};\nmodule.exports.promiseReturningOperators = {\n  every,\n  forEach,\n  reduce,\n  toArray,\n  some,\n  find\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}