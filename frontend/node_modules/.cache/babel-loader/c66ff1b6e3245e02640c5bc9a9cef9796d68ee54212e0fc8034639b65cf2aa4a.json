{"ast":null,"code":"import { RLP } from '@ethereumjs/rlp';\nimport { concatBytes } from 'ethereum-cryptography/utils';\nimport { bigIntToBytes, bigIntToHex, bytesToBigInt, bytesToHex, hexToBigInt, hexToBytes } from './bytes.js';\nimport { BIGINT_0 } from './constants.js';\nexport var CLRequestType;\n(function (CLRequestType) {\n  CLRequestType[CLRequestType[\"Deposit\"] = 0] = \"Deposit\";\n  CLRequestType[CLRequestType[\"Withdrawal\"] = 1] = \"Withdrawal\";\n  CLRequestType[CLRequestType[\"Consolidation\"] = 2] = \"Consolidation\";\n})(CLRequestType || (CLRequestType = {}));\nexport class CLRequest {\n  constructor(type) {\n    this.type = type;\n  }\n}\nexport class DepositRequest extends CLRequest {\n  constructor(pubkey, withdrawalCredentials, amount, signature, index) {\n    super(CLRequestType.Deposit);\n    this.pubkey = pubkey;\n    this.withdrawalCredentials = withdrawalCredentials;\n    this.amount = amount;\n    this.signature = signature;\n    this.index = index;\n  }\n  static fromRequestData(depositData) {\n    const {\n      pubkey,\n      withdrawalCredentials,\n      amount,\n      signature,\n      index\n    } = depositData;\n    return new DepositRequest(pubkey, withdrawalCredentials, amount, signature, index);\n  }\n  static fromJSON(jsonData) {\n    const {\n      pubkey,\n      withdrawalCredentials,\n      amount,\n      signature,\n      index\n    } = jsonData;\n    return this.fromRequestData({\n      pubkey: hexToBytes(pubkey),\n      withdrawalCredentials: hexToBytes(withdrawalCredentials),\n      amount: hexToBigInt(amount),\n      signature: hexToBytes(signature),\n      index: hexToBigInt(index)\n    });\n  }\n  serialize() {\n    const indexBytes = this.index === BIGINT_0 ? new Uint8Array() : bigIntToBytes(this.index);\n    const amountBytes = this.amount === BIGINT_0 ? new Uint8Array() : bigIntToBytes(this.amount);\n    return concatBytes(Uint8Array.from([this.type]), RLP.encode([this.pubkey, this.withdrawalCredentials, amountBytes, this.signature, indexBytes]));\n  }\n  toJSON() {\n    return {\n      pubkey: bytesToHex(this.pubkey),\n      withdrawalCredentials: bytesToHex(this.withdrawalCredentials),\n      amount: bigIntToHex(this.amount),\n      signature: bytesToHex(this.signature),\n      index: bigIntToHex(this.index)\n    };\n  }\n  static deserialize(bytes) {\n    const [pubkey, withdrawalCredentials, amount, signature, index] = RLP.decode(bytes.slice(1));\n    return this.fromRequestData({\n      pubkey,\n      withdrawalCredentials,\n      amount: bytesToBigInt(amount),\n      signature,\n      index: bytesToBigInt(index)\n    });\n  }\n}\nexport class WithdrawalRequest extends CLRequest {\n  constructor(sourceAddress, validatorPubkey, amount) {\n    super(CLRequestType.Withdrawal);\n    this.sourceAddress = sourceAddress;\n    this.validatorPubkey = validatorPubkey;\n    this.amount = amount;\n  }\n  static fromRequestData(withdrawalData) {\n    const {\n      sourceAddress,\n      validatorPubkey,\n      amount\n    } = withdrawalData;\n    return new WithdrawalRequest(sourceAddress, validatorPubkey, amount);\n  }\n  static fromJSON(jsonData) {\n    const {\n      sourceAddress,\n      validatorPubkey,\n      amount\n    } = jsonData;\n    return this.fromRequestData({\n      sourceAddress: hexToBytes(sourceAddress),\n      validatorPubkey: hexToBytes(validatorPubkey),\n      amount: hexToBigInt(amount)\n    });\n  }\n  serialize() {\n    const amountBytes = this.amount === BIGINT_0 ? new Uint8Array() : bigIntToBytes(this.amount);\n    return concatBytes(Uint8Array.from([this.type]), RLP.encode([this.sourceAddress, this.validatorPubkey, amountBytes]));\n  }\n  toJSON() {\n    return {\n      sourceAddress: bytesToHex(this.sourceAddress),\n      validatorPubkey: bytesToHex(this.validatorPubkey),\n      amount: bigIntToHex(this.amount)\n    };\n  }\n  static deserialize(bytes) {\n    const [sourceAddress, validatorPubkey, amount] = RLP.decode(bytes.slice(1));\n    return this.fromRequestData({\n      sourceAddress,\n      validatorPubkey,\n      amount: bytesToBigInt(amount)\n    });\n  }\n}\nexport class ConsolidationRequest extends CLRequest {\n  constructor(sourceAddress, sourcePubkey, targetPubkey) {\n    super(CLRequestType.Consolidation);\n    this.sourceAddress = sourceAddress;\n    this.sourcePubkey = sourcePubkey;\n    this.targetPubkey = targetPubkey;\n  }\n  static fromRequestData(consolidationData) {\n    const {\n      sourceAddress,\n      sourcePubkey,\n      targetPubkey\n    } = consolidationData;\n    return new ConsolidationRequest(sourceAddress, sourcePubkey, targetPubkey);\n  }\n  static fromJSON(jsonData) {\n    const {\n      sourceAddress,\n      sourcePubkey,\n      targetPubkey\n    } = jsonData;\n    return this.fromRequestData({\n      sourceAddress: hexToBytes(sourceAddress),\n      sourcePubkey: hexToBytes(sourcePubkey),\n      targetPubkey: hexToBytes(targetPubkey)\n    });\n  }\n  serialize() {\n    return concatBytes(Uint8Array.from([this.type]), RLP.encode([this.sourceAddress, this.sourcePubkey, this.targetPubkey]));\n  }\n  toJSON() {\n    return {\n      sourceAddress: bytesToHex(this.sourceAddress),\n      sourcePubkey: bytesToHex(this.sourcePubkey),\n      targetPubkey: bytesToHex(this.targetPubkey)\n    };\n  }\n  static deserialize(bytes) {\n    const [sourceAddress, sourcePubkey, targetPubkey] = RLP.decode(bytes.slice(1));\n    return this.fromRequestData({\n      sourceAddress,\n      sourcePubkey,\n      targetPubkey\n    });\n  }\n}\nexport class CLRequestFactory {\n  static fromSerializedRequest(bytes) {\n    switch (bytes[0]) {\n      case CLRequestType.Deposit:\n        return DepositRequest.deserialize(bytes);\n      case CLRequestType.Withdrawal:\n        return WithdrawalRequest.deserialize(bytes);\n      case CLRequestType.Consolidation:\n        return ConsolidationRequest.deserialize(bytes);\n      default:\n        throw Error(`Invalid request type=${bytes[0]}`);\n    }\n  }\n}\n//# sourceMappingURL=requests.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}