{"ast":null,"code":"import { InvalidAddressError } from '../../errors/address.js';\nimport { InvalidLegacyVError, InvalidSerializedTransactionError } from '../../errors/transaction.js';\nimport { isAddress } from '../address/isAddress.js';\nimport { toBlobSidecars } from '../blob/toBlobSidecars.js';\nimport { isHex } from '../data/isHex.js';\nimport { padHex } from '../data/pad.js';\nimport { trim } from '../data/trim.js';\nimport { hexToBigInt, hexToNumber } from '../encoding/fromHex.js';\nimport { fromRlp } from '../encoding/fromRlp.js';\nimport { isHash } from '../hash/isHash.js';\nimport { assertTransactionEIP1559, assertTransactionEIP2930, assertTransactionEIP4844, assertTransactionEIP7702, assertTransactionLegacy } from './assertTransaction.js';\nimport { getSerializedTransactionType } from './getSerializedTransactionType.js';\nexport function parseTransaction(serializedTransaction) {\n  const type = getSerializedTransactionType(serializedTransaction);\n  if (type === 'eip1559') return parseTransactionEIP1559(serializedTransaction);\n  if (type === 'eip2930') return parseTransactionEIP2930(serializedTransaction);\n  if (type === 'eip4844') return parseTransactionEIP4844(serializedTransaction);\n  if (type === 'eip7702') return parseTransactionEIP7702(serializedTransaction);\n  return parseTransactionLegacy(serializedTransaction);\n}\nfunction parseTransactionEIP7702(serializedTransaction) {\n  const transactionArray = toTransactionArray(serializedTransaction);\n  const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, authorizationList, v, r, s] = transactionArray;\n  if (transactionArray.length !== 10 && transactionArray.length !== 13) throw new InvalidSerializedTransactionError({\n    attributes: {\n      chainId,\n      nonce,\n      maxPriorityFeePerGas,\n      maxFeePerGas,\n      gas,\n      to,\n      value,\n      data,\n      accessList,\n      authorizationList,\n      ...(transactionArray.length > 9 ? {\n        v,\n        r,\n        s\n      } : {})\n    },\n    serializedTransaction,\n    type: 'eip7702'\n  });\n  const transaction = {\n    chainId: hexToNumber(chainId),\n    type: 'eip7702'\n  };\n  if (isHex(to) && to !== '0x') transaction.to = to;\n  if (isHex(gas) && gas !== '0x') transaction.gas = hexToBigInt(gas);\n  if (isHex(data) && data !== '0x') transaction.data = data;\n  if (isHex(nonce) && nonce !== '0x') transaction.nonce = hexToNumber(nonce);\n  if (isHex(value) && value !== '0x') transaction.value = hexToBigInt(value);\n  if (isHex(maxFeePerGas) && maxFeePerGas !== '0x') transaction.maxFeePerGas = hexToBigInt(maxFeePerGas);\n  if (isHex(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x') transaction.maxPriorityFeePerGas = hexToBigInt(maxPriorityFeePerGas);\n  if (accessList.length !== 0 && accessList !== '0x') transaction.accessList = parseAccessList(accessList);\n  if (authorizationList.length !== 0 && authorizationList !== '0x') transaction.authorizationList = parseAuthorizationList(authorizationList);\n  assertTransactionEIP7702(transaction);\n  const signature = transactionArray.length === 13 ? parseEIP155Signature(transactionArray) : undefined;\n  return {\n    ...signature,\n    ...transaction\n  };\n}\nfunction parseTransactionEIP4844(serializedTransaction) {\n  const transactionOrWrapperArray = toTransactionArray(serializedTransaction);\n  const hasNetworkWrapper = transactionOrWrapperArray.length === 4;\n  const transactionArray = hasNetworkWrapper ? transactionOrWrapperArray[0] : transactionOrWrapperArray;\n  const wrapperArray = hasNetworkWrapper ? transactionOrWrapperArray.slice(1) : [];\n  const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, maxFeePerBlobGas, blobVersionedHashes, v, r, s] = transactionArray;\n  const [blobs, commitments, proofs] = wrapperArray;\n  if (!(transactionArray.length === 11 || transactionArray.length === 14)) throw new InvalidSerializedTransactionError({\n    attributes: {\n      chainId,\n      nonce,\n      maxPriorityFeePerGas,\n      maxFeePerGas,\n      gas,\n      to,\n      value,\n      data,\n      accessList,\n      ...(transactionArray.length > 9 ? {\n        v,\n        r,\n        s\n      } : {})\n    },\n    serializedTransaction,\n    type: 'eip4844'\n  });\n  const transaction = {\n    blobVersionedHashes: blobVersionedHashes,\n    chainId: hexToNumber(chainId),\n    type: 'eip4844'\n  };\n  if (isHex(to) && to !== '0x') transaction.to = to;\n  if (isHex(gas) && gas !== '0x') transaction.gas = hexToBigInt(gas);\n  if (isHex(data) && data !== '0x') transaction.data = data;\n  if (isHex(nonce) && nonce !== '0x') transaction.nonce = hexToNumber(nonce);\n  if (isHex(value) && value !== '0x') transaction.value = hexToBigInt(value);\n  if (isHex(maxFeePerBlobGas) && maxFeePerBlobGas !== '0x') transaction.maxFeePerBlobGas = hexToBigInt(maxFeePerBlobGas);\n  if (isHex(maxFeePerGas) && maxFeePerGas !== '0x') transaction.maxFeePerGas = hexToBigInt(maxFeePerGas);\n  if (isHex(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x') transaction.maxPriorityFeePerGas = hexToBigInt(maxPriorityFeePerGas);\n  if (accessList.length !== 0 && accessList !== '0x') transaction.accessList = parseAccessList(accessList);\n  if (blobs && commitments && proofs) transaction.sidecars = toBlobSidecars({\n    blobs: blobs,\n    commitments: commitments,\n    proofs: proofs\n  });\n  assertTransactionEIP4844(transaction);\n  const signature = transactionArray.length === 14 ? parseEIP155Signature(transactionArray) : undefined;\n  return {\n    ...signature,\n    ...transaction\n  };\n}\nfunction parseTransactionEIP1559(serializedTransaction) {\n  const transactionArray = toTransactionArray(serializedTransaction);\n  const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, v, r, s] = transactionArray;\n  if (!(transactionArray.length === 9 || transactionArray.length === 12)) throw new InvalidSerializedTransactionError({\n    attributes: {\n      chainId,\n      nonce,\n      maxPriorityFeePerGas,\n      maxFeePerGas,\n      gas,\n      to,\n      value,\n      data,\n      accessList,\n      ...(transactionArray.length > 9 ? {\n        v,\n        r,\n        s\n      } : {})\n    },\n    serializedTransaction,\n    type: 'eip1559'\n  });\n  const transaction = {\n    chainId: hexToNumber(chainId),\n    type: 'eip1559'\n  };\n  if (isHex(to) && to !== '0x') transaction.to = to;\n  if (isHex(gas) && gas !== '0x') transaction.gas = hexToBigInt(gas);\n  if (isHex(data) && data !== '0x') transaction.data = data;\n  if (isHex(nonce) && nonce !== '0x') transaction.nonce = hexToNumber(nonce);\n  if (isHex(value) && value !== '0x') transaction.value = hexToBigInt(value);\n  if (isHex(maxFeePerGas) && maxFeePerGas !== '0x') transaction.maxFeePerGas = hexToBigInt(maxFeePerGas);\n  if (isHex(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x') transaction.maxPriorityFeePerGas = hexToBigInt(maxPriorityFeePerGas);\n  if (accessList.length !== 0 && accessList !== '0x') transaction.accessList = parseAccessList(accessList);\n  assertTransactionEIP1559(transaction);\n  const signature = transactionArray.length === 12 ? parseEIP155Signature(transactionArray) : undefined;\n  return {\n    ...signature,\n    ...transaction\n  };\n}\nfunction parseTransactionEIP2930(serializedTransaction) {\n  const transactionArray = toTransactionArray(serializedTransaction);\n  const [chainId, nonce, gasPrice, gas, to, value, data, accessList, v, r, s] = transactionArray;\n  if (!(transactionArray.length === 8 || transactionArray.length === 11)) throw new InvalidSerializedTransactionError({\n    attributes: {\n      chainId,\n      nonce,\n      gasPrice,\n      gas,\n      to,\n      value,\n      data,\n      accessList,\n      ...(transactionArray.length > 8 ? {\n        v,\n        r,\n        s\n      } : {})\n    },\n    serializedTransaction,\n    type: 'eip2930'\n  });\n  const transaction = {\n    chainId: hexToNumber(chainId),\n    type: 'eip2930'\n  };\n  if (isHex(to) && to !== '0x') transaction.to = to;\n  if (isHex(gas) && gas !== '0x') transaction.gas = hexToBigInt(gas);\n  if (isHex(data) && data !== '0x') transaction.data = data;\n  if (isHex(nonce) && nonce !== '0x') transaction.nonce = hexToNumber(nonce);\n  if (isHex(value) && value !== '0x') transaction.value = hexToBigInt(value);\n  if (isHex(gasPrice) && gasPrice !== '0x') transaction.gasPrice = hexToBigInt(gasPrice);\n  if (accessList.length !== 0 && accessList !== '0x') transaction.accessList = parseAccessList(accessList);\n  assertTransactionEIP2930(transaction);\n  const signature = transactionArray.length === 11 ? parseEIP155Signature(transactionArray) : undefined;\n  return {\n    ...signature,\n    ...transaction\n  };\n}\nfunction parseTransactionLegacy(serializedTransaction) {\n  const transactionArray = fromRlp(serializedTransaction, 'hex');\n  const [nonce, gasPrice, gas, to, value, data, chainIdOrV_, r, s] = transactionArray;\n  if (!(transactionArray.length === 6 || transactionArray.length === 9)) throw new InvalidSerializedTransactionError({\n    attributes: {\n      nonce,\n      gasPrice,\n      gas,\n      to,\n      value,\n      data,\n      ...(transactionArray.length > 6 ? {\n        v: chainIdOrV_,\n        r,\n        s\n      } : {})\n    },\n    serializedTransaction,\n    type: 'legacy'\n  });\n  const transaction = {\n    type: 'legacy'\n  };\n  if (isHex(to) && to !== '0x') transaction.to = to;\n  if (isHex(gas) && gas !== '0x') transaction.gas = hexToBigInt(gas);\n  if (isHex(data) && data !== '0x') transaction.data = data;\n  if (isHex(nonce) && nonce !== '0x') transaction.nonce = hexToNumber(nonce);\n  if (isHex(value) && value !== '0x') transaction.value = hexToBigInt(value);\n  if (isHex(gasPrice) && gasPrice !== '0x') transaction.gasPrice = hexToBigInt(gasPrice);\n  assertTransactionLegacy(transaction);\n  if (transactionArray.length === 6) return transaction;\n  const chainIdOrV = isHex(chainIdOrV_) && chainIdOrV_ !== '0x' ? hexToBigInt(chainIdOrV_) : 0n;\n  if (s === '0x' && r === '0x') {\n    if (chainIdOrV > 0) transaction.chainId = Number(chainIdOrV);\n    return transaction;\n  }\n  const v = chainIdOrV;\n  const chainId = Number((v - 35n) / 2n);\n  if (chainId > 0) transaction.chainId = chainId;else if (v !== 27n && v !== 28n) throw new InvalidLegacyVError({\n    v\n  });\n  transaction.v = v;\n  transaction.s = s;\n  transaction.r = r;\n  transaction.yParity = v % 2n === 0n ? 1 : 0;\n  return transaction;\n}\nexport function toTransactionArray(serializedTransaction) {\n  return fromRlp(`0x${serializedTransaction.slice(4)}`, 'hex');\n}\nexport function parseAccessList(accessList_) {\n  const accessList = [];\n  for (let i = 0; i < accessList_.length; i++) {\n    const [address, storageKeys] = accessList_[i];\n    if (!isAddress(address, {\n      strict: false\n    })) throw new InvalidAddressError({\n      address\n    });\n    accessList.push({\n      address: address,\n      storageKeys: storageKeys.map(key => isHash(key) ? key : trim(key))\n    });\n  }\n  return accessList;\n}\nfunction parseAuthorizationList(serializedAuthorizationList) {\n  const authorizationList = [];\n  for (let i = 0; i < serializedAuthorizationList.length; i++) {\n    const [chainId, contractAddress, nonce, yParity, r, s] = serializedAuthorizationList[i];\n    authorizationList.push({\n      chainId: hexToNumber(chainId),\n      contractAddress,\n      nonce: hexToNumber(nonce),\n      ...parseEIP155Signature([yParity, r, s])\n    });\n  }\n  return authorizationList;\n}\nfunction parseEIP155Signature(transactionArray) {\n  const signature = transactionArray.slice(-3);\n  const v = signature[0] === '0x' || hexToBigInt(signature[0]) === 0n ? 27n : 28n;\n  return {\n    r: padHex(signature[1], {\n      size: 32\n    }),\n    s: padHex(signature[2], {\n      size: 32\n    }),\n    v,\n    yParity: v === 27n ? 0 : 1\n  };\n}\n//# sourceMappingURL=parseTransaction.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}