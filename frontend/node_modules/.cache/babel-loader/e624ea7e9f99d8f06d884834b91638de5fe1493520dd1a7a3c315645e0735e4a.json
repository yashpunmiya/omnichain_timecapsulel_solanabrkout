{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst fountainDecoder_1 = __importDefault(require(\"./fountainDecoder\"));\nconst bytewords_1 = __importDefault(require(\"./bytewords\"));\nconst assert_1 = __importDefault(require(\"assert\"));\nconst utils_1 = require(\"./utils\");\nconst errors_1 = require(\"./errors\");\nconst ur_1 = __importDefault(require(\"./ur\"));\nconst fountainEncoder_1 = require(\"./fountainEncoder\");\nclass URDecoder {\n  constructor(fountainDecoder = new fountainDecoder_1.default(), type = 'bytes') {\n    this.fountainDecoder = fountainDecoder;\n    this.type = type;\n    assert_1.default(utils_1.isURType(type), 'Invalid UR type');\n    this.expected_type = '';\n  }\n  static decodeBody(type, message) {\n    const cbor = bytewords_1.default.decode(message, bytewords_1.default.STYLES.MINIMAL);\n    return new ur_1.default(Buffer.from(cbor, 'hex'), type);\n  }\n  validatePart(type) {\n    if (this.expected_type) {\n      return this.expected_type === type;\n    }\n    if (!utils_1.isURType(type)) {\n      return false;\n    }\n    this.expected_type = type;\n    return true;\n  }\n  static decode(message) {\n    const [type, components] = this.parse(message);\n    if (components.length === 0) {\n      throw new errors_1.InvalidPathLengthError();\n    }\n    const body = components[0];\n    return URDecoder.decodeBody(type, body);\n  }\n  static parse(message) {\n    const lowercase = message.toLowerCase();\n    const prefix = lowercase.slice(0, 3);\n    if (prefix !== 'ur:') {\n      throw new errors_1.InvalidSchemeError();\n    }\n    const components = lowercase.slice(3).split('/');\n    const type = components[0];\n    if (components.length < 2) {\n      throw new errors_1.InvalidPathLengthError();\n    }\n    if (!utils_1.isURType(type)) {\n      throw new errors_1.InvalidTypeError();\n    }\n    return [type, components.slice(1)];\n  }\n  static parseSequenceComponent(s) {\n    const components = s.split('-');\n    if (components.length !== 2) {\n      throw new errors_1.InvalidSequenceComponentError();\n    }\n    const seqNum = utils_1.toUint32(Number(components[0]));\n    const seqLength = Number(components[1]);\n    if (seqNum < 1 || seqLength < 1) {\n      throw new errors_1.InvalidSequenceComponentError();\n    }\n    return [seqNum, seqLength];\n  }\n  receivePart(s) {\n    if (this.result !== undefined) {\n      return false;\n    }\n    const [type, components] = URDecoder.parse(s);\n    if (!this.validatePart(type)) {\n      return false;\n    }\n    // If this is a single-part UR then we're done\n    if (components.length === 1) {\n      this.result = URDecoder.decodeBody(type, components[0]);\n      return true;\n    }\n    if (components.length !== 2) {\n      throw new errors_1.InvalidPathLengthError();\n    }\n    const [seq, fragment] = components;\n    const [seqNum, seqLength] = URDecoder.parseSequenceComponent(seq);\n    const cbor = bytewords_1.default.decode(fragment, bytewords_1.default.STYLES.MINIMAL);\n    const part = fountainEncoder_1.FountainEncoderPart.fromCBOR(cbor);\n    if (seqNum !== part.seqNum || seqLength !== part.seqLength) {\n      return false;\n    }\n    if (!this.fountainDecoder.receivePart(part)) {\n      return false;\n    }\n    if (this.fountainDecoder.isSuccess()) {\n      this.result = new ur_1.default(this.fountainDecoder.resultMessage(), type);\n    } else if (this.fountainDecoder.isFailure()) {\n      this.error = new errors_1.InvalidSchemeError();\n    }\n    return true;\n  }\n  resultUR() {\n    return this.result ? this.result : new ur_1.default(Buffer.from([]));\n  }\n  isComplete() {\n    return this.result && this.result.cbor.length > 0;\n  }\n  isSuccess() {\n    return !this.error && this.isComplete();\n  }\n  isError() {\n    return this.error !== undefined;\n  }\n  resultError() {\n    return this.error ? this.error.message : '';\n  }\n  expectedPartCount() {\n    return this.fountainDecoder.expectedPartCount();\n  }\n  expectedPartIndexes() {\n    return this.fountainDecoder.getExpectedPartIndexes();\n  }\n  receivedPartIndexes() {\n    return this.fountainDecoder.getReceivedPartIndexes();\n  }\n  lastPartIndexes() {\n    return this.fountainDecoder.getLastPartIndexes();\n  }\n  estimatedPercentComplete() {\n    return this.fountainDecoder.estimatedPercentComplete();\n  }\n  getProgress() {\n    return this.fountainDecoder.getProgress();\n  }\n}\nexports.default = URDecoder;","map":{"version":3,"names":["fountainDecoder_1","__importDefault","require","bytewords_1","assert_1","utils_1","errors_1","ur_1","fountainEncoder_1","URDecoder","constructor","fountainDecoder","default","type","isURType","expected_type","decodeBody","message","cbor","decode","STYLES","MINIMAL","Buffer","from","validatePart","components","parse","length","InvalidPathLengthError","body","lowercase","toLowerCase","prefix","slice","InvalidSchemeError","split","InvalidTypeError","parseSequenceComponent","s","InvalidSequenceComponentError","seqNum","toUint32","Number","seqLength","receivePart","result","undefined","seq","fragment","part","FountainEncoderPart","fromCBOR","isSuccess","resultMessage","isFailure","error","resultUR","isComplete","isError","resultError","expectedPartCount","expectedPartIndexes","getExpectedPartIndexes","receivedPartIndexes","getReceivedPartIndexes","lastPartIndexes","getLastPartIndexes","estimatedPercentComplete","getProgress","exports"],"sources":["C:\\Users\\yyash\\Coding\\solana-brkout\\frontend\\node_modules\\@ngraveio\\bc-ur\\src\\urDecoder.ts"],"sourcesContent":["import FountainDecoder from './fountainDecoder';\nimport bytewords from './bytewords';\nimport assert from 'assert';\nimport { isURType, toUint32 } from './utils';\nimport { InvalidSchemeError, InvalidPathLengthError, InvalidTypeError, InvalidSequenceComponentError } from './errors';\nimport UR from './ur';\nimport { FountainEncoderPart } from './fountainEncoder';\n\nexport default class URDecoder {\n  private expected_type: string;\n  private result: UR | undefined;\n  private error: Error | undefined;\n\n  constructor(\n    private fountainDecoder: FountainDecoder = new FountainDecoder(),\n    public type: string = 'bytes'\n  ) {\n    assert(isURType(type), 'Invalid UR type');\n\n    this.expected_type = '';\n  }\n\n  private static decodeBody(type: string, message: string): UR {\n    const cbor = bytewords.decode(message, bytewords.STYLES.MINIMAL);\n\n    return new UR(Buffer.from(cbor, 'hex'), type);\n  }\n\n  private validatePart(type: string): boolean {\n    if (this.expected_type) {\n      return this.expected_type === type;\n    }\n\n    if (!isURType(type)) {\n      return false;\n    }\n\n    this.expected_type = type;\n\n    return true;\n  }\n\n  public static decode(message: string): UR {\n    const [type, components] = this.parse(message);\n\n    if (components.length === 0) {\n      throw new InvalidPathLengthError();\n    }\n\n    const body = components[0];\n\n    return URDecoder.decodeBody(type, body);\n  }\n\n  public static parse(message: string): [string, string[]] {\n    const lowercase = message.toLowerCase();\n    const prefix = lowercase.slice(0, 3);\n\n    if (prefix !== 'ur:') {\n      throw new InvalidSchemeError();\n    }\n\n    const components = lowercase.slice(3).split('/')\n    const type = components[0];\n\n    if (components.length < 2) {\n      throw new InvalidPathLengthError();\n    }\n\n    if (!isURType(type)) {\n      throw new InvalidTypeError();\n    }\n\n    return [type, components.slice(1)]\n  }\n\n  public static parseSequenceComponent(s: string) {\n    const components = s.split('-');\n\n    if (components.length !== 2) {\n      throw new InvalidSequenceComponentError();\n    }\n\n    const seqNum = toUint32(Number(components[0]));\n    const seqLength = Number(components[1]);\n\n    if (seqNum < 1 || seqLength < 1) {\n      throw new InvalidSequenceComponentError();\n    }\n\n    return [seqNum, seqLength];\n  }\n\n  public receivePart(s: string): boolean {\n    if (this.result !== undefined) {\n      return false;\n    }\n\n    const [type, components] = URDecoder.parse(s)\n\n    if (!this.validatePart(type)) {\n      return false;\n    }\n\n    // If this is a single-part UR then we're done\n    if (components.length === 1) {\n      this.result = URDecoder.decodeBody(type, components[0])\n\n      return true;\n    }\n\n    if (components.length !== 2) {\n      throw new InvalidPathLengthError();\n    }\n\n    const [seq, fragment] = components;\n    const [seqNum, seqLength] = URDecoder.parseSequenceComponent(seq);\n    const cbor = bytewords.decode(fragment, bytewords.STYLES.MINIMAL);\n    const part = FountainEncoderPart.fromCBOR(cbor);\n\n    if (seqNum !== part.seqNum || seqLength !== part.seqLength) {\n      return false;\n    }\n\n    if (!this.fountainDecoder.receivePart(part)) {\n      return false;\n    }\n\n    if (this.fountainDecoder.isSuccess()) {\n      this.result = new UR(this.fountainDecoder.resultMessage(), type);\n    }\n    else if (this.fountainDecoder.isFailure()) {\n      this.error = new InvalidSchemeError();\n    }\n\n    return true;\n  }\n\n  public resultUR(): UR {\n    return this.result ? this.result : new UR(Buffer.from([]));\n  }\n\n  public isComplete(): boolean {\n    return this.result && this.result.cbor.length > 0;\n  }\n\n  public isSuccess(): boolean {\n    return !this.error && this.isComplete();\n  }\n\n  public isError(): boolean {\n    return this.error !== undefined;\n  }\n\n  public resultError() {\n    return this.error ? this.error.message : '';\n  }\n\n  public expectedPartCount() {\n    return this.fountainDecoder.expectedPartCount();\n  }\n\n  public expectedPartIndexes() {\n    return this.fountainDecoder.getExpectedPartIndexes();\n  }\n\n  public receivedPartIndexes() {\n    return this.fountainDecoder.getReceivedPartIndexes();\n  }\n\n  public lastPartIndexes() {\n    return this.fountainDecoder.getLastPartIndexes();\n  }\n\n  public estimatedPercentComplete() {\n    return this.fountainDecoder.estimatedPercentComplete();\n  }\n\n  public getProgress() {\n    return this.fountainDecoder.getProgress();\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}