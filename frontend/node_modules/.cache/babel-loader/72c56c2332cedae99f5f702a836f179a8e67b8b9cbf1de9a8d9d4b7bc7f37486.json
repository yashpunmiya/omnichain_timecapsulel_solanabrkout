{"ast":null,"code":"import { InvalidLegacyVError } from '../../errors/transaction.js';\nimport { blobsToCommitments } from '../blob/blobsToCommitments.js';\nimport { blobsToProofs } from '../blob/blobsToProofs.js';\nimport { commitmentsToVersionedHashes } from '../blob/commitmentsToVersionedHashes.js';\nimport { toBlobSidecars } from '../blob/toBlobSidecars.js';\nimport { concatHex } from '../data/concat.js';\nimport { trim } from '../data/trim.js';\nimport { bytesToHex, toHex } from '../encoding/toHex.js';\nimport { toRlp } from '../encoding/toRlp.js';\nimport { serializeAuthorizationList } from '../../experimental/eip7702/utils/serializeAuthorizationList.js';\nimport { assertTransactionEIP1559, assertTransactionEIP2930, assertTransactionEIP4844, assertTransactionEIP7702, assertTransactionLegacy } from './assertTransaction.js';\nimport { getTransactionType } from './getTransactionType.js';\nimport { serializeAccessList } from './serializeAccessList.js';\nexport function serializeTransaction(transaction, signature) {\n  const type = getTransactionType(transaction);\n  if (type === 'eip1559') return serializeTransactionEIP1559(transaction, signature);\n  if (type === 'eip2930') return serializeTransactionEIP2930(transaction, signature);\n  if (type === 'eip4844') return serializeTransactionEIP4844(transaction, signature);\n  if (type === 'eip7702') return serializeTransactionEIP7702(transaction, signature);\n  return serializeTransactionLegacy(transaction, signature);\n}\nfunction serializeTransactionEIP7702(transaction, signature) {\n  const {\n    authorizationList,\n    chainId,\n    gas,\n    nonce,\n    to,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    accessList,\n    data\n  } = transaction;\n  assertTransactionEIP7702(transaction);\n  const serializedAccessList = serializeAccessList(accessList);\n  const serializedAuthorizationList = serializeAuthorizationList(authorizationList);\n  return concatHex(['0x04', toRlp([toHex(chainId), nonce ? toHex(nonce) : '0x', maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : '0x', maxFeePerGas ? toHex(maxFeePerGas) : '0x', gas ? toHex(gas) : '0x', to ?? '0x', value ? toHex(value) : '0x', data ?? '0x', serializedAccessList, serializedAuthorizationList, ...toYParitySignatureArray(transaction, signature)])]);\n}\nfunction serializeTransactionEIP4844(transaction, signature) {\n  const {\n    chainId,\n    gas,\n    nonce,\n    to,\n    value,\n    maxFeePerBlobGas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    accessList,\n    data\n  } = transaction;\n  assertTransactionEIP4844(transaction);\n  let blobVersionedHashes = transaction.blobVersionedHashes;\n  let sidecars = transaction.sidecars;\n  // If `blobs` are passed, we will need to compute the KZG commitments & proofs.\n  if (transaction.blobs && (typeof blobVersionedHashes === 'undefined' || typeof sidecars === 'undefined')) {\n    const blobs = typeof transaction.blobs[0] === 'string' ? transaction.blobs : transaction.blobs.map(x => bytesToHex(x));\n    const kzg = transaction.kzg;\n    const commitments = blobsToCommitments({\n      blobs,\n      kzg\n    });\n    if (typeof blobVersionedHashes === 'undefined') blobVersionedHashes = commitmentsToVersionedHashes({\n      commitments\n    });\n    if (typeof sidecars === 'undefined') {\n      const proofs = blobsToProofs({\n        blobs,\n        commitments,\n        kzg\n      });\n      sidecars = toBlobSidecars({\n        blobs,\n        commitments,\n        proofs\n      });\n    }\n  }\n  const serializedAccessList = serializeAccessList(accessList);\n  const serializedTransaction = [toHex(chainId), nonce ? toHex(nonce) : '0x', maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : '0x', maxFeePerGas ? toHex(maxFeePerGas) : '0x', gas ? toHex(gas) : '0x', to ?? '0x', value ? toHex(value) : '0x', data ?? '0x', serializedAccessList, maxFeePerBlobGas ? toHex(maxFeePerBlobGas) : '0x', blobVersionedHashes ?? [], ...toYParitySignatureArray(transaction, signature)];\n  const blobs = [];\n  const commitments = [];\n  const proofs = [];\n  if (sidecars) for (let i = 0; i < sidecars.length; i++) {\n    const {\n      blob,\n      commitment,\n      proof\n    } = sidecars[i];\n    blobs.push(blob);\n    commitments.push(commitment);\n    proofs.push(proof);\n  }\n  return concatHex(['0x03', sidecars ?\n  // If sidecars are enabled, envelope turns into a \"wrapper\":\n  toRlp([serializedTransaction, blobs, commitments, proofs]) :\n  // If sidecars are disabled, standard envelope is used:\n  toRlp(serializedTransaction)]);\n}\nfunction serializeTransactionEIP1559(transaction, signature) {\n  const {\n    chainId,\n    gas,\n    nonce,\n    to,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    accessList,\n    data\n  } = transaction;\n  assertTransactionEIP1559(transaction);\n  const serializedAccessList = serializeAccessList(accessList);\n  const serializedTransaction = [toHex(chainId), nonce ? toHex(nonce) : '0x', maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : '0x', maxFeePerGas ? toHex(maxFeePerGas) : '0x', gas ? toHex(gas) : '0x', to ?? '0x', value ? toHex(value) : '0x', data ?? '0x', serializedAccessList, ...toYParitySignatureArray(transaction, signature)];\n  return concatHex(['0x02', toRlp(serializedTransaction)]);\n}\nfunction serializeTransactionEIP2930(transaction, signature) {\n  const {\n    chainId,\n    gas,\n    data,\n    nonce,\n    to,\n    value,\n    accessList,\n    gasPrice\n  } = transaction;\n  assertTransactionEIP2930(transaction);\n  const serializedAccessList = serializeAccessList(accessList);\n  const serializedTransaction = [toHex(chainId), nonce ? toHex(nonce) : '0x', gasPrice ? toHex(gasPrice) : '0x', gas ? toHex(gas) : '0x', to ?? '0x', value ? toHex(value) : '0x', data ?? '0x', serializedAccessList, ...toYParitySignatureArray(transaction, signature)];\n  return concatHex(['0x01', toRlp(serializedTransaction)]);\n}\nfunction serializeTransactionLegacy(transaction, signature) {\n  const {\n    chainId = 0,\n    gas,\n    data,\n    nonce,\n    to,\n    value,\n    gasPrice\n  } = transaction;\n  assertTransactionLegacy(transaction);\n  let serializedTransaction = [nonce ? toHex(nonce) : '0x', gasPrice ? toHex(gasPrice) : '0x', gas ? toHex(gas) : '0x', to ?? '0x', value ? toHex(value) : '0x', data ?? '0x'];\n  if (signature) {\n    const v = (() => {\n      // EIP-155 (inferred chainId)\n      if (signature.v >= 35n) {\n        const inferredChainId = (signature.v - 35n) / 2n;\n        if (inferredChainId > 0) return signature.v;\n        return 27n + (signature.v === 35n ? 0n : 1n);\n      }\n      // EIP-155 (explicit chainId)\n      if (chainId > 0) return BigInt(chainId * 2) + BigInt(35n + signature.v - 27n);\n      // Pre-EIP-155 (no chainId)\n      const v = 27n + (signature.v === 27n ? 0n : 1n);\n      if (signature.v !== v) throw new InvalidLegacyVError({\n        v: signature.v\n      });\n      return v;\n    })();\n    const r = trim(signature.r);\n    const s = trim(signature.s);\n    serializedTransaction = [...serializedTransaction, toHex(v), r === '0x00' ? '0x' : r, s === '0x00' ? '0x' : s];\n  } else if (chainId > 0) {\n    serializedTransaction = [...serializedTransaction, toHex(chainId), '0x', '0x'];\n  }\n  return toRlp(serializedTransaction);\n}\nexport function toYParitySignatureArray(transaction, signature_) {\n  const signature = signature_ ?? transaction;\n  const {\n    v,\n    yParity\n  } = signature;\n  if (typeof signature.r === 'undefined') return [];\n  if (typeof signature.s === 'undefined') return [];\n  if (typeof v === 'undefined' && typeof yParity === 'undefined') return [];\n  const r = trim(signature.r);\n  const s = trim(signature.s);\n  const yParity_ = (() => {\n    if (typeof yParity === 'number') return yParity ? toHex(1) : '0x';\n    if (v === 0n) return '0x';\n    if (v === 1n) return toHex(1);\n    return v === 27n ? '0x' : toHex(1);\n  })();\n  return [yParity_, r === '0x00' ? '0x' : r, s === '0x00' ? '0x' : s];\n}\n//# sourceMappingURL=serializeTransaction.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}