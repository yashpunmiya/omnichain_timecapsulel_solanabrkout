{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Deref = Deref;\nconst type_1 = require(\"../clone/type\");\nconst index_1 = require(\"../discard/index\");\nconst value_1 = require(\"../guard/value\");\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nconst kind_1 = require(\"../guard/kind\");\nfunction FromRest(schema, references) {\n  return schema.map(schema => Deref(schema, references));\n}\n// prettier-ignore\nfunction FromProperties(properties, references) {\n  const Acc = {};\n  for (const K of globalThis.Object.getOwnPropertyNames(properties)) {\n    Acc[K] = Deref(properties[K], references);\n  }\n  return Acc;\n}\n// prettier-ignore\nfunction FromConstructor(schema, references) {\n  schema.parameters = FromRest(schema.parameters, references);\n  schema.returns = Deref(schema.returns, references);\n  return schema;\n}\n// prettier-ignore\nfunction FromFunction(schema, references) {\n  schema.parameters = FromRest(schema.parameters, references);\n  schema.returns = Deref(schema.returns, references);\n  return schema;\n}\n// prettier-ignore\nfunction FromIntersect(schema, references) {\n  schema.allOf = FromRest(schema.allOf, references);\n  return schema;\n}\n// prettier-ignore\nfunction FromUnion(schema, references) {\n  schema.anyOf = FromRest(schema.anyOf, references);\n  return schema;\n}\n// prettier-ignore\nfunction FromTuple(schema, references) {\n  if ((0, value_1.IsUndefined)(schema.items)) return schema;\n  schema.items = FromRest(schema.items, references);\n  return schema;\n}\n// prettier-ignore\nfunction FromArray(schema, references) {\n  schema.items = Deref(schema.items, references);\n  return schema;\n}\n// prettier-ignore\nfunction FromObject(schema, references) {\n  schema.properties = FromProperties(schema.properties, references);\n  return schema;\n}\n// prettier-ignore\nfunction FromPromise(schema, references) {\n  schema.item = Deref(schema.item, references);\n  return schema;\n}\n// prettier-ignore\nfunction FromAsyncIterator(schema, references) {\n  schema.items = Deref(schema.items, references);\n  return schema;\n}\n// prettier-ignore\nfunction FromIterator(schema, references) {\n  schema.items = Deref(schema.items, references);\n  return schema;\n}\n// prettier-ignore\nfunction FromRef(schema, references) {\n  const target = references.find(remote => remote.$id === schema.$ref);\n  if (target === undefined) throw Error(`Unable to dereference schema with $id ${schema.$ref}`);\n  const discard = (0, index_1.Discard)(target, ['$id']);\n  return Deref(discard, references);\n}\n// prettier-ignore\nfunction DerefResolve(schema, references) {\n  return (0, kind_1.IsConstructor)(schema) ? FromConstructor(schema, references) : (0, kind_1.IsFunction)(schema) ? FromFunction(schema, references) : (0, kind_1.IsIntersect)(schema) ? FromIntersect(schema, references) : (0, kind_1.IsUnion)(schema) ? FromUnion(schema, references) : (0, kind_1.IsTuple)(schema) ? FromTuple(schema, references) : (0, kind_1.IsArray)(schema) ? FromArray(schema, references) : (0, kind_1.IsObject)(schema) ? FromObject(schema, references) : (0, kind_1.IsPromise)(schema) ? FromPromise(schema, references) : (0, kind_1.IsAsyncIterator)(schema) ? FromAsyncIterator(schema, references) : (0, kind_1.IsIterator)(schema) ? FromIterator(schema, references) : (0, kind_1.IsRef)(schema) ? FromRef(schema, references) : schema;\n}\n// ------------------------------------------------------------------\n// TDeref\n// ------------------------------------------------------------------\n/** `[Json]` Creates a dereferenced type */\nfunction Deref(schema, references) {\n  return DerefResolve((0, type_1.CloneType)(schema), (0, type_1.CloneRest)(references));\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}