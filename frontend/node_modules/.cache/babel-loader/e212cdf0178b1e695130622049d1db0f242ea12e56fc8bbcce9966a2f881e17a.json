{"ast":null,"code":"import { encodeEventTopics } from '../../utils/abi/encodeEventTopics.js';\nimport { observe } from '../../utils/observe.js';\nimport { poll } from '../../utils/poll.js';\nimport { stringify } from '../../utils/stringify.js';\nimport { DecodeLogDataMismatch, DecodeLogTopicsMismatch } from '../../errors/abi.js';\nimport { InvalidInputRpcError } from '../../errors/rpc.js';\nimport { decodeEventLog } from '../../utils/abi/decodeEventLog.js';\nimport { formatLog } from '../../utils/formatters/log.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { createEventFilter } from './createEventFilter.js';\nimport { getBlockNumber } from './getBlockNumber.js';\nimport { getFilterChanges } from './getFilterChanges.js';\nimport { getLogs } from './getLogs.js';\nimport { uninstallFilter } from './uninstallFilter.js';\n/**\n * Watches and returns emitted [Event Logs](https://viem.sh/docs/glossary/terms#event-log).\n *\n * - Docs: https://viem.sh/docs/actions/public/watchEvent\n * - JSON-RPC Methods:\n *   - **RPC Provider supports `eth_newFilter`:**\n *     - Calls [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) to create a filter (called on initialize).\n *     - On a polling interval, it will call [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges).\n *   - **RPC Provider does not support `eth_newFilter`:**\n *     - Calls [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) for each block between the polling interval.\n *\n * This Action will batch up all the Event Logs found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchEvent#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/actions/public/watchEvent#onLogs).\n *\n * `watchEvent` will attempt to create an [Event Filter](https://viem.sh/docs/actions/public/createEventFilter) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs) instead.\n *\n * @param client - Client to use\n * @param parameters - {@link WatchEventParameters}\n * @returns A function that can be invoked to stop watching for new Event Logs. {@link WatchEventReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { watchEvent } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = watchEvent(client, {\n *   onLogs: (logs) => console.log(logs),\n * })\n */\nexport function watchEvent(client, {\n  address,\n  args,\n  batch = true,\n  event,\n  events,\n  fromBlock,\n  onError,\n  onLogs,\n  poll: poll_,\n  pollingInterval = client.pollingInterval,\n  strict: strict_\n}) {\n  const enablePolling = (() => {\n    if (typeof poll_ !== 'undefined') return poll_;\n    if (typeof fromBlock === 'bigint') return true;\n    if (client.transport.type === 'webSocket') return false;\n    if (client.transport.type === 'fallback' && client.transport.transports[0].config.type === 'webSocket') return false;\n    return true;\n  })();\n  const strict = strict_ ?? false;\n  const pollEvent = () => {\n    const observerId = stringify(['watchEvent', address, args, batch, client.uid, event, pollingInterval, fromBlock]);\n    return observe(observerId, {\n      onLogs,\n      onError\n    }, emit => {\n      let previousBlockNumber;\n      if (fromBlock !== undefined) previousBlockNumber = fromBlock - 1n;\n      let filter;\n      let initialized = false;\n      const unwatch = poll(async () => {\n        if (!initialized) {\n          try {\n            filter = await getAction(client, createEventFilter, 'createEventFilter')({\n              address,\n              args,\n              event: event,\n              events,\n              strict,\n              fromBlock\n            });\n          } catch {}\n          initialized = true;\n          return;\n        }\n        try {\n          let logs;\n          if (filter) {\n            logs = await getAction(client, getFilterChanges, 'getFilterChanges')({\n              filter\n            });\n          } else {\n            // If the filter doesn't exist, we will fall back to use `getLogs`.\n            // The fall back exists because some RPC Providers do not support filters.\n            // Fetch the block number to use for `getLogs`.\n            const blockNumber = await getAction(client, getBlockNumber, 'getBlockNumber')({});\n            // If the block number has changed, we will need to fetch the logs.\n            // If the block number doesn't exist, we are yet to reach the first poll interval,\n            // so do not emit any logs.\n            if (previousBlockNumber && previousBlockNumber !== blockNumber) {\n              logs = await getAction(client, getLogs, 'getLogs')({\n                address,\n                args,\n                event: event,\n                events,\n                fromBlock: previousBlockNumber + 1n,\n                toBlock: blockNumber\n              });\n            } else {\n              logs = [];\n            }\n            previousBlockNumber = blockNumber;\n          }\n          if (logs.length === 0) return;\n          if (batch) emit.onLogs(logs);else for (const log of logs) emit.onLogs([log]);\n        } catch (err) {\n          // If a filter has been set and gets uninstalled, providers will throw an InvalidInput error.\n          // Reinitialize the filter when this occurs\n          if (filter && err instanceof InvalidInputRpcError) initialized = false;\n          emit.onError?.(err);\n        }\n      }, {\n        emitOnBegin: true,\n        interval: pollingInterval\n      });\n      return async () => {\n        if (filter) await getAction(client, uninstallFilter, 'uninstallFilter')({\n          filter\n        });\n        unwatch();\n      };\n    });\n  };\n  const subscribeEvent = () => {\n    let active = true;\n    let unsubscribe = () => active = false;\n    (async () => {\n      try {\n        const transport = (() => {\n          if (client.transport.type === 'fallback') {\n            const transport = client.transport.transports.find(transport => transport.config.type === 'webSocket');\n            if (!transport) return client.transport;\n            return transport.value;\n          }\n          return client.transport;\n        })();\n        const events_ = events ?? (event ? [event] : undefined);\n        let topics = [];\n        if (events_) {\n          const encoded = events_.flatMap(event => encodeEventTopics({\n            abi: [event],\n            eventName: event.name,\n            args\n          }));\n          // TODO: Clean up type casting\n          topics = [encoded];\n          if (event) topics = topics[0];\n        }\n        const {\n          unsubscribe: unsubscribe_\n        } = await transport.subscribe({\n          params: ['logs', {\n            address,\n            topics\n          }],\n          onData(data) {\n            if (!active) return;\n            const log = data.result;\n            try {\n              const {\n                eventName,\n                args\n              } = decodeEventLog({\n                abi: events_ ?? [],\n                data: log.data,\n                topics: log.topics,\n                strict\n              });\n              const formatted = formatLog(log, {\n                args,\n                eventName\n              });\n              onLogs([formatted]);\n            } catch (err) {\n              let eventName;\n              let isUnnamed;\n              if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {\n                // If strict mode is on, and log data/topics do not match event definition, skip.\n                if (strict_) return;\n                eventName = err.abiItem.name;\n                isUnnamed = err.abiItem.inputs?.some(x => !('name' in x && x.name));\n              }\n              // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).\n              const formatted = formatLog(log, {\n                args: isUnnamed ? [] : {},\n                eventName\n              });\n              onLogs([formatted]);\n            }\n          },\n          onError(error) {\n            onError?.(error);\n          }\n        });\n        unsubscribe = unsubscribe_;\n        if (!active) unsubscribe();\n      } catch (err) {\n        onError?.(err);\n      }\n    })();\n    return () => unsubscribe();\n  };\n  return enablePolling ? pollEvent() : subscribeEvent();\n}\n//# sourceMappingURL=watchEvent.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}