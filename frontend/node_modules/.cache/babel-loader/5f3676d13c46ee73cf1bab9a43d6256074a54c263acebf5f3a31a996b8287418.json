{"ast":null,"code":"import * as Bytes from './Bytes.js';\nimport * as Errors from './Errors.js';\nimport * as Hex from './Hex.js';\nimport * as Json from './Json.js';\n/**\n * Asserts that a {@link ox#PublicKey.PublicKey} is valid.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * PublicKey.assert({\n *   prefix: 4,\n *   y: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * })\n * // @error: PublicKey.InvalidError: Value \\`{\"y\":\"1\"}\\` is not a valid public key.\n * // @error: Public key must contain:\n * // @error: - an `x` and `prefix` value (compressed)\n * // @error: - an `x`, `y`, and `prefix` value (uncompressed)\n * ```\n *\n * @param publicKey - The public key object to assert.\n */\nexport function assert(publicKey, options = {}) {\n  const {\n    compressed\n  } = options;\n  const {\n    prefix,\n    x,\n    y\n  } = publicKey;\n  // Uncompressed\n  if (compressed === false || typeof x === 'bigint' && typeof y === 'bigint') {\n    if (prefix !== 4) throw new InvalidPrefixError({\n      prefix,\n      cause: new InvalidUncompressedPrefixError()\n    });\n    return;\n  }\n  // Compressed\n  if (compressed === true || typeof x === 'bigint' && typeof y === 'undefined') {\n    if (prefix !== 3 && prefix !== 2) throw new InvalidPrefixError({\n      prefix,\n      cause: new InvalidCompressedPrefixError()\n    });\n    return;\n  }\n  // Unknown/invalid\n  throw new InvalidError({\n    publicKey\n  });\n}\n/**\n * Compresses a {@link ox#PublicKey.PublicKey}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const compressed = PublicKey.compress(publicKey) // [!code focus]\n * // @log: {\n * // @log:   prefix: 3,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log: }\n * ```\n *\n * @param publicKey - The public key to compress.\n * @returns The compressed public key.\n */\nexport function compress(publicKey) {\n  const {\n    x,\n    y\n  } = publicKey;\n  return {\n    prefix: y % 2n === 0n ? 2 : 3,\n    x\n  };\n}\n/**\n * Instantiates a typed {@link ox#PublicKey.PublicKey} object from a {@link ox#PublicKey.PublicKey}, {@link ox#Bytes.Bytes}, or {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from('0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5')\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @param value - The public key value to instantiate.\n * @returns The instantiated {@link ox#PublicKey.PublicKey}.\n */\nexport function from(value) {\n  const publicKey = (() => {\n    if (Hex.validate(value)) return fromHex(value);\n    if (Bytes.validate(value)) return fromBytes(value);\n    const {\n      prefix,\n      x,\n      y\n    } = value;\n    if (typeof x === 'bigint' && typeof y === 'bigint') return {\n      prefix: prefix ?? 0x04,\n      x,\n      y\n    };\n    return {\n      prefix,\n      x\n    };\n  })();\n  assert(publicKey);\n  return publicKey;\n}\n/**\n * Deserializes a {@link ox#PublicKey.PublicKey} from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromBytes(new Uint8Array([128, 3, 131, ...]))\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @param publicKey - The serialized public key.\n * @returns The deserialized public key.\n */\nexport function fromBytes(publicKey) {\n  return fromHex(Hex.fromBytes(publicKey));\n}\n/**\n * Deserializes a {@link ox#PublicKey.PublicKey} from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromHex('0x8318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5')\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @example\n * ### Deserializing a Compressed Public Key\n *\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromHex('0x038318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed75')\n * // @log: {\n * // @log:   prefix: 3,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log: }\n * ```\n *\n * @param publicKey - The serialized public key.\n * @returns The deserialized public key.\n */\nexport function fromHex(publicKey) {\n  if (publicKey.length !== 132 && publicKey.length !== 130 && publicKey.length !== 68) throw new InvalidSerializedSizeError({\n    publicKey\n  });\n  if (publicKey.length === 130) {\n    const x = BigInt(Hex.slice(publicKey, 0, 32));\n    const y = BigInt(Hex.slice(publicKey, 32, 64));\n    return {\n      prefix: 4,\n      x,\n      y\n    };\n  }\n  if (publicKey.length === 132) {\n    const prefix = Number(Hex.slice(publicKey, 0, 1));\n    const x = BigInt(Hex.slice(publicKey, 1, 33));\n    const y = BigInt(Hex.slice(publicKey, 33, 65));\n    return {\n      prefix,\n      x,\n      y\n    };\n  }\n  const prefix = Number(Hex.slice(publicKey, 0, 1));\n  const x = BigInt(Hex.slice(publicKey, 1, 33));\n  return {\n    prefix,\n    x\n  };\n}\n/**\n * Serializes a {@link ox#PublicKey.PublicKey} to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const bytes = PublicKey.toBytes(publicKey) // [!code focus]\n * // @log: Uint8Array [128, 3, 131, ...]\n * ```\n *\n * @param publicKey - The public key to serialize.\n * @returns The serialized public key.\n */\nexport function toBytes(publicKey, options = {}) {\n  return Bytes.fromHex(toHex(publicKey, options));\n}\n/**\n * Serializes a {@link ox#PublicKey.PublicKey} to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const hex = PublicKey.toHex(publicKey) // [!code focus]\n * // @log: '0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5'\n * ```\n *\n * @param publicKey - The public key to serialize.\n * @returns The serialized public key.\n */\nexport function toHex(publicKey, options = {}) {\n  assert(publicKey);\n  const {\n    prefix,\n    x,\n    y\n  } = publicKey;\n  const {\n    includePrefix = true\n  } = options;\n  const publicKey_ = Hex.concat(includePrefix ? Hex.fromNumber(prefix, {\n    size: 1\n  }) : '0x', Hex.fromNumber(x, {\n    size: 32\n  }),\n  // If the public key is not compressed, add the y coordinate.\n  typeof y === 'bigint' ? Hex.fromNumber(y, {\n    size: 32\n  }) : '0x');\n  return publicKey_;\n}\n/**\n * Validates a {@link ox#PublicKey.PublicKey}. Returns `true` if valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const valid = PublicKey.validate({\n *   prefix: 4,\n *   y: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * })\n * // @log: false\n * ```\n *\n * @param publicKey - The public key object to assert.\n */\nexport function validate(publicKey, options = {}) {\n  try {\n    assert(publicKey, options);\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\n/**\n * Thrown when a public key is invalid.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * PublicKey.assert({ y: 1n })\n * // @error: PublicKey.InvalidError: Value `{\"y\":1n}` is not a valid public key.\n * // @error: Public key must contain:\n * // @error: - an `x` and `prefix` value (compressed)\n * // @error: - an `x`, `y`, and `prefix` value (uncompressed)\n * ```\n */\nexport class InvalidError extends Errors.BaseError {\n  constructor({\n    publicKey\n  }) {\n    super(`Value \\`${Json.stringify(publicKey)}\\` is not a valid public key.`, {\n      metaMessages: ['Public key must contain:', '- an `x` and `prefix` value (compressed)', '- an `x`, `y`, and `prefix` value (uncompressed)']\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'PublicKey.InvalidError'\n    });\n  }\n}\n/** Thrown when a public key has an invalid prefix. */\nexport class InvalidPrefixError extends Errors.BaseError {\n  constructor({\n    prefix,\n    cause\n  }) {\n    super(`Prefix \"${prefix}\" is invalid.`, {\n      cause\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'PublicKey.InvalidPrefixError'\n    });\n  }\n}\n/** Thrown when the public key has an invalid prefix for a compressed public key. */\nexport class InvalidCompressedPrefixError extends Errors.BaseError {\n  constructor() {\n    super('Prefix must be 2 or 3 for compressed public keys.');\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'PublicKey.InvalidCompressedPrefixError'\n    });\n  }\n}\n/** Thrown when the public key has an invalid prefix for an uncompressed public key. */\nexport class InvalidUncompressedPrefixError extends Errors.BaseError {\n  constructor() {\n    super('Prefix must be 4 for uncompressed public keys.');\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'PublicKey.InvalidUncompressedPrefixError'\n    });\n  }\n}\n/** Thrown when the public key has an invalid serialized size. */\nexport class InvalidSerializedSizeError extends Errors.BaseError {\n  constructor({\n    publicKey\n  }) {\n    super(`Value \\`${publicKey}\\` is an invalid public key size.`, {\n      metaMessages: ['Expected: 33 bytes (compressed + prefix), 64 bytes (uncompressed) or 65 bytes (uncompressed + prefix).', `Received ${Hex.size(Hex.from(publicKey))} bytes.`]\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'PublicKey.InvalidSerializedSizeError'\n    });\n  }\n}\n//# sourceMappingURL=PublicKey.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}