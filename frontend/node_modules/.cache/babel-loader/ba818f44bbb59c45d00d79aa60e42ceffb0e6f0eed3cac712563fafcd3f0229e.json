{"ast":null,"code":"import * as abitype from 'abitype';\nimport * as Address from './Address.js';\nimport * as Bytes from './Bytes.js';\nimport * as Errors from './Errors.js';\nimport * as Hex from './Hex.js';\nimport * as Solidity from './Solidity.js';\nimport * as internal from './internal/abiParameters.js';\nimport * as Cursor from './internal/cursor.js';\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function decode(parameters, data, options = {}) {\n  const {\n    as = 'Array',\n    checksumAddress = false\n  } = options;\n  const bytes = typeof data === 'string' ? Bytes.fromHex(data) : data;\n  const cursor = Cursor.create(bytes);\n  if (Bytes.size(bytes) === 0 && parameters.length > 0) throw new ZeroDataError();\n  if (Bytes.size(bytes) && Bytes.size(bytes) < 32) throw new DataSizeTooSmallError({\n    data: typeof data === 'string' ? data : Hex.fromBytes(data),\n    parameters: parameters,\n    size: Bytes.size(bytes)\n  });\n  let consumed = 0;\n  const values = as === 'Array' ? [] : {};\n  for (let i = 0; i < parameters.length; ++i) {\n    const param = parameters[i];\n    cursor.setPosition(consumed);\n    const [data, consumed_] = internal.decodeParameter(cursor, param, {\n      checksumAddress,\n      staticPosition: 0\n    });\n    consumed += consumed_;\n    if (as === 'Array') values.push(data);else values[param.name ?? i] = data;\n  }\n  return values;\n}\n/**\n * Encodes primitive values into ABI encoded data as per the [Application Binary Interface (ABI) Specification](https://docs.soliditylang.org/en/latest/abi-spec).\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.encode(\n *   AbiParameters.from(['string', 'uint', 'bool']),\n *   ['wagmi', 420n, true],\n * )\n * ```\n *\n * @example\n * ### JSON Parameters\n *\n * Specify **JSON ABI** Parameters as schema:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.encode(\n *   [\n *     { type: 'string', name: 'name' },\n *     { type: 'uint', name: 'age' },\n *     { type: 'bool', name: 'isOwner' },\n *   ],\n *   ['wagmi', 420n, true],\n * )\n * ```\n *\n * @param parameters - The set of ABI parameters to encode, in the shape of the `inputs` or `outputs` attribute of an ABI Item. These parameters must include valid [ABI types](https://docs.soliditylang.org/en/latest/types.html).\n * @param values - The set of primitive values that correspond to the ABI types defined in `parameters`.\n * @returns ABI encoded data.\n */\nexport function encode(parameters, values, options) {\n  const {\n    checksumAddress = false\n  } = options ?? {};\n  if (parameters.length !== values.length) throw new LengthMismatchError({\n    expectedLength: parameters.length,\n    givenLength: values.length\n  });\n  // Prepare the parameters to determine dynamic types to encode.\n  const preparedParameters = internal.prepareParameters({\n    checksumAddress,\n    parameters: parameters,\n    values: values\n  });\n  const data = internal.encode(preparedParameters);\n  if (data.length === 0) return '0x';\n  return data;\n}\n/**\n * Encodes an array of primitive values to a [packed ABI encoding](https://docs.soliditylang.org/en/latest/abi-spec.html#non-standard-packed-mode).\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const encoded = AbiParameters.encodePacked(\n *   ['address', 'string'],\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 'hello world'],\n * )\n * // @log: '0xd8da6bf26964af9d7eed9e03e53415d37aa9604568656c6c6f20776f726c64'\n * ```\n *\n * @param types - Set of ABI types to pack encode.\n * @param values - The set of primitive values that correspond to the ABI types defined in `types`.\n * @returns The encoded packed data.\n */\nexport function encodePacked(types, values) {\n  if (types.length !== values.length) throw new LengthMismatchError({\n    expectedLength: types.length,\n    givenLength: values.length\n  });\n  const data = [];\n  for (let i = 0; i < types.length; i++) {\n    const type = types[i];\n    const value = values[i];\n    data.push(encodePacked.encode(type, value));\n  }\n  return Hex.concat(...data);\n}\n(function (encodePacked) {\n  // eslint-disable-next-line jsdoc/require-jsdoc\n  function encode(type, value, isArray = false) {\n    if (type === 'address') {\n      const address = value;\n      Address.assert(address);\n      return Hex.padLeft(address.toLowerCase(), isArray ? 32 : 0);\n    }\n    if (type === 'string') return Hex.fromString(value);\n    if (type === 'bytes') return value;\n    if (type === 'bool') return Hex.padLeft(Hex.fromBoolean(value), isArray ? 32 : 1);\n    const intMatch = type.match(Solidity.integerRegex);\n    if (intMatch) {\n      const [_type, baseType, bits = '256'] = intMatch;\n      const size = Number.parseInt(bits) / 8;\n      return Hex.fromNumber(value, {\n        size: isArray ? 32 : size,\n        signed: baseType === 'int'\n      });\n    }\n    const bytesMatch = type.match(Solidity.bytesRegex);\n    if (bytesMatch) {\n      const [_type, size] = bytesMatch;\n      if (Number.parseInt(size) !== (value.length - 2) / 2) throw new BytesSizeMismatchError({\n        expectedSize: Number.parseInt(size),\n        value: value\n      });\n      return Hex.padRight(value, isArray ? 32 : 0);\n    }\n    const arrayMatch = type.match(Solidity.arrayRegex);\n    if (arrayMatch && Array.isArray(value)) {\n      const [_type, childType] = arrayMatch;\n      const data = [];\n      for (let i = 0; i < value.length; i++) {\n        data.push(encode(childType, value[i], true));\n      }\n      if (data.length === 0) return '0x';\n      return Hex.concat(...data);\n    }\n    throw new InvalidTypeError(type);\n  }\n  encodePacked.encode = encode;\n})(encodePacked || (encodePacked = {}));\n/**\n * Formats {@link ox#AbiParameters.AbiParameters} into **Human Readable ABI Parameters**.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const formatted = AbiParameters.format([\n *   {\n *     name: 'spender',\n *     type: 'address',\n *   },\n *   {\n *     name: 'amount',\n *     type: 'uint256',\n *   },\n * ])\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param parameters - The ABI Parameters to format.\n * @returns The formatted ABI Parameters  .\n */\nexport function format(parameters) {\n  return abitype.formatAbiParameters(parameters);\n}\n/**\n * Parses arbitrary **JSON ABI Parameters** or **Human Readable ABI Parameters** into typed {@link ox#AbiParameters.AbiParameters}.\n *\n * @example\n * ### JSON Parameters\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from([\n *   {\n *     name: 'spender',\n *     type: 'address',\n *   },\n *   {\n *     name: 'amount',\n *     type: 'uint256',\n *   },\n * ])\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable Parameters\n *\n * Human Readable ABI Parameters can be parsed into a typed {@link ox#AbiParameters.AbiParameters}:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from('address spender, uint256 amount')\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'Foo foo, address bar',\n * ])\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param parameters - The ABI Parameters to parse.\n * @returns The typed ABI Parameters.\n */\nexport function from(parameters) {\n  if (Array.isArray(parameters) && typeof parameters[0] === 'string') return abitype.parseAbiParameters(parameters);\n  if (typeof parameters === 'string') return abitype.parseAbiParameters(parameters);\n  return parameters;\n}\n/**\n * Throws when the data size is too small for the given parameters.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x010f')\n * //                                             ↑ ❌ 2 bytes\n * // @error: AbiParameters.DataSizeTooSmallError: Data size of 2 bytes is too small for given parameters.\n * // @error: Params: (uint256)\n * // @error: Data:   0x010f (2 bytes)\n * ```\n *\n * ### Solution\n *\n * Pass a valid data size.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                                             ↑ ✅ 32 bytes\n * ```\n */\nexport class DataSizeTooSmallError extends Errors.BaseError {\n  constructor({\n    data,\n    parameters,\n    size\n  }) {\n    super(`Data size of ${size} bytes is too small for given parameters.`, {\n      metaMessages: [`Params: (${abitype.formatAbiParameters(parameters)})`, `Data:   ${data} (${size} bytes)`]\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'AbiParameters.DataSizeTooSmallError'\n    });\n  }\n}\n/**\n * Throws when zero data is provided, but data is expected.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x')\n * //                                           ↑ ❌ zero data\n * // @error: AbiParameters.DataSizeTooSmallError: Data size of 2 bytes is too small for given parameters.\n * // @error: Params: (uint256)\n * // @error: Data:   0x010f (2 bytes)\n * ```\n *\n * ### Solution\n *\n * Pass valid data.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                                             ↑ ✅ 32 bytes\n * ```\n */\nexport class ZeroDataError extends Errors.BaseError {\n  constructor() {\n    super('Cannot decode zero data (\"0x\") with ABI parameters.');\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'AbiParameters.ZeroDataError'\n    });\n  }\n}\n/**\n * The length of the array value does not match the length specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from('uint256[3]'), [[69n, 420n]])\n * //                                               ↑ expected: 3  ↑ ❌ length: 2\n * // @error: AbiParameters.ArrayLengthMismatchError: ABI encoding array length mismatch\n * // @error: for type `uint256[3]`. Expected: `3`. Given: `2`.\n * ```\n *\n * ### Solution\n *\n * Pass an array of the correct length.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['uint256[3]']), [[69n, 420n, 69n]])\n * //                                                         ↑ ✅ length: 3\n * ```\n */\nexport class ArrayLengthMismatchError extends Errors.BaseError {\n  constructor({\n    expectedLength,\n    givenLength,\n    type\n  }) {\n    super(`Array length mismatch for type \\`${type}\\`. Expected: \\`${expectedLength}\\`. Given: \\`${givenLength}\\`.`);\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'AbiParameters.ArrayLengthMismatchError'\n    });\n  }\n}\n/**\n * The size of the bytes value does not match the size specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from('bytes8'), [['0xdeadbeefdeadbeefdeadbeef']])\n * //                                            ↑ expected: 8 bytes  ↑ ❌ size: 12 bytes\n * // @error: BytesSizeMismatchError: Size of bytes \"0xdeadbeefdeadbeefdeadbeef\"\n * // @error: (bytes12) does not match expected size (bytes8).\n * ```\n *\n * ### Solution\n *\n * Pass a bytes value of the correct size.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['bytes8']), ['0xdeadbeefdeadbeef'])\n * //                                                       ↑ ✅ size: 8 bytes\n * ```\n */\nexport class BytesSizeMismatchError extends Errors.BaseError {\n  constructor({\n    expectedSize,\n    value\n  }) {\n    super(`Size of bytes \"${value}\" (bytes${Hex.size(value)}) does not match expected size (bytes${expectedSize}).`);\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'AbiParameters.BytesSizeMismatchError'\n    });\n  }\n}\n/**\n * The length of the values to encode does not match the length of the ABI parameters.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['string', 'uint256']), ['hello'])\n * // @error: LengthMismatchError: ABI encoding params/values length mismatch.\n * // @error: Expected length (params): 2\n * // @error: Given length (values): 1\n * ```\n *\n * ### Solution\n *\n * Pass the correct number of values to encode.\n *\n * ### Solution\n *\n * Pass a [valid ABI type](https://docs.soliditylang.org/en/develop/abi-spec.html#types).\n */\nexport class LengthMismatchError extends Errors.BaseError {\n  constructor({\n    expectedLength,\n    givenLength\n  }) {\n    super(['ABI encoding parameters/values length mismatch.', `Expected length (parameters): ${expectedLength}`, `Given length (values): ${givenLength}`].join('\\n'));\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'AbiParameters.LengthMismatchError'\n    });\n  }\n}\n/**\n * The value provided is not a valid array as specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['uint256[3]']), [69])\n * ```\n *\n * ### Solution\n *\n * Pass an array value.\n */\nexport class InvalidArrayError extends Errors.BaseError {\n  constructor(value) {\n    super(`Value \\`${value}\\` is not a valid array.`);\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'AbiParameters.InvalidArrayError'\n    });\n  }\n}\n/**\n * Throws when the ABI parameter type is invalid.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'lol' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                             ↑ ❌ invalid type\n * // @error: AbiParameters.InvalidTypeError: Type `lol` is not a valid ABI Type.\n * ```\n */\nexport class InvalidTypeError extends Errors.BaseError {\n  constructor(type) {\n    super(`Type \\`${type}\\` is not a valid ABI Type.`);\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'AbiParameters.InvalidTypeError'\n    });\n  }\n}\n//# sourceMappingURL=AbiParameters.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}