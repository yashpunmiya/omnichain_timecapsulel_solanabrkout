import { utils } from 'ethers';

interface LayerZeroParsedError {
    message: string;
    name: string;
    cause: string;
    args: FormattedErrorArg[];
}
type Abi = ConstructorParameters<typeof utils.Interface>[0];
interface FormattedErrorArg {
    param: string | null;
    type: string;
    value: string;
}
declare class LayerZeroContractError extends Error implements Error {
    args: FormattedErrorArg[];
    cause: string;
    constructor(message: string, cause: string, args: FormattedErrorArg[]);
}
/**
 * Class responsible for parsing errors related to LayerZero operations.
 */
declare class LayerZeroErrorParser {
    abi: Abi;
    /**
     * Creates an instance of LayerZeroErrorParser.
     * @param abi The error abi of the contracts that are interacted with.
     */
    constructor(abi: Abi);
    /**
     * Parses a contract error from a given data string.
     * @param data The error data string to parse.
     * @returns The parsed error information or null if parsing fails.
     * @private
     */
    private parseContractError;
    /**
     * Parses an error from a given data string.
     * @param data The error data string to parse.
     * @returns The parsed error information or null if the error is unrecognized.
     */
    parse(data: string): LayerZeroParsedError | null;
    /**
     * Checks for a contract error in the given data string, throwing a `LayerZeroContractError` if one is found.
     * @param data The error data string to check.
     * @param cleanUpStackTrace An optional function to clean up the stack. This function and all function above in the stack will be excluded from the trace.
     * @throws {LayerZeroContractError} Throws a LayerZeroContractError if an error is found corresponding to the data string.
     */
    check(data: string, cleanUpStackTrace?: (...args: any) => any): void;
}

export { type Abi, type FormattedErrorArg, LayerZeroContractError, LayerZeroErrorParser, type LayerZeroParsedError };
